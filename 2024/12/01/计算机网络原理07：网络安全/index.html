

<!DOCTYPE html>
<html lang="zh-CN" >



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Mr.x">
  <meta name="keywords" content="">
  
    <meta name="description" content="随着计算机网络的发展和广泛应用，当今全球几乎所有的计算机系统都已通过网络互连起来，并且无论组织还是个人都越来越依赖这些系统存储和传输信息。而病毒、“黑客”、电子窃听和电子欺诈使得网络中的安全问题日趋严重。本章将对计算机网络的安全问题进行初步的讨论，并介绍一些基本的安全技术，包括保护信息使其不被泄露、保证数据的真实性、保护系统使其不受来自网络的攻击等；最后讨论几种常见的网络攻击的机制和相应的防范措施">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络原理：网络安全">
<meta property="og:url" content="https://kuberxy.github.io/2024/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%8607%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/index.html">
<meta property="og:site_name" content="Kubxy">
<meta property="og:description" content="随着计算机网络的发展和广泛应用，当今全球几乎所有的计算机系统都已通过网络互连起来，并且无论组织还是个人都越来越依赖这些系统存储和传输信息。而病毒、“黑客”、电子窃听和电子欺诈使得网络中的安全问题日趋严重。本章将对计算机网络的安全问题进行初步的讨论，并介绍一些基本的安全技术，包括保护信息使其不被泄露、保证数据的真实性、保护系统使其不受来自网络的攻击等；最后讨论几种常见的网络攻击的机制和相应的防范措施">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kuberxy.github.io/img/d7fbe83f0577702a7c9c2ef304cc34cf.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/2225c0101c1469cb40d3edcea8ab1364.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/1db1c582090262b9752eba82244fc37c.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/3efae35bc558a06b60400d7aea474a8d.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/58584e654e159ed4c2b6b8014853abad.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/210d07df1a3a435242a467eb473901dd.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/0f24ce9e1d256b7baf2032384b9de8f8.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/3a3299ab933523d7b642441cf3f4731f.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/9d70952d8ae299ffd6fa41c36e22fb05.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/d09b9ffa2d6be03d71cf801846c872a3.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/6689dba4841e4a4fe2a7d2509a60df43.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/795feb6934bf0fa1c3dcd5e2cda6f5aa.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/6b239d326beef5b34b9aedd526639e6d.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/b56806999a897b4b9bccb3f4d892eeb4.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/f6e0ee5b1e975f35208d5b6905bd2e4c.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/36440b3f352f685bb96921c11104b989.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/580ad9df47ffa19a5d8c826c65c6891d.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/80b14fca006c6e3541eafed5a5a43455.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/7f17842c244160d185d543ad40f829c3.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/b9e8195498fa19aa29541b9f83c5d75a.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/3eeb422dbe95145383dfdf7d67d9d70e.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/925e3c061e02b0aa0fb431229bea9190.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/284fbf5dd4836c415ea0ed9d39e5bcd7.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/32e5c984dceb5f663711526570612be2.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/1372d166aa24d13721ed092a2ca92d9d.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/699aa04b1bbb6c6647f4864655609fa0.jpg">
<meta property="article:published_time" content="2024-12-01T05:47:11.000Z">
<meta property="article:modified_time" content="2024-12-01T08:38:55.000Z">
<meta property="article:author" content="Mr.x">
<meta property="article:tag" content="计算机网络原理">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://kuberxy.github.io/img/d7fbe83f0577702a7c9c2ef304cc34cf.jpg">
  
  
  
  <title>计算机网络原理：网络安全 - Kubxy</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"kuberxy.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Kubxy</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="计算机网络原理：网络安全"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-12-01 13:47" pubdate>
          2024年12月1日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          22k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          181 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">计算机网络原理：网络安全</h1>
            
            
              <div class="markdown-body">
                
                <p>随着计算机网络的发展和广泛应用，当今全球几乎所有的计算机系统都已通过网络互连起来，并且无论组织还是个人都越来越依赖这些系统存储和传输信息。而病毒、“黑客”、电子窃听和电子欺诈使得网络中的安全问题日趋严重。本章将对计算机网络的安全问题进行初步的讨论，并介绍一些基本的安全技术，包括保护信息使其不被泄露、保证数据的真实性、保护系统使其不受来自网络的攻击等；最后讨论几种常见的网络攻击的机制和相应的防范措施。</p>
<p>本章最重要的内容如下。</p>
<p>（1）网络安全威胁及安全服务的概念。</p>
<p>（2）对称密钥密码体制与公钥密码体制的特点。</p>
<p>（3）实现信息机密性、完整性和实体鉴别的安全机制。</p>
<p>（4）网络各层的安全协议。</p>
<p>（5）防火墙的概念。</p>
<h2 id="一、网络安全概述">一、网络安全概述</h2>
<p>网络安全涉及三个方面：安全威胁、安全服务和安全机制。本节先讨论前两个方面，后面几节具体讨论各种安全机制。</p>
<h3 id="1-1、安全威胁">1.1、安全威胁</h3>
<p>计算机网络面临的安全威胁主要分为两大类，即被动攻击和主动攻击；从攻击对象来看，又可分为对通信本身的攻击和利用网络对计算机系统的攻击。图7-1所示的是对网络通信的四种最基本的攻击形式。</p>
<p><img src="/img/d7fbe83f0577702a7c9c2ef304cc34cf.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>（1）截获（Interception）：攻击者从网络上窃听他人的通信内容。</p>
<p>（2）中断（Interruption）：攻击者有意中断他人在网络上的通信。</p>
<p>（3）篡改（Modification）：攻击者故意篡改网络上传送的报文。</p>
<p>（4）伪造（Fabrication）：攻击者伪造信息在网络上传送。</p>
<p>在被动攻击中，攻击者只是观察和分析网络中传输的数据流而不干扰数据流本身。通过窃听手段，攻击者可以截获电话、电子邮件和传输的文件中的敏感信息，而不被发现。即使通信的内容被加密，攻击者不能直接从内容中获取机密信息，他也可以通过观察分组的协议控制信息部分来了解正在通信的协议实体的地址和身份，通过研究分组的长度和传输的频度来了解所交换的数据的性质。这种被动攻击称为流量分析（Traffic Analysis）。</p>
<p>主动攻击是指攻击者对传输中的数据流进行各种处理。例如，有选择地更改、删除、延迟或改变消息的顺序，以获得非授权的效果。攻击者可以主动发送伪造的信息或伪装自己的身份与被攻击者通信。除了中断、篡改和伪造外，还有一种重放攻击是将截获的报文再次发送以产生非授权的效果。</p>
<p>拒绝服务 （Denial of Service，DoS）攻击 是一种很难防范的利用网络对计算机系统的主动攻击。攻击者通过发送巨量恶意报文使目标系统或网络崩溃，阻止系统为合法用户提供正常服务。攻击者甚至可利用系统漏洞先非法控制互联网上成百上千的主机（这些主机被称为僵尸主机 ），然后从这些僵尸主机上同时向某个目标系统发起猛烈攻击。这就是分布式拒绝服务 （Distributed Denial of Service，DDoS）攻击 。例如，2000年2月7日至9日，美国几个著名网站遭受DDoS攻击，使这些网站的服务器一直处于“忙”的状态，因而拒绝向发出请求的客户提供正常服务。</p>
<p>网络在方便人们远程访问计算机系统的同时，也给攻击者远程非法访问计算机系统带来了极大的便利。攻击者通过破解管理员口令、利用系统漏洞获取管理员权限等手段入侵计算机系统，对信息资源进行非法访问或对信息系统进行恶意破坏。这类攻击被称为远程入侵 ，所有连接在互联网上的计算机系统都面临被非法入侵的危险。</p>
<p>还有一种特殊的主动攻击就是恶意程序（Rogue Program）攻击。恶意程序种类繁多，并且可以通过网络在计算机系统间传播，对计算机系统的安全造成了巨大的威胁。目前恶意程序主要有以下几种。</p>
<p>（1）计算机病毒（Computer Virus）：一种会“传染”其他程序的程序。“传染”是通过修改其他程序把自身或其变种复制进去完成的。</p>
<p>（2）计算机蠕虫（Computer Worm）：一种通过网络的通信功能主动将自身从一个结点发送到另一个结点，并启动运行的程序。</p>
<p>（3）特洛伊木马（Trojan Horse）：或简称为木马，是一种在表面功能掩护下执行非授权功能的程序。例如，一个伪造成编辑器软件的特洛伊木马程序，在用户编辑一个机密文件时偷偷将该文件内容通过网络发送给攻击者，以窃取机密信息。计算机病毒有时也以特洛伊木马的形式出现。</p>
<p>（4）逻辑炸弹（Logic Bomb）：一种当运行环境满足某种特定条件时执行其他特殊功能的程序。例如，一个编辑程序，平时运行正常，但当系统时间为13日同时又为星期五时，它就会删去系统中所有的文件，这种程序就是一种逻辑炸弹。</p>
<p>这里讨论的计算机病毒是狭义的，也有人把所有的恶意程序泛称为计算机病毒。例如，1988年10月，“Morris病毒”入侵美国互联网。舆论说它是“计算机病毒入侵美国计算机网”，而计算机安全专家却称之为“互联网蠕虫事件”。</p>
<p>被动攻击不涉及对数据的更改，所以很难察觉，人们对被动攻击主要采用密码技术进行预防，而不是检测。与被动攻击相反，预防主动攻击非常困难，因为物理通信设施、软件和网络本身潜在的弱点具有多样性。不过主动攻击容易检测，因此对付主动攻击除了采取访问控制等预防措施外，还需要采用各种检测技术及时发现并阻止攻击，同时对攻击源进行追踪，并利用法律手段对其进行打击。</p>
<h3 id="1-2、安全服务">1.2、安全服务</h3>
<p>为应对以上安全威胁，计算机网络需要提供以下基本安全服务。</p>
<ul>
<li>
<p>机密性（Confidentiality）：确保计算机系统中的信息或网络中传输的信息不会泄露给非授权用户。这是计算机网络中最基本的安全服务。</p>
</li>
<li>
<p>报文完整性（Message Integrity）：确保计算机系统中的信息或网络中传输的信息不被非授权用户篡改或伪造。后者要求对报文源进行鉴别。</p>
</li>
<li>
<p>不可否认性（Nonrepudiation）：防止发送方或接收方否认发送或接收过某信息。在电子商务中这是一种非常重要的安全服务。</p>
</li>
<li>
<p>实体鉴别（Entity Authentication）：通信实体能够验证正在通信的对端实体的真实身份，确保不会与冒充者进行通信。请注意鉴别与授权（Authorization）是不同的概念。授权涉及的问题是，实体的行为是否被允许（如是否可以对某文件进行读或写等）。</p>
</li>
<li>
<p>访问控制（Access Control）：系统具有限制和控制不同实体对信息源或其他系统资源进行访问的能力。系统必须在鉴别实体身份的基础上对实体的访问权限进行控制。</p>
</li>
<li>
<p>可用性（Availability）：确保授权用户能够正常访问系统信息或资源。很多攻击会导致系统可用性的损失，拒绝服务攻击是对可用性最直接的威胁。</p>
</li>
</ul>
<p>接下来，介绍实现以上安全服务的各种安全机制。</p>
<h2 id="二、机密性与密码学">二、机密性与密码学</h2>
<p>机密性应该是密码学最早的应用领域，我们在后面几节将会看到，密码学技术和鉴别报文完整性及不可否认性等是紧密相关的，可以说密码学就是计算机网络安全的基础。本节介绍密码学的一些基本概念及其在机密性方面的应用。</p>
<p>我们通过计算机网络传输数据时，如果无法防止他人窃听，可以利用密码学技术将发送的数据变换成对任何不知道如何做逆变换的人都不可理解的形式，从而保证数据的机密性。这种变换被称为加密 （Encryption），被加密的数据被称为密文 （Ciphertext），而加密前的数据被称为明文 （Plaintext）。接收方必须能通过某种逆变换将密文变换回原来的明文，该逆变换被称为解密 （Decryption）。密码学家很早就发现，加密和解密过程可以以一个密钥 （Key）为参数，并且加密和解密过程可以公开，而只有密钥需要保密，即只有知道密钥的人才能解密密文，而任何人，即使知道加密或解密算法也无法解密密文 。采用该原则的一个原因是，如果你依靠算法保密，一旦算法失密就必须放弃该算法。这意味着要频繁地修改算法，而开发一个新的算法是非常困难的事情。另外，密钥空间可以很大，用密钥将密码算法参数化后，同一个算法可以为大量用户提供加密服务。图7-2所示为数据加密的一般模型。</p>
<p><img src="/img/2225c0101c1469cb40d3edcea8ab1364.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>待加密的明文 X 用加密算法 E 和加密密钥 KA得到密文 。用公式可把加密过程写成下面的式（7-1）。有时我们也说，明文经过E 运算转换为密文。</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>Y</mi><mo>=</mo><msub><mi>E</mi><mrow><mi>K</mi><mi>A</mi></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y=E_{KA}(X)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mord mathnormal mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span></span></p>
<p>在传送密文的过程中可能会出现密文截取者。密文传送到接收端后，利用解密算法 D 和解密密钥 KB可解出明文X 。用公式可把解密过程写成下面的式（7-2）。因此，密文经过D 运算就还原为原来的明文。</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>D</mi><mrow><mi>K</mi><mi>B</mi></mrow></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>D</mi><mrow><mi>K</mi><mi>B</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>E</mi><mrow><mi>K</mi><mi>A</mi></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">D_{KB}(Y)=D_{KB}(E_{KA}(X))=X
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mord mathnormal mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span></span></p>
<p>请注意，加密密钥和解密密钥可以相同，也可以不同，取决于采用的是对称密钥密码体制还是公钥密码体制。</p>
<p>截取者 又称为攻击者 ，或入侵者 。如果不论截取者获得了多少密文，在密文中都没有足够的信息来唯一地确定出对应的明文，则这一密码体制称为无条件安全的 ，或称为在理论上是不可破的 。在无任何限制的条件下，目前几乎所有实用的密码体制均是可破的。因此，人们关心的是要研制出在计算上（而不是在理论上）是不可破的密码体制 。如果一个密码体制中的密码不能在一定时间内被可以使用的计算资源破译，则这一密码体制称为在计算上是安全的 。一般来说，通过使用长的密钥可以有效增加破解密文的难度，但同时也使得加密和解密的计算量加大。</p>
<h3 id="2-1、对称密钥密码体制">2.1、对称密钥密码体制</h3>
<p>所谓对称密钥密码体制 是一种加密密钥与解密密钥相同的密码体制 。在这种加密系统中，两个参与者共享同一个秘密密钥，如果用一个特定的密钥加密一条消息，就必须要使用相同的密钥来解密该消息。该系统又称为对称密钥系统 。</p>
<p>数据加密标准 （Data Encryption Standard，DES）是对称密钥密码的典型代表，由IBM公司研制，于1977年被美国定为联邦信息标准后，在国际上引起了极大的重视。ISO曾把DES作为国际标准。DES使用的密钥为64位（实际密钥长度为56位，有8位用于奇偶校验）。</p>
<p>DES是一个优秀的密码算法，目前还没有发现比蛮力攻击更好的破解方法。但随着计算机运算速度的快速提高，56位长的密钥已显得太短。56位长的密钥意味着共有256 种可能的密钥，也就是说，共约有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7.6</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">7.6×10^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">7.6</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span> 种密钥。假设一台计算机1 µs可执行一次DES加密，同时假定平均只需搜索密钥空间的一半即可找到密钥，那么破译DES用时超过1000年。但现在人们利用并行计算技术已经设计出搜索DES密钥的专用芯片。例如，在1999年，有一批在互联网上合作的人借助于一台价值不到25万美元的专用计算机，在略大于22h的时间内破译了56位密钥的DES。</p>
<p>为解决DES密钥太短的问题，人们提出了三重DES （Triple DES，3DES）。3DES在1985年成为美国的商用加密标准（RFC 2420）。3DES在加密时用三个密钥，执行三次DES算法，即E 运算→D 运算→E 运算；解密时，按相反顺序使用这三个密钥，执行D 运算→E 运算→D 运算，如图7-3所示。</p>
<p><img src="/img/1db1c582090262b9752eba82244fc37c.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>3DES使用现有的DES算法，并且当三个密钥相同时，效果就和DES一样。这有利于逐步推广使用3DES。也可以仅使用两个密钥，即K 1 =K 3 ，相当于密钥长度为112位，这对于多数商业应用也已经足够长了。目前还没有关于攻破三重DES的报道。</p>
<p>由于IBM公司最初设计DES是为了用硬件来实现，DES/3DES的软件实现较慢。3DES目前正在被2001年发布的高级加密标准（Advanced Encryption Standard，AES）所替代。AES能够使用128位、192位和256位长的密钥，用硬件和软件都可以快速实现。它不需要太多内存，因此适用于小型移动设备。美国国家标准与技术研究所（National Institute of Standards and Technology，NIST）估计，如果用1s破解56位DES的计算机来破解一个128位的AES密钥，要用大约149万亿年的时间才有可能完成破解。</p>
<h3 id="2-2、公钥密码体制">2.2、公钥密码体制</h3>
<p>在对称密钥系统中，两个参与者要共享一个秘密密钥。但怎样才能做到这一点呢？一种是事先约定，另一种是用信使来传送。在高度自动化的大型计算机网络中，用信使来传送密钥显然是不合适的。如果事先约定密钥，就会给密钥的管理和更换带来极大的不便。后面我们将会介绍如何使用复杂的密钥分发中心 （Key Distribution Center，KDC）来解决该问题。然而采用公钥密码体制可以比较容易地解决这个问题。</p>
<p>公钥密码体制的概念是由美国斯坦福大学的研究人员迪菲（Diffie）与海尔曼（Hellman）于1976年提出的。公钥密码体制使用不同的加密密钥与解密密钥 。</p>
<p>在公钥密码体制中，加密密钥 （即公钥 ）PK是公开信息，而解密密钥 （即私钥 ）SK是需要保密的，因此私钥也叫作秘密密钥 。加密算法E 和解密算法D 也都是公开的。虽然私钥SK是由公钥 PK决定的，但却不能根据 PK计算出 SK。</p>
<p>公钥算法有以下主要特性。</p>
<p>（1）发送方用加密密钥PK对明文X 加密后，接收方用解密密钥SK解密，即可恢复出明文，此过程可写为：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>D</mi><mrow><mi>S</mi><mi>K</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>E</mi><mrow><mi>P</mi><mi>K</mi></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">D_{SK}(E_{PK}(X))=X
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span></span></p>
<p>加密密钥是公钥，而解密密钥是接收方专用的私钥，对其他人都保密。</p>
<p>此外，加密和解密的运算可以对调，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mrow><mi>P</mi><mi>K</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>D</mi><mrow><mi>S</mi><mi>K</mi></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">E_{PK}(D_{SK}(X))=X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>。</p>
<p>（2）加密密钥不能用它来解密，即：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>D</mi><mrow><mi>P</mi><mi>K</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>E</mi><mrow><mi>P</mi><mi>K</mi></mrow></msub><mo stretchy="false">)</mo><mo mathvariant="normal">≠</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">D_{PK}(E_{PK}) \ne X
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span></span></p>
<p>（3）在计算机上可以容易地产生成对的PK和SK。</p>
<p>（4）从已知的PK在计算上不可能推导出SK，即从PK到SK是“计算上不可能的”。</p>
<p>（5）加密算法和解密算法都是公开的。</p>
<p>由于加密密钥不能用来解密，并且从加密密钥不能推导出解密密钥，因此加密密钥可以公开。例如，参与者A可以在报纸上公布自己的加密密钥（即公钥），而解密密钥（即私钥）自己秘密保存。任何参与者都可以获得该公钥，并用来加密发送给参与者A的信息，而该信息只能由A解密。可见采用公钥密码体制更易解决密钥分发的问题。</p>
<p>公钥密码体制提出不久，人们就设计了三种公钥密码算法。目前最著名的是由美国三位科学家李维斯特（Rivest）、沙米尔（Shamir）和艾德曼（Adleman）于1976年提出，并在1978年正式发表的RSA算法 ，它是基于数论中大数分解问题的算法。</p>
<p>公钥密码体制有许多很好的特性，它不仅可以用于加密，还可以很方便地用于鉴别和数字签名。但不幸的是，目前的公钥密码算法比对称密码算法慢好几个数量级。因此，对称密码被用于绝大部分加密，而公钥密码则通常用于会话密钥 的建立。例如，参与者A要发送大量秘密信息给B。A首先选择一个用于加密数据本身（如采用DES算法或AES算法）的密钥。该密钥仅用于该次会话，被称为会话密钥。因为对称密钥由双方共享，A必须将该会话密钥通过秘密渠道告知B。为此，A用B的RSA公钥加密该会话密钥后将其发送给B，B收到加密的会话密钥后用自己的私钥解密得到会话密钥。此后，A和B之间就可以用该会话密钥加密通信的数据。</p>
<p>最后我们要强调一下，加密方法的安全性取决于密钥的长度，以及攻破密文所需的计算量，而不是简单地取决于加密的体制。因此我们不能简单地认为，公钥密码体制和传统加密体制相比，哪一种密码体制的安全性更加优越。</p>
<h2 id="三、完整性与鉴别">三、完整性与鉴别</h2>
<p>有时，通信双方并不关心通信的内容是否会被人窃听，而只关心通信的内容是否被人篡改或伪造，这就是报文完整性 问题。报文完整性验证又称为报文鉴别 ，即鉴别报文的真伪。例如，路由器之间交换的路由信息不一定要求保密，但要求能检测出被篡改或伪造的路由信息。</p>
<p>很多情况下，通信的双方需要验证通信对端的真实身份。例如，当客户在互联网上远程登录某银行的网上银行时，银行服务器要验证客户所声称的身份的真实性，而客户也需要验证登录的确实是该银行的网站。这时就需要实体鉴别。实体鉴别（经常简称为鉴别）就是一方验证另一方身份的技术。</p>
<h3 id="3-1、报文摘要和报文鉴别码">3.1、报文摘要和报文鉴别码</h3>
<p>使用加密通常可达到报文鉴别的目的，因为伪造的报文解密后一般不能得到可理解的内容。但简单采用这种方法，计算机很难自动识别报文是否被篡改。另外，对于不需要保密而只需要报文鉴别的网络应用，对整个报文的加密和解密会给计算机增加很多不必要的负担（加密和解密要花费相当多的CPU时间）。更有效的方法是使用报文摘要（Message Digest，MD）来进行报文鉴别，如图7-4所示。</p>
<p><img src="/img/3efae35bc558a06b60400d7aea474a8d.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>发送方将可变长度的报文m 经过报文摘要算法运算后，得出固定长度的报文摘要H (m )。然后对H (m )进行加密，得出E K (H (m ))，并将其附加在报文m 后面发送出去。接收方把E K (H (m ))解密还原为H (m )，再把收到的报文进行报文摘要运算，看结果是否与解密还原的H (m )一样。如不一样，则可断定收到的报文不是发送方产生的。报文摘要的优点就是，仅对短得多的定长报文摘要H (m )进行加密比对整个长报文m 进行加密要简单得多，但对鉴别报文m 来说，其效果是一样的。密钥K仅在通信双方之间共享，没有第三方能用伪造报文m’ 产生出E K (H (m’ ))。附加在报文上用于鉴别报文真伪的码串，如上面的E K (H (m ))，被称为报文鉴别码 （Message Authentication Code，MAC ）。</p>
<p>报文摘要和差错检验码都是多对一（Many-to-One）的散列函数（Hash Function）的例子。但要抵御攻击者的恶意篡改，报文摘要算法必须满足以下条件。</p>
<p>（1）任意给定一个报文摘要值x ，若想找到一个报文y 使得H (y )=x ，则在计算上是不可行的 。</p>
<p>（2）若想找到两个不同的报文x 和y ，使得H (x )=H (y )，则在计算上是不可行的 。</p>
<p>上述的两个条件表明：若(x ，H (x ))是发送方产生的报文和报文摘要对，则攻击者不可能伪造出另一个报文y ，使得y 与x 具有同样的报文摘要。</p>
<p>满足以上条件的散列函数称为密码散列函数 或安全散列函数 ，因为无法把报文摘要还原为报文，所以可以把密码散列函数运算看成没有密钥的加密运算。</p>
<p>要注意的是，差错检验码通常并不满足以上条件。例如，鲍勃（Bob）希望艾莉斯（Alice）给他电汇9213美元，为此他发送给Alice一条消息“SEND9213.BOB”，并用前面介绍的用于UDP差错检测的互联网检验和算法生产16位的报文摘要来生成报文鉴别码，以防止消息被篡改。但可惜的是，攻击者可以轻易地将该消息篡改为“SEND1293.BOB”而不会被发现，因为这两个不同的字符串的摘要是完全一样的（习题7-10），这可能导致Bob的一次重要交易的失败。通过这个例子可以看出，虽然差错检验码可以检测出报文的随机改变，但它无法抵御攻击者的恶意篡改，因为攻击者很容易找到差错检验码与原文相同的其他报文，从而达到攻击目的。</p>
<p>目前广泛应用的报文摘要算法有MD5算法（RFC 1321）和安全散列算法 1（Secure Hash Algorithm-1，SHA-1）。MD5算法输出128位的摘要，SHA-1算法输出160位的摘要。SHA-1算法比MD5算法更安全，但计算起来比MD5算法要慢。</p>
<p>细心的读者可能会发现，对于图7-4中的报文鉴别过程，其实并不需要将报文鉴别码解密出来就可以进行报文鉴别。接收方只需采用与发送方一样的运算，对收到的报文进行摘要，然后加密，再与报文鉴别码进行比较即可。也就是说报文鉴别码的计算并不需要可逆性 。利用这个性质可以设计出比使用加密运算更简单但更高效的报文鉴别码算法。</p>
<p>实际上，利用密码散列函数的特殊性质，无须对报文摘要加密就可以实现对报文的鉴别，前提是通信双方共享一个称为鉴别密钥 的秘密比特串s 。发送方用s 与报文m 级连生成m +s ，并计算散列H (m +s )；然后将H (m +s )作为MAC附加到报文m 上，一起发送给接收方。接收方利用s 和收到的报文m 重新计算MAC，与接收到的MAC进行比较，从而实现对报文的鉴别。由于攻击者不知道s ，也不能从截获的MAC中计算出s ，因此他不能为伪造报文m’ 产生H (m’ +s )。直接使用密码散列函数实现报文鉴别码的技术又称为散列报文鉴别码 （Hashed MAC，HMAC）。图7-5所示的是直接使用密码散列函数实现报文鉴别码进行报文鉴别。</p>
<p><img src="/img/58584e654e159ed4c2b6b8014853abad.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="3-2、数字签名">3.2、数字签名</h3>
<p>在日常生活中，我们可以用亲笔签名或印章来证明书信或文件的真实来源。在计算机网络中传送的文件又如何盖章呢？这就是数字签名<br>
（Digital Signature）所要解决的问题。数字签名必须保证以下三点。</p>
<p>（1）接收方能够核实发送方对报文的数字签名。</p>
<p>（2）发送方事后不能抵赖对报文的数字签名。</p>
<p>（3）任何人包括接收方都不能伪造对报文的签名。</p>
<p>现在已有多种实现数字签名的方法，但采用公钥算法要比采用对称密钥算法更容易实现。下面就来介绍这种数字签名技术。</p>
<p>发送方A用其私钥（即解密密钥）SKA对报文X 进行运算，将结果D SKA (X )传送给接收方B。读者可能要问：报文X 还没有加密，怎么能够进行解密呢？其实“解密”仅仅是一个数学运算。发送方此时的运算并非想将报文X 解密，而是为了进行数字签名。B收到报文D SKA (X)后，用已知的A的公钥（即加密密钥）对报文D SKA (X )进行运算，得出E PKA (D SKA (X ))=X 。因为除A外没有别人能具有A的解密密钥SKA，所以除A外没有别人能产生密文D SKA (X )，而任何伪造的报文经E PKA 运算后都不会得到可理解的内容。这样，B就核实了报文X 的确是A签名发送的，如图7-6所示。</p>
<p><img src="/img/210d07df1a3a435242a467eb473901dd.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>若A要抵赖曾发送报文给B，B可把X 及D SKA (X )出示给具有权威的第三方。第三方很容易用PKA去证实A确实发送了X 给B。反之，若B把X 伪造成X’ ，则B不能在第三方前出示D SKA (X’ )。这样就证明了B伪造了报文。可见数字签名实现了对报文来源的鉴别。我们知道公钥密码算法的计算代价非常大，对整个报文进行数字签名是一件非常耗时的事情。更有效的方法是仅对报文摘要进行数字签名 。</p>
<p>上述过程仅对报文进行了签名，对报文X 本身却未保密。因为截获D SKA (X )并知道发送方身份的任何人，通过查阅手册即可获得发送方的公钥PKA，因而能得知报文内容。若采用图7-7所示的方法，则可同时实现秘密通信和数字签名。图中SKA和SKB分别为A和B的私钥，而PKA和PKB分别为A和B的公钥。</p>
<p><img src="/img/0f24ce9e1d256b7baf2032384b9de8f8.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="3-3、实体鉴别">3.3、实体鉴别</h3>
<p>实体鉴别（经常简称为鉴别）就是一方验证另一方身份的技术。一个实体可以是人、客户/服务器进程等。这里仅讨论如何鉴别通信对端实体的身份，即验证正在通信的对方确实是所认为的通信实体，而不是其他的假冒者。进行通信实体鉴别需要使用鉴别协议。鉴别协议通常在两个通信实体之间传输实际数据或者进行访问控制之前运行，是很多安全协议的重要组成部分或前奏。</p>
<p>最简单的实体鉴别方法就是利用用户名/口令，但直接在网络中传输用户名/口令是不安全的，因为攻击者可以在网络上截获该用户名/口令，所以在实体鉴别过程中需要使用加密技术。如图7-8所示，参与者A向B发送有自己身份信息（如用户名和口令）的报文，并且使用双方共享的对称密钥K AB 进行加密。为简洁起见，这里用K （m ）表示通过密钥K 对信息m 加密。B收到此报文后，用K AB 解密即可验证A的身份。</p>
<p><img src="/img/3a3299ab933523d7b642441cf3f4731f.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>不幸的是，这种简单的鉴别方法具有明显的漏洞。因为攻击者C从网络上截获该报文后，完全不用破译该报文而仅仅直接将该报文发送给B，就可以使B误认为C就是A。这就是重放攻击 （Replay Attack）。</p>
<p>为了对付重放攻击，可以使用不重数 （Nonce），即一个不重复使用的大随机数，也称为“一次一数”。图7-9给出了使用不重数进行实体鉴别的过程。</p>
<p><img src="/img/9d70952d8ae299ffd6fa41c36e22fb05.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在图7-9中，A首先用明文发送其身份和一个不重数R A 给B。接着，B在响应A的报文中用共享的密钥K AB 加密R A ，并同时也给出自己的不重数R B 。最后，A再用加密的R B 响应B。A和B分别通过验证对方返回的加密的不重数实现双向的实体鉴别。由于不重数不能重复使用，攻击者C无法利用重放攻击来冒用A或B的身份。这种使用不重数进行实体鉴别的协议又称为挑战—响应（Challenge-Response）协议。</p>
<p>同样，使用公钥加密算法也能实现实体鉴别。这时，通信双方可以利用自己的私钥对不重数进行签名，而用对方的公钥来鉴别对方签名的不重数，从而实现通信双方身份的鉴别。</p>
<h2 id="四、密钥分发与公钥认证">四、密钥分发与公钥认证</h2>
<p>由于密码算法是公开的，因此密钥系统的安全性依赖于密钥的安全保护。在对称密钥密码体制中，通信双方要共享一个秘密密钥，如何将密钥分发到通信的双方是一个需要解决的问题。显然密钥必须通过安全的通路进行分发。例如，可以派非常可靠的信使携带密钥分发给互相通信的用户。这种方法称为网外分发 。但随着用户的增多和通信量的增大，密钥更换频繁（密钥必须定期更换才能做到可靠），派信使的办法将不再适用。因此必须解决网内密钥自动分发 的问题。对于公钥密码体制，虽然不需要共享密钥，公钥可以发布在报纸或网站上，但如何验证该公钥确实是某实体真正的公钥仍然是一个问题。这些问题的解决都可以通过使用一个可信的中介机构得到解决。对于对称密钥密码体制，这个可信的中介机构就是密钥分发中心 （Key Distribution Center，KDC）。而对于公钥密码体制，则通过认证中心 （Certification Authority，CA）来实现公钥的签发和认证</p>
<h3 id="4-1、对称密钥的分发">4.1、对称密钥的分发</h3>
<p>对称密钥的分发问题在于如何让通信双方共享密钥。目前常用的对称密钥分发方式是设立密钥分发中心 。KDC是一个大家都信任的机构，其任务就是给需要进行秘密通信的用户临时分发一个会话密钥。图7-10是KDC进行密钥分发的基本过程。</p>
<p><img src="/img/d09b9ffa2d6be03d71cf801846c872a3.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>我们假定用户A和B都是KDC的登记用户，他们分别拥有与KDC通信的主密钥KA和KB。图中密钥分发的三个步骤说明如下。</p>
<ul>
<li>
<p>首先，用户A向KDC发送用自己私有的主密钥KA加密的报文E K A(A，B)，说明想和用户B通信。</p>
</li>
<li>
<p>KDC用随机数产生一个“一次一密 ”密钥R 1 供A和B这次 的通信使用，然后向A发送回答报文，这个回答报文用A的主密钥KA加密，报文中有密钥R 1 和请A转发给B的报文E K B(A，R 1 )，但报文E KB (A，R 1 )是用B的私有主密钥KB加密的，因此A无法知道报文E KB (A，R 1 )的内容（A没有B的主密钥KB，也不需要知道此报文的内容）。</p>
</li>
<li>
<p>当B收到A转发的报文E KB (A，R 1 )，并使用自己的私有主密钥KB解密后，就知道A要和它通信，同时也知道和A通信时所使用的密钥R 1 。</p>
</li>
</ul>
<p>此后，A和B就可使用这个一次一密的密钥R 1 进行本次通信了。</p>
<p>KDC还可在报文中加入时间戳，防止报文的截取者利用以前记录下的报文进行重放攻击。密钥R 1 是一次性的，因此保密性较高。而KDC分配给用户的主密钥，如KA和KB，都应定期更换以减少攻击者破译密钥的机会。RFC 1510描述了目前最出名的密钥分发协议Kerberos，它是由美国麻省理工学院开发的。</p>
<h3 id="4-2、公钥的签发与认证">4.2、公钥的签发与认证</h3>
<p>在公钥体制中，如果每个用户都具有其他用户的公钥，就可实现安全通信。这样看来好像可以随意公布用户的公钥。其实不然。设想用户A要欺骗用户B，A可以向B发送一份伪造是C发送的报文。A用自己的私钥进行数字签名，并附上A自己的公钥，谎称这公钥是C的。B如何知道这个公钥不是C的呢？显然，需要有一个值得信赖的机构将公钥与其对应的实体（人或机器）绑定 （Binding）。这样的机构就叫作认证中心 （CA），它一般由政府出资建立。需要发布公钥的用户可以让CA为自己的公钥签发一个证书 （Certificate），里面有公钥及其拥有者的身份标识信息（人名、公司名或IP地址等）。CA首先通过检查身份证等方式核实用户的真实身份，然后为用户产生私钥公钥对并生成证书，最后用CA的私钥对证书进行数字签名。该证书可以通过网络发送给任何希望与之通信的实体或存放在服务器由用户自由下载，当然私钥需要用户自己秘密保存。任何用户都可从可信的地方（如代表政府的报纸）获得CA的公钥，并用这个公钥验证某个证书的真伪。一旦证书被鉴别是真实的，则可以相信证书中的公钥确实属于证书中声称的用户。</p>
<p>由一个CA来签发全世界所有的证书显然是不切实际的，这会带来负载过重和单点故障问题。一种解决方案就是将许多CA组成一个层次结构的基础设施，即公钥基础设施 （Public Key Infrastructure，PKI），在全球范围内为所有互联网用户提供证书的签发与认证服务，如图7-11所示。</p>
<p><img src="/img/6689dba4841e4a4fe2a7d2509a60df43.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>下级CA的证书由其上级CA签发和认证。顶级的根CA能验证所有1级CA的证书，各个1级CA可以在一个很大的地理区域或逻辑区域内运作，而2级CA可以在一个相对较小的区域内运作。</p>
<p>所有用户都信任该层次结构中顶级的CA，但可以信任也可以不信任中间的CA。用户可以在自己信任的CA获取个人证书，当要验证来自不信任CA签发的证书时，需要到上一级验证该CA的证书的真伪，如果上一级CA也不可信任，则需要到更上一级进行验证，一直追溯到可信任的一级CA。这一过程最终有可能一直追溯到根CA。</p>
<h2 id="五、访问控制">五、访问控制</h2>
<p>访问控制（Access Control）是在保障授权用户能获取所需资源的同时拒绝非授权用户的安全机制，是保证网络资源不被非法使用和非法访问的重要手段。</p>
<h3 id="5-1、访问控制的基本概念">5.1、访问控制的基本概念</h3>
<p>在信息系统中，用户在通过身份鉴别进入系统后，只能访问授权范围内的资源，而不能毫无限制地对系统中的资源进行访问。身份鉴别常常被视为信息系统的第一道安全防线，因为身份鉴别可以将未授权用户屏蔽在信息系统之外。相应地，访问控制可以看作信息系统的第二道安全防线，它对进入系统的合法用户进行监督和限制，解决“合法用户在系统中对各类资源以何种权限访问”的问题。</p>
<p>实施访问控制的依据是用户的访问权限。用户访问权限的授予一般遵循最小特权原则。最小特权原则指的是基于用户完成工作的实际需求为用户赋予权限，用户不会被赋予超出其实际需求的权限。最小特权原则可以有效防范用户滥用权限所带来的安全风险。</p>
<p>访问控制包括主体、客体、访问及访问控制策略等基本要素。</p>
<p>（1）主体。</p>
<p>主体（Subject）指访问活动的发起者。主体可以是某个用户，也可以是代表用户执行操作的进程、服务和设备等。</p>
<p>（2）客体</p>
<p>客体（Object）指访问活动中被访问的对象。凡是可以被操作的信息、文件、设备、资源、服务等都可以作为客体，如网络中的某台服务器。</p>
<p>（3）访问</p>
<p>访问指的是对资源的各种类型的使用，如读取、修改、创建、删除、执行、发送、接收等操作。不同的系统有不同的访问类型。</p>
<p>（4）访问控制策略</p>
<p>访问控制策略体现了系统的授权行为，表现为主体访问客体时需要遵守的约束规则。访问控制策略可以采用三元组(S，O，P)的形式描述，其中S表示主体，O表示客体，P表示许可（Permission）。P指明了允许主体对客体进行访问的类型。访问控制策略是访问控制的核心，访问控制依据访问控制策略限制主体对客体的访问。访问控制策略通常存储在系统的授权服务器中。</p>
<p>访问监控器 （Reference Monitor）模型是最为著名的描述访问控制的抽象模型。如图7-12所示，按照访问监控器模型的描述，在系统中出现访问请求时，访问监控器对访问请求进行裁决，它向授权服务器进行查询，根据其中存储的访问控制策略决定主体对客体的访问是否被允许。</p>
<p><img src="/img/795feb6934bf0fa1c3dcd5e2cda6f5aa.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>访问监控器模型中有一个负责审计的功能模块。审计是访问控制的必要补充。审计文件将记录与访问有关的各类信息，包括主体、客体、访问类型、访问时间及访问是否被允许等。管理员通过查看审计文件，能够详细了解系统中访问活动的具体情况，主要可以掌握三个方面的信息。一是哪些主体对哪些资源的访问请求被拒绝。主体发出大量违规的访问请求往往是攻击、破坏活动的征兆，需要引起特别的关注。二是访问控制策略是否得到了严格执行。如果在配置或者执行规则过程中存在失误，一些违反访问控制策略的访问请求可能被许可。通过查看审计文件可以发现此类情况，亡羊补牢。三是访问活动的证据，这可以为事后追查、追究提供依据。</p>
<h3 id="5-2、访问控制策略">5.2、访问控制策略</h3>
<p>访问控制策略主要可分为三类：自主访问控制（Discretionary Access Control，DAC）、强制访问控制（Mandatory Access Control，MAC）和基于角色的访问控制（Role Based Access Control，RBAC）。</p>
<h4 id="5-2-1、自主访问控制">5.2.1、自主访问控制</h4>
<p>自主访问控制通常基于主客体的隶属关系，“自主”指的是客体的拥有者可以自主地决定其他主体对其拥有的客体进行访问的权限。自主访问控制具有很强的灵活性，但是存在一些明显的缺陷：权限管理过于分散，容易出现漏洞；无法有效控制被攻击主体破坏系统安全性的行为。</p>
<p>木马程序利用自主访问控制的以上缺陷，可以轻松破坏系统的安全性。例如，用户A对文件a具有读取权限。攻击者B为了非法获取该文件，编写了一个木马程序，并诱骗用户A运行该程序。当用户A运行木马程序时，木马程序获得用户A的访问权限，能够读取文件a的内容，并将该文件的内容写入新创建的文件b；然后用户A将文件b的读取权限授予用户B，则用户B将非法读取到文件a的内容。</p>
<h4 id="5-2-2、强制访问控制">5.2.2、强制访问控制</h4>
<p>自主访问控制的最大特点是自主，即资源的拥有者对资源的访问控制策略具有决策权，因此是一种限制比较弱的访问控制策略。这种策略在给用户带来灵活性的同时，也带来了安全隐患。</p>
<p>强制访问控制与自主访问控制不同，它不允许一般的主体进行访问权限的设置。在强制访问控制中，主体和客体被赋予一定的安全级别，普通用户不能改变自身或任何客体的安全级别，通常只有系统的安全管理员可以进行安全级别的设定。系统通过比较主体和客体的安全级别来决定某个主体是否能够访问某个客体。</p>
<p>下读和上写是在强制访问控制中广泛使用的两项原则。</p>
<p>（1）下读原则：主体的安全级别必须高于或等于被读客体的安全级别，主体读取客体的访问活动才能被允许。</p>
<p>（2）上写原则：主体的安全级别必须低于或等于被写客体的安全级别，主体写入客体的访问活动才能被允许。</p>
<p>下读原则和上写原则限制了信息只能由低级别的对象流向高级别或同级别的对象，能有效防止木马等恶意程序的窃密攻击。例如，用户A的安全级别高于文件a，而用户B的安全级别低于文件a，因此用户A可以读取文件a，而用户B不能读取文件a。即使用户A运行了用户B编写的木马程序，由于该木马程序具有与用户A同样的安全级别，它可以读取文件a，却不能将文件a的安全级别修改成用户B可读的安全级别，也无法将其内容写入安全级别比用户A低的文件，因此，用户B仍然无法读取到文件a中的信息。</p>
<h4 id="5-2-3、基于角色的访问控制">5.2.3、基于角色的访问控制</h4>
<p>基于角色的访问控制旨在降低安全管理的复杂度。在信息系统中，赋予用户什么样的访问权限往往取决于用户在工作中承担的角色（Role）。基于角色的访问控制的核心思想就是根据安全策略划分不同的角色，用户不再直接与许可关联，而是通过角色与许可关联。</p>
<p>在基于角色的访问控制中，一个用户可以拥有多个角色，一个角色也可以被赋予多个用户；一个角色可以拥有多种许可，一种许可也可以分配给多个角色。许可指明了对某客体可以进行的访问类型。</p>
<p>基于角色的访问控制通过角色的概念实现了用户和访问权限的逻辑分离。给角色配置许可的工作一般比较复杂，需要一定的专业知识，可以由专门的技术人员来承担；而赋予用户角色则较为简单，可以由一般管理人员来执行。角色与许可之间的关系比角色与用户的关系更加稳定，当一个用户的职责发生变化时或需要为一个新的用户授权时，只要修改或设置用户的角色即可。因此将用户和访问权限进行逻辑分离能够降低授权的复杂性，增强权限的可管理性，减少因授权失误导致安全漏洞的风险。</p>
<h2 id="六、网络各层的安全实例">六、网络各层的安全实例</h2>
<p>在前面各节中，我们学习了利用密码学技术实现机密性、完整性、数字签名和实体鉴别等安全服务的基本方法。在本节我们将讨论这些方法在网络各层的具体应用实例。这些安全应用实例涉及从物理层到应用层的所有层次。</p>
<p>读者可能会有这样的疑惑：为什么需要在网络的各层都提供安全服务，而不是仅在底层或最高层提供安全服务？通常低层协议的安全服务会为所有上层协议提供安全性，但层次越低，提供的安全性越通用，受众面越广，安全防护的粒度也就越粗。例如，在IP层的安全机制可以为所有主机提供安全通信服务，但却无法保证用户间电子邮件的安全性。因为利用电子邮件通信的双方并不直接在IP层上进行通信，电子邮件需要通过中间的邮件服务器转发。</p>
<p>反过来，是不是只要在应用层提供安全服务就足够了呢？网络应用种类繁多，出于开发成本、维护成本和使用成本的考虑，可能大多数用户只希望网络为各种应用提供基本的安全性保护，不一定需要每种网络应用都使用自己专用的安全协议。总之，不同用户对安全性会有不同的要求。另外，像拒绝服务这类破坏系统可用性的攻击，仅靠应用层的安全机制是无法防范的。因此，网络的不同层次都需要相应的安全机制，用户应根据具体情况和需求去选择。</p>
<h3 id="6-1、物理层实例：信道加密机">6.1、物理层实例：信道加密机</h3>
<p>信道加密技术是在物理层保证通信数据的机密性和完整性的方法。这项技术在计算机网络出现之前（甚至在数字通信出现之前）就已经存在了。信道加密机位于通信结点（如路由器）前端，对通信结点发送的所有数据都进行加密处理，然后将其发送到物理链路上。信道加密机一般用于点对点链路，并成对使用。信道加密是一种物理层的链路级加密（链路级加密也可以在数据链路层进行），网络中每段链路上的加密是独立实现的，如图7-13所示。</p>
<p><img src="/img/6b239d326beef5b34b9aedd526639e6d.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>使用信道加密技术的一个好处就是对上层协议几乎没有任何影响（即具有很好的透明性），又能为通过该链路的所有数据提供安全保护。由于链路上传输的协议数据单元中的控制信息和数据信息都被加密了，掩盖了源地址和目的地址，因此它还能防止各种形式的流量分析。信道加密机完全使用硬件加密技术，速度快，不需要传送额外的数据，采用这种技术不会降低网络的有效带宽。</p>
<p>但由于分组是以明文形式在各结点内部进行加密的，所以结点本身必须是安全的。一般认为网络的源点和终点在物理上都是安全的，但所有的中间结点（包括可能经过的路由器）则未必都是安全的。因此，在网络互连的情况下，仅采用信道加密是不能保证端到端通信的安全性的，它只能用于保护网络局部链路的通信安全。因此，在实际应用中，通常只在容易被窃听的无线链路上（如卫星链路）或者在军用网络等专用网络的通信链路（如SDH专线）穿过不安全区域时使用信道加密技术，更多的情况是在网络层以上使用端到端的加密技术为用户提供安全通信服务。</p>
<h3 id="6-2、数据链路层实例：802-11i">6.2、数据链路层实例：802.11i</h3>
<p>随着802.11无线局域网技术应用的日益广泛，无线网络的安全问题越来越受到人们的关注。网络的安全性主要体现在访问控制和数据加密两个方面。访问控制保证只有授权用户才能对网络资源进行访问，而数据加密则保证发送的数据只能被期望的用户所接收和理解。在无线通信方式下，电磁波在自由空间中辐射传播，只要在无线AP信号覆盖的范围内，所有的无线终端都可以接收到无线信号。如果没有相应的安全机制，任何终端都可以随意接入网络，使用网络资源或窃听所有的通信。因此802.11无线局域网的安全保密问题就显得尤为突出。802.11无线局域网主要在数据链路层为用户提供安全性。</p>
<h4 id="6-2-1、早期无线局域网的安全机制">6.2.1、早期无线局域网的安全机制</h4>
<p>早期802.11无线局域网的安全机制比较简单，主要使用以下几种安全机制为用户提供极其有限的安全保护。</p>
<p>（1）SSID匹配</p>
<p>该机制提供了一种无加密的鉴别服务，主要以服务集标识符（Service Set ID，SSID）作为基本的鉴别方式。试图接入无线局域网的终端必须配置与BSS中AP相同的SSID。网络管理员安装AP时，必须为该AP分配一个不超过32字节的名字，这个名字就是SSID。通常AP会周期性广播SSID，无线终端通过扫描功能查看当前区域内的SSID，并选择要接入的网络。当AP采用无加密鉴别方式时，要禁用SSID广播，此时用户要手工设置无线终端的SSID才能接入相应的网络。SSID在客户端和AP之间以明文形式传输，就是一种简单的不加密的口令鉴别。这种鉴别方式显然不能防止窃听和冒充，只是提供了一种非常弱的访问控制机制。</p>
<p>（2）MAC地址过滤</p>
<p>一些厂商的接入点使用MAC地址过滤来进行简单的访问控制。管理员可以为AP设置一个允许接入无线局域网的MAC地址列表，也可以设置要拒绝接入的MAC地址列表。只有MAC地址被规则允许的无线终端发送的帧，才能被AP接收和转发。由于攻击者可以通过无线网络信息流来侦听有效的MAC地址，并通过配置无线局域网网卡使用同样的MAC地址来接入网络，所以MAC地址过滤和SSID匹配一样，只能提供最简单的访问控制功能。</p>
<p>（3）WEP算法</p>
<p>有线等效保密（Wired Equivalent Privacy，WEP）算法是一种可选的数据链路层安全机制，用来提供实体鉴别、访问控制、数据加密和完整性检验等。WEP采用对称共享密钥加密技术，它需要管理员预先在终端和AP中配置共享的WEP密钥（静态WEP密钥）。一方使用这个密钥对数据进行加密，另一方使用相同的共享密钥对接收到的密文进行解密。该加密算法和共享密钥既用于实体鉴别，又用于数据通信。WEP算法采用我们在7.3节介绍的挑战—响应协议进行实体鉴别。</p>
<p>WEP算法中没有密钥分发机制，不产生临时的通信密钥，包括鉴别在内的所有通信过程都使用同一共享密钥，并且所有接入该服务集的终端都使用这个密钥。WEP算法加密强度较低，国内外众多研究已从理论和实践上证明了WEP加密存在严重的安全隐患。</p>
<h4 id="6-2-2、IEEE-802-11i">6.2.2、IEEE 802.11i</h4>
<p>IEEE 802.11于1999年发布后不久，人们就开始研究具有更强安全性机制的、新型的、改进的802.11版本。这个新标准被称为802.11i，在2004年最终得到批准。WEP算法提供了相对弱的加密形式，执行鉴别仅有单一机制，并且没有密钥分发机制，IEEE 802.11i却提供了强得多的加密形式，主要包括一种可扩展的鉴别机制的集合、更强的加密算法，以及一种密钥分发机制。IEEE 802.11i的商业名称为WPA2（WiFiProtected Access 2，意思是“无线局域网受保护的接入”的第二个版本），而WPA是802.11i的一个子集，在802.11i正式发布前，作为无线局域网安全的过渡标准，代替WEP算法为802.11无线局域网提供更强的安全性。</p>
<p>当前无线局域网大都支持WPA或WPA2，但应该尽量使用WPA2。我们在PC的Windows桌面上单击“开始”→“设置”→“网络连接”→“无线网络连接”，就会看见在当前无线局域网信号覆盖范围中的一些网络名称。有的网络名称下面会显示“启用安全的无线网络（WPA）/（WPA2）”，这就表明对这个网络，只有在弹出的密码窗口中输入正确密码后，才能与其AP建立关联。</p>
<p>图7-14描述了802.11i的基本交互过程。除了无线终端和接入点外，802.11i定义了一台鉴别服务器（Authentication Server，AS），AP能够与它通信。将鉴别服务器与AP分离，使得一台鉴别服务器服务于许多AP，负责做出有关鉴别和接入的决定，这降低了AP的成本和复杂性。在802.11i中，终端和AP间建立安全通信的过程分为四个阶段。</p>
<p><img src="/img/b56806999a897b4b9bccb3f4d892eeb4.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>（1）安全性能力发现。在发现阶段，AP通告它的存在并能够向无线终端提供鉴别和加密的方式。该终端则请求它希望的特定鉴别和加密方式。尽管终端和AP这时已经交换了报文，但该终端还没有被鉴别，也没有用于数据通信的加密密钥，因此在该终端能够通过无线信道与任何远程主机通信之前，还需要进行几个其他步骤。</p>
<p>（2）相互鉴别和主密钥（Master Key，MK）生成。鉴别发生在无线终端和鉴别服务器之间。在这个阶段，接入点基本上只是起到通信中继的作用，在终端和鉴别服务器之间转发报文。扩展的鉴别协议 （Extensible Authentication Protocol，EAP）（RFC 2284）定义了一种端到端的报文格式，用于终端和鉴别服务器之间的双向鉴别过程。实际上，EAP是一个鉴别框架，并未指定具体的鉴别协议。使用EAP，鉴别服务器能够选择若干方式中的一种来执行鉴别，主要是利用公钥加密技术（包括不重数加密和报文摘要）在终端和鉴别服务器之间进行相互鉴别，并生成为双方所共知的一个主密钥MK。</p>
<p>（3）成对主密钥（Pairwise Master Key，PMK）生成。MK是一个仅为该终端和鉴别服务器所知的共享密钥（在WEP中，所有终端共享同一密钥），它们彼此再来生成一个次密钥，即成对主密钥PMK，由于AP和终端共享。鉴别服务器将该PMK发送给AP，这时终端和AP具有一个共享的密钥，并相互鉴别。</p>
<p>（4）临时密钥（Temporal Key，TK）生成。使用PMK，无线终端和AP能够生成用于通信的临时密钥TK（即会话密钥）。TK将被用于执行经无线链路向任意远程主机发送数据的链路级的数据加密。</p>
<p>802.11i提供了几种加密形式，包括一种基于高级加密标准 （Advanced Encryption Standard，AES）的加密方案和WEP加密的强化版本临时密钥完整性协议 （Temporal Key Integrity Protocol，TKIP）。</p>
<p>802.11i考虑了不同的用户和不同的应用安全需要。例如，企业用户需要很高的安全保护（企业级），否则可能会泄露非常重要的商业机密；而家庭用户往往只是使用网络来浏览网页、收发电子邮件等，这些用户对安全的要求相对较低。为了满足不同用户的需要，802.11i规定了两种应用模式。</p>
<p>企业模式：通过使用鉴别服务器和复杂的安全鉴别机制来保护无线网络的通信安全。</p>
<p>家庭模式（包括小型办公室）：也称为个人模式，在AP（或者无线路由器）及连接无线网络的无线终端上配置预设共享密钥<br>
（Pre-Shared Key，PSK）来保护无线网络的通信安全。</p>
<h4 id="6-2-3、WAPI">6.2.3、WAPI</h4>
<p>针对WLAN安全隐患，我国早在2003年就正式发布了中国无线局域网安全标准——无线局域网鉴别和保密基础架构 （WLAN Authentication Privacy Infrastructure，WAPI）。WAPI安全系统采用公钥密码技术，AS负责证书的签发、验证与吊销等，无线终端与无线接入点上都要安装AS签发的证书。当无线终端接入网络时，必须通过AS进行双向鉴别，并生成会话密钥对数据传输进行保护。虽然WAPI功能强大，但它与IEEE 802.11i并不兼容，目前支持WAPI的设备还比较少。</p>
<h3 id="6-3、网络层实例：IPSec">6.3、网络层实例：IPSec</h3>
<p>IPsec（IP security，IP安全）是为互联网网络层提供安全服务的一组协议（RFC 2401～RFC 2411）。这个协议相当复杂，在此仅介绍其基本原理。IPsec可以以两种不同的方式运行：传输方式和隧道方式，如图7-15所示。</p>
<p><img src="/img/f6e0ee5b1e975f35208d5b6905bd2e4c.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在传输方式 下，IPsec保护运输层交给网络层传递的内容，即只保护IP数据报的有效载荷，而不保护IP数据报的首部。传输方式通常用于主机到主机的数据保护，如图7-16所示。发送主机使用IPsec加密来自运输层的有效载荷，并将其封装成IP数据报进行传输。接收主机使用IPsec解密IP数据报，并将它传递给运输层。使用IPsec时还可以增加鉴别功能，或仅仅进行鉴别而不加密。</p>
<p><img src="/img/36440b3f352f685bb96921c11104b989.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在隧道方式 下，IPsec保护包括IP首部在内的整个IP数据报，为了对整个IP数据报进行鉴别或加密，要为该IP数据报增加一个新的IP首部，而将原IP数据报作为有效载荷进行保护。隧道方式通常用于两个路由器之间，或一个主机与一个路由器之间，如图7-17所示。IPsec的隧道方式常用来实现虚拟专用网 （VPN）。</p>
<p><img src="/img/580ad9df47ffa19a5d8c826c65c6891d.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>IPsec协议簇中有两个主要的协议：鉴别首部 （Authentication Header，AH）协议 和封装安全载荷 （Encapsulation Security Payload，ESP）协议 。AH协议提供源鉴别和数据完整性服务，但不提供机密性服务。ESP协议同时提供鉴别、数据完整性和机密性服务。</p>
<p>在两个结点之间用AH协议或ESP协议进行通信之前，首先要在这两个结点之间建立一条网络层的逻辑连接，称为安全关联 （Security Association，SA）。通过安全关联，双方确定将采用的加密或鉴别算法，以及各种安全参数，并在SA建立时产生一个32位的安全参数索引 （Security Parameter Index，SPI）。目的结点根据IPsec报文携带的SPI将其与特定SA使用的加密算法和密钥等相关联。</p>
<h4 id="6-3-1、鉴别首部协议">6.3.1、鉴别首部协议</h4>
<p>在使用AH协议时，源结点把AH首部插到IP数据报首部和被保护的数据之间，如图7-18所示，同时将IP首部中的协议字段置为51，指明该报文数据中包含一个AH首部。在传输过程中，中间路由器并不查看AH首部，当IP数据报到达终点时，目的主机或终点路由器才处理AH字段，以鉴别源和报文数据的完整性。</p>
<p><img src="/img/80b14fca006c6e3541eafed5a5a43455.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>AH首部中的一些主要字段如下。</p>
<p>（1）下一个首部：标志紧接AH首部的下一个首部的类型（如TCP、UDP、IP等）。</p>
<p>（2）安全参数索引SPI：标志一个安全关联（SA）。</p>
<p>（3）序号：该SA中每个数据报的序号，当建立SA时起始序号为0。AH协议用该序号防止重放攻击。</p>
<p>（4）鉴别数据 ：一个可变长字段，包含一个经过加密或签名的报文摘要。该报文摘要对整个IP数据报进行鉴别，但不包括在传输中会发生改变的那些IP首部字段，如生存时间（TTL）等。</p>
<h4 id="6-3-2、封装安全载荷协议">6.3.2、封装安全载荷协议</h4>
<p>在使用ESP协议时，IP数据报首部的协议字段置为50，指明其后紧接着的是一个ESP首部，如图7-19所示。ESP首部包含一个SPI字段和一个序号字段。ESP尾部包含下一个首部字段和填充数据。鉴别数据和AH协议中的鉴别数据的作用一样，但不对IP首部进行鉴别。ESP协议对有效载荷和ESP尾部进行了加密，因此ESP协议既提供鉴别和数据完整性服务，又提供机密性服务。</p>
<p><img src="/img/7f17842c244160d185d543ad40f829c3.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="6-4、运输层实例：SSL-TLS">6.4、运输层实例：SSL/TLS</h3>
<p>当万维网能够用于网上购物时，安全问题就被提到桌面上来了。当一位顾客在网上在线购物时，他会要求得到下列安全服务。</p>
<p>（1）顾客需要确保服务器属于真正的销售商，而不是属于一个冒充者（如一个钓鱼网站），因为顾客不希望将他的信用卡账号交给一个冒充者。同样，销售商也需要对顾客进行鉴别。</p>
<p>（2）顾客与销售商需要确保报文的内容（如账单）在传输过程中没有被篡改。</p>
<p>（3）顾客与销售商需要确保信用卡账号之类的敏感信息不被冒充者窃听。</p>
<p>上述安全服务需要使用运输层的安全协议。现在广泛使用的有两个协议：SSL（Secure Socket Layer，安全套接字层 ）协议和TLS（Transport Layer Security，运输层安全 ）协议。</p>
<p>下面简单介绍这两个协议的特点。</p>
<p>SSL协议是Netscape公司在1994年开发的安全协议，广泛用于基于万维网的各种网络应用（但不限于万维网应用）。SSL作用在端系统应用层的HTTP和运输层之间，在TCP之上建立起一个安全通道，为通过TCP传输的应用层数据提供安全保障。</p>
<p>1995年，Netscape公司把SSL协议转交给IETF，希望能够把SSL协议标准化。于是IETF在SSL 3.0的基础上设计了TLS协议，为所有基于TCP的网络应用提供安全数据传输服务。现在使用最多的运输层安全协议是TLS 1.0，但新的版本TLS 1.2已经公布了（RFC 5246，RFC 5746，RFC 5878）。</p>
<p>图7-20表示SSL/TLS协议处在应用层和运输层之间。在应用层中使用SSL/TLS协议最多的就是HTTP，但并不局限于HTTP。当用浏览器查看普通网站的网页时，HTTP直接使用TCP连接，这时SSL/TLS协议不起作用。但当用信用卡进行网上支付而键入信用卡密码时，支持SSL/TLS协议的Web服务器会提供一个使用SSL/TLS协议的安全网页，浏览器访问该网页时就需要运行SSL/TLS协议。这时，HTTP会调用SSL/TLS协议对整个网页进行加密。这时网址栏原来显示http的地方变成了https。在http后面加上的s代表security，表明现在使用的是提供安全服务的HTTP。</p>
<p><img src="/img/b9e8195498fa19aa29541b9f83c5d75a.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>SSL协议提供以下三种安全服务。</p>
<p>（1）SSL服务器鉴别：允许用户证实服务器的身份。支持SSL协议的客户通过验证来自服务器的证书来鉴别服务器的真实身份并获得服务器的公钥。</p>
<p>（2）SSL客户鉴别：SSL协议的可选安全服务，允许服务器证实客户的身份。</p>
<p>（3）加密的SSL会话：对客户和服务器间发送的所有报文进行加密，并检测报文是否被篡改。</p>
<p>下面以万维网应用为例来说明SSL协议的工作过程。</p>
<p>销售商B的万维网服务器使用SSL协议为顾客提供安全的在线购物。为此，万维网服务器使用SSL协议的默认服务443端口来取代普通万维网服务的80端口，并且在该安全网页的URL中用https替代http。当顾客单击该网站链接建立TCP连接后，SSL协议先进行浏览器和服务器之间的握手，完成加密算法的协商和会话密钥的传递，然后进行安全数据传输。其简要过程如图7-21所示（实际步骤要复杂得多）。</p>
<p><img src="/img/3eeb422dbe95145383dfdf7d67d9d70e.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>（1）协商加密算法。浏览器A向服务器B提供一些可选的加密算法，B从中选定自己所支持的算法，并告知A。</p>
<p>（2）服务器鉴别。服务器B向浏览器A发送一个包含其公钥的数字证书，A使用该证书的CA公开发布的公钥对该证书进行验证。</p>
<p>（3）会话密钥计算。浏览器A随机产生一个秘密数，用服务器B的公钥进行加密后发送给B。双方根据协商的算法产生一个共享的对称会话密钥。</p>
<p>（4）安全数据传输。双方用会话密钥加密和解密它们之间传送的数据，并验证其完整性。</p>
<p>现在SSL协议和TLS协议已广泛用在各种浏览器中。例如，我们单击IE浏览器菜单中的“工具”→“选项”，再单击弹出的对话框中的“高级”，就可看到屏幕显示的默认选项是使用SSL 3.0和TLS 1.0，如图7-22所示。</p>
<p><img src="/img/925e3c061e02b0aa0fb431229bea9190.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="6-5、应用层实例：PGP">6.5、应用层实例：PGP</h3>
<p>在应用层实现安全通信相对简单，特别是当互联网的通信只涉及两方时，如电子邮件。本小节我们介绍在应用层为电子邮件提供安全服务的软件PGP。</p>
<p>PGP（Pretty Good Privacy）是由菲尔·齐默尔曼（Phil Zimmermann）于1995年开发的一个安全电子邮件软件。它是一个完整的电子邮件安全软件包，包括加密、数字签名和压缩等功能，为用户提供机密性、完整性、发件人鉴别和不可否认性四种安全服务。虽然PGP已被广泛使用，但PGP并不是互联网的正式标准。PGP通过报文摘要和数字签名技术为电子邮件提供完整性和不可否认性，使用对称密钥和公钥的组合加密来提供机密性。图7-23和图7-24说明了PGP是如何利用散列函数、发件方私钥、收件方公钥和一次性密钥实现安全电子邮件的。</p>
<p><img src="/img/284fbf5dd4836c415ea0ed9d39e5bcd7.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>PGP发件方用散列函数得到邮件摘要，并用其私钥进行签名，然后用生成的一次性密钥对邮件及其摘要进行加密。由于收件方不知道该一次性密钥，因此发件方用收件方公钥对其进行加密后将其与加密的邮件及其摘要一起发送给收件方。</p>
<p><img src="/img/32e5c984dceb5f663711526570612be2.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>PGP收件方首先用自己的私钥解密一次性密钥，然后用该密钥解密被加密的邮件及其摘要，最后用发件方的公钥核实摘要签名，验证邮件的完整性并对发件方进行鉴别。</p>
<p>在PGP中，发件方和收件方如何获得对方的公钥呢？当然，最安全的办法是双方面对面直接交换公钥，但在大多数情况下这并不现实。因此可以通过CA签发的证书来验证公钥持有者的合法身份。在PGP中不要求使用CA，而允许用一种第三方签署的方式来解决该问题。例如，如果用户A和用户B已经分别和第三方C互相确认对方拥有的公钥属实，则C可以用其私钥分别对A和B的公钥进行签名，为这两个公钥进行担保。当A得到一个经C签名的B的公钥时，可以用已确认的C的公钥对B的公钥进行鉴别。不过，用户发布其公钥的最常见的方式还是把公钥发布在他们的个人网页上或仅仅通过电子邮件进行分发。具体采用哪种方式发布自己的公钥取决于用户对安全性的要求。</p>
<h2 id="七、系统安全：防火墙与入侵检测系统">七、系统安全：防火墙与入侵检测系统</h2>
<p>恶意用户或软件通过网络对计算机系统的入侵或攻击已成为对计算机安全最严重的威胁之一。用户入侵方式包括利用系统漏洞进行未授权登录，以及授权用户非法获取更高级别权限。软件入侵方式包括通过网络传播病毒、蠕虫和特洛伊木马，以及阻止合法用户正常使用服务的拒绝服务攻击等。上一节讨论的安全机制都不能有效解决以上安全问题。例如，加密技术并不能阻止植入了特洛伊木马的计算机系统通过网络向攻击者泄露秘密信息。</p>
<p>防火墙 （Firewall）作为一种访问控制技术，通过严格控制进出网络边界的分组，禁止任何不必要的通信，来减少潜在入侵的发生，尽可能降低这类安全威胁所带来的安全风险。由于防火墙不可能阻止所有入侵行为，作为系统防御的第二道防线，入侵检测系统 （Intrusion Detection System）通过对进入网络的分组进行深度分析与检测，来发现疑似入侵行为的网络活动，并进行报警，以便进一步采取相应措施。</p>
<h3 id="7-1、防火墙">7.1、防火墙</h3>
<p>防火墙 是把一个组织的内部网络与其他网络（通常就是互联网）隔离开的软件和硬件的组合。根据访问控制策略，它允许一些分组通过，而禁止另一些分组通过。访问控制策略由使用防火墙的组织根据自己的安全需要自行制定。</p>
<p>图7-25所示为防火墙在互连网络中的位置。一般将防火墙内的网络称为“可信网络 ”（Trusted Network），而将外部的互联网称为“不可信网络 ”（Untrusted Network）。</p>
<p><img src="/img/1372d166aa24d13721ed092a2ca92d9d.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="7-1-1、防火墙的基本原理">7.1.1、防火墙的基本原理</h4>
<p>根据所采用的技术，防火墙一般分为两类，即分组过滤路由器和应用级网关。</p>
<h5 id="7-1-1-1、分组过滤路由器">7.1.1.1、分组过滤路由器</h5>
<p>分组过滤路由器是一种具有分组过滤功能的路由器，它根据过滤规则对进出内部网络的分组执行转发或者丢弃（即过滤）。过滤规则基于分组的网络层或运输层首部的信息，如源/目的地址、源/目的端口号、协议类型、标志位等。我们知道，TCP的端口号指出了在TCP上面的应用层服务。例如，端口号23对应TELNET，端口号119对应USENET，等等。所以如果在分组过滤路由器中对所有目的端口号为23的入分组 （Incoming Packet）都进行阻拦，那么所有外单位用户就不能使用TELNET登录到本单位的主机上。同理，如果某公司不愿意其雇员在上班时花费大量时间去看互联网的USENET新闻，就可以将目的端口号为119的出分组 （Outgoing Packet）阻拦住，使其无法发送到互联网。通常，过滤规则以访问控制列表 （Access Control List，ACL）的形式存储在路由器中，管理人员可以通过命令配置访问控制列表中的规则。表7-1是一个简单的ACL例子。</p>
<p><img src="/img/699aa04b1bbb6c6647f4864655609fa0.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>分组过滤可以是无状态的，即独立地处理每一个分组，如表7-1所示的ACL。更复杂的分组过滤路由器支持有状态的分组过滤，即要跟踪每个连接或会话的通信状态，并根据这些状态信息来决定是否转发分组。例如，一个目的端口是某个客户动态分配端口（该端口无法事先包含在规则中）的进入分组被允许通过的唯一条件是，该分组是该端口发出的合法请求的一个响应。这样的规则只能通过有状态的检查来实现。</p>
<p>分组过滤路由器的优点是简单、高效，且对于用户是透明的，但不能对高层数据进行过滤。例如，它不能禁止某个用户对某个特定应用进行某个特定的操作，也不支持应用层用户鉴别等。这些功能需要使用应用级网关来实现。</p>
<h5 id="7-1-1-2、应用级网关">7.1.1.2、应用级网关</h5>
<p>应用级网关也称为代理服务器 （Proxy Server），它在应用层通信中扮演报文中继的角色。一种网络应用需要一个应用级网关，例如，前面介绍过的万维网缓存就是一种万维网应用的代理服务器。在应用级网关中可以实现基于应用层数据的过滤和高层用户鉴别。</p>
<p>所有进出网络的应用程序报文都必须通过应用级网关。当用户通过应用级网关访问内网或外网资源时，应用级网关可以要求对用户的身份进行鉴别，然后根据用户身份对用户行为进行访问控制。</p>
<p>某应用的客户进程向服务器发送一份请求报文时，会先发送给应用级网关，应用级网关在应用层打开该报文，查看该请求是否合法（根据应用层用户标识符或其他应用层信息）。如果请求合法，应用级网关以客户进程的身份将请求报文转发给原始服务器。如果请求不合法，报文则被丢弃。例如，一个邮件网关在检查每一个邮件时，根据邮件地址或邮件的其他首部，甚至报文的内容（如有没有“导弹”“核弹头”等关键词）来确定该邮件能否通过防火墙。</p>
<p>应用级网关也有一些缺点。首先，每种应用都需要一个不同的应用级网关（可以运行在同一台主机上）。其次，在应用层转发和处理报文，处理负担较重。另外，它对应用程序不透明，需要在应用程序客户端配置应用级网关地址。</p>
<p>通常可将这两种技术结合使用，图7-25所示的防火墙就同时使用了这两种技术。它包括两个分组过滤路由器和一个应用级网关，它们通过两个局域网连接在一起。</p>
<h4 id="7-1-2、个人防火墙">7.1.2、个人防火墙</h4>
<p>某应用的客户进程向服务器发送一份请求报文时，会先发送给应用级网关，应用级网关在应用层打开该报文，查看该请求是否合法（根据应用层用户标识符或其他应用层信息）。如果请求合法，应用级网关以客户进程的身份将请求报文转发给原始服务器。如果请求不合法，报文则被丢弃。例如，一个邮件网关在检查每一个邮件时，根据邮件地址或邮件的其他首部，甚至报文的内容（如有没有“导弹”“核弹头”等关键词）来确定该邮件能否通过防火墙。以上讨论的防火墙以保护内部网络为目的，又称为网络防火墙 ，主要由负责网络安全的管理员配置和使用，普通计算机用户较少接触。普通用户接触更多的是个人防火墙 。个人防火墙指的是一种安装在用户计算机上的应用程序，其作用类似分组过滤路由器，对用户计算机的网络通信行为进行监控。与网络防火墙不同，个人防火墙只保护单台计算机。在用户计算机进行网络通信时，个人防火墙执行预设的分组过滤规则，拒绝或允许网络通信。</p>
<p>在配置完善的情况下，个人防火墙可以较好地阻止网络中的“黑客”或恶意代码攻击用户计算机，也有助于用户发现主机感染的木马等恶意程序。例如，用户在计算机上安装了一个新的网络游戏软件，该软件需要通过网络接收数据，防火墙会报警并询问用户要阻止连接还是允许连接。如果用户选择允许连接，个人防火墙会为程序创建一个例外，该程序以后需要进行网络通信时防火墙不会再报警，而是允许该程序从网络接收数据。</p>
<p>个人防火墙相对于网络防火墙而言，结构和实现都比较简单，在网络安全领域更多的是对网络防火墙的研究。</p>
<h4 id="7-1-3、防火墙的局限性">7.1.3、防火墙的局限性</h4>
<p>在网络边界位置部署防火墙，对于提高内网安全能够起到积极的作用，但是防火墙技术并不能解决所有的网络安全问题，我们要清楚它在安全防护方面的一些局限性。</p>
<p>（1）防火墙所发挥的安全防护作用在很大程度上取决于防火墙的配置是否正确和完备。用户要根据自己的情况制定严密的访问控制规则，阻止内网和外网间一切可疑的、未授权的或者不必要的通信，才能将安全风险降到最低。</p>
<p>（2）一些利用系统漏洞或网络协议漏洞进行的攻击，防火墙难以防范。攻击者通过防火墙允许的端口对服务器的漏洞进行攻击，一般的分组过滤防火墙基本上无力防御，应用级网关也必须具有识别该特定漏洞的条件，才可能阻断攻击。</p>
<p>（3）防火墙不能有效防止病毒、木马等通过网络传播。由于查杀恶意代码计算开销非常大，与网络宽带化对防火墙的处理速度的要求有巨大的矛盾，因此防火墙对恶意代码的查杀能力非常有限。</p>
<p>（4）防火墙技术自身存在一些不足。例如，分组过滤路由器不能防止IP地址和端口号欺骗，而应用级网关自身也可能有软件漏洞而存在被渗透攻击的风险。</p>
<h3 id="7-2、入侵检测系统">7.2、入侵检测系统</h3>
<p>防火墙试图在入侵行为发生之前阻止所有可疑的通信，但事实上不可能阻止所有的入侵行为。因此，有必要采取措施在入侵已经开始但还没有造成危害时，或在其造成更大危害前，及时检测到入侵，以便把危害降低到最小。入侵检测系统 （Intrusion Detection System，IDS）正是这样一种技术。IDS对进入网络的分组执行深度分组检查，当观察到可疑分组时，向网络管理员发出告警或执行阻断操作（由于IDS的误报率通常较高，因此多数情况下不执行自动阻断）。IDS能用于检测多种网络攻击，包括网络映射、端口扫描、DoS攻击、蠕虫和病毒、系统漏洞攻击等。</p>
<p>IDS一般可以分为基于特征的IDS和基于异常的IDS。</p>
<p>基于特征的IDS维护一个所有已知攻击标志性特征的数据库。每个特征就是一个与某种入侵活动相关联的行为模式或规则集，这些特征可能基于单个分组的首部字段值或数据中的特定比特串，或者与一系列分组有关。当发现与某种攻击特征匹配的分组或分组序列时，基于特征的IDS认为可能检测到了某种入侵行为。这些特征通常由网络安全专家提供，机构的网络管理员定制并将其加入数据库。被用于入侵检测的攻击特征必须具有很好的区分度，即这种特征出现在攻击活动中，而在系统正常的运行过程中通常不会出现。</p>
<p>基于特征的IDS只能检测已知攻击，对未知攻击则束手无策。基于异常的IDS通过观察系统正常运行时的网络流量，学习正常流量的统计特性和规律，当检测到网络流量中某种统计规律不符合正常情况时，则认为可能发生了入侵行为。例如，当攻击者对内网主机进行ping搜索时，可能导致ICMP报文突然大量增加，这与正常的统计规律有明显不同。但辨认正常流和统计异常流是一个非常困难的事情。迄今为止，大多数IDS是基于特征的，尽管其中一些IDS包括了某些基于异常的特性。</p>
<p>现在很多研究致力于将机器学习方法应用于入侵检测系统，让机器自动学习某种网络攻击的特征或者正常流量的模式。这种智能的方法可以大大减小人们对网络安全专家的依赖。</p>
<p>不论采用什么检测技术都存在“漏报”和“误报”情况。如果漏报率比较高，则只能检测到少量的入侵，给人以安全的假象。对于特定IDS，可以通过调整某些阈值或参数来降低漏报率，但这同时会提升误报率。误报率太高会导致大量虚假警报，网络管理员需要花费大量时间分析报警信息，甚至会因为虚假警报太多对报警“视而不见”，使IDS形同虚设。因此，误报率和漏报率是评价入侵检测系统效能的重要依据。</p>
<h2 id="八、网络攻击及其防范">八、网络攻击及其防范</h2>
<h3 id="8-1、网络扫描">8.1、网络扫描</h3>
<h3 id="8-2、网络监听">8.2、网络监听</h3>
<h3 id="8-3、拒绝服务攻击">8.3、拒绝服务攻击</h3>
<h2 id="九、参考">九、参考</h2>
<p><a target="_blank" rel="noopener" href="https://www.dedao.cn/ebook/detail?id=6JvkYVNn8NXVry5MeG6Z9RALK2dxJ3Gdd2w7olBEmjgakz1DPvYObQ4qpQdZqme9">计算机网络教程（第6版·微课版）</a></p>
<p><a target="_blank" rel="noopener" href="https://product.dangdang.com/29274044.html">计算机网络原理创新教程</a></p>
<p><a target="_blank" rel="noopener" href="https://product.dangdang.com/11846567948.html">计算机网络原理 自考04741</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%BD%91%E7%BB%9C/" class="category-chain-item">网络</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/" class="print-no-link">#计算机网络原理</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>计算机网络原理：网络安全</div>
      <div>https://kuberxy.github.io/2024/12/01/计算机网络原理07：网络安全/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Mr.x</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年12月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%8606%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/" title="计算机网络原理：物理层">
                        <span class="hidden-mobile">计算机网络原理：物理层</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
