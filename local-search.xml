<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据结构：外部排序</title>
    <link href="/2024/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/"/>
    <url>/2024/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>前述各类排序方法都是建立在关键字比较的基础上，而分配类排序不需要比较关键字的大小，它是根据关键字中各位的值，通过对待排序记录进行若干趟“分配”与“收集”来实现排序的，是一种借助于多关键字排序的思想对单关键字排序的方法。基数排序（Radix Sorting）是典型的分配类排序。</p><h2 id="一、直接插入排序">一、直接插入排序</h2><h2 id="二、折半插入排序">二、折半插入排序</h2><h2 id="三、希尔排序">三、希尔排序</h2><h2 id="四、小结">四、小结</h2><h2 id="五、参考">五、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：分配排序</title>
    <link href="/2024/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%88%86%E9%85%8D%E6%8E%92%E5%BA%8F/"/>
    <url>/2024/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%88%86%E9%85%8D%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>前述各类排序方法都是建立在关键字比较的基础上，而分配类排序不需要比较关键字的大小，它是根据关键字中各位的值，通过对待排序记录进行若干趟“分配”与“收集”来实现排序的，是一种借助于多关键字排序的思想对单关键字排序的方法。基数排序（Radix Sorting）是典型的分配类排序。</p><h2 id="一、直接插入排序">一、直接插入排序</h2><h2 id="二、折半插入排序">二、折半插入排序</h2><h2 id="三、希尔排序">三、希尔排序</h2><h2 id="四、小结">四、小结</h2><h2 id="五、参考">五、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：归并排序</title>
    <link href="/2024/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2024/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>归并排序（Merging Sort）就是将两个或两个以上的有序表合并成一个有序表的过程。将两个有序表合并成一个有序表的过程称为2-路归并，2-路归并最为简单和常用。</p><h2 id="一、直接插入排序">一、直接插入排序</h2><h2 id="二、折半插入排序">二、折半插入排序</h2><h2 id="三、希尔排序">三、希尔排序</h2><h2 id="四、小结">四、小结</h2><h2 id="五、参考">五、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：选择排序</title>
    <link href="/2024/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/2024/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>选择排序的基本思想是：每一趟从待排序的记录中选出关键字最小的记录，按顺序放在已经排序的记录序列的最后，直到全部排完为止。</p><h2 id="一、简单选择排序">一、简单选择排序</h2><p>简单选择排序（Simple Selection Sort）也称作直接选择排序。其算法步骤为：</p><ul><li>设待排序的记录存放在数组r[1…n]中。第一趟从r[1]开始，通过n-1次比较，从n个记录中选出关键字最小的记录，记为r[k]，交换r[1]和r[k]。</li><li>第二趟从r[2]开始，通过n-2次比较，从n-1个记录中选出关键字最小的记录，记为r[k]，交换r[2]和r[k]。</li><li>依次类推，第i趟从r[i]开始，通过n-i次比较，从n-i+1个记录中选出关键字最小的记录，记为r[k]，交换r[i]和r[k]。</li><li>经过n-1趟，排序完成。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 对顺序表L做简单选择排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">SelectSort</span><span class="hljs-params">(SqList &amp;L)</span> &#123;<br>    <span class="hljs-comment">// 在L.r[i..L.length]中选择关键字最小的记录</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;L.length;++i) &#123;<br>        k=i;<br>        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;=L.length;++j)<br>            <span class="hljs-comment">// k指向此趟排序中关键字最小的记录</span><br>            <span class="hljs-keyword">if</span>(L.r[j].key&lt;L.r[k].key) k=j;<br>        <span class="hljs-comment">// 交换r[i]与r[k]</span><br>        <span class="hljs-keyword">if</span>(k!=i) &#123;<br>            t=L.r[i];<br>            L.r[i]=L.r[k];<br>            L.r[k]=t;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单选择排序过程中，所需进行记录移动的次数较少。最好情况（正序）：不移动；最坏情况（逆序）：移动3(n−1)次。然而，无论记录的初始排列如何，所需进行的关键字间的比较次数相同，均为</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>K</mi><mi>C</mi><mi>N</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><mi>n</mi><mo>−</mo><mi>i</mi><mo>=</mo><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>≈</mo><msup><mi>n</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">KCN=\sum_{i=1}^{n-1} n-i = n(n-1)/2 \approx n^2/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.10903em;">CN</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/2</span></span></span></span></span></p><p>因此，简单选择排序的时间复杂度也是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><p>同冒泡排序一样，只有在两个记录交换时需要一个辅助空间，所以空间复杂度为O(1)。</p><p>算法特点：</p><ul><li>就选择排序方法本身来讲，它是一种稳定的排序方法，但图8.6所表现出来的现象是不稳定的，这是因为上述实现选择排序的算法采用“交换记录”的策略所造成的，改变这个策略，可以写出不产生“不稳定现象”的选择排序算法。</li><li>可用于链式存储结构。</li><li>移动记录次数较少，当每一记录占用的空间较多时，此方法比直接插入排序快。</li></ul><p>从上述可见，选择排序的主要操作是进行关键字间的比较，因此改进简单选择排序应从如何减少“比较”出发考虑。显然，在n个关键字中选出最小值，至少要进行n−1次比较，然而，继续在剩余的n−1个关键字中选择次小值并非一定要进行n−2次比较，若能利用前n−1次比较所得信息，则可减少以后各趟选择排序中所用的比较次数。实际上，体育比赛中的锦标赛便是一种选择排序。比如，在8个运动员中决出前3名至多需要11场比赛，而不是7+6+5=18场比赛（它的前提是，若乙胜丙，甲胜乙，则认为甲必能胜丙）。</p><p>例如，下图（a）中最低层的叶子结点中8个选手之间经过第一轮的4场比寒之后选拔出4个优胜者“CHA”、“BAO”、“DIAO”和“WANG”，然后经过两场半决赛和一场决赛之后，选拔出冠军“BAO”。显然，按照锦标赛的传递关系，亚军只能产生于分别在决赛、半决赛和第一轮比赛中输给冠军的选手中。由此，在经过“CHA”和“LIU”、“CHA”和“DIAO”的两场比赛之后，选拔出亚军“CHA”，同理，选拔季军的比赛只要在“ZHAO”、“LIU”和“DIAO”3个选手之间进行即可。按照这种锦标赛的思想可导出树形选择排序。</p><p><img src="/img/e45e70a8b5c7b05e533f7c26c628796a.jpg" alt="img"></p><h2 id="二、树形选择排序">二、树形选择排序</h2><p>树形选择排序（Tree Selection Sort），又称锦标赛排序（Tournament Sort），是一种按照锦标赛的思想进行选择排序的方法。首先对n个记录的关键字进行两两比较，然后在其中$\lceil n/2 \rceil $个较小者之间再进行两两比较，如此重复，直至选出最小关键字的记录为止。这个过程可用一棵有n个叶子结点的完全二叉树表示。例如，下图中的二叉树表示从8个关键字中选出最小关键字的过程。</p><p><img src="/img/0b4e7172ef4832b2e5d5be4138cb1070.jpg" alt="img"></p><p>8个叶子结点中依次存放排序之前的8个关键字，每个非终端结点中的关键字均等于其左、右孩子结点中较小的关键字，则根结点中的关键字即为叶子结点中的最小关键字。在输出最小关键字之后，根据关系的可传递性，欲选出次小关键字，仅需将叶子结点中的最小关键字13改为“最大值”，然后从该叶子结点开始，和其左（或右）兄弟的关键字进行比较，修改从叶子结点到根的路径上各结点的关键字，则根结点的关键字即为次小关键字。同理，可依次选出从小到大的所有关键字（参见上图（b）和（c））。</p><p>由于含有n个叶子结点的完全二叉树的深度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">⌉</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lceil log_2n \rceil + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，则在树形选择排序中，除了最小关键字外，每选择一个次小关键字仅需进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil log_2n \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">⌉</span></span></span></span>次比较，因此，它的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。但是，这种排序方法尚有辅助存储空间较多、和“最大值”进行多余的比较等缺点。为了改进这个缺点，威廉姆斯（J.Willioms）在1964年提出了另一种形式的选择排序——堆排序。</p><h2 id="三、堆排序">三、堆排序</h2><p>堆排序（Heap Sort）是一种树形选择排序，在排序过程中，将待排序的记录r[1…n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系，在当前无序的序列中选择关键字最大（或最小）的记录。</p><h3 id="3-1、堆的定义">3.1、堆的定义</h3><p>堆是含有n个元素的序列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>k</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>k</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>k</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{k_1,k_2,...,k_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，并且满足以下条件：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub><mo>≥</mo><msub><mi>k</mi><mrow><mn>2</mn><mi>i</mi></mrow></msub><mtext>且</mtext><msub><mi>k</mi><mi>i</mi></msub><mo>≥</mo><msub><mi>K</mi><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mspace width="1em"/><mtext>或</mtext><mspace width="1em"/><msub><mi>k</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>k</mi><mrow><mn>2</mn><mi>i</mi></mrow></msub><mtext>且</mtext><msub><mi>k</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>K</mi><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mo stretchy="false">⌊</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k_i \ge k_{2i}且k_i \ge K_{2i+1} \quad 或 \quad k_i \le k_{2i}且k_i \le K_{2i+1} (1 \le i \le \lfloor n/2 \rfloor)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">且</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9028em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">或</span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">且</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal">n</span><span class="mord">/2</span><span class="mclose">⌋)</span></span></span></span></span></p><p>若将和此序列对应的一维数组（即以一维数组做此序列的存储结构）看成是一个完全二叉树，则堆实质上是一个特殊的完全二叉树：树中所有非终端结点的值均不大于（或不小于）其左、右孩子结点的值。</p><p>例如，关键字序列{96,83,27,38,11,09}和{12,36,24,85,47,30,53,91}分别满足条件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub><mo>≥</mo><msub><mi>k</mi><mrow><mn>2</mn><mi>i</mi></mrow></msub><mtext>且</mtext><msub><mi>k</mi><mi>i</mi></msub><mo>≥</mo><msub><mi>K</mi><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mo stretchy="false">⌊</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k_i \ge k_{2i}且k_i \ge K_{2i+1} (1 \le i \le \lfloor n/2 \rfloor)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">且</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal">n</span><span class="mord">/2</span><span class="mclose">⌋)</span></span></span></span>和条件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="1em"/><msub><mi>k</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>k</mi><mrow><mn>2</mn><mi>i</mi></mrow></msub><mtext>且</mtext><msub><mi>k</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>K</mi><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mo stretchy="false">⌊</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\quad k_i \le k_{2i}且k_i \le K_{2i+1} (1 \le i \le \lfloor n/2 \rfloor)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">且</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal">n</span><span class="mord">/2</span><span class="mclose">⌋)</span></span></span></span>，故它们均为堆，对应的完全二叉树分别如下图（a）和（b）所示。显然，在这两种堆中，堆顶元素（或完全二叉树的根）必为序列中n个元素的最大值（或最小值），分别称之为大根堆（或小根堆）。</p><p><img src="/img/image-20240225145259741.png" alt="image-20240225145259741"></p><h3 id="3-2、算法步骤">3.2、算法步骤</h3><p>堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征，使得在当前无序的序列中选择关键字最大（或最小）的记录变得简单。下面讨论用大根堆进行排序，堆排序的步骤如下。</p><ul><li>按堆的定义将待排序序列r[1…n]调整为大根堆（这个过程称为建初堆），交换r[1]和r[n]，则r[n]为关键字最大的记录。</li><li>将r[1…n-1]重新调整为大根堆，交换r[1]和r[n-1]，则r[n-1]为关键字次大的记录。</li><li>循环n-1次，直到交换了r[1]和r[2]为止，得到一个非递减的有序序列r[1…n]。</li></ul><p>同样，可以通过构造小根堆得到一个非递增的有序序列。由此，实现堆排序需要解决如下两个问题。</p><p>（1）建初堆：如何将一个无序序列建成一个堆？</p><p>（2）调整堆：去掉堆顶元素，在堆顶元素改变之后，如何将剩余元素调整成为一个新的堆？</p><p>因为建初堆要用到调整堆的操作，所以下面先讨论调整堆的实现。</p><h3 id="3-2、调整堆">3.2、调整堆</h3><p>我们先看一个具体例子，下图（a）是一个大根堆，将堆顶元素97和堆中最后一个元素38交换后，如下图（b）所示。此时除根结点外，其余结点均满足堆的性质，因此需从上到下进行一条路径上的结点调整。</p><p><img src="/img/image-20240225154048879.png" alt="image-20240225154048879"></p><p>首先将堆顶元素38和其左、右子树根结点的值进行比较，由于左子树根结点的值大于右子树根结点的值且大于根结点的值，因此将38和76交换（如下图（c））；因为38替代了76之后破坏了左子树的“堆”，所以需进行和上述相同的调整，直至叶子结点，最终调整完成后的状态如下图（d）所示。</p><p><img src="/img/image-20240225155015249.png" alt="image-20240225155015249"></p><p>重复上述过程，将堆顶元素76和堆中最后一个元素27交换，进行相应调整后，得到如下图（f）所示新的堆。</p><p><img src="/img/image-20240225155844165.png" alt="image-20240225155844165"></p><p>上述调整过程就像过筛子一样，把较小的关键字逐层筛下去，而将较大的关键字逐层选上来。因此，称此方法为“筛选法”。</p><p>假设r[s+1…m]已经是堆，按“筛选法”将r[s…m]调整为以r[s]为根的堆，其算法步骤是：从r[2s]和r[2s+1]中选出关键字较大者，假设r[2s]的关键字较大，比较r[s]和r[2s]的关键字。</p><ul><li>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo stretchy="false">[</mo><mi>s</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>k</mi><mi>e</mi><mi>y</mi><mo>≥</mo><mi>r</mi><mo stretchy="false">[</mo><mn>2</mn><mi>s</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">r[s].key \ge r[2s].key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord">2</span><span class="mord mathnormal">s</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span></span></span></span>，说明以r[s]为根的子树已经是堆，不必做任何调整。</li><li>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo stretchy="false">[</mo><mi>s</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>k</mi><mi>e</mi><mi>y</mi><mo>&lt;</mo><mi>r</mi><mo stretchy="false">[</mo><mn>2</mn><mi>s</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">r[s].key \lt r[2s].key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord">2</span><span class="mord mathnormal">s</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span></span></span></span>，则交换r[s]和r[2s]。交换后，以r[2s+1]为根的子树仍是堆，如果以r[2s]为根的子树不是堆，则重复上述过程，将以r[2s]为根的子树调整为堆，直至进行到叶子结点为止。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 假设r[s+1..m]已经是堆，将r[s..m]调整为以r[s]为根的大根堆</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">HeapAdjust</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> m)</span> &#123;<br>    rc=L.r[s];<br><br>    <span class="hljs-comment">// 沿key较大的孩子结点向下筛选</span><br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">2</span>*s;j&lt;=m;j*=<span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-comment">// j为r[2s]和r[2s+1]中关键字较大者的下标</span><br>        <span class="hljs-keyword">if</span>(j&lt;m &amp;&amp; L.r[j].key&lt;L.r[j+<span class="hljs-number">1</span>].key ) ++j;<br>        <span class="hljs-comment">// r[s].key&gt;=r[2s].key，无需进行交换</span><br>        <span class="hljs-keyword">if</span>(rc.key&gt;=L.r[j].key) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// r[s].key&lt;r[2s].key，交换r[s]和r[2s]</span><br>        L.r[s]=L.r[j];<br>        s=j;<br>    &#125;<br><br>    <span class="hljs-comment">// rc应插入在位置s上</span><br>    L.r[s]=rc;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3、建初堆">3.3、建初堆</h3><p>要将一个无序序列调整为堆，就必须将其所对应的完全二叉树中以每一结点为根的子树都调整为堆。显然，只有一个结点的树必是堆，而在完全二叉树中，所有序号大于$\lfloor n/2 \rfloor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>的结点都是叶子，因此以这些结点为根的子树均已是堆。这样，只需利用筛选法，从最后一个非终端结点</mtext></mrow><annotation encoding="application/x-tex">的结点都是叶子，因此以这些结点为根的子树均已是堆。这样，只需利用筛选法，从最后一个非终端结点</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">的结点都是叶子，因此以这些结点为根的子树均已是堆。这样，只需利用筛选法，从最后一个非终端结点</span></span></span></span>\lfloor n/2 \rfloor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>开始，依次将序号为</mtext></mrow><annotation encoding="application/x-tex">开始，依次将序号为</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">开始，依次将序号为</span></span></span></span>\lfloor n/2 \rfloor , \lfloor n/2 \rfloor - 1,…,1$的结点作为根的子树都调整为堆即可。</p><p>建初堆的算法步骤为：对于无序序列r[1…n]，从i=n/2开始，反复调用筛选法HeapAdjust(L,i,n)，依次将以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">r[i],r[i-1],...,r[1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>为根的子树调整为堆。相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 把无序序列L.r[1..n]建成大根堆</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreatHeap</span><span class="hljs-params">(SqList &amp;L)</span> &#123;<br>    n=L.length;<br><br>    <span class="hljs-comment">// 反复调用HeapAdjust</span><br>    <span class="hljs-keyword">for</span>(i=n/<span class="hljs-number">2</span>;i&gt;<span class="hljs-number">0</span>;--i)<br>        HeapAdjust(L,i,n);<br>&#125;<br></code></pre></td></tr></table></figure><p>例如，已知无序序列为{49,38,65,97,76,27,<strong>49</strong>}，用“筛选法”将其调整为一个大根堆，其建堆过程如下。</p><p><img src="/img/image-20240225171128156.png" alt="image-20240225171128156"></p><p>从上图（a）所示的无序序列的最后一个非终端结点开始筛选，即从第4个元素97开始，由于97&gt;<strong>49</strong>，无需交换。同理，第3个元素65不小于其左、右子树根的值，仍无需交换。而第2个元素38&lt;97，被筛选之后序列的状态如上图（b）所示，然后对根元素49筛选之后得到上图（c）所示的大根堆。</p><h3 id="3-4、算法实现">3.4、算法实现</h3><p>根据前面堆排序算法步骤的描述，可知堆排序就是将无序序列建成初堆以后，反复进行交换和堆调整。在建初堆和调整堆算法实现的基础上，下面给出堆排序算法的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 对顺序表L进行堆排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">HeapSort</span><span class="hljs-params">(SqList &amp;L)</span> &#123;<br>    <span class="hljs-comment">// 把无序序列L.r[1..L.length]建成大根堆</span><br>    CreatHeap(L);<br><br>    <span class="hljs-keyword">for</span>(i=L.length;i&gt;<span class="hljs-number">1</span>;--i) &#123;<br>        <span class="hljs-comment">// 将堆顶记录和当前未经排序的子序列L.r[1..i]中的最后一个记录互换</span><br>        x=L.r[<span class="hljs-number">1</span>];<br>        L.r[<span class="hljs-number">1</span>]=L.r[i];<br>        L.r[i]=x;<br><br>        <span class="hljs-comment">// 将L.r[1..i-1]重新调整为大根堆</span><br>        HeapAdjust(L,<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如，已知无序序列为{49,38,65,97,76,27,<strong>49</strong>}，用堆排序法进行排序的过程为：首先，将无序序列建初堆；然后，在初始大根堆的基础上，反复交换堆顶元素和最后一个元素，并重新调整堆；直至最后得到一个有序序列，整个堆排序过程如下图所示。</p><h2 id="四、小结">四、小结</h2><h2 id="五、参考">五、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：交换排序</title>
    <link href="/2024/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/"/>
    <url>/2024/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>交换排序的基本思想是：两两比较待排序记录的关键字，一旦发现两个记录不满足次序要求时则进行交换，直到整个序列全部满足要求为止。</p><h2 id="一、冒泡排序">一、冒泡排序</h2><p>冒泡排序（Bubble Sort）是一种最简单的交换排序方法，它通过两两比较相邻记录的关键字，如果发生逆序，则进行交换，从而使关键字小的记录如气泡一般逐渐往上“漂浮”（左移），或者使关键字大的记录如石块一样逐渐向下“坠落”（右移）。</p><p>冒泡排序的算法步骤为：</p><ul><li>设待排序的记录存放在数组r[1…n]中。首先，将第一个记录的关键字和第二个记录的关键字进行比较，若为逆序（即L.r[1].key&gt;L.r[2].key），则交换两个记录。然后，比较第二个记录和第三个记录的关键字。依此类推，直至第n-1个记录和第n个记录的关键字进行过比较为止。该过程称作第一趟起泡排序，其结果使得关键字最大的记录被安置到最后一个记录的位置上。</li><li>接着进行第二趟起泡排序，对前n-1个记录进行同样操作，其结果是使关键字次大的记录被安置到第n-1个记录的位置上。</li><li>重复上述比较和交换过程，第i趟是从L.r[1]到L.r[n-i+1]依次比较相邻两个记录的关键字，并在“逆序”时交换相邻记录，其结果是这n-i+1个记录中关键字最大的记录被交换到第n-i+1的位置上。直到在某一趟排序过程中没有进行过交换记录的操作，说明序列已全部达到排序要求，则完成排序。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 对顺序表L做冒泡排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BubbleSort</span><span class="hljs-params">(SqList &amp;L)</span> &#123;<br>    <span class="hljs-comment">// m用来标记每趟排序需要进行比较的次数</span><br>    m=L.length<span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">// flag用来标记某一趟排序是否发生交换</span><br>    flag=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span>( (m&gt;<span class="hljs-number">0</span>)&amp;&amp;(flag==<span class="hljs-number">1</span>) ) &#123;<br>        <span class="hljs-comment">// flag为0，表示本趟排序没有发生交换，则不会执行下一趟排序</span><br>        flag=<span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 两两比较相邻记录</span><br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=m;j++) &#123;<br>            <span class="hljs-comment">// 相邻记录逆序，交换两个记录</span><br>            <span class="hljs-keyword">if</span>(L.r[j].key&gt;L.r[j+<span class="hljs-number">1</span>].key) &#123;<br>                <span class="hljs-comment">// flag置为1，表示本趟排序发生了交换 </span><br>                flag=<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 交换前后两个记录</span><br>                t=L.r[j];<br>                L.r[j]=L.r[j+<span class="hljs-number">1</span>];<br>                L.r[j+<span class="hljs-number">1</span>]=t;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 下一趟排序需要进行m-1次比较</span><br>        --m;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最好情况（初始序列为正序）：只需进行一趟排序，在排序过程中进行n−1次关键字间的比较，且不移动记录。</p><p>最坏情况（初始序列为逆序）：需进行n−1趟排序，总的关键字比较次数KCN和记录移动次数RMN（每次交换都要移动3次记录）分别为</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>K</mi><mi>C</mi><mi>N</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>n</mi></mrow><mn>2</mn></munderover><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>≈</mo><msup><mi>n</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">KCN=\sum_{i=n}^{2} (i-1)=n(n-1)/2 \approx n^2/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.10903em;">CN</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/2</span></span></span></span></span></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mi>M</mi><mi>N</mi><mo>=</mo><mn>3</mn><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>n</mi></mrow><mn>2</mn></munderover><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>≈</mo><mn>3</mn><msup><mi>n</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">RMN=3\sum_{i=n}^{2} (i-1)=3n(n-1)/2 \approx 3n^2/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">RMN</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/2</span></span></span></span></span></p><p>所以，在平均情况下，冒泡排序关键字的比较次数和记录移动次数分别约为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">n^2/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/4</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><msup><mi>n</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">3n^2/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/4</span></span></span></span>，即时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><p>冒泡排序只有在两个记录交换位置时需要一个辅助空间用做暂存记录，所以空间复杂度为O(1)。</p><p>该算法特点为：</p><ul><li>稳定排序。</li><li>可用于链式存储结构。</li><li>移动记录次数较多，算法平均时间性能比直接插入排序差。当初始记录无序，n较大时，此算法不宜采用。</li></ul><h2 id="二、快速排序">二、快速排序</h2><p>快速排序（Quick Sort）是由冒泡排序改进而得的。在冒泡排序过程中，只对相邻的两个记录进行比较，因此每次交换两个相邻记录时只能消除一个逆序。如果能通过两个（不相邻）记录的一次交换，消除多个逆序，则会大大加快排序的速度。快速排序方法中的一次交换可能消除多个逆序。</p><p>快速排序算法的步骤为：在待排序的n个记录中任取一个记录（通常取第一个记录）作为枢轴（或支点），设其关键字为pivotkey。经过一趟排序后，把所有关键字小于pivotkey的记录交换到前面，把所有关键字大于pivotkey的记录交换到后面，结果将待排序记录分成两个子表，最后将枢轴放置在分界处的位置。然后，分别对左、右子表重复上述过程，直至每一子表只有一个记录时，排序完成。其中，一趟快速排序的具体步骤如下：</p><ul><li>选择待排序表中的第一个记录作为枢轴，将枢轴记录暂存在r[0]的位置上。附设两个指针low和high，初始时分别指向表的下界和上界（第一趟时，low=1;high=L.length;）。</li><li>从表的最右侧位置依次向左搜索，找到第一个关键字小于枢轴关键字pivotkey的记录，将其移到low处。具体操作是：当low&lt;high时，若high所指记录的关键字大于等于pivotkey，则向左移动指针high（执行操作–high）;否则将high所指记录移动到low处。</li><li>然后再从表的最左侧位置，依次向右搜索找到第一个关键字大于pivotkey的记录，将其移到high处。具体操作是：当low&lt;high时，若low所指记录的关键字小于等于pivotkey，则向右移动指针low（执行操作++low）；否则将low所指记录移动到high处。</li><li>重复第二步和第三步，直至low与high相等为止。此时low或high的位置即为枢轴在此趟排序中的最终位置，原表被分成两个子表。</li></ul><p>在上述过程中，记录的交换都是与枢轴之间发生，每次交换都要移动3次记录，可以先将枢轴记录暂存在r[0]的位置上，排序过程中只移动要与枢轴交换的记录，即只做r[low]或r[high]的单向移动，直至一趟排序结束后再将枢轴记录移至正确位置上。</p><p>快速排序的算法描述如下所示。其中，算法Partition完成一趟快速排序，返回枢轴的位置。若待排序序列长度大于1（low&lt;high），算法QuickSort调用Partition获取枢轴位置，然后递归执行分别对分割所得的两个子表进行排序。若待排序序列中只有一个记录，递归结束，排序完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 对顺序表L中的子表r[low..high]进行一趟排序，返回枢轴位置</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Partition</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-comment">// 用子表的第一个记录做枢轴记录</span><br>    L.r[<span class="hljs-number">0</span>]=L.r[low];<br>    <span class="hljs-comment">// 将枢轴记录关键字保存在pivotkey中</span><br>    pivotkey=L.r[low].key;<br><br>    <span class="hljs-comment">// 从表的两端交替地向中间扫描</span><br>    <span class="hljs-keyword">while</span>(low&lt;high) &#123;<br>        <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; L.r[high].key&gt;=pivotkey) --high;<br>        <span class="hljs-comment">// 将比枢轴记录小的记录移到低端</span><br>        L.r[low]=L.r[high];<br>        <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; L.r[low].key&lt;=pivotkey) ++low;<br>        <span class="hljs-comment">// 将比枢轴记录大的记录移到高端</span><br>        L.r[high]=L.[low];<br>    &#125;<br>    <span class="hljs-comment">// 枢轴记录到位</span><br>    L.r[low]=L.r[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-comment">// 返回枢轴位置</span><br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-comment">// 对顺序表L中的子表L.r[low..high]做快速排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">QSort</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-comment">// 表的长度大于1</span><br>    <span class="hljs-keyword">if</span>(low&lt;high) &#123;<br>        <span class="hljs-comment">// 将L.r[low..high]一分为二，pivotloc是枢轴位置</span><br>        pivotloc=Partition(L, low, high);<br>        <span class="hljs-comment">// 对左子表递归排序</span><br>        QSort(L, low, pivotloc<span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">// 对右子表递归排序</span><br>        QSort(L, pivotloc+<span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 对顺序表L做快速排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">QuickSort</span><span class="hljs-params">(SqList &amp;L)</span> &#123;<br>    QSort(L,<span class="hljs-number">1</span>,L.length);<br>&#125;<br></code></pre></td></tr></table></figure><p>从快速排序算法的递归树可知，快速排序的趟数取决于递归树的深度。</p><p>最好情况：每一趟排序后都能将记录序列均匀地分割成两个长度大致相等的子表，类似折半查找。在n个元素的序列中，对枢轴定位所需时间为O(n)。若设T(n)是对n个元素的序列进行排序所需的时间，而且每次对枢轴正确定位后，正好把序列划分为长度相等的两个子表，此时，设Cn是一个常数，表示n个元素进行一趟快速排序的时间，则总的排序时间为</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p><p>理论上可以证明，平均情况下，快速排序的时间复杂度为O(nlog2n)。</p><p>快速排序是递归的，执行时需要有一个栈来存放相应的数据。最大递归调用次数与递归树的深度一致，所以最好情况下的空间复杂度为O(log2n)，最坏情况下为O(n)。</p><p>算法特点：</p><ul><li>记录非顺次的移动导致排序方法是不稳定的。</li><li>排序过程中需要定位表的下界和上界，所以适合用于顺序结构，很难用于链式结构。</li><li>当n较大时，在平均情况下快速排序是所有内部排序方法中速度最快的一种，所以其适合初始记录无序、n<br>较大时的情况。</li></ul><h2 id="三、小结">三、小结</h2><h2 id="四、参考">四、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：插入排序</title>
    <link href="/2024/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <url>/2024/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>插入排序的基本思想是：每一趟将一个待排序的记录，按其关键字的大小插入到已经排好序的一组记录的适当位置上，直到所有待排序记录全部插入为止。例如，打扑克牌在抓牌时要保证抓过的牌有序排列，则每抓一张牌，就插入到合适的位置，直到抓完牌为止，即可得到一个有序序列。</p><p>可以选择不同的方法在已排好序的记录中寻找插入位置。根据查找方法的不同，有多种插入排序方法，这里仅介绍三种方法：直接插入排序、折半插入排序和希尔排序。</p><h2 id="一、直接插入排序">一、直接插入排序</h2><p>直接插入排序（Straight Insertion Sort）是一种最简单的排序方法，其基本操作是将一条记录插入到已排好序的有序表中，从而得到一个新的、记录数量增1的有序表。</p><p>直接插入排序的算法步骤为：</p><ul><li>设待排序的记录存放在数组r[1…n]中，r[1]是一个有序序列。</li><li>循环n-1次，每次使用顺序查找法，查找r[i]（i=2,3,…,n）在已排好序的序列r[1…i-1]中的插入位置，然后将r[i]插入到表长为i-1的有序序列r[1…i-1]中，直到将r[n]插入到表长为n-1的有序序列r[1…n-1]中，最后得到一个表长为n的有序序列。</li></ul><p>在具体实现将r[i]插入到有序序列时，有两种方法：一种是将r[i]与r[1],r[2],…,r[i-1]从前向后顺序比较；另一种是将r[i]与r[i-1],r[i-2],…,r[1]从后向前顺序比较。这里采用后一种方法，和顺序查找类似，为了在查找插入位置的过程中避免数组下标出界，在r[0]处设置监视哨。在自r[i-1]到r[1]从后向前查找插入位置的过程中，可以同时后移记录。</p><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 对顺序表L做直接插入排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertSort</span><span class="hljs-params">(SqList &amp;L)</span> &#123;<br>    <span class="hljs-comment">// 循环n-1次，将待排序记录插入到有序序列中</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=L.length;++i) &#123;<br>        <span class="hljs-comment">// </span><br>        <span class="hljs-keyword">if</span>(L.r[i].key&lt;L.r[i<span class="hljs-number">-1</span>].key) &#123;<br>            <span class="hljs-comment">// 将待插入记录暂存到监视哨中</span><br>            L.r[<span class="hljs-number">0</span>]=L.r[i];<br>            <span class="hljs-comment">// 后移r[i-1]</span><br>            L.r[i]=L.r[i<span class="hljs-number">-1</span>];<br>            <span class="hljs-comment">// 从后向前寻找插入位置</span><br>            <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-2</span>; L.r[<span class="hljs-number">0</span>].key&lt;L.r[j].key; --j)<br>                <span class="hljs-comment">// 记录逐个后移，直到找到插入位置</span><br>                L.r[j+<span class="hljs-number">1</span>]=L.r[j];<br>            <span class="hljs-comment">// 将r[0]即原r[i]，插入到正确位置</span><br>            L.r[j+<span class="hljs-number">1</span>]=L.r[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从时间来看，排序的基本操作为：比较两个关键字的大小和移动记录。</p><p>对于其中的某一趟插入排序，上述算法中内层的for循环次数取决于待插记录的关键字与前i-1个记录的关键字之间的关系。其中，在最好情况（正序：待排序序列中记录按关键字非递减有序排列）下，比较1次，不移动；在最坏情况（逆序：待排序序列中记录按关键字非递增有序排列）下，比较i次（依次同前面的i−1个记录进行比较，并和哨兵比较1次），移动i+1次（前面的i−1个记录依次向后移动，另外开始时将待插入的记录移动到监视哨中，最后找到插入位置，又从监视哨中移过去）。</p><p>对于整个排序过程需执行n−1趟，最好情况下，总的比较次数达最小值n−1，记录不需移动；最坏情况下，总的关键字比较次数KCN和记录移动次数RMN均达到最大值，分别为</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p><p>若待排序序列中出现各种可能排列的概率相同，则可取上述最好情况和最坏情况的平均情况。在平均情况下，直接插入排序关键字的比较次数和记录移动次数均约为n2/4。</p><p>由此，直接插入排序的时间复杂度为O(n2)。直接插入排序只需要一个记录的辅助空间r[0]，所以空间复杂度为O(1)。</p><p>算法特点：</p><ul><li>稳定排序。</li><li>算法简便，且容易实现。</li><li>也适用于链式存储结构，只是在单链表上无需移动记录，只需修改相应的指针。</li><li>更适合于初始记录基本有序（正序）的情况，当初始记录无序，n较大时，此算法时间复杂度较高，不宜采用。</li></ul><h2 id="二、折半插入排序">二、折半插入排序</h2><p>直接插入排序采用顺序查找法查找当前记录在已排好序的序列中的插入位置，这个“查找”操作其实也可利用“折半查找”来实现，由此进行地插入排序称之为折半插入排序（Binary Insertion Sort）。</p><p>折半插入排序地算法步骤为：</p><ul><li>设待排序的记录存放在数组r[1…n]中，r[1]是一个有序序列。</li><li>循环n-1次，每次使用折半查找法，查找r[i]（i=2,3,…,n）在已排好序的序列r[1…i-1]中的插入位置，然后将r[i]插入到表长为i-1的有序序列r[1…i-1]中，直到将r[n]插入到表长为n-1的有序序列r[1…n-1]中，最后得到一个表长为n的有序序列。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 对顺序表L做折半插入排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BInsertSort</span><span class="hljs-params">(SqList &amp;L)</span> &#123;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=L.length;++i) &#123;<br>        <span class="hljs-comment">// 将待插入的记录暂存到监视哨中</span><br>        L.r[<span class="hljs-number">0</span>]=L.r[i];<br>        <span class="hljs-comment">// 设置查找区间初值</span><br>        low=<span class="hljs-number">1</span>;high=i<span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 在r[low..high]中折半查找插入位置</span><br>        <span class="hljs-keyword">while</span>(low&lt;=high) &#123;<br>            <span class="hljs-comment">// 折半</span><br>            m=(low+high)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 插入点在前一子表</span><br>            <span class="hljs-keyword">if</span>(L.r[<span class="hljs-number">0</span>].key&lt;L.r[m].key) high=m<span class="hljs-number">-1</span>;<br>            <span class="hljs-comment">// 插入点在后一子表</span><br>            <span class="hljs-keyword">else</span> low=m+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 记录后移</span><br>        <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>;j&gt;=high+<span class="hljs-number">1</span>;--j)<br>            L.r[j+<span class="hljs-number">1</span>]=L.r[j];<br>        <span class="hljs-comment">// 将r[0]即原r[i]，插入到正确位置</span><br>        L.r[high+<span class="hljs-number">1</span>]=L.r[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从时间上比较，折半查找比顺序查找快，所以就平均性能来说，折半插入排序优于直接插入排序。</p><p>折半插入排序所需要的关键字比较次数与待排序序列的初始排列无关，仅依赖于记录的个数。不论初始序列情况如何，在插入第i个记录时，需要经过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>i</mi><mo stretchy="false">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lfloor log_2 i \rfloor + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">i</span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>次比较，才能确定它应插入的位置。所以当记录的初始排列为正序或接近正序时，直接插入排序比折半插入排序执行的关键字比较次数要少。</p><p>折半插入排序的对象移动次数与直接插入排序相同，依赖于对象的初始排列。在平均情况下，折半插入排序仅减少了关键字间的比较次数，而记录的移动次数不变。因此，折半插入排序的时间复杂度仍为O(n2)。</p><p>折半插入排序所需附加存储空间和直接插入排序相同，只需要一个记录的辅助空间r[0]，所以空间复杂度为O(1)。</p><p>算法特点：</p><ul><li>稳定排序。</li><li>因为要进行折半查找，所以只能用于顺序结构，不能用于链式结构。</li><li>适合初始记录无序、n较大时的情况。</li></ul><h2 id="三、希尔排序">三、希尔排序</h2><p>希尔排序（Shell’s Sort）又称“缩小增量排序”（Diminishing Increment Sort），是插入排序的一种，因D.L.希尔（D.L.Shell）于1959年提出而得名。</p><p>直接插入排序，当待排序的记录个数较少且待排序序列的关键字基本有序时，效率较高。希尔排序基于以上两点，从“减少记录个数”和“序列基本有序”两个方面对直接插入排序进行了改进。</p><p>希尔排序实质上是采用分组插入的方法。先将整个待排序记录序列分割成几组，从而减少参与直接插入排序的数据量，对每组分别进行直接插入排序，然后增加每组的数据量，重新分支。这样当经过几次分组排序后，整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。</p><p>希尔对记录的分组，不是简单地“逐段分割”，而是将相隔某个“增量”的记录分成一组。</p><ul><li>第一趟取增量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>d</mi><mn>1</mn></msub><mo>&lt;</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d_1(d_1&lt;n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>把全部记录分成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">d_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>个组，所有间隔为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">d_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的记录分在同一组，在各个组中进行直接插入排序。</li><li>第二趟取增量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>d</mi><mn>2</mn></msub><mo>&lt;</mo><msub><mi>d</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d_2(d_2&lt;d_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，重复上述的分组和排序。</li><li>依次类推，直到所取的增量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo stretchy="false">(</mo><msub><mi>d</mi><mi>t</mi></msub><mo>&lt;</mo><msub><mi>d</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>&lt;</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>&lt;</mo><msub><mi>d</mi><mn>2</mn></msub><mo>&lt;</mo><msub><mi>d</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d_t=1(d_t&lt;d_{t-1}&lt;...&lt;d_2&lt;d_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9028em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，所有记录在同一组中进行直接插入排序为止。</li></ul><p>例如，已知待排序记录的关键字序列为，希尔排序过程如下图所示。</p><p><img src="/F:/blog/source/img/91727ea7295750c8fb2f3f5e2e668bea.jpg" alt="img"></p><p>（1）第一趟取增量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">d_1=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>，所有间隔为5的记录分在同一组，全部记录分成5组，在各个组中分别进行直接插入排序，排序结果如上图第7行所示。</p><p>（2）第二趟取增量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>2</mn></msub><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">d_2=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>，所有间隔为3的记录分在同一组，全部记录分成3组，在各个组中分别进行直接插入排序，排序结果如上图第11行所示。</p><p>（3）第三趟取增量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>3</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">d_3=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，对整个序列进行一趟直接插入排序，排序完成。</p><p>希尔排序的算法实现如下所示。预设好的增量序列保存在数组dt[0…t−1]中，整个希尔排序算法需执行t趟。从上述排序过程可见，直接插入排序可以看成一趟增量是1的希尔排序，所以可以通过改写直接插入排序的算法，得到一趟希尔排序算法ShellInsert。在ShellInsert中，具体改写主要有两处：</p><ul><li>前后记录位置的增量式dk，而不是1；</li><li>r[0]只是暂存单元，不是哨兵。当j&lt;=0时，插入位置已找到。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 对顺序表L进行一趟增量是dk的希尔插入排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ShellInsert</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> dk)</span> &#123;<br>    <span class="hljs-keyword">for</span>(i=dk+<span class="hljs-number">1</span>;i&lt;=L.length;++i) &#123;<br>        <span class="hljs-comment">// 将L.r[i]插入有序增量子表</span><br>        <span class="hljs-keyword">if</span>(L.r[i].key&lt;L.r[i-dk].key) &#123;<br>            <span class="hljs-comment">// 暂存在L.r[0]</span><br>            L.r[<span class="hljs-number">0</span>]=L.r[i];<br>            <span class="hljs-keyword">for</span>(j=i-dk; j&gt;<span class="hljs-number">0</span> &amp;&amp; L.r[<span class="hljs-number">0</span>].key&lt;L.r[j].key; j-=dk)<br>                <span class="hljs-comment">// 记录后移，直到找到插入位置</span><br>                L.r[j+dk]=L.r[j];<br>            <span class="hljs-comment">// 将r[0]即原r[i]，插入到正确位置</span><br>            L.r[j+dk]=L.r[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 按增量序列dt[0..t-1]对顺序表L作t趟希尔排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ShellSort</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> dt[], <span class="hljs-type">int</span> t)</span> &#123;<br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;t;++k)<br>        <span class="hljs-comment">// 进行一趟增量为dt[t]的希尔插入排序</span><br>        ShellInsert(L,dt[k])<br>&#125;<br></code></pre></td></tr></table></figure><p>当增量大于1时，关键字较小的记录就不是一步一步地挪动，而是跳跃式地移动，从而使得在进行最后一趟增量为1的插入排序中，序列已基本有序，只要做记录的少量比较和移动即可完成排序，因此希尔排序的时间复杂度较直接插入排序低。</p><p>但要具体进行分析，则是一个复杂的问题，因为希尔排序的时间复杂度是所取“增量”序列的函数，这涉及一些数学上尚未解决的难题。因此，到目前为止尚未有人求得一种最好的增量序列，但大量的研究已得出一些局部的结论。如有人指出，当增量序列为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>t</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>=</mo><msup><mn>2</mn><mrow><mi>t</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dt[k]=2^{t-k+1}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>时，希尔排序的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><mn>3</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{3/2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3/2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中t为排序趟数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>t</mi><mo>≤</mo><mo stretchy="false">⌊</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">1 \leq k \leq t \leq \lfloor log_2 (n+1) \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)⌋</span></span></span></span>。还有人在大量的实验基础上推出：当n在某个特定范围内，希尔排序所需的比较和移动次数约为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>1.3</mn></msup></mrow><annotation encoding="application/x-tex">n^{1.3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1.3</span></span></span></span></span></span></span></span></span></span></span></span>，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">n \rightarrow \infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>时，比较和移动次数可减少到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n(log_2 n)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>。</p><p>从空间来看，希尔排序和前面两种排序方法一样，也只需要一个辅助空间r[0]，空间复杂度为O(1)。</p><p>算法特点：</p><ul><li>记录跳跃式地移动导致排序方法是不稳定的。</li><li>只能用于顺序结构，不能用于链式结构。</li><li>增量序列可以有各种取法，但应该使增量序列中的值没有除1之外的公因子，并且最后一个增量值必须等于1。</li><li>记录总的比较次数和移动次数都比直接插入排序要少，n越大时，效果越明显。所以适合初始记录无序、n较大时的情况。</li></ul><h2 id="四、小结">四、小结</h2><h2 id="五、参考">五、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：排序的基本概念</title>
    <link href="/2024/04/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/04/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>排序是计算机程序设计中的一种重要操作，在很多领域中都有广泛的应用。如各种升学考试的录取工作，日常生活的各类竞赛活动等都离不开排序。排序的一个主要目的是便于查找，从前面的讨论中容易看出，有序的顺序表可以采用查找效率较高的折半查找法，又如创建树表（无论是二叉排序树还是B-树）的过程本身就是一个排序的过程。</p><h2 id="一、排序的基本概念">一、排序的基本概念</h2><h3 id="1-1、排序">1.1、排序</h3><p>排序（Sorting）是按关键字的非递减或非递增顺序对一组记录重新进行排列的操作。确切描述如下。</p><p>假设含n个记录的序列为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>R</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{R_1,R_2,...,R_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span></p><p>其相应的关键字序列为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>K</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>K</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>K</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{K_1,K_2,...,K_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span></p><p>需确定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1,2,...,n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span>的一种排列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>p</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">p_1,p_2,...,p_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，使其相应的关键字满足如下的非递减（或非递增）关系：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>K</mi><msub><mi>p</mi><mn>1</mn></msub></msub><mo>&lt;</mo><mo>=</mo><msub><mi>K</mi><msub><mi>p</mi><mn>2</mn></msub></msub><mo>&lt;</mo><mo>=</mo><msub><mi>K</mi><msub><mi>p</mi><mi>n</mi></msub></msub></mrow><annotation encoding="application/x-tex">K_{p_1}&lt;=K_{p_2}&lt;=K_{p_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>即使含n个记录的序列成为一个按关键字有序的序列：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>R</mi><msub><mi>p</mi><mn>1</mn></msub></msub><mo separator="true">,</mo><msub><mi>R</mi><msub><mi>p</mi><mn>2</mn></msub></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>R</mi><msub><mi>p</mi><mi>n</mi></msub></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{R_{p_1},R_{p_2},...,R_{p_n}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span></p><p>这样一种操作称为排序。</p><h3 id="1-2、排序的稳定性">1.2、排序的稳定性</h3><p>当排序记录中的关键字<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_i(i=1,2,...,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>都不相同时，则任何一个记录的无序序列经排序后得到的结果唯一；反之，当待排序的序列中存在两个或两个以上关键字相等的记录时，则排序所得的结果不唯一。</p><p>假设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub><mo>=</mo><msub><mi>K</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>i</mi><mo>&lt;</mo><mo>=</mo><mi>n</mi><mo separator="true">,</mo><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>j</mi><mo>&lt;</mo><mo>=</mo><mi>n</mi><mo separator="true">,</mo><mi>i</mi><mo mathvariant="normal">≠</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_i=K_j(1&lt;=i&lt;=n,1&lt;=j&lt;=n,i \neq j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，且在排序前的序列中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>领先于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>（即i&lt;j）。若在排序后的序列中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>仍领先于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>，则称所用的排序方法是稳定的；反之，若可能使排序后的序列中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>领先于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则称所用的排序方法是不稳定的。需要注意的是，排序算法的稳定性是针对所有记录而言的。也就是说，在所有的待排序记录中，只要有一组关键字的实例不满足稳定性要求，则该排序方法就是不稳定的。</p><p>虽然稳定的排序方法和不稳定的排序方法排序结果不同，但不能说不稳定的排序方法就不好，各有各的适用场合。</p><h3 id="1-3、内部排序和外部排序">1.3、内部排序和外部排序</h3><p>由于待排序记录的数量不同，使得排序过程中数据所占用的存储设备会有所不同。根据在排序过程中记录所占用的存储设备，可将排序方法分为两大类：</p><ul><li>一类是内部排序，指的是待排序记录全部存放在计算机内存中进行排序的过程；</li><li>另一类是外部排序，指的是待排序记录的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。</li></ul><h2 id="二、内部排序方法的分类">二、内部排序方法的分类</h2><p>内部排序的方法很多，但就其全面性能而言，很难提出一种被认为是最好的方法，每一种方法都有各自的优缺点，适合在不同的环境（如记录的初始排列状态等）下使用。</p><p>内部排序的过程是一个逐步扩大记录的有序序列长度的过程。在排序的过程中，可以将排序记录区分为两个区域：有序序列区和无序序列区。使有序区中记录的数目增加一个或几个的操作称为一趟排序。</p><p>根据逐步扩大记录有序序列长度的原则不同，可以将内部排序分为以下几类。</p><ul><li>插入类：将无序子序列中的一个或几个记录“插入”到有序序列中，从而增加记录的有序子序列的长度。主要包括直接插入排序、折半插入排序和希尔排序。</li><li>交换类：通过“交换”无序序列中的记录从而得到其中关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度。主要包括冒泡排序和快速排序。</li><li>选择类：从记录的无序子序列中“选择”关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度。主要包括简单选择排序、树形选择排序和堆排序。</li><li>归并类：通过“归并”两个或两个以上的记录有序子序列，逐步增加记录有序序列的长度。2-路归并排序是最为常见的归并排序方法。</li><li>分配类：是唯一一类不需要进行关键字之间比较的排序方法，排序时主要利用分配和收集两种基本操作来完成。基数排序是主要的分配类排序方法。</li></ul><h2 id="三、待排序记录的存储方式">三、待排序记录的存储方式</h2><p>（1）顺序表：记录之间的次序关系由其存储位置决定，实现排序需要移动记录。</p><p>（2）链表：记录之间的次序关系由指针指示，实现排序不需要移动记录，仅需修改指针即可。这种排序方式称为链表排序。</p><p>待排序记录本身存储在一组地址连续的存储单元内，同时另设一个指示各个记录存储位置的地址向量，在排序过程中不移动记录本身，而移动地址向量中这些记录的“地址”，在排序结束之后再按照地址向量中的值调整记录的存储位置。这种排序方式称为地址排序。</p><p>为方便讨论，在后续讲解具体排序算法时，都将采用顺序表作为存储方式，同时设记录的关键字均为整数。待排序记录的数据类型定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 顺序表的最大长度</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 20</span><br><br><span class="hljs-comment">// 定义关键字类型为整型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> KeyType;<br><br><span class="hljs-comment">// 记录类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">// 关键字项</span><br>    KeyType key;<br>    <span class="hljs-comment">// 其他数据项</span><br>    InfoType otherinfo;<br>&#125;RedType;<br><br><span class="hljs-comment">// 顺序表类型</span><br>typdef <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">// r[0]闲置或用做哨兵单元</span><br>    RedType r[MAXSIZE+<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 顺序表长度</span><br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;<br></code></pre></td></tr></table></figure><h2 id="四、排序算法效率的评价指标">四、排序算法效率的评价指标</h2><p>就排序方法的全面性能而言，很难提出一种被认为是最好的方法。目前，评价排序算法好坏的标准主要有两点。</p><ul><li><p>执行时间</p><p>对于排序操作，时间主要消耗在关键字之间的比较和记录的移动上（这里，只考虑以顺序表方法存储待排序记录），排序算法的时间复杂度由这两个指标决定。因此可以认为，高效的排序算法的比较次数和移动次数都应该尽可能的少。</p></li><li><p>辅助空间</p><p>空间复杂度由排序算法所需的辅助空间决定。辅助空间是除了存放待排序记录占用的空间之外，执行算法所需要的其他存储空间。理想的空间复杂度为O(1)，即算法执行期间所需要的辅助空间与待排序的数据量无关。</p></li></ul><h2 id="五、小结">五、小结</h2><h2 id="六、参考">六、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：散列表的查找</title>
    <link href="/2024/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2024/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p>和树的遍历类似，图的遍历也是从图中某一顶点出发，按照某种方法对图中所有顶点访问且仅访问一次。图的遍历算法是求解图的连通性问题、拓扑排序和关键路径等算法的基础。</p><h2 id="一、散列表的基本概念">一、散列表的基本概念</h2><p>前面讨论了基于线性表、树表结构的查找方法，这类查找方法都是以关键字的比较为基础的。在查找过程中只考虑各元素关键字之间的相对大小，记录在存储结构中的位置和其关键字无直接关系，其查找时间与表的长度有关，特别是当结点个数很多时，查找时要大量地与无效结点的关键字进行比较，致使查找速度很慢。</p><p>如果能在元素的存储位置和其关键字之间建立某种直接关系，那么在进行查找时，就无需做比较或做很少次的比较，按照这种关系直接由关键字找到相应的记录。这就是散列查找法（Hash Search）的思想，它通过对元素的关键字值进行某种运算，直接求出元素的地址，即使用关键字到地址的直接转换方法，而不需要反复比较。因此，散列查找法又叫杂凑法或散列法。</p><p>下面给出散列法中常用的几个术语。</p><ul><li>散列函数和散列地址：在记录的存储位置p和其关键字key之间建立一个确定的对应关系H，使p=H(key)，称这个对应关系H为散列函数，p为散列地址。</li><li>散列表：一个有限连续的地址空间，用以存储按散列函数计算得到相应散列地址的数据记录。通常，散列表的存储空间是一个一维数组，散列地址是数组的下标。</li><li>冲突和同义词：对不同的关键字可能得到同一散列地址，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>e</mi><msub><mi>y</mi><mn>1</mn></msub><mo mathvariant="normal">≠</mo><mi>k</mi><mi>e</mi><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">key_1 \neq key_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H(key_1)=H(key_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，这种现象称为冲突。具有相同函数值的关键字对该散列函数来说称作同义词，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>e</mi><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">key_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>e</mi><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">key_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>互称为同义词。</li></ul><p>例如，对C语言某些关键字集合建立一个散列表，关键字集合为</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">{</mo><mi>m</mi><mi>a</mi><mi>i</mi><mi>n</mi><mo separator="true">,</mo><mi>i</mi><mi>n</mi><mi>t</mi><mo separator="true">,</mo><mi>f</mi><mi>l</mi><mi>o</mi><mi>a</mi><mi>t</mi><mo separator="true">,</mo><mi>w</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>e</mi><mo separator="true">,</mo><mi>r</mi><mi>e</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>n</mi><mo separator="true">,</mo><mi>b</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>k</mi><mo separator="true">,</mo><mi>s</mi><mi>w</mi><mi>i</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo separator="true">,</mo><mi>c</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo separator="true">,</mo><mi>d</mi><mi>o</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">S_1=\{main, int, float, while, return, break, switch, case, do\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">main</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">hi</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">re</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.03148em;">ak</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">se</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mclose">}</span></span></span></span></span></p><p>设定一个长度为26的散列表应该足够，散列表可定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> HT[<span class="hljs-number">26</span>][<span class="hljs-number">8</span>];<br></code></pre></td></tr></table></figure><p>假设散列函数的值取为关键字key中第一个字母在字母表{a, b,…, z}中的序号（序号范围为0～25），即</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><msup><mo>−</mo><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">H(key)=key[0]-&#x27;a&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">−</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8019em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中，设key的类型是长度为8的字符数组，根据此散列函数构造的散列表如下表所示。</p><p><img src="/img/81989fb78f769e55ba3213fad33790f0.jpg" alt="img"></p><p>假设关键字集合扩充为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub><mo>=</mo><msub><mi>S</mi><mn>1</mn></msub><mo>+</mo><mo stretchy="false">{</mo><mi>s</mi><mi>h</mi><mi>o</mi><mi>r</mi><mi>t</mi><mo separator="true">,</mo><mi>d</mi><mi>e</mi><mi>f</mi><mi>a</mi><mi>u</mi><mi>l</mi><mi>t</mi><mo separator="true">,</mo><mi>d</mi><mi>o</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>e</mi><mo separator="true">,</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>c</mi><mo separator="true">,</mo><mi>f</mi><mi>o</mi><mi>r</mi><mo separator="true">,</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">S_2=S_1+\{short, default, double, static, for, struct\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">u</span><span class="mord mathnormal">lt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mclose">}</span></span></span></span></span></p><p>如果散列函数不变，新加入的7个关键字经过计算得到：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>s</mi><mi>h</mi><mi>o</mi><mi>r</mi><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mn>18</mn></mrow><annotation encoding="application/x-tex">H(short)=H(static)=H(struct)=18</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">18</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>d</mi><mi>e</mi><mi>f</mi><mi>a</mi><mi>u</mi><mi>l</mi><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mi>d</mi><mi>o</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">H(default)=H(double)=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">u</span><span class="mord mathnormal">lt</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>f</mi><mi>o</mi><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">H(for)=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>，而18、3和5这几个位置均已存放相应的关键字，这就发生了冲突现象，其中，switch、short、static和struct称为同义词；do、default和double称为同义词；float和for称为同义词。</p><p>集合<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中的关键字仅有15个，仔细分析这15个关键字的特性，应该不难构造一个散列函数避免冲突。但在实际应用中，理想化的、不产生冲突的散列函数极少存在，这是因为通常散列表中关键字的取值集合远远大于表空间的地址集。例如，高级语言的编译程序要对源程序中的标识符建立一张符号表进行管理，多数都采取散列表。在设定散列函数时，考虑的查找关键字集合应包含所有可能产生的关键字，不同的源程序中使用的标识符一般也不相同，如果此语言规定标识符为长度不超过8的、字母开头的字母数字串，字母区分大小写，则标识符取值集合的大小为：</p><p><img src="/img/e365712a3765e3d42a7e407acad0b5ce.jpg" alt="img"></p><p>而一个源程序中出现的标识符是有限的，所以编译程序将散列表的长度设为1000足矣。于是，要将多达<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">10^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span>个可能的标识符映射到有限的地址上，难免产生冲突。通常，散列函数是一个多对一的映射，所以冲突是不可避免的，只能通过选择一个“好”的散列函数使得在一定程度上减少冲突。而一旦发生冲突，就必须采取相应措施及时予以解决。</p><p>综上所述，散列查找法主要研究以下两方面的问题：</p><ul><li>如何构造散列函数；</li><li>如何处理冲突；</li></ul><h2 id="二、散列函数的构造方法">二、散列函数的构造方法</h2><h3 id="2-1、数字分析法">2.1、数字分析法</h3><h3 id="2-2、平方取中法">2.2、平方取中法</h3><h3 id="2-3、折叠法">2.3、折叠法</h3><h3 id="2-4、除留余数法">2.4、除留余数法</h3><h2 id="三、处理冲突的方法">三、处理冲突的方法</h2><h3 id="3-1、开放地址法">3.1、开放地址法</h3><h3 id="3-2、链地址法">3.2、链地址法</h3><h2 id="四、散列表的查找">四、散列表的查找</h2><p>在散列表上进行查找的过程和创建散列表的过程基本一致。下面以开放地址法（线性探测法）处理冲突为例，给出在散列表中进行查找的过程。</p><h3 id="4-1、算法实现">4.1、算法实现</h3><p>首先，给出散列表的存储表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* -----开放地址法散列表的存储表示----- */</span><br><span class="hljs-comment">// 散列表的表长</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> m 20</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">// 关键字项</span><br>    KeyType key;<br>    <span class="hljs-comment">// 其他数据项</span><br>    InfoType otherinfo;<br>&#125;HashTable[m];<br></code></pre></td></tr></table></figure><p>在散列表中进行查找的算法步骤为：</p><ul><li>给定待查找的关键字key，根据创建表时设定的散列函数计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H_0=H(key)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mclose">)</span></span></span></span>；</li><li>若单元<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">H_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为空，则所查元素不存在；</li><li>若单元<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">H_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中元素的关键字为key，则查找成功；</li><li>否则重复下述解决冲突的过程：<ul><li>按处理冲突的方法，计算下一个散列地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">H_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>；</li><li>若单元<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">H_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为空，则所查元素不存在；</li><li>若单元<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">H_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中元素的关键字为key，则查找成功。</li></ul></li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 单元为空的标记</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULLKEY 0</span><br><br><span class="hljs-comment">// 在散列表HT中查找关键字为key的元素，若查找成功，返回散列表的单元标号，否则返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">SearchHash</span><span class="hljs-params">(HashTable HT, KeyType key)</span> &#123;<br>    <span class="hljs-comment">// 根据散列函数H(key)计算散列地址</span><br>    H0=H(Key);<br>    <span class="hljs-comment">// 若单元H0为空，则所查元素不存在</span><br>    <span class="hljs-keyword">if</span>(HT[H0].key==NULLKEY) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">// 若单元H0中元素的关键字为key，则查找成功</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(HT[H0].key==key) <span class="hljs-keyword">return</span> H0;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;m;++i) &#123;<br>            <span class="hljs-comment">// 按照线性探测法计算下一个散列地址Hi</span><br>            Hi=(H0+i)%m;<br>            <span class="hljs-comment">// 若单元Hi为空，则所查元素不存在</span><br>            <span class="hljs-keyword">if</span>(HT[Hi].key==NULLKEY) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            <span class="hljs-comment">// 若单元Hi中元素的关键字为key，则查找成功</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(HT[Hi].key==key) <span class="hljs-keyword">return</span> Hi;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2、算法分析">4.2、算法分析</h3><p>从散列表的查找过程可见：</p><ul><li>虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于“冲突”的产生，使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍需以平均查找长度作为衡量散列表查找效率的量度。</li><li>查找过程中需和给定值进行比较的关键字的个数取决于三个因素：散列函数、处理冲突的方法和散列表的装填因子。散列表的装填因子<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>定义为：</li></ul><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>α</mi><mo>=</mo><mfrac><mtext>表中填入的记录数</mtext><mtext>散列表的长度</mtext></mfrac></mrow><annotation encoding="application/x-tex">\alpha = \frac{表中填入的记录数}{散列表的长度}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">散列表的长度</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">表中填入的记录数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>表示散列表的装填程度。直观地看，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>越小，发生冲突的可能性就越小；反之，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>越大，表中已填入的记录越多，再填记录时，发生冲突的可能性就越大，则查找时，给定值需与之进行比较的关键字的个数也就越多。</p><ul><li>散列函数的“好坏”首先影响出现冲突的频繁程度。但一般情况下认为：凡是“均匀的”散列函数，对同一组随机的关键字，产生冲突的可能性相同，假如所设定的散列函数是“均匀”的，则影响平均查找长度的因素只有两个——处理冲突的方法和装填因子<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>。下表给出了在等概率情况下，采用几种不同方法处理冲突时，得到的散列表查找成功和查找失败时的平均查找长度。</li></ul><p><img src="/img/bfb2d0fed998f3f56b918a64745cfd6b.jpg" alt="img"></p><ul><li>从上表可以看出，散列表的平均查找长度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>的函数，而不是记录个数n的函数。由此，在设计散列表时，不管n多大，总可以选择合适的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>以便将平均查找长度限定在一个范围内。</li></ul><h2 id="五、小结">五、小结</h2><h2 id="六、参考">六、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：树表的查找</title>
    <link href="/2024/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2024/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p>和树的遍历类似，图的遍历也是从图中某一顶点出发，按照某种方法对图中所有顶点访问且仅访问一次。图的遍历算法是求解图的连通性问题、拓扑排序和关键路径等算法的基础。</p><h2 id="一、二叉排序树">一、二叉排序树</h2><p>二叉排序树（Binary Sort Tree），又称二叉查找树，是一种对排序和查找都很有用的特殊二叉树。</p><h3 id="1-1、定义">1.1、定义</h3><p>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树。</li></ul><p>二叉排序树是递归定义的。由定义可以得出二叉排序树的一个重要性质：中序遍历一棵二叉排序树时，可以得到一个结点值递增的有序序列。例如，下图就是一棵二叉排序树。</p><p><img src="/img/image-20240213135134595.png" alt="image-20240213135134595"></p><p>中序遍历这棵二叉排序树，将得到一个按数值大小排序的递增序列：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>3</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>24</mn><mo separator="true">,</mo><mn>37</mn><mo separator="true">,</mo><mn>45</mn><mo separator="true">,</mo><mn>53</mn><mo separator="true">,</mo><mn>61</mn><mo separator="true">,</mo><mn>78</mn><mo separator="true">,</mo><mn>90</mn><mo separator="true">,</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">3,12,24,37,45,53,61,78,90,100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">24</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">37</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">45</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">53</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">61</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">78</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">90</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span></span></span></span></span></p><p>接下来，我们以二叉链表作为存储结构，讨论二叉排序树的各种操作。因为二叉排序树的操作要根据结点的关键字域来进行，所以下面给出了每个结点的数据域的类型定义（包括关键字项和其他数据项）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 每个结点的数据域的类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">// 关键字项</span><br>    KeyType key;<br>    <span class="hljs-comment">// 其他数据项</span><br>    InfoType otherinfo;<br>&#125;ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BSTNode</span> &#123;</span><br>    <span class="hljs-comment">// 每个结点的数据域包括关键字项和其他数据项</span><br>    ElemType data;<br>    <span class="hljs-comment">// 左右孩子指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BSTNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><br>&#125;BSTNode, *BSTree;<br></code></pre></td></tr></table></figure><h3 id="1-2、查找">1.2、查找</h3><p>二叉排序树可以看成是一个有序表，在二叉排序树上进行查找和折半查找类似，也是一个逐步缩小查找范围的过程。二叉排序树的递归查找算法步骤为：</p><ul><li>若二叉排序树为空，则查找失败，返回空指针。</li><li>若二叉排序树非空，将给定值key与根结点的关键字T-&gt;data.key进行比较：<ul><li>若key等于T-&gt;data.key，则查找成功，返回根结点地址；</li><li>若key小于T-&gt;data.key，则递归查找左子树；</li><li>若key大于T-&gt;data.key，则递归查找右子树。</li></ul></li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在根指针T所指向的二叉排序树中，递归查找关键字等于key的数据元素</span><br><span class="hljs-comment">// 若查找成功，则返回指向该数据元素结点的指针，否则返回空指针</span><br>BSTree <span class="hljs-title function_">SearchBST</span><span class="hljs-params">(BSTree T, KeyType key)</span> &#123;<br>    <span class="hljs-comment">// 指针为空或找到关键字等于key的数据元素，查找结束</span><br>    <span class="hljs-keyword">if</span>( (!T) || key==T-&gt;data.key ) <span class="hljs-keyword">return</span> T;<br><br>    <span class="hljs-comment">// 在左子树中继续查找</span><br>    <span class="hljs-keyword">if</span>(key&lt;T-&gt;data.key) SearchBST(T-&gt;lchild, key);<br>    <span class="hljs-comment">// 在右子树中继续查找</span><br>    <span class="hljs-keyword">else</span> SearchBST(T-&gt;rchild, key);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们以下图为例，说明在二叉排序树中进行查找的过程：</p><p><img src="/img/image-20240213135134595.png" alt="image-20240213135134595"></p><p>在这棵二叉排序树中查找关键字等于100的记录（树中结点内的数均为记录的关键字）。首先以key=100和根结点的关键字做比较，因为key&gt;45，则查找以45为根的右子树，此时右子树不空，且key&gt;53，则继续查找以结点53为根的右子树，由于key和53的右子树根的关键字100相等，则查找成功，返回指向结点100的指针值。</p><p>在这棵二叉排序树中查找关键字等于40的记录。和上述过程类似，在给定值key与关键字45、12及37相继比较之后，继续查找以结点37为根的右子树，此时右子树为空，则说明该树中没有待查记录，故查找不成功，返回指针值为“NULL”。</p><p>从上述的两个查找例子（key=100和key=40）可见，在二叉排序树上查找其关键字等于给定值的结点的过程，恰是走了一条从根结点到该结点的路径的过程，和给定值比较的关键字个数等于路径长度加1（或结点所在层次数）。因此，和折半查找类似，与给定值比较的关键字个数不超过树的深度。然而，折半查找长度为n的顺序表的判定树是唯一的，而含有n个结点的二叉排序树却不唯一。例如，下图中的两棵二叉排序树。</p><p><img src="/img/image-20240213142948486.png" alt="image-20240213142948486"></p><p>在这两棵二叉排序树中，结点的值都相同，但创建这两棵树的序列不同，分别是：(45, 24, 53, 12, 37, 93)和(12, 24, 37, 45, 53, 93)。图（a）所示树的深度为3，而图（b）所示树的深度为6。从平均查找长度来看，假设6个记录的查找概率相等，为1/6，则图（a）所示树的平均查找长度为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><mfrac><mn>1</mn><mn>6</mn></mfrac><mo stretchy="false">[</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>3</mn><mo stretchy="false">]</mo><mo>=</mo><mn>14</mn><mi mathvariant="normal">/</mi><mn>6</mn></mrow><annotation encoding="application/x-tex">ASL=\frac{1}{6}[1+2+2+3+3+3]=14/6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">14/6</span></span></span></span></span></p><p>而图（b）所示树的平均查找长度为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><mfrac><mn>1</mn><mn>6</mn></mfrac><mo stretchy="false">[</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>5</mn><mo>+</mo><mn>6</mn><mo stretchy="false">]</mo><mo>=</mo><mn>21</mn><mi mathvariant="normal">/</mi><mn>6</mn></mrow><annotation encoding="application/x-tex">ASL=\frac{1}{6}[1+2+3+4+5+6]=21/6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">6</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">21/6</span></span></span></span></span></p><p>因此，含有n个结点的二叉排序树的平均查找长度和树的形态有关。当先后插入的关键字有序时，构成的二叉排序树蜕变为单支树。树的深度为n，其平均查找长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n+1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>（和顺序查找相同），这是最差的情况。显然，最好的情况是，二叉排序树的形态和折半查找的判定树相似，其平均查找长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">\log_{2}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span></span>。若考虑把n个结点按各种可能的次序插入到二叉排序树中，则有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">n</span><span class="mclose">!</span></span></span></span>棵二叉排序树（其中有的形态相同）。可以证明，综合所有可能的情况，就平均而言，二叉排序树的平均查找度仍然和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">\log_{2}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span></span>是同数量级的。</p><p>综上，二叉排序树上的查找和折半查找相差不大。但就维护表的有序性而言，二叉排序树更加有效，因为无需移动记录，只需修改指针即可完成对结点的插入和删除操作。因此，对于需要经常进行插入、删除和查找运算的表，采用二叉排序树比较好。</p><h3 id="1-3、插入">1.3、插入</h3><p>二叉排序树的插入操作是以查找为基础的。要将一个关键字值为key的结点<code>*S</code>插入到二叉排序树中，则需要从根结点向下查找，当树中不存在关键字等于key的结点时才进行插入。新插入的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。其算法步骤为：</p><ul><li>若二叉排序树为空，则待插入结点<code>*S</code>作为根结点插入到空树中。</li><li>若二叉排序树非空，则将key与根结点的关键字T-&gt;data.key进行比较：<ul><li>若key小于T-&gt;data.key，则在根结点的左子树中插入<code>*s</code>；</li><li>若key大于T-&gt;data.key，则在根结点的右子树中插入<code>*s</code>。</li></ul></li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 当二叉排序树T中不存在关键字等于e.key的数据元素时，则插入该元素</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertBST</span><span class="hljs-params">(BSTree &amp;T, ElemType e)</span> &#123;<br>    <span class="hljs-comment">// 找到插入为止，递归结束</span><br>    <span class="hljs-keyword">if</span>(!T) &#123;<br>        <span class="hljs-comment">// 生成新结点</span><br>        S=new BSTNode;<br>        <span class="hljs-comment">// 新结点*S的数据域置为e</span><br>        S-&gt;data=e;<br>        <span class="hljs-comment">// 新结点*S作为叶子结点</span><br>        s-&gt;lchild=S-&gt;rchild=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 把新结点*S链接到已找到的插入位置</span><br>        T=S;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e.key&lt;T-&gt;data.key)<br>        <span class="hljs-comment">// 将*S插入左子树</span><br>        InsertBST(T-&gt;lchild,e);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e.key&gt;T-&gt;data.key)<br>        <span class="hljs-comment">// 将*S插入右子树</span><br>        InsertBST(T-&gt;rchild,e);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们以下图为例，说明在二叉排序树中进行插入结点的过程：</p><p><img src="/img/image-20240213144823624.png" alt="image-20240213144823624"></p><p>在这棵二叉排序树中插入关键字为55的结点。由于插入前二叉排序树非空，故将55和根结点45进行比较，因55&gt;45，则应将55插入到45的右子树上；然后，将55和45的右子树的根53比较，因55&gt;53，则应将55插入到53的右子树上；依次类推，直至最后55&lt;61，且61的左子树为空，所以将55作为61的左孩子插入到树中。</p><p>二叉排序树插入的基本过程是查找，所以时间复杂度同查找一样，是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{2}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>。</p><h3 id="1-4、创建">1.4、创建</h3><p>二叉排序树的创建是从空的二叉排序树开始的，每输入一个结点，经过查找操作，将新结点插入到当前二叉排序树的合适位置。该算法步骤为：</p><ul><li>将二叉排序树T初始化为空树。</li><li>读入一个关键字为key的结点。</li><li>如果读入的关键字key不是输入结束标志，则循环执行以下操作：<ul><li>将此结点插入二叉排序树T中；</li><li>读入一个关键字为key的结点。</li></ul></li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 依次读入一个关键字为key的结点，将此结点插入二叉排序树T中</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateBST</span><span class="hljs-params">(BSTree &amp;T)</span> &#123;<br>    <span class="hljs-comment">// 将二叉排序树T初始化为空树</span><br>    T=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;e;<br><br>    <span class="hljs-comment">// ENDFLAG为自定义常量，作为输入结束标志</span><br>    <span class="hljs-keyword">while</span>(e.key!=ENDFLAG) &#123;<br>        <span class="hljs-comment">// 将此结点插入二叉排序树T中</span><br>        InsertBST(T,e);<br>        <span class="hljs-built_in">cin</span>&gt;&gt;e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设，关键字的输入次序为：45, 24, 53, 45, 12, 24, 90，按上述算法生成的二叉排序树的过程如下图所示。</p><p><img src="/img/image-20240213150940731.png" alt="image-20240213150940731"></p><p>容易看出，一个无序序列可以通过构造一棵二叉排序树而变成一个有序序列，构造树的过程就是对无序序列进行排序的过程。不仅如此，从上面的插入过程还可以看到，每次插入的新结点都是二叉排序树上新的叶子结点，则在进行插入操作时，不必移动其他结点，仅需改动某个结点的指针，由空变为非空即可。这就相当于在一个有序序列上插入一个记录而不需要移动其他记录。</p><p>当有n个结点时，需要进行n次插入操作，而插入一个结点的算法时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，所以创建二叉排序树算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><h3 id="1-5、删除">1.5、删除</h3><p>被删除的结点可能是二叉排序树中的任意结点，删除结点后，要根据其位置不同修改其双亲结点及相关结点的指针，以保持二叉排序树的特性。二叉排序树的删除算法比较复杂，接下来，我们以下图为例，说明删除过程。</p><p><img src="/img/image-20240213171353273.png" alt="image-20240213171353273"></p><p>首先从二叉排序树的根结点开始查找关键字为key的待删结点，如果树中不存在此结点，则不做任何操作；否则，假设被删结点为*p（指向该结点的指针为p），其双亲结点为*f（指向该结点的指针为f），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">P_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">P_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>分别表示其左子树和右子树。不失一般性，可设*p是*f的左孩子（右孩子情况类似）。下面分3种情况进行讨论。</p><p>（1）若*p结点为叶子结点，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">P_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">P_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>均为空树。由于删去叶子结点不破坏整棵树的结构，因此只需要修改其双亲结点的指针即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">f-&gt;lchild=<span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>（2）若*p结点只有左子树<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">P_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>或者只有右子树<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">P_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。此时只要令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">P_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">P_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>直接成为其双亲结点*f的左子树即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">f-&gt;lchild=p-&gt;lchild;<br>or<br>f-&gt;lchild=p-&gt;rchild;                    <br></code></pre></td></tr></table></figure><p>（3）若*p结点的左子树和右子树均非空。从上图（b）可知，在删去*p结点之前，中序遍历该二叉树得到的序列为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>C</mi><mi>L</mi></msub><mo separator="true">,</mo><mi>C</mi><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>Q</mi><mi>L</mi></msub><mo separator="true">,</mo><mi>Q</mi><mo separator="true">,</mo><msub><mi>S</mi><mi>L</mi></msub><mo separator="true">,</mo><mi>S</mi><mo separator="true">,</mo><mi>P</mi><mo separator="true">,</mo><msub><mi>P</mi><mi>R</mi></msub><mo separator="true">,</mo><mi>F</mi><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(...,C_L,C,...,Q_L,Q,S_L,S,P,P_R,F,...)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mclose">)</span></span></span></span>，在删去*p之后，为保持其他元素之间的相对位置不变，可以有两种处理方法：</p><ul><li>令*p的左子树为*f的左子树，而*p的右子树为*s的右子树，如上图（c）所示。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">f-&gt;lchild=p-&gt;lchild;<br>s-&gt;rchild=p-&gt;rchild;<br></code></pre></td></tr></table></figure><ul><li>令*p的直接前驱（或直接后继）替代*p，然后再从二叉排序树中删去它的直接前驱（或直接后继）。如上图（d）所示，当以直接前驱*s替代*p时，由于*s只有左子树<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">S_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则在删去*s之后，只要令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">S_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为*s的双亲*q的右子树即可。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;data=s-&gt;data;<br>q-&gt;rchild=s-&gt;lchild;<br></code></pre></td></tr></table></figure><p>显然，前一种处理方法可能增加树的深度，而后一种方法是以被删结点左子树中关键字最大的结点替代被删结点，然后从左子树中删除这个结点。此结点一定没有右子树（否则它就不是左子树中关键字最大的结点），这样不会增加树的高度，所以常采用这种处理方案。采用后一种方法的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 从二叉排序树T中删除关键字等于key的结点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DeleteBST</span><span class="hljs-params">(BSTree &amp;T, KeyType key)</span> &#123;<br>    <span class="hljs-comment">// 初始化</span><br>    f=<span class="hljs-literal">NULL</span>;<br>    p=T;<br><br>    <span class="hljs-comment">// 从根开始查找关键字等于key的结点*p</span><br>    <span class="hljs-keyword">while</span>(p) &#123;<br>        <span class="hljs-comment">// 找到关键字等于key的结点*p，结束循环</span><br>        <span class="hljs-keyword">if</span>(key==p-&gt;data.key) <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">// *f为*p的双亲结点</span><br>        f=p;<br>        <span class="hljs-comment">// 在*p的左子树中继续查找</span><br>        <span class="hljs-keyword">if</span>(key&lt;p-&gt;data.key) p=p-&gt;lchild;<br>        <span class="hljs-comment">// 在*p的右子树中继续查找</span><br>        <span class="hljs-keyword">else</span> p=p-&gt;rchild;<br>    &#125;<br>    <span class="hljs-comment">// p为NULL，说明没有找到被删结点，直接返回</span><br>    <span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">/*---- 考虑3种情况实现p所指子树内部的处理：*p左右子树均非空、无右子树、无左子树 -----*/</span><br>    <span class="hljs-comment">// 被删结点*p左右子树均非空</span><br>    <span class="hljs-keyword">if</span>( (p-&gt;lchild)&amp;&amp;(p-&gt;rchild) ) &#123;<br>        q=p;<br>        s=p-&gt;lchild;<br><br>        <span class="hljs-comment">// 在*p的左子树中查找其前驱结点（即最右下结点）</span><br>        <span class="hljs-keyword">while</span>(s-&gt;rchild) &#123;<br>            q=s;<br>            s=s-&gt;rchild;<br>        &#125;<br><br>        <span class="hljs-comment">// 以*s替代*p</span><br>        p-&gt;data=s-&gt;data;<br>        <span class="hljs-comment">// 重接*q的右子树</span><br>        <span class="hljs-keyword">if</span>(q!=p) q-&gt;rchild=s-&gt;lchild;<br>        <span class="hljs-comment">// 重接*q的左子树</span><br>        <span class="hljs-keyword">else</span> q-&gt;lchild=s-&gt;lchild;<br>        delete s;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 被删结点*p右子树为空，只需重接其左子树</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!p-&gt;rchild) &#123;<br>        q=p;<br>        p=p-&gt;lchild;<br>    &#125;<br>    <span class="hljs-comment">// 被删结点*p左子树为空，只需重接其右子树</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!p-&gt;lchild) &#123;<br>        q=p;<br>        p=p-&gt;rchild;<br>    &#125;<br><br>    <span class="hljs-comment">/*---- 将p所指的子树挂接到其双亲结点*f相应的位置 ----*/</span><br>    <span class="hljs-comment">// f为NULL，说明被删结点为根结点</span><br>    <span class="hljs-keyword">if</span>(!f) T=p;<br>    <span class="hljs-comment">// 将p所指的子树挂接到*f的左子树位置</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(q==f-&gt;lchild) f-&gt;rchild=p;<br>    <span class="hljs-comment">// 将p所指的子树挂接到*f的右子树位置</span><br>    <span class="hljs-keyword">else</span> f-&gt;rchild=p;<br><br>    delete q;<br>&#125;<br></code></pre></td></tr></table></figure><p>和二叉排序树插入一样，二叉排序树删除的基本过程也是查找，所以时间复杂度仍是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><h2 id="二、平衡二叉树">二、平衡二叉树</h2><h3 id="1-1、定义-2">1.1、定义</h3><p>二叉排序树查找算法的性能取决于二叉树的结构，而二叉排序树的形状则取决于其数据集。如果数据呈有序排序，则二叉排序树是线性的，查找的时间复杂度为O(n)；反之，如果二叉排序树的结构合理，则查找速度较快，查找的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。事实上，树的高度越小，查找速度越快。因此，希望二叉树的高度尽可能小。</p><p>平衡二叉树（Balanced Binary Tree或Height-Balanced Tree），是一种特殊的二叉排序树。它由前苏联数学家阿德尔森-维尔斯基（Adelson-Velskii）和兰迪斯（Landis）提出，所以又称AVL树。</p><p>平衡二叉树或者是空树，或者是具有如下特征的二叉排序树：</p><ul><li>左子树和右子树的深度之差的绝对值不超过1；</li><li>左子树和右子树也是平衡二叉树。</li></ul><p>若将二叉树上结点的平衡因子（Balance Factor，BF）定义为该结点左子树和右子树的深度之差，则平衡二叉树上所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。</p><p>因为AVL树上任何结点的左右子树的深度之差都不超过1，则可以证明它的深度和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>是同数量级的（其中n为结点个数）。由此，其查找的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><h3 id="1-2、平衡调整方法">1.2、平衡调整方法</h3><p>如何创建一棵平衡二叉树呢？插入结点时，首先按照二叉排序树处理，若插入结点后破坏了平衡二叉树的特性，需对平衡二叉树进行调整。调整方法是：找到离插入结点最近且平衡因子绝对值超过1的祖先结点，以该结点为根的子树称为最小不平衡子树，可将重新平衡的范围局限于这棵子树。</p><h4 id="1-2-1、示例">1.2.1、示例</h4><p>首先，我们来看一个具体的例子。假设表中关键字序列为(12,24,37,90,53)。</p><p>空树和只有1个结点13的树显然都是平衡的二叉树。在插入24之后树仍是平衡的，只是根结点的平衡因子由0变为−1。</p><p>在继续插入37之后，由于结点13的平衡因子由−1变成−2，因此出现了不平衡的现象。此时好比一根扁担出现一头重、一头轻的现象，若能将扁担的支撑点由13改至24，扁担的两头就平衡了。由此，可以对树做一个向左逆时针“旋转”的操作，令结点24为根，而结点13为它的左子树，此时，结点13和结点24的平衡因子都为0，而且仍保持二叉排序树的特性。</p><p>在继续插入结点90和结点53之后，结点37的平衡因子由−1变成−2，排序树中出现了新的不平衡现象，需进行调整。但此时由于是结点53插在结点90的左子树上，因此不能如上做简单调整。离插入结点最近的最小不平衡子树是以结点37为根的子树。这时，必须以53作为根结点，而37成为它的左子树的根，90成为它的右子树的根。这好比对树做了两次“旋转”操作，先向右顺时针旋转，后向左逆时针旋转，使二叉排序树由不平衡转化为平衡。</p><h4 id="1-2-2、一般情况">1.2.2、一般情况</h4><p>接下来，我们讨论一般情况，假设最小不平衡子树的根结点为A，则失去平衡后进行调整的规律可归纳为下列4种情况。</p><p>（1）LL型：由于在A的左子树根结点的左子树上插入结点，A的平衡因子由1增至2，致使以A为根结点的子树失去平衡，则需进行一次向右的顺时针旋转操作。</p><p><img src="/img/c64f5c1f18d5d157cdff18364cd75088.jpg" alt="img"></p><p>如下图所示，为两个LL型调整的示例。</p><p><img src="/img/image-20240215162038273.png" alt="image-20240215162038273"></p><p>（2）RR型：由于在A的右子树根结点的右子树上插入结点，A的平衡因子由-1增至-2，致使以A为根结点的子树失去平衡，因此需进行一次向左的逆时针旋转操作。</p><p><img src="/img/968fc5ba8633290d98e5c11edfd2472d.jpg" alt="img"></p><p>如下图所示，为两个RR型调整的示例。</p><p><img src="/img/image-20240215164351798.png" alt="image-20240215164351798"></p><p>（3）LR型：由于在A的左子树根节点的右子树上插入结点，A的平衡因子由1增至2，致使以A为根结点的子树失去平衡，则需进行两次旋转操作。第一次对B及其右子树进行逆时针旋转，C转上去成为B的根，这时变成了LL型，所以第二次进行LL型的顺时针旋转即可恢复平衡。如果C原来有左子树，则调整C的左子树为B的右子树。</p><p><img src="/img/5068f9aa42c7af6ce0f6f1bc0b5126ac.jpg" alt="img"></p><p>LR型旋转前后A、B、C三个结点的平衡因子的变化分为3种情况，如下图所示，为3种LR型调整的示例。</p><p><img src="/img/image-20240215173622579.png" alt="image-20240215173622579"></p><p>（4）RL型：由于在A的右子树根结点的左子树上插入结点，A的平衡因子由-1变成-2，致使以A为根结点的子树失去平衡，因此旋转方法和LR型的旋转方法相”对称“，也需进行两次旋转，先顺时针向右旋转，再逆时针向左旋转。</p><p><img src="/img/a134af4a8f49bd6e3be31e18a8efe3c0.jpg" alt="img"></p><p>同LR型旋转类似，RL型旋转前后A、B、C这3个结点的平衡因子的变化也分为3种情况，如下图所示，为3种RL型调整的示例。</p><p><img src="/img/image-20240215180042033.png" alt="image-20240215180042033"></p><h4 id="1-2-3、小结">1.2.3、小结</h4><p>上述4种情况中，（1）和（2）对称，（3）和（4）对称。旋转操作的正确性容易由“保持二叉排序树的特性：中序遍历所得关键字序列自小至大有序”证明之。同时，无论哪一种情况，在经过平衡旋转处理之后，以B或C为根的新子树为平衡二叉树，而且它们的深度和插入之前以A为根的子树相同。因此，当平衡的二叉排序树因插入结点而失去平衡时，仅需对最小不平衡子树进行平衡旋转处理即可。因为经过旋转处理之后的子树深度和插入之前相同，因而不影响插入路径上所有祖先结点的平衡度。</p><h3 id="1-3、插入-2">1.3、插入</h3><p>在平衡二叉树BBT上插入一个新的数据元素e的递归算法可描述如下：</p><ul><li>若BBT为空树，则插入一个数据元素为e的新结点作为BBT的根结点，树的深度增1。</li><li>若e的关键字和BBT的根结点的关键字相等，则不进行插入。</li><li>若e的关键字小于BBT的根结点的关键字，而且在BBT的左子树中不存在和e有相同关键字的结点，则将e插入在BBT的左子树上，并且当插入之后的左子树深度增加（+1）时，分别就下列不同情况处理：<ul><li>BBT的根结点的平衡因子为-1（右子树的深度大于左子树的深度）：将根结点的平衡因子更改为0，BBT的深度不变；</li><li>BBT的根结点的平衡因子为0（左、右子树的深度相等）：将根结点的平衡因子更改为1，BBT的深度增1；</li><li>BBT的根结点的平衡因子为1（左子树的深度大于右子树的深度）：若BBT的左子树根结点的平衡因子为1，则需进行单向右旋平衡处理，并且在右旋处理之后，将根结点和其右子树根结点的平衡因子更改为0，树的深度不变；</li><li>若BBT的左子树根结点的平衡因子为-1，则需进行先向左、后向右的双向旋转平衡处理，并且在旋转处理之后修改根结点和其左、右子树根结点的平衡因子，树的深度不变。</li></ul></li><li>若e的关键字大于BBT的根结点的关键字，而且在BBT的右子树中不存在和e有相同关键字的结点，则将e插入在BBT的右子树上，并且当插入之后的右子树深度增加（+1）时，分别就不同情况处理。其处理操作和第三步中所述相对称。</li></ul><h2 id="三、B-树">三、B-树</h2><p>前面介绍的查找方法均适用于存储在计算机内存中较小的文件，统称为内查找法。若文件很大且存放于外存进行查找时，这些查找方法就不适用了。内查找法都以结点为单位进行查找，这样需要反复地进行内、外存的交换，是很费时的。1970年，鲁道夫·拜尔（R.Bayer）和E·麦克雷特（E.Mccreight）提出了一种适用于外查找的平衡多叉树——B-树，磁盘管理系统中的目录管理，以及数据库系统中的索引组织多数都采用B-树这种数据结构。</p><h3 id="3-1、定义">3.1、定义</h3><p>一棵m阶的B-树，或为空树，或为满足下列特性的m叉树：</p><ul><li>树中每个结点最多有m棵子树；</li><li>若根结点不是叶子结点，则至少有两棵子树；</li><li>除根之外的所有非终端结点至少有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil m/2 \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span></span></span></span>棵子树；</li><li>所有的叶子结点都出现在同一层次上，并且不带信息，通常称为失败结点；</li><li>所有的非终端结点最多有m-1个关键字。</li></ul><p>注：失败结点并不存在，指向这些结点的指针为空。引入失败结点是为了便于分析B-树的查找性能。</p><p>在B-树中，结点的结构如下图所示：</p><p><img src="/img/image-20240216173241549.png" alt="image-20240216173241549"></p><p>其中：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo><mo>−</mo><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>n</mi><mo>&lt;</mo><mo>=</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(\lceil m/2 \rceil -1 &lt;= n &lt;= m-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>为关键字的个数（或n+1为子树个数）；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_i(i=1,2,...n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>为关键字，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>K</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_i&lt;K_{i+1}(i=1,2,...,n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_i(i=0,1,...,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>为指向子树根结点的指针，且指针<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">P_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>所指子树中所有结点的关键字均小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_i(i=1,2,...,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">P_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>所指子树中所有结点的关键字均大于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">K_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li></ul><p>从上述定义可以看出，对任一关键字<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>而言，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">P_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>相当于指向其“左子树”，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>相当于指向其“右子树”。如下图所示，为一棵4阶的B-树。</p><p><img src="/img/f59ecf2be3d94a06c4ba389dfc961964.jpg" alt="img"></p><p>B-树具有平衡、有序、多路的特点。上图所示的树能很好地说明B-树的特点。</p><p>（1）所有叶子结点均在同一层次，这体现出其平衡的特点。</p><p>（2）树中每个结点中的关键字都是有序的，且关键字<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>“左子树”中的关键字均小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，而其“右子树”中的关键字均大于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，这体现出其有序的特点。</p><p>（3）除叶子结点外，有的结点中有一个关键字、两棵子树，有的结点中有两个关键字、3棵子树，这种4阶的B-树最多有3个关键字、4棵子树，这体现出其多路的特点。</p><p>在具体实现时，为记录其双亲结点，B-树结点的存储结构通常增加一个parent指针，指向其双亲结点，其存储结构示意图如下所示。</p><p><img src="/img/image-20240216174925728.png" alt="image-20240216174925728"></p><h3 id="3-2、查找">3.2、查找</h3><p>由B-树的定义可知，在B-树上进行查找的过程和二叉排序树的查找过程类似。</p><p><img src="/img/f59ecf2be3d94a06c4ba389dfc961964.jpg" alt="img"></p><p>在这棵B-树中查找关键字47的过程如下：首先从根开始，根据根结点指针t找到*a结点，因*a结点中只有一个关键字，且47&gt;35，若查找的记录存在，则必在指针<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>所指的子树内，顺指针找到*c结点，该结点有两个关键字（43和78），而43&lt;47&lt;78，若查找的记录存在，则必在指针<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>所指的子树中。同样，顺指针找到*g结点，在该结点中顺序查找，找到关键字47，由此，查找成功。</p><p>查找不成功的过程也类似，例如，在同一棵树中查找23。从根开始，因为23&lt;35，则顺该结点中指针<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>找到*b结点，又因为*b结点中只有一个关键字18，且23&gt;18，所以顺结点中第二个指针<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>找到*e结点。同理，因为23&lt;27，则顺指针往下找，此时因指针所指为叶子结点，说明此棵B-树中不存在关键字23，查找因失败而告终。</p><p>由此可见，在B-树上进行查找的过程是一个顺指针查找结点，和在结点的关键字中查找交叉进行的过程。</p><p>由于B-树主要用做文件的索引，因此它的查找涉及外存的存取，在此略去外存的读写，只做示意性的描述。假设结点类型定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// B-树的阶，暂设为3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> m 3</span><br><br><span class="hljs-comment">// B-树结点和B-树的类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span> &#123;</span><br>    <span class="hljs-comment">// 结点中关键字的个数，即结点的大小</span><br>    <span class="hljs-type">int</span> keynum;<br>    <span class="hljs-comment">// 指向双亲结点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span> *<span class="hljs-title">parent</span>;</span><br>    <span class="hljs-comment">// 关键字向量，0号单元未用</span><br>    KeyType K[m+<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 子树指针向量</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span> *<span class="hljs-title">ptr</span>[<span class="hljs-title">m</span>+1];</span><br>    <span class="hljs-comment">// 记录指针向量，0号单元未用</span><br>    Record *recptr[m+<span class="hljs-number">1</span>];<br>&#125;BTNode, *BTree;<br><br><span class="hljs-comment">// B-树的查找结果类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">// 指向找到的结点</span><br>    BTNode *pt;<br>    <span class="hljs-comment">// 1..m，在结点中的关键字序号</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">// 1：查找成功，0：查找失败</span><br>    <span class="hljs-type">int</span> tag;<br>&#125;Result;<br></code></pre></td></tr></table></figure><p>B-树的查找算法步骤为，将给定值key与根结点的各个关键字<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>K</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>K</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>j</mi><mo>&lt;</mo><mo>=</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_1,K_2,...,K_j(1&lt;=j&lt;=m-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>进行比较，由于该关键字序列是有序的，所以查找时可采用顺序查找，也可采用折半查找。查找时：</p><ul><li>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>e</mi><mi>y</mi><mo>=</mo><msub><mi>K</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>i</mi><mo>&lt;</mo><mo>=</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">key=K_i(1&lt;=i&lt;=j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，则查找成功；</li><li>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>e</mi><mi>y</mi><mo>&lt;</mo><msub><mi>K</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">key&lt;K_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则顺着指针<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>所指向的子树继续向下查找；</li><li>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub><mo>&lt;</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>&lt;</mo><msub><mi>K</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mtext>（</mtext><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>i</mi><mo>&lt;</mo><mo>=</mo><mi>j</mi><mo>−</mo><mn>1</mn><mtext>）</mtext></mrow><annotation encoding="application/x-tex">K_i&lt;key&lt;K_{i+1}（1&lt;=i&lt;=j-1）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">（</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">）</span></span></span></span>，则顺着指针<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>所指向的子树继续向下查找；</li><li>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>e</mi><mi>y</mi><mo>&gt;</mo><msub><mi>K</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">key&gt;K_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>，则顺着指针<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>所指向的子树继续向下查找。</li></ul><p>如果在自上而下的查找过程中，找到了值为key的关键字，则查找成功；如果直到叶子结点也未找到，则查找失败。相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在m阶B-树T中查找关键字key，返回结果(pt, i, tag)</span><br><span class="hljs-comment">// 若查找成功，则特征值tag=1，指针pt所指结点中第i个关键字等于key</span><br><span class="hljs-comment">// 否则特征值tag=0，等于key的关键字应插入在指针pt所指结点中第i和第i+1个关键字之间</span><br>Result <span class="hljs-title function_">SearchBTree</span><span class="hljs-params">(BTree T, KeyType key)</span> &#123;<br>    <span class="hljs-comment">// 初始化，p指向待查结点，q指向p的双亲</span><br>    p=T;q=<span class="hljs-literal">NULL</span>;found=FALSE;i=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(p&amp;&amp;!found) &#123;<br>        <span class="hljs-comment">// 在p-&gt;K[1..keynum]中查找i，使得p-&gt;K[i] &lt;= key &lt; p-&gt;K[i+1]</span><br>        i=Search(p,key);<br>        <span class="hljs-comment">// 找到待查关键字</span><br>        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; p-&gt;K[i]==key) found=TRUE<br>        <span class="hljs-keyword">else</span> &#123;<br>            q=p;<br>            p=p-&gt;ptr[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 查找成功</span><br>    <span class="hljs-keyword">if</span>(found) <span class="hljs-keyword">return</span>(p, i, <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 查找不成功，返回key的插入位置信息</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>(q, i, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述算法可见，在B-树上进行查找包含两种基本操作：（1）在B-树中找结点；（2）在结点中找关键字。</p><p>由于B-树通常存储在磁盘上，则前一查找操作是在磁盘上进行的（在上述算法中没有体现），而后一查找操作是在内存中进行的，即在磁盘上找到指针p所指结点后，先将结点中的信息读入内存，然后再利用顺序查找或折半查找查询等于key的关键字。显然，在磁盘上进行一次查找比在内存中进行一次查找耗费时间多出很多，因此，在磁盘上进行查找的次数，即待查关键字所在结点在B-树上的层次数，是决定B-树查找效率的首要因素。</p><p>现考虑最坏的情况，即待查结点在B-树的最下面一层。也就是说，含N个关键字的m阶B-树的最大深度是多少？</p><p>先看一棵3阶的B-树。按B-树的定义，3阶的B-树上所有非终端结点至多可有两个关键字，至少有一个关键字（即子树个数为2或3，故又称2-3树）。因此，若关键字个数小于等于2时，树的深度为2（即叶子结点层次为2）；若关键字个数小于等于6时，树的深度不超过3。反之，若B-树的深度为4，则关键字的个数必须大于等于7（见下图（g）），此时，每个结点都含有可能的关键字的最小数目。</p><p><img src="/img/1625aad680bcc2526f817c5bf21e50cf.jpg" alt="img"></p><p>一般情况的分析可类似平衡二叉树进行，先讨论深度为h+1的m阶B-树所具有的最少结点数。</p><p>根据B-树的定义，第一层至少有1个结点；第二层至少有2个结点；由于除根之外的每个非终端结点至少有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil m/2 \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span></span></span></span>棵子树，则第三层至少有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2(\lceil m/2 \rceil)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉)</span></span></span></span>个结点；依次类推，第h+1层至少有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo><msup><mo stretchy="false">)</mo><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2(\lceil m/2 \rceil)^{h-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>个结点。而h+1层的结点为叶子结点。若m阶B-树中具有N个关键字，则叶子结点数即查找不成功的结点数为N+1，由此有：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn><mo>&gt;</mo><mo>=</mo><mn>2</mn><mo>∗</mo><mo stretchy="false">(</mo><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo><msup><mo stretchy="false">)</mo><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">N+1 &gt;= 2*(\lceil m/2 \rceil)^{h-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1491em;vertical-align:-0.25em;"></span><span class="mopen">(⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>反之：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>h</mi><mo>&lt;</mo><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mo stretchy="false">⌉</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow></msub><mo stretchy="false">(</mo><mfrac><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h&lt;=log_{\rceil m/2 \rceil} (\frac{N+1}{2})+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mclose mtight">⌉</span><span class="mord mathnormal mtight">m</span><span class="mord mtight">/2</span><span class="mclose mtight">⌉</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><p>这就是说，在含有N个关键字的B-树上进行查找时，从根结点到关键字所在结点的路径上涉及的结点数不超过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mo stretchy="false">⌉</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow></msub><mo stretchy="false">(</mo><mfrac><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">log_{\rceil m/2 \rceil} (\frac{N+1}{2})+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2275em;vertical-align:-0.3552em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mclose mtight">⌉</span><span class="mord mathnormal mtight">m</span><span class="mord mtight">/2</span><span class="mclose mtight">⌉</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p><h3 id="3-3、插入">3.3、插入</h3><p>B-树是动态查找树，因此其生成过程是从空树起，在查找的过程中通过逐个插入关键字而得到。但由于B-树中除根之外的所有非终端结点中的关键字个数必须大于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lceil m/2 \rceil -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，因此，每次插入一个关键字不是在树中添加一个叶子结点，而是首先在最低层的某个非终端结点中添加一个关键字，若该结点的关键字个数不超过m-1，则插入完成，否则表明结点已满，要产生结点的“分裂”，将此结点在同一层分成两个结点。一般情况下，结点分裂方法是：以中间关键字为界把结点一分为二，成为两个结点，并把中间关键字向上插入到双亲结点上，若双亲结点已满，则采用同样的方法继续分解。最坏的情况下，一直分解到树根结点，这时B-树高度增加1。</p><p>例如，下图所示为3阶的B-树（图中略去F结点（即叶子结点）），假设需依次插入关键字30、26、85和7。</p><p><img src="/img/image-20240217161844576.png" alt="image-20240217161844576"></p><p>首先通过查找确定应插入的位置。由根*a起进行查找，确定30应插入在*d结点中，由于*d中关键字数目不超过2（即m−1），故第一个关键字插入完成。插入30后的B-树如下图所示。</p><p><img src="/img/image-20240217162057027.png" alt="image-20240217162057027"></p><p>同样，通过查找确定关键字26亦应插入在*d结点中。由于*d中关键字的数目超过2，此时需将*d分裂成两个结点，关键字26及其前、后两个指针仍保留在*d结点中，而关键字37及其前、后两个指针存储到新产生的结点*d’中。同时，将关键字30和指示结点*d’的指针插入到其双亲结点中。由于*b结点中的关键字数目没有超过2，则插入完成。插入后的B-树如下图所示。</p><p><img src="/img/image-20240217162748510.png" alt="image-20240217162748510"></p><p><img src="/img/image-20240217163133943.png" alt="image-20240217163133943"></p><p>类似地，在*g中插入85之后需分裂成两个结点，而当70继而插入到双亲结点中时，由于*e中关键字数目超过2，则再次分裂为结点*e和*e’，如下图所示。</p><p><img src="/img/image-20240217163725611.png" alt="image-20240217163725611"></p><p>最后在插入关键字7时，*c、*b和*a相继分裂，并生成一个新的根结点*m，如下图所示。</p><p><img src="/img/image-20240217164059429.png" alt="image-20240217164059429"></p><p><img src="/img/48cddcc8ca5cd961d26924f08213d958.jpg" alt="img"></p><p>在B-树中插入关键字的算法步骤为：</p><ul><li>在B-树中查找给定关键字的记录，若查找成功，则插入操作失败，否则将新记录作为空指针ap插入查找失败的叶子结点的上一层结点（由q指向）。</li><li>若插入新记录和空指针后，q指向的结点的关键字个数未超过m-1，则插入操作成功，否则转入第三步；</li><li>以该结点的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil m/2 \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span></span></span></span>个关键字<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow></msub></mrow><annotation encoding="application/x-tex">K_{\lceil m/2 \rceil}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">⌈</span><span class="mord mathnormal mtight">m</span><span class="mord mtight">/2</span><span class="mclose mtight">⌉</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span></span></span></span>为拆分点，将该结点分成3个部分：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow></msub></mrow><annotation encoding="application/x-tex">K_{\lceil m/2 \rceil}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">⌈</span><span class="mord mathnormal mtight">m</span><span class="mord mtight">/2</span><span class="mclose mtight">⌉</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span></span></span></span>左边部分、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow></msub></mrow><annotation encoding="application/x-tex">K_{\lceil m/2 \rceil}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">⌈</span><span class="mord mathnormal mtight">m</span><span class="mord mtight">/2</span><span class="mclose mtight">⌉</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow></msub></mrow><annotation encoding="application/x-tex">K_{\lceil m/2 \rceil}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">⌈</span><span class="mord mathnormal mtight">m</span><span class="mord mtight">/2</span><span class="mclose mtight">⌉</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span></span></span></span>右边部分。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow></msub></mrow><annotation encoding="application/x-tex">K_{\lceil m/2 \rceil}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">⌈</span><span class="mord mathnormal mtight">m</span><span class="mord mtight">/2</span><span class="mclose mtight">⌉</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span></span></span></span>左边部分仍然保留在原结点中；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow></msub></mrow><annotation encoding="application/x-tex">K_{\lceil m/2 \rceil}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">⌈</span><span class="mord mathnormal mtight">m</span><span class="mord mtight">/2</span><span class="mclose mtight">⌉</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span></span></span></span>右边部分存放在一个新创建的结点（由ap指向）中；关键字为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow></msub></mrow><annotation encoding="application/x-tex">K_{\lceil m/2 \rceil}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">⌈</span><span class="mord mathnormal mtight">m</span><span class="mord mtight">/2</span><span class="mclose mtight">⌉</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span></span></span></span>的记录和指针ap插入q的双亲结点。因q的双亲结点增加一个新的记录，所以必须对q的双亲结点重复第2步和第3步的操作，依此类推，直至由q指向的结点是根结点，转入第4步。</li><li>由于根结点无双亲，则由其分裂产生的两个结点的指针ap和q，以及关键字为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow></msub></mrow><annotation encoding="application/x-tex">K_{\lceil m/2 \rceil}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">⌈</span><span class="mord mathnormal mtight">m</span><span class="mord mtight">/2</span><span class="mclose mtight">⌉</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span></span></span></span>的记录构成一个新的根结点。此时，B-树的高度增加1。</li></ul><p>相应的算法描述为：(注：下面算法描述中的q和i是由查找函数SearchBTree返回的信息而得。)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在m阶B-树T上结点*q的K[i]与K[i+1]之间插入关键字key</span><br><span class="hljs-comment">// 若引起结点过大，则沿双亲链进行必要的结点分裂调整，使T仍是m阶B-树</span><br>Status <span class="hljs-title function_">InsertBTree</span><span class="hljs-params">(BTree &amp;T, KeyType key, BTree q, <span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-comment">// x表示新插入的关键字，ap为一个空指针</span><br>    x=key;ap=<span class="hljs-literal">NULL</span>;finished=FALSE;<br><br>    <span class="hljs-keyword">while</span>(q &amp;&amp; !finished) &#123;<br>        <span class="hljs-comment">// 将x和ap分别插入到q-&gt;key[i+1]和q-&gt;ptr[i+1]</span><br>        Insert(q, i, x, ap);<br>        <span class="hljs-comment">// 插入完成</span><br>        <span class="hljs-keyword">if</span>(q-&gt;keynum&lt;m) finished=TRUE;<br>        <span class="hljs-comment">// 分裂结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 将q-&gt;K[s+1..m],q-&gt;ptr[s..m]和q-&gt;recptr[s+1..m]移入新结点*ap</span><br>            s=(m+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            split(q,s,ap);<br>            x=q-&gt;K[s];<br>            q=q-&gt;parent;<br>            <span class="hljs-comment">// 在双亲结点*q中查找x的插入位置</span><br>            <span class="hljs-keyword">if</span>(q) i=Search(q,x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// T是空树（参数q初值为NULL）或者根结点已分裂为结点*q和*ap</span><br>    <span class="hljs-keyword">if</span>(!finished)<br>        <span class="hljs-comment">// 生成含信息(T,x,ap)的新的根结点*T，原T和ap为子树指针</span><br>        NewRoot(T,q,x,ap);<br><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4、删除">3.4、删除</h3><p>m阶B-树的删除操作是在B-树的某个结点中删除指定的关键字及其邻近的一个指针，删除后应该进行调整使该树仍然满足B-树的定义，也就是要保证每个结点的关键字数目范围为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\lceil m/2 \rceil-1,m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">]</span></span></span></span>。删除记录后，结点的关键字个数如果小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lceil m/2 \rceil - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，则要进行“合并”结点的操作。除了删除记录，还要删除该记录邻近的指针。若该结点为最下层的非终端结点，由于其指针均为空，删除后不会影响其他结点，可直接删除；若该结点不是最下层的非终端结点，邻近的指针则指向一棵子树，不可直接删除。此时可做如下处理：将要删除记录用其右（左）边邻近指针指向的子树中关键字最小（大）的记录（该记录必定在最下层的非终端结点中）替换。采取这种方法进行处理，无论要删除的记录所在的结点是否为最下层的非终端结点，都可归结为在最下层的非终端结点中删除记录的情况。</p><p>例如，在下图所示的B-树上删去45。</p><p><img src="/img/image-20240217161844576.png" alt="image-20240217161844576"></p><p>可以用*f结点中的50替代45，然后在*f结点中删去50。因此，下面可以只讨论删除最下层非终端结点中的关键字的情形。有以下3种可能。</p><p>（1）被删关键字所在结点中的关键字数目不小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil m/2 \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span></span></span></span>，则只需从该结点中删去该关键字<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和相应指针<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，树的其他部分不变。例如，从上图所示B-树中删去关键字12，删除后的B-树如下图所示。</p><p><img src="/img/image-20240217180002759.png" alt="image-20240217180002759"></p><p>（2）被删关键字所在结点中的关键字数目等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lceil m/2 \rceil-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，而与该结点相邻的右兄弟（或左兄弟）结点中的关键字数目大于，则需将其兄弟结点中的最小（或最大）的关键字上移至双亲结点中，而将双亲结点中小于（或大于）且紧靠该上移关键字的关键字下移至被删关键字所在结点中。例如，从上图中删去50，需将其右兄弟结点中的61上移至*e结点中，而将*e结点中的53移至*f，从而使*f和*g中关键字数目均不小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lceil m/2 \rceil-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，而双亲结点中的关键字数目不变，如下图所示。</p><p><img src="/img/image-20240217180212069.png" alt="image-20240217180212069"></p><p>（3）被删关键字所在结点和其相邻的兄弟结点中的关键字数目均等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lceil m/2 \rceil-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。假设该结点有右兄弟，且其右兄弟结点地址由双亲结点中的指针<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>所指，则在删去关键字之后，它所在结点中剩余的关键字和指针，加上双亲结点中的关键字<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>一起，合并到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>所指兄弟结点中（若没有右兄弟，则合并至左兄弟结点中）。例如，从上图所示B-树中删去53，则应删去*f结点，并将*f的剩余信息（指针“空”）和双亲*e结点中的61一起合并到右兄弟结点*g中，删除后的树如下图（c）所示。如果因此使双亲结点中关键字数目小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lceil m/2 \rceil-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，则依次类推做相应处理。例如，在下图（c）的B-树中删去关键字37之后，双亲*b结点中剩余信息（指针c）应和其双亲*a结点中关键字45一起合并至右兄弟结点*e中，删除后的B-树如下图（d）所示。</p><h2 id="四、B-树">四、B+树</h2><p>B+树是一种B-树的变形树，更适合用于文件索引系统。严格来讲，它已不符合树的定义了。</p><h3 id="4-1、B-树和B-树的差异">4.1、B+树和B-树的差异</h3><p>一棵m阶的B+树和m阶的B-树的差异在于：</p><ul><li>有n棵子树的结点中含有n个关键字；</li><li>所有的叶子结点中包含了全部关键字的信息，以及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接；</li><li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中的最大（或最小）关键字。</li></ul><p>例如，下图所示为一棵3阶的B+树，通常在B+树上有两个头指针，一个指向根结点，另一个指向关键字最小的叶子结点。因此，可以对B+树进行两种查找运算：一种是从最小关键字起顺序查找，另一种是从根结点开始，进行随机查找。</p><p><img src="/img/728785492088547ab47f6c100fb7339b.jpg" alt="img"></p><h3 id="4-2、B-树的查找、插入和差异">4.2、B+树的查找、插入和差异</h3><p>在B+树上进行随机查找、插入和删除的过程基本上与B-树类似。</p><p>（1）查找：若非终端结点上的关键字等于给定值，并不终止，而是继续向下直到叶子结点。因此，在B+树中，不管查找成功与否，每次查找都是走了一条从根到叶子结点的路径。B+树查找的分析类似于B-树。</p><p>B+树不仅能够有效地查找单个关键字，而且更适合查找某个范围内的所有关键字。例如，在B+树上找出范围在[a，b]之间的所有关键字值。处理方法如下：通过一次查找找出关键字a，不管它是否存在，都可以到达可能出现a的叶子结点，然后在叶子结点中查找关键字值等于a或大于a的那些关键字，对于所找到的每个关键字都有一个指针指向相应的记录，这些记录的关键字在所需要的范围。如果在当前结点中没有发现大于b的关键字，就可以使用当前叶子结点的最后一个指针找到下一个叶子结点，并继续进行同样的处理，直至在某个叶子结点中找到大于b的关键字，才停止查找。</p><p>（2）插入：仅在叶子结点上进行插入，当结点中的关键字个数大于m时要分裂成两个结点，它们所含关键字的个数分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor \frac{m+1}{2} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mfrac><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil \frac{m+1}{2} \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span></span></span></span>；并且，它们的双亲结点中应同时包含这两个结点中的最大关键字。</p><p>（3）删除：B+树的删除也仅在叶子结点进行，当叶子结点中最大关键字被删除时，其在非终端结点中的值可以作为一个“分界关键字”存在。若因删除而使结点中关键字的个数少于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil m/2 \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span></span></span></span>时，其和兄弟结点的合并过程亦和B-树类似。</p><h2 id="五、小结">五、小结</h2><p>树是一种具有层次关系的非线性数据结构。二叉树是一种最常用的树形结构，而满二叉树和完全二叉树又是两种特殊形态的二叉树；二叉树具有一些特殊的性质；二叉树有两种存储表示：顺序存储和链式存储。</p><h2 id="六、参考">六、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：线性表的查找</title>
    <link href="/2024/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2024/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p>查找是计算机科学中一项重要的技术，用于在数据集中查找特定元素。在实际应用中，查找是一种很常用的操作。对于一些数据量很大的实时系统，比如订票系统、互联网上的信息检索系统等，查找效率尤其重要。而不同的查找算法有着各自的优势和适用场景，了解这些算法的原理和特点，可以帮助我们在处理大规模数据时更加高效地进行查找操作。</p><h2 id="一、查找的基本概念">一、查找的基本概念</h2><p>在讨论具体的查找算法之前，我们首先要了解一下与查找相关的概念和术语。</p><h3 id="1-1、查找表">1.1、查找表</h3><p>查找表是由同一类型的数据元素（或记录）构成的集合。</p><p>由于“集合”中的数据元素之间存在着完全松散的关系，因此查找表是一种非常灵便的数据结构，可以利用其他的数据结构来实现，比如线性表、树表、散列表等。</p><h3 id="1-2、关键字">1.2、关键字</h3><p>关键字是数据元素（或记录）中某个数据项的值，用它可以标识一个数据元素（或记录）。</p><p>若关键字可以唯一地标识一个记录，则称此关键字为主关键字（对不同的记录，其主关键字均不同）。反之，称用以识别若干记录地关键字为次关键字。当数据元素只有一个数据项时，其关键字即为该数据元素的值。</p><h3 id="1-3、查找">1.3、查找</h3><p>查找是指在查找表中确定是否存在一个关键字等于给定值的数据元素（或记录）。</p><p>若表中存在关键字等于给定值的记录，则称查找成功，此时查找的结果可给出整个记录的信息，或指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称查找不成功，此时查找的结果可给出一个“空”记录或“空”指针。</p><h3 id="1-4、动态查找表和静态查找表">1.4、动态查找表和静态查找表</h3><p>若在查找的同时对表进行修改操作（如插入或删除），则相应的表称之为动态查找表，否则称之为静态查找表。</p><p>换句话说，动态查找表的表结构是在查找过程中动态生成的，即在创建表时，对于给定值，若表中存在关键字等于给定值的记录，则查找成功返回；否则插入关键字等于给定值的记录。</p><h3 id="1-5、平均查找长度">1.5、平均查找长度</h3><p>平均查找长度（Average Search Length，ASL），是指在查找成功时，需要和给定值进行比较的关键字个数的期望值。对于含有n个记录的表，查找成功时的平均查找长度为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>P</mi><mi>i</mi></msub><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">ASL=\sum_{i=1}^n P_i C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为在表中找到第i个元素的概率，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>P</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_{i=1}^n P_i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为在表中找到其关键字与给定值相等的第i个记录时，已和给定值进行过比较的关键字个数。显然，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>随查找过程不同而不同。</p><p>由于查找算法的基本运算是关键字之间的比较操作，所以可用平均查找长度来衡量查找算法的性能。</p><h2 id="二、线性表的查找">二、线性表的查找</h2><p>在查找表的组织方式中，线性表是最简单的一种。线性表常用的查找方法有3种：顺序查找、折半查找和分块查找。</p><h3 id="2-1、顺序查找">2.1、顺序查找</h3><p>顺序查找（Sequential Search），也称线性查找，是一种简单直观的查找算法。其查找过程为：从表的一端开始，依次将记录的关键字和给定值进行比较。若某个记录的关键字和给定值相等，则查找成功；反之，若扫描整个表后，仍未找到关键字和给定值相等的记录，则查找失败。</p><h4 id="2-1-1、存储结构">2.1.1、存储结构</h4><p>顺序查找不仅适用于线性表的顺序存储结构，也适用于线性表的链式存储结构。下面只介绍以顺序表作为存储结构时，实现的顺序查找算法。在C语言中，数据元素类型和顺序表的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 数据元素类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">// 关键字域</span><br>    KeyType key;<br>    <span class="hljs-comment">// 其他域</span><br>    InfoType otherinfo;<br>&#125;ElemType;<br><br><span class="hljs-comment">// 顺序表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">// 存储空间基地址</span><br>    ElemType *R;<br>    <span class="hljs-comment">// 当前长度</span><br>    <span class="hljs-type">int</span> length;<br>&#125;SSTable;<br></code></pre></td></tr></table></figure><h4 id="2-1-2、算法实现">2.1.2、算法实现</h4><p>在此假设元素从ST.R[1]开始顺序向后存放，ST.R[0]闲置不用，查找时从表的最后开始比较。顺序查找的算法步骤为：</p><ul><li>从最后一个元素起，依次比较元素值和给定值，若找到值与给定值相等的元素，则查找成功，返回该元素的序号。</li><li>若查遍整个顺序表都没有找到，则查找失败，返回0。</li></ul><p>相应的的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在顺序表ST中，顺序查找其关键字等于key的数据元素。</span><br><span class="hljs-comment">// 若找到，则函数值为该元素在表中的位置，否则为0。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Search_Seq</span><span class="hljs-params">(SSTable ST, KeyType key)</span> &#123;<br>    <span class="hljs-comment">// 从后往前查找</span><br>    <span class="hljs-keyword">for</span>(i=ST.length;i&gt;=<span class="hljs-number">1</span>;--i)<br>        <span class="hljs-keyword">if</span>(ST.R[i].key==key) <span class="hljs-keyword">return</span> i;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该算法在查找过程中每步都要检测整个表是否查找完毕，即每步都要有循环变量是否满足条件i&gt;=1的检测。改进这个程序，可以免去这个检测过程。改进方法是查找之前先对ST.R[0]的关键字赋值key，在此，ST.R[0]起到了监视哨的作用。设置监视哨的顺序查找的算法描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在顺序表ST中，顺序查找其关键字等于key的数据元素。</span><br><span class="hljs-comment">// 若找到，则函数值为该元素在表中的位置，否则为0。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Search_Seq</span><span class="hljs-params">(SSTable ST, KeyType key)</span> &#123;<br>    <span class="hljs-comment">// 设置哨兵</span><br>    ST.R[<span class="hljs-number">0</span>].key=key;<br>    <span class="hljs-comment">// 从后往前查找</span><br>    <span class="hljs-keyword">for</span>(i=ST.length;ST.R[i].key!=key;--i);<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-1-3、算法分析">2.1.3、算法分析</h4><p>通过设置监视哨，免去查找过程中每一步都要检测整个表是否查找完毕。实践证明，这个改进能使顺序查找在ST.length≥1000时，进行一次查找所需的平均时间几乎减少一半。当然，监视哨也可设在高下标处。上述两个算法的时间复杂度一样，为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>i</mi><mo>=</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">ASL=\frac{1}{n} \sum_{i=1}^n i=\frac{n+1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>即时间复杂度为O(n)。</p><h4 id="2-1-4、优缺点">2.1.4、优缺点</h4><p>顺序查找的优点是：算法简单，对表结构无任何要求，既适用于顺序结构，也适用于链式结构，无论记录是否按关键字有序均可应用。其缺点是：平均查找长度较大，查找效率较低，所以当n很大时，不宜采用顺序查找。</p><h3 id="2-2、折半查找">2.2、折半查找</h3><p>折半查找，也称二分查找（Binary Search），是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素要按关键字有序排列。（在下面及后续的讨论中，均假设顺序表是递增有序的。）</p><p>折半查找的查找过程为：从表的中间记录开始，如果给定值和中间记录的关键字相等，则查找成功；如果给定值大于或者小于中间记录的关键字，则在表中大于或小于中间记录的那一半中查找，这样重复操作，直到查找成功，或者在某一步中查找区间为空，则代表查找失败。</p><p>折半查找每一次查找比较都使查找范围缩小一半，与顺序查找相比，很显然会提高查找效率。</p><h4 id="2-2-1、算法实现">2.2.1、算法实现</h4><p>为了标记查找过程中每一次的查找区间，下面分别用low和high来表示当前查找区间的下界和上界，mid为区间的中间位置。折半查找的算法步骤为：</p><ul><li>设置查找区间初值，low为1，high为表长。</li><li>当low小于等于high时，循环执行以下操作：<ul><li>mid取low和high的中间值；</li><li>将给定值key与中间位置记录的关键字进行比较，若相等则查找成功，返回中间位置mid；</li><li>若不相等则利用中间位置记录将表对分成前、后两个子表。如果key比中间位置记录的关键字小，则high取为mid-1，否则low取为mid+1。</li></ul></li><li>循环结束，说明查找区间为空，则查找失败，返回0。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在有序表ST中，折半查找其关键字等于key的数据元素。</span><br><span class="hljs-comment">// 若找到，则函数值为该元素在表中的位置，否则为0。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Search_Bin</span><span class="hljs-params">(SSTable ST,KeyType key)</span> &#123;<br>    <span class="hljs-comment">// 设置查找区间初始值</span><br>    low=<span class="hljs-number">1</span>;<br>    high=ST.length;<br><br>    <span class="hljs-keyword">while</span>(low&lt;=high) &#123;<br>        mid=(low+high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 找到待查元素</span><br>        <span class="hljs-keyword">if</span>(key==ST.R[mid].key) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-comment">// 继续在前一子表进行查找</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key&lt;ST.R[mid].key) high=mid<span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 继续在后一子表进行查找</span><br>        <span class="hljs-keyword">else</span> low=mid+<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 表中不存在待查元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里唯一需要注意的是，循环执行的条件是low&lt;=high，而不是low&lt;high。因为当low=high时，查找区间还有一个结点，所以也需要进行比较。</p><h4 id="2-2-2、查找示例">2.2.2、查找示例</h4><p>已知一个包含11个数据元素的有序表为(5,16,20,27,30,36,44,55,60,67,71)，请给出折半查找关键字为27和65的数据元素的过程。</p><blockquote><p>折半查找关键字key=27的过程如下图所示。</p></blockquote><p><img src="/img/image-20240212170813739.png" alt="image-20240212170813739"></p><p>假设指针low和high分别指示待查元素所在范围的下界和上界，指针mid指示区间的中间位置，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mo stretchy="false">⌊</mo><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo>+</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">mid = \lfloor (low+high)/2 \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">hi</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mord">/2</span><span class="mclose">⌋</span></span></span></span>。在此例中，low和high的初值分别为1和11，即[1,11]为待查范围，mid初值为6。</p><p>首先，将给定值key=27与中间位置的数据元素的关键字ST.R[mid].key相比较，因为36&gt;27，说明待查元素若存在，必在区间[low, mid−1]的范围内，则令指针high指向第mid−1个元素，即high=5，重新求得mid的值为3。</p><p>然后，仍以key和ST.R[mid].key相比，因为20&lt;27，说明待查待元素若存在，必在[mid+1，high]范围内，则令指针low指向第mid+1个元素，即low=4，求得mid的新值为4。</p><p>最后，比较key和ST.R[mid].key，因为相等，则查找成功，返回所查元素在表中的序号，即指针mid的值4。</p><blockquote><p>折半查找关键字key=65的过程如下图所示。</p></blockquote><p><img src="/img/image-20240212172816433.png" alt="image-20240212172816433"></p><p>整个查找过程和查找关键字为27的过程相同，只是在最后一趟查找时，因为low&gt;high，查找区间不存在，说明表中没有关键字等于65的元素，查找失败，返回0。</p><h4 id="2-2-3、算法分析">2.2.3、算法分析</h4><p>折半查找过程可用二叉树来描述。树中每一结点对应表中一个记录，但结点值不是记录的关键字，而是记录在表中的位置序号。把当前查找区间的中间位置作为根，左子表和右子表分别作为根的左子树和右子树，由此得到的二叉树称为折半查找的判定树。</p><blockquote><p>在前面的查找示例中，查找27时的判断树。</p></blockquote><p><img src="/img/image-20240212181019168.png" alt="image-20240212181019168"></p><p>从该判定树可见，成功的折半查找恰好是走了一条从判定树的根到被查结点的路径，比较次数恰为该结点在树中的层次。例如，查找27的过程是一条从根到结点④的路径，需要比较3次，比较次数即为结点④所在的层次。上图中，比较1次的只有一个根结点，比较2次的有两个结点，比较3次和4次的各有四个结点。假设每个记录的查找概率相同，根据此判定树可知，对长度为11的有序表进行折半查找的平均查找长度为</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><mfrac><mn>1</mn><mn>11</mn></mfrac><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>∗</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>∗</mo><mn>4</mn><mo>+</mo><mn>4</mn><mo>∗</mo><mn>4</mn><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">ASL=\frac{1}{11}(1+2*2+3*4+4*4)=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">11</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span></span></p><p>由此可见，折半查找法在查找成功时进行比较的关键字个数最多不超过树的深度。而判定树的形态只与表的记录个数n相关，而与关键字的取值无关，具有n个结点的判定树的深度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lfloor \log_2 n \rfloor + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。所以，对于长度为n<br>的有序表，折半查找法在查找成功时和给定值进行比较的关键字个数至多为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lfloor \log_2 n \rfloor + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p><blockquote><p>在前面的查找示例中，查找56时的判断树。</p></blockquote><p>如果在上图所示的判定树中，为所有结点的空指针域加一个指向方形结点的指针，如下图所示。并且，称这些方形结点为判定树的外部结点（与之相对，称那些圆形结点为内部结点），那么查找失败的过程就是走了一条从根结点到外部结点的路径，和给定值进行比较的关键字个数等于该路径上内部结点个数。</p><p>例如，查找65的过程即为走了一条从根到结点9～10的路径。因此，折半查找在查找不成功时和给定值进行比较的关键字个数最多也不超过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lfloor \log_2 n \rfloor + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p><p><img src="/img/image-20240212182844423.png" alt="image-20240212182844423"></p><blockquote><p>折半查找的平均查找长度</p></blockquote><p>借助于判定树，很容易求得折半查找的平均查找长度。为了讨论方便起见，假定有序表的长度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n=2^h-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，则判定树是深度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">h=\log_{2}{(n+1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>的满二叉树。树中层次为1的结点有1个，层次为2的结点有2个，…，层次为h的结点有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{h-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>个。假设表中每个记录的查找概率相等，则查找成功时折半查找的平均查找长度为</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>P</mi><mi>i</mi></msub><msub><mi>C</mi><mi>i</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>h</mi></munderover><mi>j</mi><mo>∗</mo><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mi>n</mi></mfrac><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ASL=\sum_{i=1}^n P_i C_i=\frac{1}{n} \sum_{j=1}^h j*2^{j-1}=\frac{n+1}{n} \log_2 (n+1) -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.2499em;vertical-align:-1.4138em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8747em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8747em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><p>当n较大时，可有下列近似结果</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ASL=\log_2(n+1)-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><p>因此，折半查找的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{2}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>。可见，折半查找的效率比顺序查找高，但折半查找只适用于有序表，且限于顺序存储结构。</p><h4 id="2-2-4、优缺点">2.2.4、优缺点</h4><p>折半查找的优点是：比较次数少，查找效率高。其缺点是：对表结构要求高，只能用于顺序存储的有序表。查找前需要排序，而排序本身是一种费时的运算。同时为了保持顺序表的有序性，对有序表进行插入和删除时，平均比较和移动表中一半元素，这也是一种费时的运算。因此，折半查找不适用于数据元素经常变动的线性表。</p><h3 id="2-3、分块查找">2.3、分块查找</h3><p>分块查找（Blocking Search），又称索引顺序查找，是一种性能介于顺序查找和折半查找之间的一种查找方法。</p><h4 id="2-3-1、查找过程">2.3.1、查找过程</h4><p>在分块查找法中，除线性表本身外，还需要建立一个“索引表”。例如，下图是一个线性表及其索引表。</p><p><img src="/img/image-20240331112633589.png" alt="image-20240331112633589"></p><p>在该线性表中，有18个记录，将其分成3个子表<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>R</mi><mn>6</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(R_1,R_2,...,R_6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>R</mi><mn>7</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>8</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>R</mi><mn>12</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(R_7,R_8,...,R_{12})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>R</mi><mn>13</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>14</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>R</mi><mn>18</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(R_{13},R_{14},...,R_{18})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">13</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">18</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，对每个子表（或称块）建立一个索引项，其中包括两项内容：</p><ul><li><p>指针项（指示该子表的第一个记录在表中位置）</p></li><li><p>关键字项（其值为该子表内的最大关键字）</p></li></ul><p>索引表按关键字有序，则表有序或者分块有序。所谓“分块有序”，指的是第二个子表中所有记录的关键字均大于第一个子表中的最大关键字，第三个子表中的所有关键字均大于第二个子表中的最大关键字，…，依次类推。因此，分块查找过程需分两步进行。先确定待查记录所在的块（子表），然后在块中顺序查找。</p><p>假设给定值key=38，则先将key依次和索引表中各最大关键字进行比较，因为22&lt;key&lt;48，则关键字为38的记录若存在，必定在第二个子表中。由于同一索引项中的指针指示第二个子表中的第一个记录是线性表的第7个记录，则自第7个记录起进行顺序查找，直到ST.elem[10].key=key为止。</p><p>假设此子表中没有关键字等于key的记录（例如，key=29时自第7个记录起至第12个记录的关键字和key比较都不等），则查找不成功。</p><h4 id="2-3-2、查找性能">2.3.2、查找性能</h4><p>因为由索引项组成的索引表按关键字有序，所以确定块的查找可以用顺序查找，亦可用折半查找，而块中记录是任意排列的，则在块中只能是顺序查找。由此，分块查找算法是顺序查找和折半查找两种算法的简单合成。</p><p>分块查找的平均查找长度为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>S</mi><msub><mi>L</mi><mrow><mi>b</mi><mi>s</mi></mrow></msub><mo>=</mo><msub><mi>L</mi><mi>b</mi></msub><mo>+</mo><msub><mi>L</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">ASL_{bs}=L_b+L_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">L_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为查找索引表确定所在块的平均查找长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">L_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为在块中查找元素的平均查找长度。</p><p>一般情况下，为进行分块查找，可以将长度为n的表均匀地分成b块，每块含有s个记录，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mo stretchy="false">⌊</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">b=\lfloor n/s \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mclose">⌋</span></span></span></span>；又假定表中每个记录的查找概率相等，则每块查找的概率为1/b，块中每个记录的查找概率为1/s。</p><blockquote><p>顺序查找确定块</p></blockquote><p>若用顺序查找确定所在块，则分块查找的平均查找长度为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>S</mi><msub><mi>L</mi><mrow><mi>b</mi><mi>s</mi></mrow></msub><mo>=</mo><msub><mi>L</mi><mi>b</mi></msub><mo>+</mo><msub><mi>L</mi><mi>w</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>b</mi></mfrac><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>b</mi></munderover><mi>j</mi><mo>+</mo><mfrac><mn>1</mn><mi>s</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>s</mi></munderover><mi>i</mi><mo>=</mo><mfrac><mrow><mi>b</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo>+</mo><mfrac><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><mfrac><mi>n</mi><mi>s</mi></mfrac><mo>+</mo><mi>s</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ASL_{bs}=L_b+L_w=\frac{1}{b} \sum_{j=1}^b j + \frac{1}{s} \sum_{i=1}^s i = \frac{b+1}{2} + \frac{s+1}{2} = \frac{1}{2}(\frac{n}{s}+s)+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.2499em;vertical-align:-1.4138em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><p>可见，此时的平均查找长度不仅和表长n有关，而且和每一块中的记录个数s有关。在给定n的前提下，s是可以选择的。容易证明，当s取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.2397em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">n</span></span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span></span></span></span>时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>S</mi><msub><mi>L</mi><mrow><mi>b</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">ASL_{bs}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>取最小值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>n</mi></msqrt><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sqrt{n}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.2397em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">n</span></span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。这个值比顺序查找有了很大改进，但远不及折半查找。</p><blockquote><p>折半查找确定块</p></blockquote><p>若用折半查找确定所在块，则分块查找的平均查找长度为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>S</mi><msubsup><mi>L</mi><mrow><mi>b</mi><mi>s</mi></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo>≈</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mfrac><mi>n</mi><mi>s</mi></mfrac><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mfrac><mi>s</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">ASL&#x27;_{bs} \approx \log_2 (\frac{n}{s}+1) + \frac{s}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0489em;vertical-align:-0.247em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h4 id="2-3-3、优缺点">2.3.3、优缺点</h4><p>分块查找的优点是：在表中插入和删除数据元素时，只要找到该元素对应的块，就可以在该块内进行插入和删除运算。由于块内是无序的，故插入和删除比较容易，无需进行大量移动。如果线性表既要快速查找又经常动态变化，则可采用分块查找。其缺点是：要增加一个索引表的存储空间并对初始索引表进行排序运算。</p><h2 id="三、小结">三、小结</h2><p>查找，通常是指对查找表的查找。常用的查找表有3种：线性表、树表和散列表。其中，线性表的查找，主要包括顺序查找、折半查找和分块查找。</p><p><img src="/img/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE.jpeg" alt="img"></p><h2 id="四、参考">四、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：关键路径</title>
    <link href="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
    <url>/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p>关键路径一种进度分析技术，用于在程计划中估算完成整项工程至少需要多少时间、判断哪些活动是影响工程进度的关键等。在项目管理中，关键路径具有重要意义。它决定着项目的最短工期，因此项目经理需要重点关注关键路径上的所有活动，确保它们按时完成，以避免整个项目进度的延误。可以说，了解关键路径的概念和算法对于解决实际问题具有重要意义。</p><h2 id="一、基本概念">一、基本概念</h2><h3 id="1-1、AOE网">1.1、AOE网</h3><p>AOE网（Activity On Edge），是指以边表示活动的网。AOE网是一个带权的有向无环图，其中，顶点表示事件，弧表示活动，权表示活动持续的时间。通常，AOE网可用来估算工程的完成时间。</p><p>例如，下图所示为一个有11项活动的AOE网。其中有9个事件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>v</mi><mn>8</mn></msub></mrow><annotation encoding="application/x-tex">v_0,v_1,...,v_8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，每个事件表示在它之前的活动已经完成，在它之后的活动可以开始。比如，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示整个工程开始，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>8</mn></msub></mrow><annotation encoding="application/x-tex">v_8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示整个工程结束，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">v_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">a_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">a_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>已经完成，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>7</mn></msub></mrow><annotation encoding="application/x-tex">a_7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>8</mn></msub></mrow><annotation encoding="application/x-tex">a_8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可以开始了。与每个活动相联系的数是执行该活动所需的时间，比如，活动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>需要6天，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>需要4天等。</p><p><img src="/img/image-20240324114125320.png" alt="image-20240324114125320"></p><h3 id="1-2、关键路径">1.2、关键路径</h3><p>在程计划中，工程进度控制的关键在于抓住关键活动。在一定范围内，非关键活动的提前完成对于整个工程的进度没有直接的好处，它的稍许拖延也不会影响整个工程的进度。工程的指挥者可以把非关键活动的人力和物力资源暂时调给关键活动，加速其进展速度，以使整个工程提前完工。由于整个工程只有一个开始点和一个完成点，故在正常的情况（无环）下，网中只有一个入度为零的点，称作源点 ，也只有一个出度为零的点，称作汇点 。</p><p>在AOE网中，一条路径各弧上的权值之和称为该路径的带权路径长度 （后面简称路径长度）。要估算整项工程完成的最短时间，就是要找一条从源点到汇点的带权路径长度最长的路径，称为关键路径 （Critical Path）。关键路径上的活动叫做关键活动 ，这些活动是影响工程进度的关键，它们的提前或拖延将使整个工程提前或拖延。</p><p>例如，在前面的AOE网中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是源点，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>8</mn></msub></mrow><annotation encoding="application/x-tex">v_8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是汇点，关键路径有两条：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>6</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>8</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_0,v_1,v_4,v_6,v_8)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>7</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>8</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_0,v_1,v_4,v_7,v_8)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，长度均为18。关键活动为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>7</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>10</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_1,a_4,a_7,a_{10})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>8</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>11</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_1,a_4,a_8,a_{11})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。比如，关键活动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>需要6天完成，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>提前1天，整个工程也可以提前1天完成。所以不论是估算工期，还是研究如何加快工程进度，主要问题就在于要找到AOE网的关键路径。</p><h2 id="二、求解过程">二、求解过程</h2><h3 id="2-1、关键路径的4个描述量">2.1、关键路径的4个描述量</h3><p>确定关键路径，需要先定义4个描述量。</p><blockquote><p>事件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最早发生时间ve(i)</p></blockquote><p>进入事件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的每一活动都结束，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>才可发生，所以ve(i)是从源点到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最长路径长度。</p><p>求ve(i)的值，可根据拓扑顺序从源点开始向汇点递推。通常将工程的开始顶点事件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最早发生时间定义为0，即</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>v</mi><mi>e</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">ve(0)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>v</mi><mi>e</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mi>v</mi><mi>e</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>w</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub><mo stretchy="false">}</mo><mspace width="1em"/><mo>&lt;</mo><msub><mi>v</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo>&gt;</mo><mo>∈</mo><mi>T</mi><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ve(i)=Max\{ve(k)+w_{k,i}\} \quad &lt;v_k,v_i&gt; \in T,1 \le i \le n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><p>其中，T是所有以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为头的弧的集合，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">w_{k,i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>是弧<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_k,v_i&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>的权值，即对应活动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_k,v_i&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>的持续时间。</p><blockquote><p>事件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最迟发生时间vl(i)</p></blockquote><p>事件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的发生不得延误<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的每一后继事件的最迟发生时间。为了不拖延工期，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最迟发生时间不得迟于其后继事件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最迟发生时间减去活动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mtext>，</mtext><msub><mi>v</mi><mi>k</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_i，v_k&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>的持续时间。</p><p>求出ve(i)后，可根据逆拓扑顺序从汇点开始向源点递推，求出vl(i)。即</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>v</mi><mi>l</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>v</mi><mi>e</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">vl(n-1)=ve(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>v</mi><mi>l</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>M</mi><mi>i</mi><mi>n</mi><mo stretchy="false">{</mo><mi>v</mi><mi>l</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>w</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo stretchy="false">}</mo><mspace width="1em"/><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>k</mi></msub><mo>&gt;</mo><mo>∈</mo><mi>S</mi><mo separator="true">,</mo><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">vl(i)=Min\{vl(k)-w_{i,k}\} \quad &lt;v_i,v_k&gt; \in S,0 \le i \le n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">in</span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></span></p><p>其中，S是所有以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为尾的弧的集合，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">w_{i,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>是弧<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>k</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_i,v_k&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>的权值。</p><blockquote><p>活动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mo>&lt;</mo><msub><mi>v</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>k</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">a_i=&lt;v_j,v_k&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8252em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>的最早开始时间e(i)</p></blockquote><p>只有事件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>发生了，活动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>才能开始。所以，活动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最早开始时间等于事件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的最早发生时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>e</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ve(j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，即</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>v</mi><mi>e</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(i)=ve(j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></span></p><blockquote><p>活动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mo>&lt;</mo><msub><mi>v</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>k</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">a_i=&lt;v_j,v_k&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8252em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>的最晚开始时间l(i)</p></blockquote><p>活动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的开始时间需保证不延误事件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最迟发生时间。所以活动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最晚开始时间l(i)等于事件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最迟发生时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>l</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">vl(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>减去活动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的持续时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">w_{j,w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>，即：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>l</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>v</mi><mi>l</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>w</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">l(i)=vl(k)-w_{j,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>显然，对于关键活动而言，e(i)=l(i)。对于非关键活动，l(i)-e(i)的值是该工程的期限余量，在此范围内的适度延误不会影响整个工程的工期。</p><p>一个活动的最迟开始时间l(i)和其最早开始时间e(i)的差值l(i)-e(i)是该活动完成的时间余量。它是在不增加完成整个工程所需的总时间的情况下，该活动可以拖延的时间。当一个活动的时间余量为零时，说明该活动必须如期完整，否则就会拖延整个工程的进度。所以称l(i)−e(i)=0，即l(i)=e(i)的活动是关键活动。</p><h3 id="2-2、求解关键路径的过程">2.2、求解关键路径的过程</h3><p>知道了如何确定关键路径，就能给出求解关键路径的过程了，该过程如下：</p><ul><li>对图中顶点进行拓扑排序，在排序过程中按拓扑序列求出每个事件的最早发生时间ve(i)。</li><li>按逆拓扑序列求出每个事件的最迟发生时间vl(i)。</li><li>求出每个活动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最早开始时间e(i)。</li><li>求出每个活动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最晚开始时间l(i)。</li><li>找出e(i)=l(i)的活动，即关键活动。由关键活动形成的从源点到汇点的每一条路径就是关键路径，关键路径有可能不止一条。</li></ul><h3 id="2-3、计算关键路径的示例">2.3、计算关键路径的示例</h3><p>例如，对前面的AOE网，计算其关键路径，过程如下。</p><blockquote><p>计算各顶点事件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最早发生时间ve(i)。</p></blockquote><p>ve(0) = 0<br>ve(1) = max{ve(0) + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{0,1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>} = 6<br>ve(2) = max{ve(0) + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>0</mn><mo separator="true">,</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{0,2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>} = 4<br>ve(3) = max{ve(0) + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>0</mn><mo separator="true">,</mo><mn>3</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{0,3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>} = 5<br>ve(4) = max{ve(1) + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>1</mn><mo separator="true">,</mo><mn>4</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{1,4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>, ve(2) + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>2</mn><mo separator="true">,</mo><mn>4</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{2,4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mpunct mtight">,</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>} = 7<br>ve(5) = max{ve(3) + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>3</mn><mo separator="true">,</mo><mn>5</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{3,5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mpunct mtight">,</span><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>} = 7<br>ve(6) = max{ve(4) + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>4</mn><mo separator="true">,</mo><mn>6</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{4,6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mpunct mtight">,</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>} = 16<br>ve(7) = max{ve(4) + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>4</mn><mo separator="true">,</mo><mn>7</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{4,7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mpunct mtight">,</span><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>, ve(5) + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>5</mn><mo separator="true">,</mo><mn>7</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{5,7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mpunct mtight">,</span><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>} = 14<br>ve(8) = max{ve(6) + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>6</mn><mo separator="true">,</mo><mn>8</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{6,8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mpunct mtight">,</span><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>, ve(7) + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>7</mn><mo separator="true">,</mo><mn>8</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{7,8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span><span class="mpunct mtight">,</span><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>} = 18</p><blockquote><p>计算各顶点事件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最迟发生时间ve(i)。</p></blockquote><p>vl(8) = ve(8) = 18<br>vl(7) = min{vl(8) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>7</mn><mo separator="true">,</mo><mn>8</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{7,8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span><span class="mpunct mtight">,</span><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>} = 14<br>vl(6) = min{vl(8) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>6</mn><mo separator="true">,</mo><mn>8</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{6,8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mpunct mtight">,</span><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>} = 16<br>vl(5) = min{vl(7) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>5</mn><mo separator="true">,</mo><mn>7</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{5,7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mpunct mtight">,</span><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>} = 10<br>vl(4) = min{vl(6) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>4</mn><mo separator="true">,</mo><mn>6</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{4,6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mpunct mtight">,</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>, vl(7) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>4</mn><mo separator="true">,</mo><mn>7</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{4,7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mpunct mtight">,</span><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>} = 7<br>vl(3) = min{vl(5) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>3</mn><mo separator="true">,</mo><mn>5</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{3,5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mpunct mtight">,</span><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>} = 8<br>vl(2) = min{vl(4) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>2</mn><mo separator="true">,</mo><mn>4</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{2,4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mpunct mtight">,</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>} = 6<br>vl(1) = min{vl(4) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>1</mn><mo separator="true">,</mo><mn>4</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{1,4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>} = 6<br>vl(0) = min{vl(1) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{0,1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>, vl(2) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>0</mn><mo separator="true">,</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{0,2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>, vl(3) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>0</mn><mo separator="true">,</mo><mn>3</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{0,3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>} = 0</p><blockquote><p>计算各活动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最早开始时间e(i)。</p></blockquote><p>e(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = ve(0) = 0<br>e(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = ve(0) = 0<br>e(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">a_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = ve(0) = 0<br>e(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">a_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = ve(1) = 6<br>e(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">a_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = ve(2) = 4<br>e(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">a_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = ve(3) = 5<br>e(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>7</mn></msub></mrow><annotation encoding="application/x-tex">a_7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = ve(4) = 7<br>e(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>8</mn></msub></mrow><annotation encoding="application/x-tex">a_8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = ve(4) = 7<br>e(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>9</mn></msub></mrow><annotation encoding="application/x-tex">a_9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = ve(5) = 7<br>e(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>10</mn></msub></mrow><annotation encoding="application/x-tex">a_{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = ve(6) = 16<br>e(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>11</mn></msub></mrow><annotation encoding="application/x-tex">a_{11}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = ve(7) = 14</p><blockquote><p>计算各活动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最迟开始时间l(i)。</p></blockquote><p>l(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>11</mn></msub></mrow><annotation encoding="application/x-tex">a_{11}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = vl(8) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>7</mn><mo separator="true">,</mo><mn>8</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{7,8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span><span class="mpunct mtight">,</span><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> = 14<br>l(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>10</mn></msub></mrow><annotation encoding="application/x-tex">a_{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = vl(8) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>6</mn><mo separator="true">,</mo><mn>8</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{6,8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mpunct mtight">,</span><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> = 16<br>l(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>9</mn></msub></mrow><annotation encoding="application/x-tex">a_9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = vl(7) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>5</mn><mo separator="true">,</mo><mn>7</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{5,7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mpunct mtight">,</span><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> = 10<br>l(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>8</mn></msub></mrow><annotation encoding="application/x-tex">a_8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = vl(7) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>4</mn><mo separator="true">,</mo><mn>7</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{4,7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mpunct mtight">,</span><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> = 7<br>l(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>7</mn></msub></mrow><annotation encoding="application/x-tex">a_7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = vl(6) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>4</mn><mo separator="true">,</mo><mn>6</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{4,6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mpunct mtight">,</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> = 7<br>l(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">a_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = vl(5) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>3</mn><mo separator="true">,</mo><mn>5</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{3,5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mpunct mtight">,</span><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> = 8<br>l(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">a_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = vl(4) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>2</mn><mo separator="true">,</mo><mn>4</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{2,4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mpunct mtight">,</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> = 6<br>l(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">a_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = vl(4) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>1</mn><mo separator="true">,</mo><mn>4</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{1,4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> = 6<br>l(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">a_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = vl(3) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>0</mn><mo separator="true">,</mo><mn>3</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{0,3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> = 3<br>l(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = vl(2) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>0</mn><mo separator="true">,</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{0,2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> = 2<br>l(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = vl(1) - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{0,1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> = 0</p><p>顶点的发生时间和活动的开始时间可分别汇总为如下两个表：</p><p><img src="/img/image-20240324122416538.png" alt="image-20240324122416538"></p><p>可以看出，在前面的AOE网中，有两条关键路径：一条是由活动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>7</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>10</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_1,a_4,a_7,a_{10})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>组成的关键路径，另一条是由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>8</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>11</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_1,a_4,a_8,a_{11})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>组成的关键路径，如下图所示。</p><p><img src="/img/image-20240324122946881.png" alt="image-20240324122946881"></p><h2 id="三、算法实现">三、算法实现</h2><p>由于每个事件的最早发生时间ve(i)和最迟发生时间vl(i)要在拓扑序列的基础上进行计算，所以实现关键路径算法要基于拓扑排序算法。采用邻接表作为有向图的存储结构，实现关键路径算法要引入以下辅助的数据结构。</p><ul><li>一维数组ve[i]：事件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最早发生时间。</li><li>一维数组vl[i]：事件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最迟发生时间。</li><li>一维数组topo[i]：记录拓扑序列的顶点序号。</li></ul><p>实现关键路径算法的步骤为：</p><ul><li><p>调用拓扑排序算法，将拓扑序列保存在一维数组topo中。</p></li><li><p>将每个事件的最早发生时间ve[i]初始化为0，即ve[i]=0。</p></li><li><p>根据一维数组topo中的值，按从前向后的拓扑次序，依次求每个事件的最早发生时间，循环n次，执行以下操作：</p><ul><li>取得拓扑序列中的顶点序号k，即k=topo[i]；</li><li>用指针p依次指向k的每个邻接顶点，取得每个邻接点的序号j=p-&gt;adjvex，依次更新顶点j的最早发生时间ve[j]：</li></ul></li></ul><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>i</mi><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mi>e</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>v</mi><mi>e</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mi>p</mi><mo>−</mo><mo>&gt;</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">)</mo><mspace width="1em"/><mi>v</mi><mi>e</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>v</mi><mi>e</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mi>p</mi><mo>−</mo><mo>&gt;</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">if(ve[j]&lt;ve[k]+p-&gt;weight) \quad ve[j]=ve[k]+p-&gt;weight;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mpunct">;</span></span></span></span></span></p><ul><li><p>将每个事件的最迟发生时间vl[i]初始化为汇点的最早发生时间，vl[i]=ve[n-1]。</p></li><li><p>根据一维数组topo中的值，按从后向前的逆拓扑次序，依次求每个事件的最迟发生时间，循环n次，执行以下操作：</p><ul><li>取得拓扑序列中的顶点序号k，即k=topo[i]；</li><li>用指针p依次指向k的每个邻接顶点，取得每个邻接点的序号j=p-&gt;adjvex，依次根据k的邻接点，更新k的最迟发生时间vl[k]：</li></ul></li></ul><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>i</mi><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mi>l</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>&gt;</mo><mi>v</mi><mi>l</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>−</mo><mi>p</mi><mo>−</mo><mo>&gt;</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">)</mo><mspace width="1em"/><mi>v</mi><mi>l</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>=</mo><mi>v</mi><mi>l</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>−</mo><mi>p</mi><mo>−</mo><mo>&gt;</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">if(vl[k]&gt;vl[j]-p-&gt;weight) \quad vl[k]=vl[j]-p-&gt;weight;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mpunct">;</span></span></span></span></span></p><ul><li><p>判断某一活动是否为关键活动，循环n次，执行以下操作：</p><ul><li>对于每个顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，用指针p依次指向<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的每个邻接点，取得每个邻接点的序号j=p-&gt;adjvex，分别计算活动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_i,v_j&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8252em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>的最早和最迟开始时间e和l：</li></ul><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>e</mi><mo>=</mo><mi>v</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">;</mo><mi>l</mi><mo>=</mo><mi>v</mi><mi>l</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>−</mo><mi>p</mi><mo>−</mo><mo>&gt;</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">e=ve[i];l=vl[j]-p-&gt;weight;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mpunct">;</span></span></span></span></span></p><ul><li>如果e和l相等，则活动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_i,v_j&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8252em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>为关键活动，输出弧<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_i,v_j&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8252em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>。</li></ul></li></ul><p>关键路径算法的C语言描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 有向网G的存储结构为邻接表，输出其关键活动</span><br>Status <span class="hljs-title function_">CriticalPath</span><span class="hljs-params">(ALGraph G)</span> &#123;<br>    <span class="hljs-comment">// 对G进行拓扑排序，将拓扑序列保存在topo中</span><br>    <span class="hljs-comment">// 若调用失败，说明存在有向环，返回ERROR</span><br>    <span class="hljs-keyword">if</span>(!TopologicalOrder(G,topo)) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-comment">// n为顶点个数</span><br>    n=G.vexnum;<br><br>    <span class="hljs-comment">// 将每个事件的最早发生时间初始化为0</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++) ve[i]=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 按拓扑次序求每个事件的最早发生时间</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>        <span class="hljs-comment">// 取得拓扑序列中的顶点序号k</span><br>        k=topo[i];<br>        <span class="hljs-comment">// p指向k的第一个邻接点</span><br>        p=G.vertices[k].firstarc;<br>        <span class="hljs-comment">// 依次更新k的所有邻接点的最早发生时间</span><br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-comment">// j为邻接点的序号</span><br>            j=p-&gt;adjvex;<br>            <span class="hljs-comment">// 更新顶点j的最早发生时间ve[j]</span><br>            <span class="hljs-keyword">if</span>(ve[j]&lt;ve[k]+p-&gt;weight)<br>                ve[j]=ve[k]+p-&gt;weight;<br>            <span class="hljs-comment">// p指向k的下一个邻接点</span><br>            p=p-&gt;nextarc;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将每个事件的最迟发生时间初始化为ve[n-1]</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++) vl[i]=ve[n<span class="hljs-number">-1</span>];<br>    <span class="hljs-comment">// 按逆拓扑次序求每个事件的最迟发生时间</span><br>    <span class="hljs-keyword">for</span>(i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;<br>        <span class="hljs-comment">// 取得拓扑序列中的顶点序号k</span><br>        k=topo[i];<br>        <span class="hljs-comment">// p指向k的第一个邻接点</span><br>        p=G.vertices[k].firstarc;<br>        <span class="hljs-comment">// 依次更新k的所有邻接点的最迟发生时间</span><br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-comment">// j为邻接点的序号</span><br>            j=p-&gt;adjvex;<br>            <span class="hljs-comment">// 更新顶点j的最迟发生时间vl[k]</span><br>            <span class="hljs-keyword">if</span>(vl[k]&gt;vl[j]-p-&gt;weight)<br>                vl[k]=vl[j]-p-&gt;weight;<br>            <span class="hljs-comment">// p指向k的下一个邻接点</span><br>            p=p-&gt;nextarc;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断某一活动是否为关键活动</span><br>    <span class="hljs-comment">// 每次循环针对以vi作为活动开始点的所有活动</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>        <span class="hljs-comment">// p指向i的第一个邻接点</span><br>        p=G.vertices[i].firstarc;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-comment">// j为i的邻接顶点的序号</span><br>            j=p-&gt;adjvex;<br>            <span class="hljs-comment">// 计算活动&lt;vi,vj&gt;的最早开始时间</span><br>            e=ve[i];<br>            <span class="hljs-comment">// 计算活动&lt;vi,vj&gt;的最迟开始时间</span><br>            l=vl[j]-p-&gt;weight;<br>            <span class="hljs-comment">// 若为关键活动，则输出&lt;vi, vj&gt;</span><br>            <span class="hljs-keyword">if</span>(e==l) <span class="hljs-built_in">cout</span>&lt;&lt;G.vertices[i].data&lt;&lt;G.vertices[j].data;<br>            <span class="hljs-comment">// p指向i的下一个邻接点</span><br>            p=p-&gt;nextarc;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在求每个事件的最早和最迟发生时间，以及活动的最早和最迟开始时间时，都要对所有顶点及每个顶点边表中所有的边结点进行检查，由此，求关键路径算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>。</p><p>经实践证明：用AOE网来估算某些工程完成的时间是非常有用的。实际上，求关键路径的方法最初就是与维修和建造工程一起发展的。由于网中各项活动是互相牵涉的，因此，影响关键活动的因素亦是多方面的，任何一项活动持续时间的改变都可能引起关键路径的改变。所以，当子工程在进行过程中持续时间有所调整时，就要重新计算关键路径。另外，若网中有几条关键路径，那么，单是提高一条关键路径上关键活动的速度，还不能导致整个工程缩短工期，而必须同时提高在几条关键路径上的活动速度。</p><h2 id="四、小结">四、小结</h2><p>关键路径算法基于以边表示活动的有向图，即AOE网。关键路径上的活动叫做关键活动，这些活动是影响工程进度的关键，它们的提前或拖延将使整个工程提前或拖延。关键路径算法的实现建立在拓扑排序的基础上，用邻接表表示有向图，关键路径算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>。</p><p><img src="/img/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84-1711846184135.jpeg" alt="img"></p><h2 id="五、参考">五、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：拓扑排序</title>
    <link href="/2024/03/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <url>/2024/03/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>拓扑排序是一种对有向无环图（DAG）中的节点进行排序的算法。拓扑排序在实际应用中具有重要意义，可以帮助我们解决诸如任务调度、依赖关系分析等问题。同时，拓扑排序也可以用来检测有向图是否存在环路，如果图中存在环路，则无法进行拓扑排序。因此，拓扑排序是一种常用且有效的图算法，对于理解和处理有向无环图具有重要意义。</p><h2 id="一、基本概念">一、基本概念</h2><h3 id="1-1、DAG图">1.1、DAG图</h3><p>一个无回路的有向图称作有向无环图（Directed Acyclic Graph），简称DAG图。</p><p>有向无环图是描述一项工程的进行过程的有效工具。通常把计划、施工过程、生产流程、程序流程等都当成一个工程。除了很小的工程外，一般的工程都可分为若干个称做活动（Activity）的子工程，而这些子工程之间，通常受着一定条件的约束，如其中某些子工程的开始必须在另一些子工程完成之后。</p><p>例如，一个软件专业的学生必须学习一系列基本课程，其中有些课程是基础课，独立于其他课程，如《高等数学》；而另一些课程必须在学完作为其基础的先修课程才能开始。比如，在《程序设计基础》和《离散数学》学完之前就不能开始学习《数据结构》。这些先决条件定义了课程之间的优先关系。这个关系可以用有向图更清楚地表示，如下图所示。图中顶点表示课程，有向弧表示先决条件。若课程i是课程j的先决条件，则图中有弧&lt;i, j&gt;。</p><p><img src="/img/image-20240323113015120.png" alt="image-20240323113015120"></p><h3 id="1-2、AOV网">1.2、AOV网</h3><p>AOV网，是指以顶点表示活动的网（Activity On Vertex Network）。它是一个特殊的有向无环图，用顶点表示活动、用弧表示活动间的优先关系。在AOV网中，若从顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>有一条有向路径，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的前驱；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的后继。若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_i , v_j&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8252em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>是网中的一条弧，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的直接前驱，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的直接后继。</p><p>在AOV网中，不应该出现有向环，因为存在环意味着某项活动应以自己为先决条件。显然，这是荒谬的。若设计出这样的流程图，工程便无法进行；而对程序的数据流图来说，则表明存在一个死循环。因此，对给定的AOV网应首先判定网中是否存在环。检测的办法是对有向图的顶点进行拓扑排序，若网中所有顶点都在它的拓扑有序序列中，则该AOV网中必定不存在环。</p><h3 id="1-3、拓扑排序">1.3、拓扑排序</h3><p>所谓拓扑排序，就是将AOV网中的所有顶点排成一个线性序列，该序列满足：若在AOV网中从顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>有一条路径，则在该线性序列中的顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>必定在顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>之前。</p><p>例如，在前面的表示课程间优先关系的有向图中，有如下两个拓扑有序序列（当然，对此图也可构造出其他的拓扑有序序列）：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>5</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>7</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>9</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>10</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>11</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>6</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>12</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>8</mn></msub></mrow><annotation encoding="application/x-tex">v_1,v_2,v_3,v_4,v_5,v_7,v_9,v_{10},v_{11},v_6,v_{12},v_8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>v</mi><mn>9</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>10</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>11</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>6</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>12</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>5</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>7</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>8</mn></msub></mrow><annotation encoding="application/x-tex">v_9,v_{10},v_{11},v_6,v_1,v_{12},v_4,v_2,v_3,v_5,v_7,v_8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>学生必须按照拓扑有序的顺序来安排学习计划，这样才能保证学习任一门课程时其先修课程已经学过。</p><h2 id="二、拓扑排序的过程">二、拓扑排序的过程</h2><p>那么如何进行拓扑排序呢？拓扑排序的过程如下：</p><ul><li>在有向图中选一个无前驱的顶点且输出它。</li><li>从图中删除该顶点和所有以它为尾的弧。</li><li>重复第一步和第二步，直至不存在无前驱的顶点。</li><li>若此时输出的顶点数小于有向图中的顶点数，则说明有向图中存在环，否则输出的顶点序列即为一个拓扑序列。</li></ul><p>例如，下图所示的有向图G：</p><p><img src="/img/image-20240323143618751.png" alt="image-20240323143618751"></p><p>在该图中，顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">v_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>没有前驱，则可任选一个。假设先输出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">v_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，在删除<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">v_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>及弧<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mn>6</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>4</mn></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_6, v_4&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mn>6</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>5</mn></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_6, v_5&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>之后，只有顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>没有前驱，则输出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>且删去<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>及弧<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_1, v_2&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>3</mn></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_1, v_3&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>4</mn></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_1, v_4&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>，之后<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">v_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">v_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>都没有前驱。依次类推，可从中任选一个继续进行。最后得到该有向图的拓扑有序序列为</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>v</mi><mn>6</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">v_6, v_1, v_4, v_3, v_2, v_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><h2 id="三、拓扑排序的实现">三、拓扑排序的实现</h2><p>拓扑排序可采用邻接表作为有向图的存储结构。算法实现要引入以下辅助数据结构：</p><ul><li>一维数组indegree[i]：存放各顶点入度，没有前驱的顶点就是入度为零的顶点。删除顶点及以它为尾的弧的操作，可不必真正对图的存储结构进行改变，可用弧头顶点的入度减1的办法来实现。</li><li>栈S：暂存所有入度为零的顶点，这样可以避免重复扫描数组indegree检测入度为0的顶点，提高算法的效率。</li><li>一维数组topo[i]：记录拓扑序列的顶点序号。</li></ul><p>拓扑排序的算法步骤为：</p><ul><li>求出各顶点的入度存入数组indegree[i]中，并将入度为0的顶点入栈。</li><li>只要栈不为空，就重复以下操作：<ul><li>栈顶顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>出栈并保存在拓扑序列数组topo中；</li><li>对顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的每个邻接点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的入度减一，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的入度变为0，则将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>入栈。</li></ul></li><li>如果输出顶点个数少于AOV网的顶点个数，则网中存在有向环，无法进行拓扑排序，否则拓扑排序成功。</li></ul><p>拓扑排序算法的C语言描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 对采用邻接表作为存储结构的有向图G进行拓扑排序</span><br><span class="hljs-comment">// 若G无回路，则生成G的一个拓扑序列topo[]并返回OK，否则返回ERROR</span><br>Status <span class="hljs-title function_">TopologicalSort</span><span class="hljs-params">(ALGraph G, <span class="hljs-type">int</span> topo[])</span> &#123;<br>    <span class="hljs-comment">// 求出各顶点的入度存入数组indegree中</span><br>    FindInDegree(G, indegree);<br>    <span class="hljs-comment">// 栈S初始化为空</span><br>    InitStack(S);<br>    <span class="hljs-comment">// 入度为0者进栈</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i)<br>        <span class="hljs-keyword">if</span>(!indegree[i]) Push(S,i);<br><br>    <span class="hljs-comment">// 对输入顶点计数，初始为0</span><br>    m=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 栈S非空</span><br>    <span class="hljs-keyword">while</span>(!StackEmpty(S)) &#123;<br>        <span class="hljs-comment">// 栈顶顶点vi出栈</span><br>        Pop(S,i);<br>        <span class="hljs-comment">// 将vi保存在拓扑序列数组topo中</span><br>        topo[m]=i;<br>        <span class="hljs-comment">// p指向vi的第一个邻接点</span><br>        p=G.vertices[i].firstarc;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-comment">// vk为vi的邻接点</span><br>            k=p-&gt;adjvex;<br>            <span class="hljs-comment">// vi的每个邻接点的入度减1</span><br>            --indegree[k];<br>            <span class="hljs-comment">// 若入度减为0，则入栈</span><br>            <span class="hljs-keyword">if</span>(indegree[k]==<span class="hljs-number">0</span>) Push(S,k);<br>            <span class="hljs-comment">// p指向顶点vi的下一个邻接顶点</span><br>            p=p-&gt;nextarc;<br>        &#125;<br>        <span class="hljs-comment">// 对输出顶点计数</span><br>        ++m;<br>    &#125;<br><br>    <span class="hljs-comment">// 输出的顶点个数少于图中顶点个数返回ERROR，否则返回OK</span><br>    <span class="hljs-keyword">if</span>(m&lt;G.vexnum) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>对有n 个顶点和e 条边的有向图而言，建立求各顶点入度的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>；建立零入度顶点栈的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>；在拓扑排序过程中，若有向图无环，则每个顶点进一次栈，出一次栈，入度减1的操作在循环中总共执行e 次，所以，总的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n +e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>。</p><h2 id="四、小结">四、小结</h2><p>拓扑排序，基于以顶点表示活动的网，即AOV网。对于不存在环的有向图，图中所有顶点一定能够排成一个线性序列，即拓扑序列，拓扑序列是不唯一的。用邻接表表示图，拓扑排序的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>。</p><p><img src="/img/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F.jpeg" alt="img"></p><h2 id="五、参考">五、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：最短路径</title>
    <link href="/2024/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2024/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p>在实际应用中，最短路径算法被广泛应用于网络路由、交通规划、物流配送等领域。例如，在物流管理中，通过优化整个物流体系，实现最短路径、最低成本的物流管理，可以有效降低物流成本，提高效率。因此，了解最短路径的概念和算法对于解决实际问题具有重要意义。</p><h2 id="一、最短路径问题">一、最短路径问题</h2><p>假若要在计算机上建立一个交通咨询系统，则可以采用图的结构来表示实际的交通网络。如下图所示，图中顶点表示城市，边表示城市间的交通联系。例如，一位旅客要从A城到B城，他希望选择一条中转次数最少的路线。</p><p><img src="/img/d02dbf546e9551c5392a6f863594b0fb.jpg" alt="img"></p><p>假设图中每一站都需要换车，则这个问题反映到图上就是要找一条从顶点A到B所含边的数目最少的路径。只需从顶点A出发对图做广度优先搜索，一旦遇到顶点B就终止。由此所得的广度优先生成树上，从根顶点A到顶点B的路径就是中转次数最少的路径，路径上A与B之间的顶点数就是中转次数，但是，这只是一类最简单的图的最短路径问题。</p><p>有时，对于旅客来说，可能更关心的是节省交通费用；而对于司机来说，里程和速度则是他们感兴趣的信息。为了在图上表示有关信息，可对边赋以权，权的值表示两城市间的距离，或途中所需时间，或交通费用等。此时路径长度的度量就不再是路径上边的数目，而是路径上边的权值之和。</p><p>考虑到交通图的有向性，例如，汽车的上山和下山，轮船的顺水和逆水，所花费的时间或代价就不相同，所以交通网往往是用带权有向网表示。在带权有向网中，习惯上称路径上的第一个顶点为源点（Source），最后一个顶点为终点（Destination）。</p><p>最常见的最短路径问题有两种：一种是求从某个源点到其余各顶点的最短路径，另一种是求每一对顶点之间的最短路径。下面，我们将分别讨论这两种最短路径问题。</p><h2 id="二、迪杰斯特拉算法">二、迪杰斯特拉算法</h2><p>从某个源点到其余各顶点的最短路径，也称单源点最短路径问题。即，给定带权有向图G和源点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，求从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到G中其余各顶点的最短路径。迪杰斯特拉（Dijkstra）提出了一个按路径长度递增的次序产生最短路径的算法，因此称为迪杰斯特拉算法。</p><h3 id="2-1、求解过程">2.1、求解过程</h3><p>对于网G=(V, E)，迪杰斯特拉算法的求解过程如下：</p><ul><li>首先，将G中的顶点分成两组：第一组S，为已求出最短路径的终点集合（初始时只包含源点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）；第二组V-S，为尚未求出最短路径的顶点集合（初始时为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>−</mo><mo stretchy="false">{</mo><msub><mi>v</mi><mn>0</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">V-\{v_0\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>）。</li><li>然后，按各顶点与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>间最短路径长度递增的次序，逐个将集合V-S中的顶点并入到集合S中。在这个过程中，总保持从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到集合S中各顶点的路径长度始终不大于到集合V-S中各顶点的路径长度。</li></ul><p>这种求解方法能确保是正确的。因为，假设S为已求得最短路径的终点的集合，则可证明：下一条最短路径（设其终点为x）或者是边(v, x)，或者是中间只经过S中的顶点而最后到达顶点x的路径。这可用反证法来证明。假设此路径上有一个顶点不在S中，则说明存在一条终点不在S而长度比此路径短的路径。但是，这是不可能的。因为算法是按路径长度递增的次序来产生最短路径的，故长度比此路径短的所有路径均已产生，它们的终点必定在S中，即假设不成立。</p><p>例如，下图是一个带权有向图：</p><p><img src="/img/image-20240316121239041.png" alt="image-20240316121239041"></p><p>下表是从图中顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到其余各顶点的最短路径：</p><table><thead><tr><th>源点</th><th>终点</th><th>最短路径</th><th>路径长度</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">v_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_0,v_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>10</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">v_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>4</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_0,v_4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>30</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">v_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_0,v_4,v_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>50</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">v_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>5</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_0,v_4,v_3,v_5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>60</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>无</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span></td></tr></tbody></table><p>根据迪杰斯特拉算法的求解过程，按路径长度递增的次序，首先求出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">v_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的路径<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_0,v_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，然后依次求得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">v_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的路径<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>4</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_0,v_4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">v_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的路径<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_0,v_4,v_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">v_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的路径<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>5</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_0,v_4,v_3,v_5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，而从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>没有路径。</p><h3 id="2-2、算法步骤">2.2、算法步骤</h3><p>假设用带权的邻接矩阵arcs来表示带权有向网G，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>r</mi><mi>c</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">G.arcs[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">rcs</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示弧<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_i, v_j&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8252em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>上的权值。若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_i, v_j&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8252em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>不存在，则置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>r</mi><mi>c</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">G.arcs[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">rcs</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>为无穷大。求源点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到其余各顶点的算法实现要引入以下辅助数据结构：</p><ul><li>一维数组S[i]：记录从源点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到终点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最短路径是否已被确定，true表示已经确定，false表示尚未确定。</li><li>一维数组Path[i]：记录从源点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到终点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的当前最短路径上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的直接前驱顶点序号。其初值为：如果从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>有弧，则Path[i]为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>；否则为-1。</li><li>一维数组D[i]：记录从源点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到终点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的当前最短路径长度。其初值为：如果从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>有弧，则D[i]为弧上的权值；否则为无穷大。</li></ul><p>显然，长度最短的一条最短路径必为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_0, v_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其满足以下条件：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>D</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>=</mo><mi>M</mi><mi>i</mi><mi>n</mi><mo stretchy="false">{</mo><mi>D</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">∣</mi><msub><mi>v</mi><mi>i</mi></msub><mo>∈</mo><mi>V</mi><mo>−</mo><mi>S</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D[k]=Min\{D[i] | v_i \in V-S \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">in</span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">}</span></span></span></span></span></p><p>当求得从顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最短路径后，将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>加入到第一组顶点集S中。每当加入一个新的顶点到顶点集S，对第二组剩余的各个顶点而言，多了一个“中转”顶点，从而多了一条“中转”路径，所以要对第二组剩余的各个顶点的最短路径长度进行更新。例如，原来<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最短路径长度为D[i]，加进<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之后，以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>作为中间顶点的“中转”路径长度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mi>G</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>r</mi><mi>c</mi><mi>s</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">D[k]+G.arcs[k][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">rcs</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mi>G</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>r</mi><mi>c</mi><mi>s</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>D</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">D[k]+G.arcs[k][i]&lt;D[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">rcs</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，则用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mi>G</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>r</mi><mi>c</mi><mi>s</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">D[k]+G.arcs[k][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">rcs</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>取代D[i]。更新后，再选择数组D中值最小的顶点加入到第一组顶点集S中，如此进行下去，直到图中所有顶点都加入到第一组顶点集S中为止。</p><p>迪杰斯特拉算法的步骤为：</p><ul><li>初始化：<ul><li>将源点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>加到S中，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">[</mo><msub><mi>v</mi><mn>0</mn></msub><mo stretchy="false">]</mo><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">S[v_0]=true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span>；</li><li>将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到各个终点的最短路径长度初始化为权值，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>G</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>r</mi><mi>c</mi><mi>s</mi><mo stretchy="false">[</mo><msub><mi>v</mi><mn>0</mn></msub><mo stretchy="false">]</mo><mo stretchy="false">[</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo>∈</mo><mi>V</mi><mo>−</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D[i]=G.arcs[v_0][v_i], (v_i \in V-S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">rcs</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>；</li><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之间有弧，则将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的前驱置为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>a</mi><mi>t</mi><mi>h</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">Path[i]=v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，否则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>a</mi><mi>t</mi><mi>h</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">Path[i]=-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</li></ul></li><li>循环n-1次，执行以下操作：<ul><li>选择下一条最短路径的终点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，使得：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>=</mo><mi>M</mi><mi>i</mi><mi>n</mi><mo stretchy="false">{</mo><mi>D</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">∣</mi><msub><mi>v</mi><mi>i</mi></msub><mo>∈</mo><mi>V</mi><mo>−</mo><mi>S</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D[k]=Min\{D[i] | v_i \in V-S \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">in</span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">}</span></span></span></span></li><li>将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>加到S中，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">[</mo><msub><mi>v</mi><mi>k</mi></msub><mo stretchy="false">]</mo><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">S[v_k]=true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span>；</li><li>更新从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>出发到集合V-S中任一顶点的最短路径的长度，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mi>G</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>r</mi><mi>c</mi><mi>s</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>D</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">D[k]+G.arcs[k][i]&lt;D[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">rcs</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，则更新<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>D</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mi>G</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>r</mi><mi>c</mi><mi>s</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">D[i]=D[k]+G.arcs[k][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">rcs</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，同时更改<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的前驱为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，即Path[i]=k。</li></ul></li></ul><h3 id="2-3、算法描述">2.3、算法描述</h3><p>迪杰斯特拉算法的C语言描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 用迪杰斯特拉算法求有向网G的顶点v0到其余各顶点的最短路径</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ShortestPath</span><span class="hljs-params">(AMGraph G, <span class="hljs-type">int</span> v0)</span> &#123;<br>    <span class="hljs-comment">// n为G中顶点的个数</span><br>    n=G.vexnum;<br>    <span class="hljs-comment">// 依次初始化所有顶点</span><br>    <span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>;v&lt;n;++v) &#123;<br>        <span class="hljs-comment">// S初始为空集</span><br>        S[v]=<span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 将v0到其余个顶点的最短路径长度初始化为弧上的权值</span><br>        D[v]=G.arcs[v0][v]<br>        <span class="hljs-comment">// 如果v0和v之间有弧，则将v的前驱置为v0，否则置为-1</span><br>        <span class="hljs-keyword">if</span>(D[v]&lt;MaxInt) Path[v]=v0;<br>        <span class="hljs-keyword">else</span> Path[v]=<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将v0加入S</span><br>    S[v0]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 源点到源点的距离为0</span><br>    D[v0]=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 循环n-1次，每次求得v0到某个顶点v的最短路径</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<br>        min=MaxInt;<br>        <span class="hljs-comment">// 选择一条当前的最短路径，其终点为v</span><br>        <span class="hljs-keyword">for</span>(w=<span class="hljs-number">0</span>;w&lt;n;++w) &#123;<br>            <span class="hljs-keyword">if</span>(!S[w]&amp;&amp;D[w]&lt;min) &#123;<br>                v=w;<br>                min=D[w];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将顶点v并入S</span><br>        S[v]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 更新从v0到V-S中所有顶点的最短路径长度</span><br>        <span class="hljs-keyword">for</span>(w=<span class="hljs-number">0</span>;w&lt;n;++w) &#123;<br>            <span class="hljs-keyword">if</span>(!S[w]&amp;&amp;(D[v]+G.arcs[v][w]&lt;D[w])) &#123;<br>                <span class="hljs-comment">// 更新D[w]</span><br>                D[w]=D[v]+G.arcs[v][w];<br>                <span class="hljs-comment">// 更新w的前驱为v</span><br>                Path[w]=v;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4、示例说明">2.4、示例说明</h3><p>利用迪杰斯特拉算法，对下图所示的有向网G求解最短路径，给出算法中各参量的初始化结果和求解过程中的变化。</p><p><img src="/img/image-20240316121011271.png" alt="image-20240316121011271"></p><p>对图中个顶点依次初始化，迪杰斯特拉算法初始化结果，如下表：</p><p><img src="/img/image-20240317113203027.png" alt="image-20240317113203027"></p><p>迪杰斯特拉算法求解过程中各参量的变化，如下表</p><p><img src="/img/image-20240317112947591.png" alt="image-20240317112947591"></p><p>如何从上表读取源点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到终点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最短路径？以顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">v_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Path</span>[<span class="hljs-number">5</span>]=<span class="hljs-number">3</span><br><span class="hljs-attribute">Path</span>[<span class="hljs-number">3</span>]=<span class="hljs-number">4</span><br><span class="hljs-attribute">Path</span>[<span class="hljs-number">4</span>]=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>反过来排列，得到路径0、4、3、5，这就是源点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到终点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最短路径。</p><h3 id="2-5、算法分析">2.5、算法分析</h3><p>迪杰斯特拉算法的主循环共进行n−1次，每次执行的时间是O(n)，所以算法的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><p>如果用带权的邻接表作为有向图的存储结构，则虽然更新数组D的时间可以减少，但由于在D中找出最短路径的时间不变，所以时间复杂度仍为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><p>在实际应用中，人们可能只希望找到从某个源点出发，到某一个特定终点的最短路径。但是，这个问题和单求源点到其他所有顶点的最短路径一样复杂，也需要利用迪杰斯特拉算法来解决，其时间复杂度仍为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><h2 id="三、弗洛伊德算法">三、弗洛伊德算法</h2><p>求解每一对顶点之间的最短路径有两种方法：其一是分别以图中的每个顶点为源点共调用n次迪杰斯特拉算法；其二是采用弗洛伊德（Floyd）算法。下面，我们终点讨论弗洛伊德算法。</p><h3 id="3-1、算法步骤">3.1、算法步骤</h3><p>弗洛伊德算法仍然使用带权的邻接矩阵arcs来表示有向网G。求从顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的最短路径的算法实现要引入以下辅助的数据结构：</p><ul><li>二维数组Path[i][j]：记录最短路径上顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的前一顶点的序号。</li><li>二维数组D[i][j]：记录顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>之间的最短路径长度。</li></ul><p>弗洛伊德算法的步骤为：</p><ul><li>初始化<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的最短路径长度，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>G</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>r</mi><mi>c</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">D[i][j]=G.arcs[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">rcs</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>；</li><li>进行n次比较和更新：<ul><li>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>间加入顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，比较<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_i, v_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_i, v_0, v_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的路径长度，取其中较短者作为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的中间顶点序号不大于0的最短路径。</li><li>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>间加入顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_i,...,v_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_1,...,v_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_i,...,v_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的中间顶点序号不大于0的最短路径，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_1,...,v_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的中间顶点序号不大于0的最短路径，这两条路径已在上一步中求出。比较<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_i,...,v_1,...,v_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>与上一步求出的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的中间顶点序号不大于0的最短路径，取其中较短者作为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的中间顶点序号不大于1的最短路径。</li><li>依次类推，在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>间加入顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>v</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_i,...,v_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>k</mi></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_k,...,v_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>分别是从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的中间顶点序号不大于k-1的最短路径，则将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>v</mi><mi>k</mi></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_i,...,v_k,...,v_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>和已经得到的从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>且中间顶点序号不大于k-1的最短路径相比较，其长度较短者便是从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的中间顶点序号不大于k的最短路径。</li><li>这样，经过n次比较后，最后求得的必是从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的最短路径。按此方法，可以同时求得各对顶点间的最短路径。</li></ul></li></ul><p>根据上述求解过程，图中所有顶点对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_i,v_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>间的最短路径长度对应一个n阶方阵D。在上述n+1步中，D的值不断变化，可对应到一个n阶方阵序列。这个n阶方阵序列可定义为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>D</mi><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo separator="true">,</mo><msup><mi>D</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msup><mo separator="true">,</mo><msup><mi>D</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msup><mi>D</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></msup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msup><mi>D</mi><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">D^{(-1)},D^{(0)},D^{(1)},...,D^{(k)},...,D^{(n-1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1324em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">0</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中，</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>D</mi><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>G</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>r</mi><mi>c</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">D^{(-1)}[i][j]=G.arcs[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">rcs</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>D</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">{</mo><msup><mi>D</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><msup><mi>D</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><msup><mi>D</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo><mspace width="1em"/><mn>0</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">D^{(k)}[i][j]=min\{D^{(k-1)}[i][j],D^{(k-1)}[i][k]+D^{(k-1)}[k][j]\} \quad 0 \le k \le n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]}</span><span class="mspace" style="margin-right:1em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><p>显然，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>D</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">D^{(1)}[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>是从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的中间顶点序号不大于1的最短路径的长度；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>D</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">D^{(k)}[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>是从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的中间顶点序号不大于k的最短路径的长度；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>D</mi><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">D^{(n-1)}[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>是从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的最短路径的长度。</p><h3 id="3-2、算法描述">3.2、算法描述</h3><p>弗洛伊德算法的C语言描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 用弗洛伊德算法求有向网G中各对顶点i和i之间的最短路径</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ShortestPath_Floyd</span><span class="hljs-params">(AMGraph G)</span> &#123;<br>    <span class="hljs-comment">// 初始化各对顶点之间的路径以及距离</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i) &#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;G.verxnum;++j) &#123;<br>            D[i][j]=G.arcs[i][j];<br>            <span class="hljs-comment">// 如果i和j之间有弧，则将j的前驱置为i，否则置为-1</span><br>            <span class="hljs-keyword">if</span>(D[i][j]&lt;MaxInt) Path[i][j]=i;<br>            <span class="hljs-keyword">else</span> Path[i][j]=<span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 进行n次比较和更新</span><br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;G.vexnum;++k) &#123;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i) &#123;<br>            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;i&lt;G.vexnum;++j) &#123;<br>                <span class="hljs-comment">// 从i经k到j的一条路径更短</span><br>                <span class="hljs-keyword">if</span>(D[i][k]+D[k][j]&lt;D[i][j]) &#123;<br>                    <span class="hljs-comment">// 更新D[i][j]</span><br>                    D[i][j]=D[i][k]+D[k][j];<br>                    <span class="hljs-comment">// 更新j的前驱为k</span><br>                    Path[i][j]=Path[k][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3、示例说明">3.3、示例说明</h3><p>利用弗洛伊德算法，对下图所示的有向网G求解最短路径，，给出每一对顶点之间的最短路径及其路径长度在求解过程中的变化。</p><p><img src="/img/image-20240317123729184.png" alt="image-20240317123729184"></p><p>每一对顶点i和j之间的最短路径长度D[i][j]和最短路径Path[i][j]在求解过程中的变化，如下表：</p><p><img src="/img/image-20240317152342100.png" alt="image-20240317152342100"></p><h3 id="3-4、算法分析">3.4、算法分析</h3><p>弗洛伊德算法的主循环共进行n次，每次执行的时间是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，所以算法的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。调用n次迪杰斯特拉算法的间复杂度也是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，但弗洛伊德算法在形式上更加简单。</p><h2 id="四、小结">四、小结</h2><p>最常见的最短路径问题有两种：一种是求从某个源点到其余各顶点的最短路径，另一种是求每一对顶点之间的最短路径。迪杰斯特拉算法，求从某个源点到其余各顶点的最短路径，求解过程是按路径长度递增的次序产生最短路径，时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>。弗洛伊德算法，求每一对顶点之间的最短路径，时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，从实现形式上来说，这种算法比以图中的每个顶点为源点调用n次迪杰斯特拉算法更为简洁。</p><p><img src="/img/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.jpeg" alt="img"></p><h2 id="五、参考">五、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：最小生成树</title>
    <link href="/2024/02/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <url>/2024/02/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>最小生成树是图论中的一个重要概念，它在许多实际应用中都扮演着重要角色，比如通信网络设计、电路板布线、城市规划等。在实际应用中，最小生成树的构建可以帮助优化网络设计、资源分配等问题。通过选择最小生成树，可以在保持网络连通性的前提下，使得整体成本最小化。因此，了解最小生成树的概念和算法对于解决实际问题具有重要意义。</p><h2 id="一、基本概念">一、基本概念</h2><p>在一个连通网的所有生成树中，各边的代价之和最小的那棵生成树称为该连通网的最小代价生成树（Minimum Cost Spanning Tree），简称为最小生成树。</p><blockquote><p>假设要在n个城市之间建立通信联络网，则连通n个城市只需要n−1条线路。这时，自然会考虑这样一个问题，如何在最节省经费的前提下建立这个通信网。</p><p>在每两个城市之间都可设置一条线路，相应地都要付出一定的经济代价。n个城市之间，最多可能设置n(n−1)/2条线路，那么，如何在这些可能的线路中选择n−1条，以使总的耗费最少呢？</p></blockquote><p>可以用连通网来表示n个城市，以及n个城市间可能设置的通信线路，其中网的顶点表示城市，边表示两城市之间的线路，赋予边的权值表示相应的代价。对于n个顶点的连通网可以建立许多不同的生成树，每一棵生成树都可以是一个通信网。最合理的通信网应该是代价之和最小的生成树。</p><p>构造最小生成树有多种算法，其中多数算法利用了最小生成树的一种简称为MST的性质：假设G=(V, E)是一个连通网，U是顶点集V的一个非空子集。若(u, v)是一条具有最小权值（代价）的边，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>∈</mo><mi>U</mi><mo separator="true">,</mo><mi>v</mi><mo>∈</mo><mi>V</mi><mo>−</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">u \in U, v \in V-U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>，则必存在一棵包含边(u, v)的最小生成树。</p><p>上述性质可用反证法来证明。假设连通网G的任何一棵最小生成树都不包含(u, v)。设T是连通网上的一棵最小生成树，当将边(u, v)加入到T中时，由生成树的定义，T中必存在一条包含(u, v)的回路。另一方面，由于T是生成树，则在T上必存在另一条边(u’, v’)，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>u</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><mi>U</mi><mo separator="true">,</mo><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><mi>V</mi><mo>−</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">u&#x27; \in U, v&#x27; \in V-U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.791em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>，且u和u’之间、v和v’之间均有路径相同。删去边(u’, v’)，便可消除上述回路，同时得到另一棵生成树T’。因为(u, v)的权值不高于(u’, v’)，则T’的权值亦不高于T，T’是包含(u, v)的一棵最小生成树。由此和假设矛盾。</p><h2 id="二、普里姆算法">二、普里姆算法</h2><h3 id="2-1、构造过程">2.1、构造过程</h3><p>假设G=(V, E)是一个具有n个顶点的连通网，T=(U, TE)是G的最小生成树。</p><ul><li>初始情况下，U和TE均为空，即U={}，TE={}。</li><li>从V中任取一个顶点（假定为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>），将它并入U中，此时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>v</mi><mn>1</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">U=\{v_1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>。</li><li>在那些一端已在U中，另一端仍在U外的所有边中，找一条权值最小的边(u, v)，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>∈</mo><mi>U</mi><mo separator="true">,</mo><mi>v</mi><mo>∈</mo><mi>V</mi><mo>−</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">u \in U, v \in V-U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>，将该边并入TE，同时v并入U。</li><li>重复上一步，直至U=V为止。此时，TE中必有n-1条边，则T是G的最小生成树。</li></ul><p>如下图，是连通网G按普里姆算法构造最小生成树的过程。</p><p><img src="/img/image-20240303171954016.png" alt="image-20240303171954016"></p><p>一开始<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>v</mi><mn>1</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">U=\{v_1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，然后在所有从U到V-U的边中，找到一条权值最小的边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_1,v_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>并入TE，并将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">v_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>并入U，此时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>3</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">U=\{v_1, v_3\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>；接着继续在所有从U到V-U的边中，找到一条权值最小的边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>6</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_3,v_6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>并入TE，并将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">v_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>并入U，此时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>6</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">U=\{v_1, v_3, v_6\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>；依此类推，直到U=V。</p><p>可以看出，普里姆算法逐步增加U中的顶点，因此可称其为“加点法”。每次选择最小边时，可能存在多条同样权值的边可选，此时任选其一即可。</p><h3 id="2-2、算法实现">2.2、算法实现</h3><p>假设一个连通网G以邻接矩阵形式存储，从顶点u出发构造G的最小生成树T，要求输出T的各条边。</p><p>为实现这个算法需附设一个辅助数组closedge，以记录从U到V−U具有最小权值的边。对每个顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub><mo>∈</mo><mi>V</mi><mo>−</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">v_i \in V-U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>，在辅助数组中存在一个相应分量closedge[i-1]，它包括两个域：lowcost和adjvex，其中lowcost存储最小边上的权值，adjvex存储最小边在U中的那个顶点。也即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>e</mi><mi>d</mi><mi>g</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>l</mi><mi>o</mi><mi>w</mi><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo>=</mo><mi>M</mi><mi>i</mi><mi>n</mi><mo stretchy="false">{</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi>u</mi><mo>∈</mo><mi>U</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">closedge[i-1].lowcost=Min\{cost(u, v_i)|u \in U\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">ose</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">cos</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">in</span><span class="mopen">{</span><span class="mord mathnormal">cos</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">∣</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">}</span></span></span></span>，其中cost(u, v)表示赋于边(u, v)的权。在C语言中，辅助数组closedge的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 辅助数组的定义，用来记录从顶点集U到V-U的权值最小的边</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    VerTexType adjvex;<br>    ArcType lowcost;<br>&#125;closedge[MVNum];<br></code></pre></td></tr></table></figure><p>普里姆算法的步骤如下：</p><ul><li>首先将初始顶点u并入U中，对其余的每一个顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>，将closedge[j]初始化为到u的边信息。</li><li>循环n-1次，选择其余的n-1个顶点，生成n-1条边：<ul><li>从closedge中选出权值最小的边closedge[k]，输出此边；</li><li>将k并入U中；</li><li>更新closedge信息 ，由于新顶点的加入，从U到V-U会有新边，如果新边的权值比closedge[j].lowcost小，则将closedge[j]更新为新边。</li></ul></li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MiniSpanTree_Prim</span><span class="hljs-params">(AMGraph G, VerTexType u)</span> &#123;<br>    <span class="hljs-comment">// k为顶点u的下标</span><br>    k=LocateVex(G,u)<br>    <span class="hljs-comment">// 初始U=&#123;u&#125;</span><br>    closedge[k].lowcost=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 对V-U中的每一个顶点vj，初始化closedge[j]</span><br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;G.vernum;++j)<br>        <span class="hljs-comment">// closedge[j]=&#123;adjvex, lowcost&#125; </span><br>        <span class="hljs-keyword">if</span>(j!=k) closedge[j]=&#123;u, G.arcs[k][j]&#125;<br><br>    <span class="hljs-comment">// 选择其余n-1个顶点，生成n-1条边(n=G.vexnum)</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;G.vexnum;++i) &#123;<br>        <span class="hljs-comment">// 求出U的下一个顶点: 第k个顶点，closedge[k]中存有当前权值最小的边</span><br>        k=Min(closedge);<br>        <span class="hljs-comment">// u0为最小边的一个顶点，u0属于U</span><br>        u0=closedge[k].adjvex;<br>        <span class="hljs-comment">// v0为最小边的另一个顶点，v0属于V−U</span><br>        v0=G.vexs[k];<br>        <span class="hljs-comment">// 输出当前的最小边(u0, v0) </span><br>        <span class="hljs-built_in">cout</span> &lt;&lt; u0 &lt;&lt; v0;<br>        <span class="hljs-comment">// 第k个顶点并入U</span><br>        closedge[k].lowcost=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 新顶点并入U后更新closedge</span><br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;G.vernum;++j)<br>            <span class="hljs-keyword">if</span>(G.arcs[k][j]&lt;closedge[j].lowcost)<br>                closedge[j]=&#123;G.vexs[k],G.arcs[k][j]&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设网中有n个顶点，则第一个进行初始化的循环语句的频度为n，第二个循环语句的频度为n−1。其中，第二个循环语句中有两个内循环：其一是在closedge[v].lowcost中求最小值，其频度为n−1；其二是重新选出具有最小权值的边，其频度为n。由此，普里姆算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，与网中的边数无关，因此适用于求稠密网的最小生成树。</p><p>下表是利用普里姆算法对前面的连通网G从顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>开始构造最小生成树各量的变化。</p><p><img src="/img/b86afbc41058dd13a2f84be07755be99.jpg" alt="img"></p><p>初始状态时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>v</mi><mn>1</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">U=\{v_1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，从U到V−U具有最小权值的边，就是从依附于顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的各条边中，找到一条权值最小的边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_1,v_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>为生成中的第一条边，同时将顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">v_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>并入集合U中。然后修改辅助数组中的值，首先将closedge[2].lowcost改为0，表明顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">v_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>已并入U。又由于边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_3,v_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的权值小于closedge[1].lowcost，则需修改closedge[1]为边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_3,v_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>及其权值。同理修改closedge[4]和closedge[5]。依次类推，直到U=V。</p><h2 id="三、克鲁斯卡尔算法">三、克鲁斯卡尔算法</h2><h3 id="3-1、构造过程">3.1、构造过程</h3><p>假设G=(V, E)是一个具有n个顶点的连通网，T=(U, TE)是G的最小生成树。</p><ul><li>初始状态下，U=V，TG={}，即T的初始状态是只含有n个顶点而无边的非连通图T=(V, {})。</li><li>将图G中的边按权值从小到大排序。</li><li>依次选取E中的边，若选取的边使生成树T不形成回路，则把它并入TE中，否则将其舍弃。</li><li>重复上一步，直到TE中包含n-1条边为止，此时的T即为最小生成树。</li></ul><p>如下图，是连通网G按克鲁斯卡尔算法构造最小生成树的过程。</p><p><img src="/img/image-20240303162307418.png" alt="image-20240303162307418"></p><p>权值分别为1、2、3、4的4条边由于满足上述条件，则先后被加入到T中；权值为5的两条边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>4</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_1,v_4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>4</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_3,v_4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>被舍去，因为它们依附的两顶点在同一连通分量上，它们若加入T 中，则会使T产生回路，而另一条权值为5的边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_2,v_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>连接两个连通分量，则可加入T 。由此，构造成一棵最小生成树。</p><p>可以看出，克鲁斯卡尔算法逐步增加生成树的边，与普里姆算法相比，可称为“加边法”。与普里姆算法一样，每次选择最小边时，可能有多条同样权值的边可选，可以任选其一。</p><h3 id="3-2、算法实现">3.2、算法实现</h3><p>克鲁斯卡尔算法的实现需要引入以下辅助的数据结构：</p><ul><li>结构体数组Edge：存储边的信息，包括边的两个顶点和权值。</li><li>数组Vexset，标识各个顶点所属的连通分量。对每个顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v_i \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>，在辅助数组中存在一个相应元素Vexset[i]表示该顶点所在的连通分量。初始时Vexset[i]=i，表示自成一个连通分量。</li></ul><p>在C语言中，上述辅助数据结构的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 结构体数组Edge</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">// 边的始点</span><br>    VerTexType Head;<br>    <span class="hljs-comment">// 边的终点</span><br>    VerTexType Tail;<br>    <span class="hljs-comment">// 边上的权值</span><br>    ArcType lowcost;<br>&#125;Edge[arcnum];<br><br><span class="hljs-comment">// 数组Vexset</span><br><span class="hljs-type">int</span> Vexset[MVNum];<br></code></pre></td></tr></table></figure><p>克鲁斯卡尔算法的步骤为：</p><ul><li>将数组Edge中的元素按权值从小到大排序。</li><li>依次查看数组Edge中的边，循环执行以下操作：<ul><li>依次从排好序的数组Edge中选出一条边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_1,v_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>；</li><li>在数组Vexset中分别查找<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">v_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>所在的连通分量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><msub><mi>s</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">vs_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">vs_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，并进行判断：<ul><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><msub><mi>s</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">vs_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">vs_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>不等，表明所选的两个顶点分属不同的连通分量，输出此边，并合并<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><msub><mi>s</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">vs_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">vs_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>两个连通分量；</li><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><msub><mi>s</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">vs_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">vs_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>相等，表明所选的两个顶点属于同一个连通分量，舍去此边而选择下一条权值最小的边。</li></ul></li></ul></li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 无向网G以邻接矩阵形式存储，构造G的最小生成树T，输出T的各条边</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MiniSpanTree_Kruskal</span><span class="hljs-params">(AMGraph G)</span> &#123;<br>    <span class="hljs-comment">// 将数组Edge中的元素按权值从小到大排序</span><br>    Sort(Edge);<br>    <span class="hljs-comment">// 初始化数组Vexset</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i) Vexset[i]=i;<br><br>    <span class="hljs-comment">// 依次查看数组Edge中的边</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.arcnum;++i) &#123;<br>        <span class="hljs-comment">// v1为边的始点Head的下标</span><br>        v1=LocateVex(G, Edge[i].Head);<br>        <span class="hljs-comment">// v2为边的终点Tail的下标</span><br>        v2=LocateVex(G, Edge[i].Tail);<br>        <span class="hljs-comment">// 获取边Edge[i]的始点所在的连通分量vs1</span><br>        vs1=Vexset[v1];<br>        <span class="hljs-comment">// 获取边Edge[i]的终点所在的连通分量vs2</span><br>        vs2=Vexset[v2];<br>        <span class="hljs-keyword">if</span>(vs1!=vs2) &#123;<br>            <span class="hljs-comment">// 输出此边</span><br>            <span class="hljs-built_in">cout</span> &lt;&lt; Edge[i].Head &lt;&lt; Edge[i].Tail;<br>            <span class="hljs-comment">// 合并vs1和vs2两个分量，即两个集合统一编号</span><br>            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;G.vexnum;++j)<br>                <span class="hljs-comment">// 集合编号为vs2的都改为vs1</span><br>                <span class="hljs-keyword">if</span>(Vexset[j]==vs2) Vexset[j]=vs1;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>若以“堆”来存放网中的边进行堆排序，对于包含e条边的网，上述算法排序时间是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>e</mi><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(e\log_{2}{e})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">e</span></span><span class="mclose">)</span></span></span></span>。在for循环中最耗时的操作是合并两个不同的连通分量，只要采取合适的数据结构，可以证明其执行时间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{2}{e})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">e</span></span><span class="mclose">)</span></span></span></span>，因此整个for循环的执行时间是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>e</mi><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(e\log_{2}{e})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">e</span></span><span class="mclose">)</span></span></span></span>。由此，克鲁斯卡尔算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>e</mi><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(e\log_{2}{e})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">e</span></span><span class="mclose">)</span></span></span></span>，与网中的边数有关，与普里姆算法相比，克鲁斯卡尔算法更适合于求稀疏网的最小生成树。</p><h2 id="四、小结">四、小结</h2><p>构造最小生成树有普里姆算法和克鲁斯卡尔算法，两者都能达到同一目的。前者算法思想的核心是归并点，时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，适用于稠密网；后者是归并边，时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>e</mi><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(e\log_{2}{e} )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">e</span></span><span class="mclose">)</span></span></span></span>，适用于稀疏网。</p><p><img src="/img/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.jpeg" alt="img"></p><h2 id="五、参考">五、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：图的遍历</title>
    <link href="/2024/02/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2024/02/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>和树的遍历类似，图的遍历也是从图中某一顶点出发，按照某种方法对图中所有顶点访问且仅访问一次。图的遍历算法是求解图的连通性问题、拓扑排序和关键路径等算法的基础。</p><h2 id="一、图的遍历问题">一、图的遍历问题</h2><p>图的遍历要比树的遍历复杂得多。因为图中任一顶点都可能和其余的顶点相邻接。所以在访问了某个顶点之后，可能沿着某条路径搜索之后，又回到该顶点上。例如，下图所示的无向图，由于图中存在回路，因此在访问了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub><mtext>、</mtext><msub><mi>v</mi><mn>2</mn></msub><mtext>、</mtext><msub><mi>v</mi><mn>3</mn></msub><mtext>、</mtext><msub><mi>v</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">v_1、v_2、v_3、v_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之后，沿着边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_4,v_1&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>又可访问到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p><img src="/img/image-20240211111006679.png" alt="image-20240211111006679"></p><p>为了避免同一顶点被访问多次，在遍历图的过程中，必须记下每个已访问过的顶点。为此，可以设一个辅助数组visited[n]，其初始值置为“false”或者0，一旦访问了顶点vi，便置visited[i]为“true”或者1。</p><p>图的遍历方法有很多，但常用的有两种，根据搜索路径的方向分为：深度优先搜索和广度优先搜索。它们对无向图和有向图都适用。</p><h2 id="二、深度优先搜索">二、深度优先搜索</h2><h3 id="2-1、遍历过程">2.1、遍历过程</h3><p>深度优先搜索（Depth First Search，DFS）类似于树的先序遍历，是树的先序遍历的推广。对于一个连通图，深度优先搜索遍历的过程如下：</p><ul><li>从图中某个顶点v出发，访问v。</li><li>找出刚访问过的顶点的第一个未被访问的邻接点，访问该顶点。以该顶点为新的刚访问过的顶点，重复该步骤，直至刚访问过的顶点没有未被访问的邻接点为止。</li><li>返回前一个访问过的且仍有未被访问的邻接点的顶点，找出该顶点的下一个未被访问的邻接点，访问该顶点。</li><li>重复第二步和第三步，直至图中所有顶点都被访问过，搜索结束。</li></ul><p>例如，下图（b）是下图（a）所示的无向图的深度优先搜索遍历过程。在图（b）中，带箭头的实线表示遍历时的访问路径，带箭头的虚线表示遍历时的回溯路径。</p><p><img src="/img/image-20240211161145131.png" alt="image-20240211161145131"></p><p>上图（a）所示的无向图的具体过程如下：</p><ul><li>从顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>出发，访问<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li><li>在访问了顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之后，选择它的第一个未被访问的邻接点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">v_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，访问<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">v_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">v_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为新顶点，重复该步骤，先后访问<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>4</mn></msub><mtext>、</mtext><msub><mi>v</mi><mn>8</mn></msub><mtext>、</mtext><msub><mi>v</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">v_4、v_8、v_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。在访问了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">v_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之后，由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">v_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的邻接点都已被访问，此步骤结束。</li><li>搜索从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">v_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>回到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>8</mn></msub></mrow><annotation encoding="application/x-tex">v_8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，由于同样的理由，搜索继续回到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>4</mn></msub><mtext>、</mtext><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">v_4、v_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>直至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，此时由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的另一个邻接点未被访问，则搜索又从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">v1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord">1</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">v3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord">3</span></span></span></span>，再继续下去。由此，得到的顶点访问序列为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub><mo>⟶</mo><msub><mi>v</mi><mn>2</mn></msub><mo>⟶</mo><msub><mi>v</mi><mn>4</mn></msub><mo>⟶</mo><msub><mi>v</mi><mn>8</mn></msub><mo>⟶</mo><msub><mi>v</mi><mn>5</mn></msub><mo>⟶</mo><msub><mi>v</mi><mn>3</mn></msub><mo>⟶</mo><msub><mi>v</mi><mn>6</mn></msub><mo>⟶</mo><msub><mi>v</mi><mn>7</mn></msub></mrow><annotation encoding="application/x-tex">v_1 \longrightarrow v_2 \longrightarrow v_4 \longrightarrow v_8 \longrightarrow v_5 \longrightarrow v_3 \longrightarrow v_6 \longrightarrow v_7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.661em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.661em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.661em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.661em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.661em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.661em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.661em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ul><p>深度优先搜索遍历最终会得到一棵以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为根的树，称之为深度优先生成树。其形式如上图（c）所示。</p><h3 id="2-2、算法实现">2.2、算法实现</h3><p>深度优先搜索遍历连通图是一个递归的过程。为了在遍历过程中便于区分顶点是否已被访问，需附设访问标志数组visited[n]，其初值为“false”，一旦某个顶点被访问，则其相应的分量置为“true”。</p><p>深度优先搜索遍历连通图的算法步骤为：</p><ul><li>从图中某个顶点v出发，访问v，并置visited[v]的值为true。</li><li>依次检查v的所有邻接点w，如果visited[w]的值为false，则再从w出发进行递归遍历，直到图中所有顶点都被访问过。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 访问标志数组，其初值为false</span><br><span class="hljs-type">bool</span> visited[MVNum]<br><br><span class="hljs-comment">// 从第v个顶点出发深度优先遍历图G</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(Graph G, <span class="hljs-type">int</span> v)</span> &#123;<br>    <span class="hljs-comment">// 访问第v个顶点，并置访问标志数组相应分量值为true</span><br>    count&lt;&lt;v;<br>    visited[v]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 依次检查v的所有邻接点w</span><br>    <span class="hljs-comment">// FirstAdjVex(G, v)表示v的第一个邻接点</span><br>    <span class="hljs-comment">// NextAdjVex(G,v,w)表示v相对于w的下一个邻接点</span><br>    <span class="hljs-comment">// w&gt;=0表示存在邻接点</span><br>    <span class="hljs-keyword">for</span>(w=FirstAdjVex(G,v);w&gt;=<span class="hljs-number">0</span>;w=NextAdjVex(G,v,w))<br>        <span class="hljs-comment">// 对v的尚未访问的邻接点w递归调用DFS()</span><br>        <span class="hljs-keyword">if</span>(!visited[w]) DFS(G,w);<br>&#125;<br></code></pre></td></tr></table></figure><p>若是非连通图，上述遍历过程执行之后，图中一定还有顶点未被访问。因此，需要从图中另选一个未被访问的顶点作为起始点，重复上述深度优先搜索过程，直到图中所有顶点均被访问过为止。这样，要实现对非连通图的遍历，就需要循环调用上述算法。深度优先搜索遍历非连通图的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 对非连通图G做深度优先遍历</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DFSTraverse</span><span class="hljs-params">(Graph G)</span> &#123;<br>    <span class="hljs-comment">// 初始化标志数组</span><br>    <span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>;v&lt;G.vexnum;++v)<br>        visited[v]=<span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 对尚未访问的顶点调用DFS</span><br>    <span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>;v&lt;G.vexnum;++v)<br>        <span class="hljs-keyword">if</span>(!visited[v]) DFS(G,v);<br>&#125;<br></code></pre></td></tr></table></figure><p>该算法每调用一次DFS算法将遍历一个连通分量，由多少次调用，就说明图中有多少个连通分量。</p><h3 id="2-3、算法分析">2.3、算法分析</h3><p>在遍历图时，对图中每个顶点至多调用一次DFS函数，因为一旦某个顶点被标志成已被访问，就不再从它出发进行搜索。因此，遍历图的过程实质上是对每个顶点查找其邻接点的过程，其耗费的时间则取决于所采用的存储结构。</p><p>当用邻接矩阵表示图时，查找每个顶点的邻接点的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中n为图中顶点数。而当以邻接表做图的存储结构时，查找邻接点的时间复杂度为O(e)，其中e为图中边数。由此，当以邻接表做存储结构时，深度优先搜索遍历图的时间复杂度为O(n+e)。</p><h2 id="三、广度优先搜索">三、广度优先搜索</h2><h3 id="3-1、遍历过程">3.1、遍历过程</h3><p>广度优先搜索（Breadth First Search，BFS）类似于树的按层次遍历的过程。广度优先搜索遍历的过程如下：</p><ul><li>从图中某个顶点v出发，访问v。</li><li>依次访问v的各个未曾访问过的邻接点。</li><li>分别从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问。重复该步骤，直至图中所有已被访问的顶点的邻接点都被访问到。</li></ul><p>例如，下图（b）是下图（a）所示的无向图的广度优先搜索遍历过程。</p><p><img src="/img/image-20240211163124880.png" alt="image-20240211163124880"></p><p>具体过程如下：</p><ul><li>首先，从顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>出发，访问<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li><li>然后，依次访问<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的各个未曾访问过的邻接点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">v_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">v_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li><li>接着，依次访问<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">v_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的邻接点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">v_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">v_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，以及<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">v_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的邻接点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">v_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>7</mn></msub></mrow><annotation encoding="application/x-tex">v_7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li><li>最后，访问<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">v_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的邻接点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>8</mn></msub></mrow><annotation encoding="application/x-tex">v_8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。由于这些顶点的邻接点均已被访问，并且图中所有顶点都被访问了，由此完成了图的遍历。得到的顶点访问序列为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub><mo>⟶</mo><msub><mi>v</mi><mn>2</mn></msub><mo>⟶</mo><msub><mi>v</mi><mn>3</mn></msub><mo>⟶</mo><msub><mi>v</mi><mn>4</mn></msub><mo>⟶</mo><msub><mi>v</mi><mn>5</mn></msub><mo>⟶</mo><msub><mi>v</mi><mn>6</mn></msub><mo>⟶</mo><msub><mi>v</mi><mn>7</mn></msub><mo>⟶</mo><msub><mi>v</mi><mn>8</mn></msub></mrow><annotation encoding="application/x-tex">v_1 \longrightarrow v_2 \longrightarrow v_3 \longrightarrow v_4 \longrightarrow v_5 \longrightarrow v_6 \longrightarrow v_7 \longrightarrow v_8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.661em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.661em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.661em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.661em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.661em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.661em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.661em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ul><p>广度优先搜索遍历最终也会构成一棵以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为根的树，称之为广度优先生成树。其形式如上图（c）所示。</p><h3 id="3-2、算法实现">3.2、算法实现</h3><p>可以看出，广度优先搜索遍历的特点是：尽可能先对横向进行搜索。设x和y是两个相继被访问过的顶点，若当前是以x为出发点进行搜索，则在访问x的所有未曾被访问过的邻接点之后，紧接着是以y为出发点进行横向搜索，并对搜索到的y的邻接点中尚未被访问的顶点进行访问。也就是说，先访问的顶点其邻接点亦先被访问。为此，算法实现时需引进队列保存已被访问过的顶点。</p><p>和深度优先搜索类似，广度优先搜索在遍历的过程中也需要一个访问标志数组。广度优先搜索遍历连通图的算法步骤为：</p><ul><li>从图中某个顶点v出发，访问v，并置visited[v]的值为true，然后将v进队。</li><li>只要队列非空，则重复下述操作：<ul><li>队头元素u出队；</li><li>依次检查u的所有邻接点w，如果visited[w]的值为false，则访问w，并置visited[w]的值为true，然后使w入队。</li></ul></li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 按广度优先遍历连通图G</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(Graph G, <span class="hljs-type">int</span> v)</span> &#123;<br>    <span class="hljs-comment">// 访问第v个顶点，并置访问标志数组相应分量值为true</span><br>    count&lt;&lt;v;<br>    visited[v]=<span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 初始化队列Q</span><br>    InitQueue(Q);<br>    <span class="hljs-comment">// v进队</span><br>    EnQueue(Q,v);<br><br>    <span class="hljs-comment">// 队列非空</span><br>    <span class="hljs-keyword">while</span>(!QueueEmpty(Q)) &#123;<br>        <span class="hljs-comment">// 队头元素出队并置为u</span><br>        DeQueue(Q,u);<br>        <span class="hljs-comment">// 依次检查u的所有邻接点w</span><br>        <span class="hljs-comment">// FirstAdjVex(G,u)表示u的第一个邻接点</span><br>        <span class="hljs-comment">// NextAdjVex(G,u,w)表示u相对于w的下一个邻接点</span><br>        <span class="hljs-comment">// w&gt;=0表示存在邻接点</span><br>        <span class="hljs-keyword">for</span>(FirstAdjVex(G,u);w&gt;=<span class="hljs-number">0</span>;w=NextAdjVex(G,u,w)) &#123;<br>            <span class="hljs-comment">// w为u的尚未访问的邻接点</span><br>            <span class="hljs-keyword">if</span>(!visited[w]) &#123;<br>                <span class="hljs-comment">// 访问w，并置访问标志数组相应分量值为true</span><br>                count&lt;&lt;w;<br>                visited[w]=<span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">// w进队</span><br>                EnQueue(Q,w)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>若是非连通图，上述遍历过程执行之后，图中一定还有顶点未被访问，需要从图中另选一个未被访问的顶点作为起始点，重复上述广度优先搜索过程，直到图中所有顶点均被访问过为止。该算法的实现类似于深度优先搜索遍历非连通图的算法，仅需将算法中的DFS函数调用改为BFS函数调用。</p><h3 id="3-3、算法分析">3.3、算法分析</h3><p>每个顶点至多进一次队列。遍历图的过程实质上是通过边找邻接点的过程，因此广度优先搜索遍历图的时间复杂度和深度优先搜索遍历相同，即当用邻接矩阵存储时，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>；用邻接表存储时，时间复杂度为O(n+e)。</p><h2 id="四、小结">四、小结</h2><p>图的遍历算法是实现图的其他运算的基础，图的遍历方法有两种：深度优先搜索遍历和广度优先搜索遍历。深度优先搜索遍历类似于树的先序遍历，借助于栈结构来实现（递归）；广度优先搜索遍历类似于树的层次遍历，借助于队列结构来实现。两种遍历方法的不同之处仅仅在于对顶点访问的顺序不同，所以时间复杂度相同。当用邻接矩阵存储时，时间复杂度为均<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，用邻接表存储时，时间复杂度均为O(n+e)。</p><p><img src="/img/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86.jpeg" alt="img"></p><h2 id="五、参考">五、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p><p><a href="https://book.douban.com/subject/35474931/">《数据结构与算法之美》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：图的基本概念</title>
    <link href="/2024/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>图是一种比线性表和树更为复杂的数据结构。在图结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。</p><p>图结构在计算机科学和算法设计中有广泛的应用。例如，在社交网络分析中，可以使用图结构来表示用户之间的关系；在路线规划中，可以使用图结构来表示道路网络和城市之间的连接关系；在人工智能领域中，图结构可以用于表示知识图谱和推荐系统等。</p><p>在离散数学中，图论是专门研究图的性质的数学分支，而在数据结构中，则应用图论的知识讨论如何在计算机上实现图的操作，因此主要学习图的存储结构，以及若干图的操作的实现。</p><h2 id="一、定义">一、定义</h2><p>图（Graph）G由两个集合V和E组成，记为G=(V, E)，其中V是顶点的有穷非空集合，E是V中顶点偶对的有穷集合，这些顶点偶对称为边。V(G)和E(G)通常分别表示图G的顶点集合和边集合，E(G)可以为空集。若E(G)为空，则图G只有顶点而没有边。</p><p><img src="/img/image-20240209112148567.png" alt="image-20240209112148567"></p><p>对于图G，若边集E(G)为有向边的集合，则称该图为有向图；若边集E(G)为无向边的集合，则称该图为无向图。如上图所示，左图为有向图，右图为无向图。</p><p>在有向图中，顶点对&lt;x, y&gt;是有序的，它称为从顶点x到顶点y的一条有向边。因此，&lt;x, y&gt;与&lt;y, x&gt;是不同的两条边。顶点对用一对尖括号括起来，x是有向边的始点，y是有向边的终点。&lt;x, y&gt;也称作一条弧，其中x为弧尾，y为弧头。</p><p>在无向图中，顶点对(x, y)是无序的，它称为与顶点x和顶点y相关联的一条边。这条边没有特定的方向，(x, y)与(y, x)是同一条边。为了有别于有向图，无向图的顶点对用一对圆括号括起来。</p><h2 id="二、基本术语">二、基本术语</h2><p>下面介绍图结构中的一些基本术语（注：n表示图中顶点数目，e表示边的数目）。</p><ul><li>子图：假设右两个图G=(V, E)和G’=(V’, E’)，如果V’<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">⊆</span></span></span></span>V且E’<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">⊆</span></span></span></span>E，则称G’为G的子图。如下图所示，图（b）是图（a）的子图。</li></ul><p><img src="/img/image-20240209102106850.png" alt="image-20240209102106850"></p><ul><li><p>无向完全图和有向完全图：对于无向图，若具有n(n-1)/2条边，则称为无向安全图。对于有向图，若具有n(n-1)条弧，则称为有向完全图。</p></li><li><p>稀疏图和稠密图：边或弧很少（如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>&lt;</mo><mi>n</mi><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">e&lt;n\log_2 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span>）的图称为稀疏图，反之称为稠密图。</p></li><li><p>权和网：若在图的每条边上标上具有某种含义的数值，该数值称为该边上的权值。这些权值可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网。</p></li><li><p>邻接点：对于无向图G，如果图的边(v, v’)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span>E，则称顶点v和v’互为邻接点，即v和v’相邻接。边(v, v’)依附于顶点v和v’，或者说边(v, v’)与顶点v和v’相关联。</p></li><li><p>度、入度和出度：顶点v的度是指和v相关联的边的数目，记为TD(v)。例如，下图（b）中的顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">v_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的度是2。</p><p>对于有向图，顶点v的度分为入度和出度。入度是以顶点v为头的弧的数目，记为ID(v)；出度是以顶点v为尾的弧的数目，记为OD(v)。顶点v的度为TD(v)=ID(v)+OD(v)。例如，下图（a）中的顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的入度ID(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)=1，出度OD(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)=2，度TD(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)=ID(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)+OD(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)=3</p></li></ul><p><img src="/img/image-20240209112148567.png" alt="image-20240209112148567"></p><ul><li>路径和路径长度：在无向图G中，从顶点v到顶点v’的路径是一个顶点序列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mo>=</mo><msub><mi>v</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo separator="true">,</mo><msub><mi>v</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>v</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>m</mi></mrow></msub><mo>=</mo><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v=v_{i,0},v_{i,1},...,v_{i,m}=v&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>v</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">(v_{i,j-1},v_{i,j})\in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1 \leq j \leq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>。如果G是有向图，则路径也是有向的，顶点序列应满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>v</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>&gt;</mo><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">&lt;v_{i,j-1},v_{i,j}&gt;\in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8252em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1 \leq j \leq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>。路径长度是一条路径上经过的边或弧的数目。</li><li>回路或环：第一个顶点和最后一个顶点相同的路径称为回路或环。</li><li>简单路径、简单回路或简单环：序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。</li><li>连通、连通图和连通分量：在无向图G中，如果从顶点v到顶点v’有路径，则称v和v’是连通的。如果对于图中任意两个顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v_i,v_j \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>都是连通的，则称G是连通图。而所谓连通分量，指的是无向图中的极大连通子图。例如，下图（a）就是一个连通图，而图（b）则是非连通图，但它有3个连通分量，见图（c）。</li></ul><p><img src="/img/image-20240209112819102.png" alt="image-20240209112819102"></p><ul><li>强连通图和强连通分量：在有向图G中，如果对于每一对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v_i,v_j \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub><mo mathvariant="normal">≠</mo><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_i \neq v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>，从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>和从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>都存在路径，则称G是强连通图。有向图中的极大强连通子图称作有向图的强连通分量。例如，下图（a）就是一个强连通图，而图（b）则不是强连通图，但它有两个强连通分量，见图（c）。</li></ul><p><img src="/img/image-20240209114747255.png" alt="image-20240209114747255"></p><ul><li>连通图的生成树：一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的n-1边，这样的连通子图称为连通图的生成树。例如，下图（c）是图（a）的最大连通分量的一棵生成树。如果在一棵生成树上添加一条边，必定构成一个环，因为这条边使得它依附的那两个顶点之间有了第二条路径。</li></ul><p><img src="/img/image-20240209120623835.png" alt="image-20240209120623835"></p><ul><li>有向树和生成森林：有一个顶点的入度为0，其余顶点的入度均为1的有向图称为有向树。一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。例如，下图（a）是一棵有向树，图（b）是一个有向图，它的森林是图（c）。</li></ul><p><img src="/img/image-20240209122749403.png" alt="image-20240209122749403"></p><h2 id="三、存储结构">三、存储结构</h2><p>由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系，即图没有顺序存储结构，但可以借助二维数组来表示元素之间的关系，即邻接矩阵表示法。</p><p>另一方面，由于图的任意两个顶点间都可能存在关系，因此，用链式存储表示图是很自然的事，图的链式存储有多种，有邻接表、十字链表和邻接多重表，应根据实际需要的不同选择不同的存储结构。</p><h3 id="3-1、邻接矩阵">3.1、邻接矩阵</h3><h4 id="3-1-1、表示法">3.1.1、表示法</h4><p>邻接矩阵（Adjacency Matrix）是表示顶点之间相邻关系的矩阵。设G(V, E)是具有n个顶点的图，则G的邻接矩阵是具有如下性质的n阶方阵：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mspace width="1em"/><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo><mtext>或</mtext><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mspace width="1em"/><mtext>其他</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">A[i][j] = \begin{cases} 1\quad&lt;v_i,v_j&gt;或(v_i,v_j)\in E \\ 0\quad其他 \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord cjk_fallback">或</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">其他</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>例如，下图为一个有向图和它的邻接矩阵:</p><p><img src="/img/image-20240209163737075.png" alt="image-20240209163737075"></p><p>若G是网，则邻接矩阵可以定义为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mspace width="1em"/><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo><mtext>或</mtext><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">∞</mi><mspace width="1em"/><mtext>其他</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">A[i][j] = \begin{cases} w_{ij}\quad&lt;v_i,v_j&gt;或(v_i,v_j)\in E \\ \infty\quad其他 \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord cjk_fallback">或</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">∞</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">其他</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mi>u</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">w_{uj}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>表示边上的权值，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>表示计算机允许的、大于所有边上权值的数。例如，下图为一个有向网和它的邻接矩阵:</p><p><img src="/img/image-20240209171532865.png" alt="image-20240209171532865"></p><p>用邻接矩阵表示法表示图，除了一个用于存储邻接矩阵的二维数组外，还需要用一个一维数组来存储顶点信息。在C语言中，图的邻接矩阵类型描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 表示极大值</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxInt 32767</span><br><span class="hljs-comment">// 最大顶点数</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum 100</span><br><br><span class="hljs-comment">// 假设顶点的数据类型为字符型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VerTexType;<br><br><span class="hljs-comment">// 假设边的权值类型为整型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ArcType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">// 顶点表</span><br>    VerTexType vexs[MVNum];<br>    <span class="hljs-comment">// 邻接矩阵</span><br>    ArcType arcs[MVNum][MVNum];<br>    <span class="hljs-comment">// 图的当前顶点数和边数</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;<br>&#125;AMGraph;<br></code></pre></td></tr></table></figure><h4 id="3-1-2、创建无向网">3.1.2、创建无向网</h4><p>已知一个图的顶点和边，使用邻接矩阵表示法来创建此图的方法比较简单，下面以一个无向网为例来说明创建图的算法。该算法的步骤为：</p><ul><li>输入总顶点数和总边数。</li><li>依次输入顶点的信息存入顶点表中。</li><li>初始化邻接矩阵，使每个权值初始化为极大值。</li><li>构造邻接矩阵。依次输入每条边依附的顶点和其权值，确定两个顶点在图中的位置之后，使相应边赋予相应的权值，同时使其对称边赋予相同的权值。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 采用邻接矩阵表示法，创建无向网G</span><br>Status <span class="hljs-title function_">CreateUDN</span><span class="hljs-params">(AMGraph &amp;G)</span> &#123;<br>    <span class="hljs-comment">// 输入总顶点数和总边数</span><br>    <span class="hljs-built_in">cin</span>&gt;&gt;G.vexnum&gt;&gt;G.arcnum;<br><br>    <span class="hljs-comment">// 依次输入顶点信息</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;G.vexnum; ++i)<br>        <span class="hljs-built_in">cin</span>&gt;&gt;G.vexs[i]<br><br>    <span class="hljs-comment">// 初始化邻接矩阵，边的权值均为极大值MaxInt</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;G.vexnum; ++i)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;G.vexnum; ++j)<br>            G.arcs[i][j]=MaxInt;<br><br>    <span class="hljs-comment">// 构造邻接矩阵</span><br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;G.arcnum;++k) &#123;<br>        <span class="hljs-comment">// 输入一条边依附的顶点和其权值</span><br>        <span class="hljs-built_in">cin</span>&gt;v1&gt;&gt;v2&gt;&gt;w;<br>        <span class="hljs-comment">// 确定v1和v2在G中的位置，即顶点数组的下标</span><br>        i=LocateVex(G,v1);<br>        j=LocateVex(G,v2);<br>        <span class="hljs-comment">// 边&lt;v1, v2&gt;的权值置为w</span><br>        G.arcs[i][j]=w;<br>        <span class="hljs-comment">// 置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值置为w</span><br>        G.arcs[j][i]=G.arcs[i][j];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>该算法的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo separator="true">,</mo><mi>n</mi><mo>∗</mo><mi>e</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(max(n^2,n*e))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mclose">))</span></span></span></span>。</p><p>若要建立无向图，只需对上述算法做两处小的改动：一是初始化邻接矩阵时，将边的权值均初始化为0；二是构造邻接矩阵时，将权值w改为常量值1即可。同样，将该算法稍做修改即可建立一个有向网或有向图。</p><h4 id="3-1-3、优缺点">3.1.3、优缺点</h4><p>邻接矩阵表示法的优点是：</p><ul><li>便于判断两个顶点之间是否有边，即根据A[i][j]=0或1来判断。</li><li>便于计算各个顶点的度。对于无向图，邻接矩阵第i行元素之和就是顶点i的度；对于有向图，第i行元素之和就是顶点i的出度，第i列元素之和就是顶点i的入度。</li></ul><p>邻接矩阵表示法的缺点是：</p><ul><li><p>不便于增加和删除顶点。</p></li><li><p>不便于统计边的数目，需要扫描邻接矩阵所有元素才能统计完毕，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p></li><li><p>空间复杂度高。如果是有向图，n个顶点需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>个单元存储边。如果是无向图，因其邻接矩阵是对称的，所以对规模较大的邻接矩阵可以采用压缩存储的方法，仅存储下三角（或上三角）的元素，这样需要n(n−1)/2个单元即可。但无论以何种方式存储，邻接矩阵表示法的空间复杂度均为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，这对于稀疏图而言尤其浪费空间。</p></li></ul><h3 id="3-2、邻接表">3.2、邻接表</h3><h4 id="3-2-1、表示法">3.2.1、表示法</h4><p>邻接表（Adjacency List）是图的一种链式存储结构。</p><p>在邻接表中，对图中每个顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>建立一个单链表，把与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>相邻接的顶点放在这个链表中。邻接表中每个单链表的第一个结点存放有关顶点的信息，把这一结点看成链表的表头，其余结点存放有关边的信息，这样邻接表便由两部分组成：表头结点表和边表。</p><p>表头结点表，由所有表头结点以顺序结构的形式存储，以便可以随机访问任一顶点的边链表。表头结点包括数据域（data）和链域（firstarc）两部分，如下图（a）所示。其中，数据域用于存储顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的名称或其他信息；链域用于指向链表中第一结点（即与顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>相邻接的第一个邻接点）。</p><p>边表，由表示图中顶点间关系的2n个边链表组成。边链表中边结点包括邻接点域、数据域和链域三部分，如下图（b）所示。其中，邻接点域指示与顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>相邻接的点在图中的位置；数据域存储和边相关的信息，如权值等；链域指示与顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>相邻接的下一个邻接点。</p><p><img src="/img/image-20240209184622997.png" alt="image-20240209184622997"></p><p>例如，在下图（a）中有两个图，图（b）则是它们对应的邻接表。</p><p><img src="/img/image-20240209191537191.png" alt="image-20240209191537191"></p><p>在无向图的邻接表中，顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的度恰为第i个链表中的结点数；而在有向图中，第i个链表中的结点个数只是顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的出度，为求入度，必须遍历整个邻接表。在所有链表中，其邻接点域的值为i的结点的个数就是顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的入度。有时，为了便于确定顶点的入度，可以建立一个有向图的逆邻接表，即对每个顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>建立一个链接所有进入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的边的表。例如，下图（c）为有向图<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的逆邻接表。</p><p><img src="/img/image-20240210101001014.png" alt="image-20240210101001014"></p><p>根据上述讨论，要定义一个邻接表，需要定义存放顶点的头结点和表示边的边结点。在C语言中，图的邻接表存储结构的类型描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 最大顶点数</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum 100</span><br><br><span class="hljs-comment">// 边结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span> &#123;</span><br>    <span class="hljs-comment">// 该边所指向的顶点的位置（邻接点域）</span><br>    <span class="hljs-type">int</span> adjvex;<br>    <span class="hljs-comment">// 指向下一条边的指针（链域）</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span> *<span class="hljs-title">nextarc</span>;</span><br>    <span class="hljs-comment">// 和边相关的信息（数据域）</span><br>    OtherInfo info;<br>&#125;ArcNode;<br><br><span class="hljs-comment">// 顶点信息</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VNode</span> &#123;</span><br>    VerTexType data;<br>    <span class="hljs-comment">// 指向第一条依附该顶点的边的指针</span><br>    ArcNode *firstarc;<br>&#125;VNode, AdjList[MVNum];<br><br><span class="hljs-comment">// 邻接表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    AdjList vertices;<br>    <span class="hljs-comment">// 图的当前顶点数和边数</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;<br>&#125;ALGraph;<br></code></pre></td></tr></table></figure><h4 id="3-2-2、创建无向图">3.2.2、创建无向图</h4><p>基于邻接表表示法创建一个图，需要创建其相应的顶点表和边表。下面以一个无向图为例来说明创建图的算法。该算法步骤为：</p><ul><li>输入总顶点数和总边数。</li><li>依次输入顶点的信息存入顶点表中，使每个表头结点的指针域初始化为NULL。</li><li>创建邻接表。依次输入每条边依附的两个顶点，确定这两个顶点的序号i和j之后，将此边结点分别插入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>对应的两个边链表的头部。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 采用邻接表表示法，创建无向图G</span><br>Status <span class="hljs-title function_">CreateUDG</span><span class="hljs-params">(ALGraph &amp;G)</span> &#123;<br>    <span class="hljs-comment">// 输入总顶点数，总边数</span><br>    <span class="hljs-built_in">cin</span>&gt;&gt;G.vexnum&gt;&gt;G.arcnum;<br><br>    <span class="hljs-comment">// 输入顶点信息，构造表头结点表</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;G.vexnum; ++i) &#123;<br>        <span class="hljs-comment">// 输入顶点的值</span><br>        <span class="hljs-built_in">cin</span>&gt;&gt;G.vertices[i].data;<br>        <span class="hljs-comment">// 初始化表头结点的指针域为NULL</span><br>        G.vertices[i].firstarc=<span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 输入各边，构造邻接表</span><br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>; k&lt;G.arcnum; ++k) &#123;<br>        <span class="hljs-comment">// 输入一条边依附的两个顶点</span><br>        <span class="hljs-built_in">cin</span>&gt;&gt;v1&gt;&gt;v2;<br>        <br>        <span class="hljs-comment">// 确定v1和v2在G中的位置，即顶点在G.vertices中的下标</span><br>        i=LocateVex(G,v1);<br>        j=LocateVex(G,v2);<br><br>        <span class="hljs-comment">// 生成一个新的边结点*p1</span><br>        p1=new ArcNode;<br>        <span class="hljs-comment">// 邻接点序号为j</span><br>        p2-&gt;adjvex=j;<br>        <span class="hljs-comment">// 将新结点*p1插入到顶点vi的边表头部</span><br>        p1-&gt;nextarc=G.vertices[i].firstarc;<br>        G.vertices[i].firstarc=p1;<br><br>        <span class="hljs-comment">// 生成另一个对称的新边结点*p2</span><br>        p2=new ArcNode;<br>        <span class="hljs-comment">// 邻接点序号为i</span><br>        p2-&gt;adjvex=i;<br>        <span class="hljs-comment">// 将新结点*p2插入到顶点vj的边表头部</span><br>        p2-&gt;nextarc=G.vertices[j].firstarc;<br>        G.vertices[j].firstarc=p2;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>该算法的时间复杂度是O(n*e)。</p><p>建立有向图的邻接表与此类似，只是更加简单，每读入一个顶点对序号&lt;i, j&gt;，仅需生成一个邻接点序号为j的边表结点，并将其插入到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的边链表头部即可。若要创建网的邻接表，可以将边的权值存储在info域中。</p><p>需要注意的是，一个图的邻接矩阵表示是唯一的，但其邻接表表示不唯一，这是因为在邻接表表示中，各边表结点的链接次序取决于建立邻接表的算法，以及边的输入次序。</p><h4 id="3-2-3、优缺点">3.2.3、优缺点</h4><p>邻接矩阵和邻接表是图的两种最常用的存储结构，它们各有所长。与邻接矩阵相比，邻接表有其自己的优缺点。其优点是：</p><ul><li>便于增加和删除顶点。</li><li>便于统计边的数目，按顶点表顺序扫描所有边表可得到边的数目，时间复杂度为O(n+e)。</li><li>空间效率高。对于一个具有n个顶点e条边的图G，若G是无向图，则在其邻接表表示中有n个顶点表结点和2e个边表结点；若G是有向图，则在它的邻接表表示或逆邻接表表示中均有n个顶点表结点和e个边表结点。因此，邻接表或逆邻接表表示的空间复杂度为O(n+e)，适合表示稀疏图。对于稠密图，考虑到邻接表中要附加链域，因此常采取邻接矩阵表示法。</li></ul><p>其缺点是：</p><ul><li>不便于判断顶点之间是否有边，要判定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>之间是否有边，就需扫描第i个边表，最坏情况下要耗费O(n)时间。</li><li>不便于计算有向图各个顶点的度。对于无向图，在邻接表表示中顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的度是第i个边表中的结点个数。在有向图的邻接表中，第i个边表上的结点个数是顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的出度，但求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的入度较困难，需遍历各顶点的边表。若有向图采用逆邻接表表示，则与邻接表表示相反，求顶点的入度容易，而求顶点的出度较难。</li></ul><h3 id="3-3、十字链表">3.3、十字链表</h3><p>十字链表（Orthogonal List）是有向图的另一种链式存储结构。它可以看成是将有向图的邻接表和逆邻接表结合起来得到的一种链表。在十字链表中，对应于有向图中每一条弧有一个结点，对应于每个顶点也有一个结点。这些结点的结构形式如下图所示。</p><p><img src="/img/image-20240210111630096.png" alt="image-20240210111630096"></p><p>在弧结点中有5个域：其中尾域tailvex和头域headvex分别指示弧尾和弧头这两个顶点在图中的位置，链域hlink指向弧头相同的下一条弧，而链域tlink指向弧尾相同的下一条弧，info域指向该弧的相关信息。弧头相同弧在同一链表上，弧尾相同的弧也在同一链表上。而它们的头结点即为顶点结点。</p><p>顶点结点由3个域组成：其中data域存储和顶点相关的信息，如顶点的名称等；firstin和firstout为两个链域，分别指向以该顶点为弧头或弧尾的第一个弧结点。</p><p>例如，下图（b）是下图（a）所示图的十字链表。</p><p><img src="/img/image-20240210121325532.png" alt="image-20240210121325532"></p><p>若将有向图的邻接矩阵看成是稀疏矩阵的话，则十字链表也可以看成是邻接矩阵的链式存储结构，在图的十字链表中，弧结点所在的链表非循环链表，结点之间相对位置自然形成，不一定按顶点序号有序，表头结点即顶点结点，它们之间不是链接，而是顺序存储。</p><p>在C语言中，有向图的十字链表存储结构的类型描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_VERTEX_NUM 20</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcBox</span> &#123;</span><br>    <span class="hljs-comment">// 该弧的尾和头结点的位置</span><br>    <span class="hljs-type">int</span> tailvex,headvex;<br>    <span class="hljs-comment">// 分别为弧头相同和弧尾相同的弧的链域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcBox</span> *<span class="hljs-title">hlink</span>,*<span class="hljs-title">tlink</span>;</span><br>    <span class="hljs-comment">// 该弧相关信息的指针</span><br>    InfoType *info;<br>&#125;ArcBox;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VexNode</span> &#123;</span><br>    VertexType data;<br>    <span class="hljs-comment">// 分别指向该顶点的第一条入弧和出弧</span><br>    ArcBox *firstin, *firstout;<br>&#125;VexNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">// 表头向量</span><br>    VexNode xlist[MAX_VERTEX_NUM];<br>    <span class="hljs-comment">// 有向图的当前顶点数和弧数</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;<br>&#125;QLGraph;<br></code></pre></td></tr></table></figure><p>只要输入n个顶点的信息和e条弧的信息，便可建立该有向图的十字链表。建立十字链表的时间复杂度和建立邻接表是相同的。在十字链表中既容易找到以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为尾的弧，也容易找到以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为头的弧，因而容易求得顶点的出度和入度（或需要，可在建立十字链表的同时求出）。在某些有向图的应用中，十字链表是很有用的工具。</p><h3 id="3-4、邻接多重表">3.4、邻接多重表</h3><p>邻接多重表（Adjacency Multilist）是无向图的另一种链式存储结构。虽然邻接表是无向图的一种很有效的存储结构，在邻接表中容易求得顶点和边的各种信息。但是，在邻接表中每一条边有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_i,v_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>两个结点，分别在第i个和第j个链表中，这给某些图的操作带来不便。例如，在某些图的应用问题中，需要对边进行某种操作，如对已被搜索过的边作记号或删除一条边等，此时需要找到表示同一条边的两个结点。因此，在进行这一类操作的无向图的问题中采用邻接多重表作存储结构更为适宜。</p><p><img src="/img/image-20240210175332262.png" alt="image-20240210175332262"></p><p>邻接多重表的结构和十字链表类似。在邻接多重表中，每一条边用一个结点表示，它由6个域组成。其中，mark为标志域，可用以标记该条边是否被搜索过；ivex和jvex为该边依附的两个顶点在图中的位置；ilink指向下一条依附于顶点ivex的边；jlink指向下一条依附于顶点jvex的边；info指向和边相关的各种信息的指针域。</p><p>每一个顶点也用一个结点表示，它由两个域组成。其中，data域存储和该顶点相关的信息，firstedge域指示第一条依附于该顶点的边。</p><p>例如，下图（b）是下图（a）所示图的邻接多重表。</p><p><img src="/img/image-20240210182857719.png" alt="image-20240210182857719"></p><p>在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，则每个边结点同时链接在两个链表中。可见，对无向图而言，其邻接多重表和邻接表的差别，仅仅在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。因此，除了在边结点中增加一个标志域外，邻接多重表所需的存储量和邻接表相同。</p><p>在C语言中，邻接多重表的类型描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_VERTEX_NUM 20</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span>&#123;</span>unvisited, visited&#125; VisitIf;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EBox</span> &#123;</span><br>    <span class="hljs-comment">// 访问标记</span><br>    VisitIf mark;<br>    <span class="hljs-comment">// 该边依附的两个顶点的位置</span><br>    <span class="hljs-type">int</span> ivex, jvex;<br>    <span class="hljs-comment">// 分别指向依附这两个顶点的下一条边</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EBox</span> *<span class="hljs-title">ilink</span>, *<span class="hljs-title">jlink</span>;</span><br>    <span class="hljs-comment">// 该边信息指针</span><br>    InfoType *info;<br>&#125;Ebox;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VexBox</span> &#123;</span><br>    VertexType data;<br>    <span class="hljs-comment">// 指向第一条依附该顶点的边</span><br>    EBox *firstedge;<br>&#125;VexBox;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    VexBox adjmulist[MAX_VERTEX_NUM];<br>    <span class="hljs-comment">// 无向图的当前顶点数和边数</span><br>    <span class="hljs-type">int</span> vexnum, edgenum;<br>&#125;AMLGraph;<br></code></pre></td></tr></table></figure><h2 id="四、小结">四、小结</h2><p>根据不同的分类规则，图分为多种类型：无向图、有向图、完全图、连通图、强连通图、带权图（网）、稀疏图和稠密图等。邻接点、路径、回路、度、连通分量、生成树等是在图的算法设计中常用到的重要术语。</p><p>图的存储方式有两大类：以边集合方式的表示法和以链接方式的表示法。其中，以边集合方式表示的为邻接矩阵，以链接方式表示的包括邻接表、十字链表和邻接多重表。邻接矩阵表示法借助二维数组来表示元素之间的关系，实现起来较为简单；邻接表、十字链表和邻接多重表都属于链式存储结构，实现起来较为复杂。在实际应用中具体采取哪种存储表示，可以根据图的类型和实际算法的基本思想进行选择。其中，邻接矩阵和邻接表是两种常用的存储结构。</p><p><img src="/img/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.jpeg" alt="img"></p><h2 id="五、参考">五、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：哈夫曼树</title>
    <link href="/2024/01/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <url>/2024/01/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>树结构是一种应用非常广泛的结构，在一些特定的应用中，树具有一些特殊特点，利用这些特点可以解决很多工程问题。例如，我们今天要讨论的哈夫曼树就是一种应用很广的树。</p><h2 id="一、哈夫曼树的基本概念">一、哈夫曼树的基本概念</h2><p>哈夫曼（Huffman）树又称最优树，是一类带权路径长度最短的树。哈夫曼树的定义，涉及路径、路径长度、权等概念，这些概念的具体含义如下：</p><ul><li>路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。</li><li>路径长度：路径上的分支数目称作路径长度。</li><li>树的路径长度：从树根到每一结点的路径长度之和。</li><li>权：赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述。在数据结构中，实体有结点（元素）和边（关系）两大类，所以对应有结点权和边权。结点权或边权具体代表什么意义，由具体情况而定。如果一棵树中的结点有权值，则对应的就有带权树等概念。</li><li>结点的带权路径长度：从该结点到树根之间的路径长度与结点上权的乘积。</li><li>树的带权路径长度：树中所有叶子结点的带权路径长度之和。</li></ul><p>假设有m个权值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>w</mi><mi>m</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{w_1,w_2,...,w_m\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，可以构造一棵含n个叶子结点的二叉树，每个叶子结点的权为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则其中带权路径长度（WPL）最小的二叉树称作最优二叉树或哈夫曼树。</p><p>如下图，有3棵二叉树，都含有4个叶子结点a、b、c、d，这4个叶子结点的权值分别为7、5、2、4。而这3棵二叉树的带权路径长度分别为36、46、35，其中树（c）的带权路径长度最小。可以验证，它恰为哈夫曼树，即其带权路径长度在所有权值为7、5、4、2的4个叶子结点的二叉树中居最小。</p><p><img src="/img/image-20240208100235495.png" alt="image-20240208100235495"></p><p>从这个例子中，可以直观地发现，在哈夫曼树中，权值越大的结点离根结点越近。根据这个特点，哈夫曼最早给出了一个构造哈夫曼树的方法，称哈夫曼算法。</p><h2 id="二、哈夫曼树的构造算法">二、哈夫曼树的构造算法</h2><h3 id="2-1、构造过程">2.1、构造过程</h3><p>哈夫曼树的构造过程如下：</p><ul><li>根据给定的n个权值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>w</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{w_1,w_2,...,w_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，构造n棵只有根结点的二叉树，这n棵二叉树构成一个森林F。</li><li>在森林F中选取两棵根结点权值最小的树作为左、右子树构造一棵新的二叉树，且置新的二叉树的根节点的权值为其左、右子树上根结点的权值之和。</li><li>在森林F中删除这两棵树，同时将新得到的二叉树加入F中。</li><li>重复第二步和第三步，直到F只含一棵树为止。这棵树便是哈夫曼树。</li></ul><p>在构造哈夫曼树时，首先选择权小的，这样保证权大的离根较近，这样一来，在计算树的带权路径长度时，自然会得到最小带权路径长度，这种生成算法是一种典型的贪心法。如下图所示，为哈夫曼树的构造过程。</p><p><img src="/img/image-20240208103840158.png" alt="image-20240208103840158"></p><h3 id="2-2、存储结构设计">2.2、存储结构设计</h3><p>哈夫曼树是一种二叉树，当然可以采用前面介绍过的通用存储方法。由于哈夫曼树中没有度为1的结点，则一棵有n个叶子结点的哈夫曼树共有2n−1个结点，可以存储在一个大小为2n−1的一维数组中。树中每个结点还要包含其双亲信息和孩子结点的信息，由此，每个结点的形式如下图所示。</p><p><img src="/img/image-20240208104513125.png" alt="image-20240208104513125"></p><p>在C语言中，哈夫曼树的存储结构的类型描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">// 结点的权值</span><br>    <span class="hljs-type">int</span> weight;<br>    <span class="hljs-comment">// 结点的双亲、左孩子、右孩子的下标</span><br>    <span class="hljs-type">int</span> parent, lchild, rchild;<br>&#125;HTNode, *HuffmaTree;<br></code></pre></td></tr></table></figure><p>哈夫曼树的各结点存储在由HuffmanTree定义的动态分配的数组中，为了实现方便，数组的0号单元不使用，从1号单元开始使用，所以数组的大小为2n。叶子结点集中存储在前面部分1～n个位置，而后面的n−1个位置存储其余非叶子结点。</p><h3 id="2-3、算法步骤">2.3、算法步骤</h3><p>哈夫曼树的构造算法的实现可以分成两大部分：</p><p>1）初始化。其步骤如下：</p><ul><li>首先，动态申请2n个单元；</li><li>然后，循环2n-1次，从1号单元开始，依次将1至2n-1号单元中的双亲、左孩子、右孩子的下标都初始化为0；</li><li>最后，循环n次，输入前n个单元中叶子结点的权值。</li></ul><p>2）创建树。通过n-1次的选择、删除与合并来创建哈夫曼树。其步骤如下：</p><ul><li>选择，从当前森林中选择双亲为0且权值最小的两个树根结点s1和s2；</li><li>删除，将结点s1和s2的双亲改为非0；</li><li>合并，将s1和s2的权值之和作为一个新结点的权值依次存入数组的n+1号及之后的单元中，同时记录这个新结点左孩子的下标为s1，右孩子的下标为s2。</li></ul><h3 id="2-4、算法描述">2.4、算法描述</h3><p>哈夫曼树的构造算法的实现，可以用如下C语言描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 构造哈夫曼树HT，n是叶子结点的个数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateHuffmanTree</span><span class="hljs-params">(HuffmanTree &amp;HT, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 哈夫曼树的结点数</span><br>    m=<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">// 0号单元未使用，所以需要动态分配m+1个单元，HT[m]表示根结点</span><br>    HT=new HTNode[m+<span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">/* ---- 初始化 ---- */</span><br>    <span class="hljs-comment">// 将1至m号单元中的双亲、左孩子、右孩子的下标都初始化为0</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<br>        HT[i].parent=<span class="hljs-number">0</span>;<br>        HT[i].lchild=<span class="hljs-number">0</span>;<br>        HT[i].rchild=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//输入前n个单元中叶子结点的权值</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;HT[i].weight;<br>    &#125;<br><br>    <span class="hljs-comment">/* ---- 创建树 ---- */</span><br>    <span class="hljs-comment">// 通过n-1次选择、删除、合并来创建哈夫曼树</span><br>    <span class="hljs-keyword">for</span>(i=n+<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<br>        <span class="hljs-comment">// 选择。在HT[k]（1&lt;=k&lt;=i-1）中选择两个其双亲域为0且权值最小的结点，并返回它们在HT中的序号s1和s2</span><br>        Select(HT,i<span class="hljs-number">-1</span>,s1,s2);<br>        <span class="hljs-comment">// 删除。从森林中删除s1和s2，即将s1和s2的双亲域由0改为i</span><br>        HT[s1].parent=i;<br>        HT[s2].parent=i;<br>        <span class="hljs-comment">// 合并。将i的权值设为s1和s2的权值之和，并将i的左右孩子分别设为s1和s2</span><br>        HT[i].weight=HT[s1].weight+HT[s2].weight;<br>        HT[i].lchild=s1;<br>        HT[i].rchild=s2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>哈夫曼树的一个典型应用是实现二进制编码。</p><h2 id="三、哈夫曼编码">三、哈夫曼编码</h2><p>编码是指将数据转换成由二进制字符0、1组成的二进制串。反之，将二进制串转换成数据就是解码。哈夫曼树在数据通信、数据压缩等技术领域有着广泛的应用。</p><h3 id="3-1、数据压缩问题">3.1、数据压缩问题</h3><p>假设待压缩的数据为“abcdabcdaaaaabbbdd”，该数据中只包含a、b、c、d四种字符。现有如下编码方案：</p><p><img src="/img/b1a345344ff8dbd72645fd6e1be512dd.jpg" alt="img"></p><p>方案（a）采用的是等长编码，用2位二进制码表示四种字符：a、b、c、d分别为00、01、10、11。上述待压缩数据为18个字符，其编码总长度为36位。但这并非最优的编码方案，因为每个字符出现的频率不同，如果在编码时考虑字符出现的频率，使频率高的字符采用尽可能短的编码，频率低的字符采用稍长的编码，来构造一种不等长编码，则会获得更好的空间效率，这也是文件压缩技术的核心思想。</p><p>方案（b）是一种不等长编，采用这种编码方案时，其编码总长度为35位。但对于不等长编码，如果设计得不合理，便会给解码带来困难。例如，方案（c）是另一种不等长编码方案，上述待压缩数据编码后为“00101111100101111100000010101111111”。但是，这样的编码数据无法翻译，比如，传送过去的字符串中前4个字符的子串“0010”就可有不同的译法，或是“aba”，或是“ac”。因此，若要设计长短不等的编码，必须满足一个条件：任何一个字符的编码都不是另一个字符的编码的前缀。显然，方案（b）所示的编码方案便满足这个条件。</p><p>那么如何设计有效的用于数据压缩的二进制编码呢？可使用哈夫曼编码。</p><h3 id="3-2、基本概念">3.2、基本概念</h3><p>哈夫曼编码，是指利用哈夫曼树求得的二进制编码。</p><p>在进行数据压缩时，为了使压缩后的数据文件尽可能短，通常会采用不定长编码。其基本思想是：为出现次数较多的字符编以较短的编码。为确保对数据文件进行有效的压缩和对压缩文件进行正确的解码，可以利用哈夫曼树来设计二进制编码。如下图所示的哈夫曼树，约定左分支记为0，右分支记为1，则根结点到每个叶子结点路径上的0、1序列即为相应字符的编码。</p><p><img src="/img/image-20240208155154316.png" alt="image-20240208155154316"></p><p>在哈夫曼编码中，有两个重要的概念：</p><ul><li>前缀编码：如果在一个编码方案中，任一个编码都不是其他任何编码的前缀（最左子串），则称编码是前缀编码。例如，编码0，10，110，111是前缀编码，而编码0，01，010，111就不是前缀编码。前缀编码可以保证对压缩文件进行解码时不产生二义性，确保正确解码。</li><li>哈夫曼编码：对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋予0，右分支赋予1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码。</li></ul><h3 id="3-3、算法实现">3.3、算法实现</h3><p>在构造哈夫曼树之后，求哈夫曼编码的主要思想是：依次以叶子为出发点，向上回溯至根结点为止。回溯时走左分支则生成代码0，走右分支则生成代码1。</p><p>由于每个哈夫曼编码是变长编码，因此使用一个指针数组来存放每个字符编码串的首地址。</p><p>各字符的哈夫曼编码存储在由HuffmanCode定义的动态分配的数组HC中，为了实现方便，数组的0号单元不使用，从1号单元开始使用，所以数组HC的大小为n+1，即编码表HC包括n+1行。但因为每个字符编码的长度事先不能确定，所以不能预先为每个字符分配大小合适的存储空间。为不浪费存储空间，动态分配一个长度为n（字符编码长度一定小于n）的一维数组cd，用来临时存放当前正在求解的第i（1≤i≤n）个字符的编码，当第i个字符的编码求解完毕后，根据数组cd的字符串长度分配HC[i]的空间，然后将数组cd中的编码复制到HC[i]中。</p><p>因为求解编码时是从哈夫曼树的叶子出发，向上回溯至根结点。所以对于每个字符，得到的编码顺序是从右向左的，故将编码向数组cd存放的顺序也是从后向前的，即每个字符的第1个编码存放在cd[n-2]中（cd[n-1]存放字符串结束标志’\0’），第2个编码存放在cd[n-3]中，依此类推，直到全部编码存放完毕。</p><p>根据哈夫曼树求哈夫曼编码的算法步骤为：</p><ul><li>分配存储n个字符编码的编码表空间HC，其长度为n+1；分配临时存储每个字符编码的动态数组空间cd，cd[n-1]置为‘\0’。</li><li>逐个求解n个字符的编码。循环n次，执行以下操作：<ul><li>设置变量start用于记录编码在cd中存放的位置，start初始时指向最后，即编码结束符的位置n-1；</li><li>设置变量c用于记录从叶子结点向上回溯至根结点所经过的结点下标，c初始时为当前待编码字符的下标i，f用于记录i的双亲结点的下标；</li><li>从叶子结点向上回溯至根结点，求得字符i的编码，当f没有到达根结点时，循环执行以下操作：<ul><li>回溯一次start向前指一个位置，即–start；</li><li>若结点c是f的左孩子，则生成代码0，否则生成代码1，生成的代码0或1保存在cd[start]中；</li><li>继续向上回溯，改变c和f的值。</li></ul></li><li>根据数组cd的字符串长度为第i个字符编码分配空间HT[i]，然后将数组cd中的编码复制到HT[i]中。</li></ul></li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表HC中</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateHuffmanCode</span><span class="hljs-params">(HuffmanTree HT, HuffmanCode &amp;HC, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 分配存储n个字符编码的编码表空间</span><br>    HC=new <span class="hljs-type">char</span>*[n+<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 分配临时存放每个字符编码的动态数组空间</span><br>    cd=new <span class="hljs-type">char</span>[n];<br>    <span class="hljs-comment">// 编码结束符</span><br>    cd[n<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-comment">// 逐个字符求哈夫曼编码</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<br>        <span class="hljs-comment">// start开始时指向最后，即编码结束符的位置</span><br>        start=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// f指向结点c的双亲结点</span><br>        c=i;<br>        f=HT[i].parent;<br><br>        <span class="hljs-comment">// 从叶子结点开始向上回溯，直到根结点</span><br>        <span class="hljs-keyword">while</span>(f!=<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 每回溯一次start向前指一个位置</span><br>            --start;<br>            <span class="hljs-comment">// 结点c是f的左孩子，则生成代码0，否则生成代码1</span><br>            <span class="hljs-keyword">if</span>(HT[f].lchild==c) cd[start]=<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">else</span> cd[start]=<span class="hljs-string">&#x27;1&#x27;</span>;<br>            <span class="hljs-comment">// 继续向上回溯</span><br>            c=f;<br>            f=HT[f].parent;<br>        &#125;<br><br>        <span class="hljs-comment">// 为第i个字符的编码分配存储空间</span><br>        HC[i]=new <span class="hljs-type">char</span>[n-start];<br>        <span class="hljs-comment">// 将求得的编码从临时空间cd复制到HC的当前行中</span><br>        <span class="hljs-built_in">strcpy</span>(HC[i], &amp;cd[start]);<br>    &#125;<br><br>    <span class="hljs-comment">// 释放临时空间</span><br>    delete cd;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4、文件的编码和译码">3.4、文件的编码和译码</h3><p>编码。有了字符集的哈夫曼编码表之后，对数据文件的编码过程是：依次读入文件中的字符c，在哈夫曼编码表HC中找到此字符，将字符c转换为编码表中存放的编码串。</p><p>译码。对编码后的文件进行译码的过程必须借助于哈夫曼树。具体过程是：依次读入文件的二进制码，从哈夫曼树的根结点（即HT[m]）出发，若当前读入0，则走向左孩子，否则走向右孩子。一旦到达某一叶子HT[i]时便译出相应的字符编码HC[i]。然后重新从根出发继续译码，直至文件结束。</p><h2 id="四、小结">四、小结</h2><p>哈夫曼树在通信编码技术上有广泛的应用，只要构造了哈夫曼树，按分支情况在左路径上写代码0，右路径上写代码1，然后从上到下叶结点相应路径上的代码序列就是该叶结点的最优前缀码，即哈夫曼编码。</p><p><img src="/img/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91-1708050974448.jpeg" alt="img"></p><h2 id="五、参考">五、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：树和森林</title>
    <link href="/2024/01/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/"/>
    <url>/2024/01/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/</url>
    
    <content type="html"><![CDATA[<p>在前面我们讨论的与有关的基本概念以及二叉树的遍历，今天我们来看另一个知识点：树和森林。</p><h2 id="一、树的存储结构">一、树的存储结构</h2><h3 id="1-1、双亲表示法">1.1、双亲表示法</h3><p>双亲表示法，是以一组连续的存储单元存储树的结点。每个结点除了数据域data之外，还附设一个parent域用以指示其双亲结点的位置，其结点形式如下图所示：</p><p><img src="/img/image-20240207094652510.png" alt="image-20240207094652510"></p><p>这种存储结构利用了每个结点（除根以外）只有唯一双亲的性质。在这种存储结构下，求结点的双亲十分方便，也很容易求树的根，但求结点的孩子时需要遍历整个结构。如下，为一棵树及其双亲表示的存储结构：</p><p><img src="/img/image-20240207101305222.png" alt="image-20240207101305222"></p><h3 id="1-2、孩子表示法">1.2、孩子表示法</h3><p>由于树中每个结点可能有多棵子树，因此可用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点。此时，链表中的结点可以有如下两种形式：</p><p><img src="/img/image-20240207102251672.png" alt="image-20240207102251672"></p><p>若采用第一种结点格式，则多重链表中的结点是同构的，其中d为树的度。由于树中很多结点的度小于d，所以链表中有很多空链域，空间较浪费。不难推出，在一棵有n个结点、度为k的树中必有n(k−1)+1个空链域。</p><p>若采用第二种结点格式，则多重链表中的结点是不同构的，其中d为结点的度，degree域的值同d。此时，虽能节约存储空间，但操作不方便。</p><p>另一种办法是，把每个结点的孩子结点排列起来，看成一个线性表，且以单链表作为存储结构。这样，在一棵有n个结点的树中，就有n个孩子链表。为了便于查找，可将树中各结点的孩子链表的头指针存放在一个指针数组中。与双亲表示法相反，孩子表示法便于那些涉及孩子的操作的实现。如下，为一棵树及其孩子链表存储结构：</p><p><img src="/img/image-20240207111133745.png" alt="image-20240207111133745"></p><p>此外，还可以把孩子表示法和双亲表示法结合起来，即将双亲表示和孩子链表合在一起。如下，为一棵树及其带双亲的孩子链表存储结构：</p><p><img src="/img/image-20240207111839184.png" alt="image-20240207111839184"></p><h3 id="1-3、孩子兄弟表示法">1.3、孩子兄弟表示法</h3><p>孩子兄弟表示法又称二叉树表示法，或二叉链表表示法，即以二叉链表做树的存储结构。链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点，分别命名为firstchild域和nextsibling域，其结点形式如下：</p><p><img src="/img/image-20240207113122343.png" alt="image-20240207113122343"></p><p>在C语言中，树的孩子兄弟表示法的类型描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span> &#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span> *<span class="hljs-title">firstchild</span>, *<span class="hljs-title">nextsibling</span>;</span><br>&#125;CSNode, *CSTree;<br></code></pre></td></tr></table></figure><p>利用这种存储结构便于实现各种树的操作。首先易于实现找结点孩子等的操作。例如，若要访问结点x的第i个孩子，则只要先从firstchild域找到第1个孩子结点，然后沿着孩子结点的nextsibling域连续走i−1步，便可找到x的第i个孩子。当然，如果为每个结点增设一个parent域，则同样能方便地实现查找双亲的操作。</p><p>这种存储结构的优点是它和二叉树的二叉链表表示完全一样，便于将一般的树结构转换为二叉树进行处理，利用二叉树的算法来实现对树的操作。因此孩子兄弟表示法是应用较为普遍的一种树的存储表示方法。如下，为一棵树及其二叉链表存储结构：</p><p><img src="/img/image-20240207120223621.png" alt="image-20240207120223621"></p><h2 id="二、森林与二叉树的转换">二、森林与二叉树的转换</h2><p>从树的二叉链表表示法可知，任何一棵和树对应的二叉树，其根结点的右子树必为空。若把森林中第二棵树的根结点看成第一棵树的根结点的兄弟，则可导出森林和二叉树的对应关系。如下，为森林与二叉树的对应关系：</p><p><img src="/img/image-20240207142955099.png" alt="image-20240207142955099"></p><h3 id="2-1、森林转换成二叉树">2.1、森林转换成二叉树</h3><p>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>T</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>T</mi><mi>m</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F=\{T_1,T_2,...,T_m\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>是森林，则可按如下规则将其转换成一棵二叉树<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo separator="true">,</mo><mi>L</mi><mi>B</mi><mo separator="true">,</mo><mi>R</mi><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B=(root, LB, RB)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">roo</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">RB</span><span class="mclose">)</span></span></span></span>：</p><ul><li>若F为空，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">m=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，则B为空树；</li><li>若F非空，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">m\neq0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，则B的根root是森林中第一棵树的根ROOT(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)；B的左子树LB是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中根节点的子树森林<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">{</mo><msub><mi>T</mi><mn>11</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>12</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>T</mi><mrow><mn>1</mn><mi>m</mi></mrow></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F_1=\{T_{11},T_{12},...,T_{1m}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>转换而成的二叉树；B的右子树RB是森林<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mo stretchy="false">{</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>T</mi><mi>m</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F&#x27;=\{T_2,T_3,...,T_m\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>转换而成的二叉树。</li></ul><h3 id="2-2、二叉树转换成森林">2.2、二叉树转换成森林</h3><p>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo separator="true">,</mo><mi>L</mi><mi>B</mi><mo separator="true">,</mo><mi>R</mi><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B=(root, LB, RB)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">roo</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">RB</span><span class="mclose">)</span></span></span></span>是一棵二叉树，则可按如下规则将其转换成森林<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>T</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>T</mi><mi>m</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F=\{T_1,T_2,...,T_m\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>：</p><ul><li>若B为空，则F为空；</li><li>若B非空，则F中第一棵树<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的根ROOT(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)是二叉树B的根root；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中根结点的子树森林<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">F_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是由B的左子树LB转换而成的森林；F中除<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之外其余树组成的森林<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mo stretchy="false">{</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>T</mi><mi>m</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F&#x27;=\{T_2,T_3,...,T_m\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>是由B的右子树RB转换而成的森林。</li></ul><h2 id="三、树和森林的遍历">三、树和森林的遍历</h2><h3 id="3-1、树的遍历">3.1、树的遍历</h3><p>由树结构的定义可引出两种遍历树的方法：一种是先根遍历树，即：先访问树的根结点，然后依次先根遍历根的每棵子树；另一种是后根遍历，即先依次后根遍历每棵子树，然后访问根结点。如下，为一棵树及其两种遍历次序：</p><p><img src="/img/image-20240207161331127.png" alt="image-20240207161331127"></p><p>由此可见，先根遍历一棵树等价于先序遍历该树对应的二叉树，而后根遍历一棵树等价于中序遍历该树对应的二叉树。因此，当以二叉链表作为树的存储结构时，树的先根遍历和后根遍历可借用二叉树的先序遍历和中序遍历的算法实现。</p><h3 id="3-2、森林的遍历">3.2、森林的遍历</h3><blockquote><p>先序遍历森林</p></blockquote><p>若森林非空，则可按下述规则遍历：</p><ul><li>访问森林中第一棵树的根结点；</li><li>先序遍历第一棵树的根结点的子树森林；</li><li>先序遍历除去第一棵树之后剩余的树构成的森林；</li></ul><p>简而言之，先序遍历森林是从左到右依次按先序次序遍历森林中的每一棵树。如下，为一个森林及其先序遍历序列：</p><p><img src="/img/image-20240207163305139.png" alt="image-20240207163305139"></p><blockquote><p>中序遍历森林</p></blockquote><p>若森林非空，则可按下述规则遍历：</p><ul><li>中序遍历森林中第一棵树的根结点的子树森林；</li><li>访问第一棵树的根结点；</li><li>中序遍历除去第一棵树之后剩余的树构成的森林。</li></ul><p>简而言之，中序遍历森林是从左到右依次按后序次序遍历森林中的每一棵树。如下，为一个森林及其中序遍历序列：</p><p><img src="/img/image-20240207163234909.png" alt="image-20240207163234909"></p><p>由森林与二叉树之间的转换规则可知，当森林转换成二叉树时，其第一棵树的子树森林转换成左子树，剩余树组成的森林转换成右子树，则上述森林的先序和中序遍历即为其对应的二叉树的先序和中序遍历。</p><h2 id="四、小结">四、小结</h2><p>树的存储结构有三种：双亲表示法、孩子表示法和孩子兄弟表示法，孩子兄弟表示法是常用的表示法，任意一棵树都能通过孩子兄弟表示法转换为二叉树进行存储。</p><p>树、森林与二叉树之间有一个自然的对应关系，即任何一棵树或一个森林都可唯一地对应于一棵二叉树，而任何一棵二叉树也能唯一地对应于一个森林或一棵树。通过这些转换，可以利用二叉树的操作解决一般树的有关问题。</p><p><img src="/img/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97.jpeg" alt="img"></p><h2 id="五、参考">五、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：二叉树的遍历</title>
    <link href="/2024/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2024/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们介绍了树和二叉树所涉及的基本概念，今天我们来看二叉树的一个重要操作：遍历。</p><p>在二叉树的一些应用中，常常要求在树中查找具有某种特征的结点，或者是对树中的全部结点逐一进行处理，这就需要对二叉树进行遍历。</p><h2 id="一、遍历二叉树">一、遍历二叉树</h2><p>遍历二叉树（traversing binary tree）是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。访问的含义很广，可以是对结点做各种处理，包括输出结点的信息，对结点进行运算和修改等。遍历二叉树是二叉树最基本的操作，也是二叉树其他各种操作的基础。</p><p>遍历的实质是对二叉树进行线性化的过程，即遍历的结果是将非线性结构的树中结点排成一个线性序列。由于二叉树中的每个结点都可能有两棵子树，因而需要寻找一种规律，以便使二叉树上的结点能排列在一个线性序列上，从而便于遍历。</p><h3 id="1-1、算法描述">1.1、算法描述</h3><p>根据二叉树的递归定义可知，二叉树由3个基本单元组成：根结点、左子树和右子树。因此，若能依次遍历这三部分，便是遍历了整个二叉树。也就是说，遍历一棵非空二叉树的问题可分解为三个子问题：访问根结点、遍历左子树和遍历右子树。</p><p>假如用L、D、R分别表示遍历左子树、访问根结点和遍历右子树，则可有DLR、LDR、LRD、DRL、RDL、RLD这6种遍历二叉树的方案。若限定先左后右，则只有前3种情况，分别称之为先（根）序遍历、中（根）序遍历和后（根）序遍历。基于二叉树的递归定义，可以得出下述三种遍历二叉树的递归算法定义：</p><p>（1）先序遍历二叉树的递归定义。若二叉树非空，则依次进行操作：</p><ul><li>访问根结点；</li><li>先序遍历左子树；</li><li>先序遍历右子树；</li></ul><p>（2）中序遍历二叉树的递归定义。若二叉树非空，则依次进行操作：</p><ul><li>中序遍历左子树；</li><li>访问根结点；</li><li>中序遍历右子树；</li></ul><p>（3）后序遍历二叉树的递归定义。若二叉树非空，则依次进行操作：</p><ul><li>后序遍历左子树；</li><li>后序遍历右子树；</li><li>访问根结点；</li></ul><h3 id="1-2、算法实现">1.2、算法实现</h3><h4 id="1-2-1、递归实现">1.2.1、递归实现</h4><p>在有了上述遍历二叉树的递归定义之后，三种遍历算法就很容易实现了。这三种遍历算法，可用如下C语言进行描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 先序遍历二叉树T的递归算法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PreOrder</span><span class="hljs-params">(BiTree T)</span> &#123;<br>    <span class="hljs-comment">// 二叉树为空时返回</span><br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 访问根结点</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,T-&gt;data);<br>    <span class="hljs-comment">// 先序遍历左子树</span><br>    PreOrder(T-&gt;lchild);<br>    <span class="hljs-comment">// 先序遍历右子树</span><br>    PreOrder(T-&gt;rchild);<br>&#125;<br><br><span class="hljs-comment">// 中序遍历二叉树T的递归算法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InOrder</span><span class="hljs-params">(BiTree T)</span> &#123;<br>    <span class="hljs-comment">// 二叉树为空时返回</span><br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 中序遍历左子树</span><br>    InOrder(T-&gt;lchild);<br>    <span class="hljs-comment">// 访问根结点</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,T-&gt;data);<br>    <span class="hljs-comment">// 中序遍历右子树</span><br>    InOrder(T-&gt;rchild);<br>&#125;<br><br><span class="hljs-comment">// 后序遍历二叉树T的递归算法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PostOrder</span><span class="hljs-params">(BiTree T)</span> &#123;<br>    <span class="hljs-comment">// 二叉树为空时返回</span><br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 后序遍历左子树</span><br>    PostOrder(T-&gt;lchild);<br>    <span class="hljs-comment">// 后序遍历右子树</span><br>    PostOrder(T-&gt;rchild);<br>    <span class="hljs-comment">// 访问根结点</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,T-&gt;data);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这三种遍历算法得到的遍历序列如下图所示：</p><p><img src="/img/%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91.jpeg" alt="img"></p><p>为了便于理解递归算法，接下来，我们以先序遍历为例，说明递归算法的执行过程。为了叙述方便，假设先序遍图中，结点旁边的序号是该结点的存储地址。</p><p>当一个函数调用先序遍历算法时，首先会以指向二叉树根结点的地址1作为实参，将它传递给算法中的形参T，然后执行算法。在算法执行过程中，总是先先序遍历左子树，此时的右子树并没有得到及时的遍历，所以系统要记住此时右子树的访问地址，等左子树遍历结束后再回来遍历右子树，因此需要用一个工作栈来存储右子树T-&gt;rchild的访问地址，假定该工作栈为S。</p><ul><li>当一开始调用PreOrder函数时，由于T=1不为NULL，因此访问根结点，输出A，然后递归调用PreOrder函数遍历左子树T=2，此时还需要将右子树的地址5存入栈S中，如下图（a）所示。</li><li>T=2不为NULL，访问T指向的结点，输出B，再递归调用PreOrder函数遍历左子树T=3，同时将右子树的地址4存入S中，如下图（b）所示。</li><li>T=3不为NULL，访问T指向的结点，输出D；此时T的左、右子树均为空，所以返回到上一层，遍历T=2的右子树4。</li><li>T=4不为NULL，访问T指向的结点，输出E；此时T的左、右子树均为空，所以继续返回到上一层，遍历T=1的右子树5。</li><li>T=5不为NULL，访问T指向的结点，输出C，由于此时T的左子树为空，因此遍历其右子树T=6。</li><li>T=6不为NULL，访问T指向的结点，输出F，这时T的左、右子树均为空，遍历结束。</li></ul><p>遍历过程中，工作栈S的变化情况如下图所示：</p><p><img src="/img/image-20240127161651002.png" alt="image-20240127161651002"></p><p>上述先序遍历算法的执行步骤，也可通过如下逻辑图来理解：</p><p><img src="/img/PreOrder(T)-1706344063737.jpeg" alt="img"></p><h4 id="1-2-2、非递归实现">1.2.2、非递归实现</h4><p>利用栈可将递归算法改写成非递归算法。比如，从中序遍历递归算法执行过程中递归工作栈的状态可见：</p><ul><li>工作记录中包含两项，其一是递归调用的语句编号（即返回地址），其二是指向根结点的指针。当栈顶记录中的指针非空时，应遍历左子树，即指向左子树根的指针进栈；</li><li>若栈顶记录中的指针值为空，则应退至上一层，若是从左子树返回，则应访问当前层（即栈顶记录）中指针所指的根结点；</li><li>若是从右子树返回，则表明当前层的遍历结束，应继续退栈。</li></ul><p>中序遍历的非递归算法的实现步骤为：</p><ul><li>初始化一个空栈S，指针p指向根结点。</li><li>申请一个结点空间q，用来存放栈顶弹出的元素。</li><li>当p非空或者栈S非空时，循环执行以下操作：<ul><li>如果p非空，则使p进栈，p指向该结点的左孩子；</li><li>如果p为空，则弹出栈顶元素并访问根结点，将p指向该结点的右孩子。</li></ul></li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span> &#123;<br>    InitStack(S);<br>    p=T;<br>    q=new BiTNode;<br>    <br>    <span class="hljs-keyword">while</span>(p||!StackEmpty(S)) &#123;<br>        <span class="hljs-comment">// p非空</span><br>        <span class="hljs-keyword">if</span>(p) &#123;<br>            <span class="hljs-comment">// 根结点指针进栈</span><br>            Push(S,p);<br>            <span class="hljs-comment">// 遍历左子树</span><br>            p=p-&gt;lchild;<br>        &#125;<br>        <span class="hljs-comment">// p为空</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 退栈</span><br>            Pop(S,q);<br>            <span class="hljs-comment">// 访问根结点</span><br>            count&lt;&lt;q-&gt;data;<br>            <span class="hljs-comment">// 遍历右子树</span><br>            p=q-&gt;rchild;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4、算法分析">1.4、算法分析</h3><p>无论是递归还是非递归遍历二叉树，因为每个结点被访问一次，则不论按哪一种次序进行遍历，对含n个结点的二叉树，其时间复杂度均为O(n)。所需辅助空间为遍历过程中栈的最大容量，即树的深度，最坏情况下为n，则空间复杂度也为O(n)。</p><h3 id="1-5、算法的应用">1.5、算法的应用</h3><blockquote><p>以二叉链表作为存储结构，创建二叉树</p></blockquote><p>为简化问题，设二叉树中结点的元素均为一个单字符。假设按先序遍历的顺序建立二叉链表，T为指向根结点的指针，对于给定的一个字符序列，依次读入字符，从根结点开始，递归创建二叉树。该算法的实现步骤为：</p><ul><li>扫描字符序列，读入字符ch。</li><li>如果ch是一个“#”字符，则表明该二叉树为空树，即T为NULL；否则执行以下操作：<ul><li>申请一个结点空间T；</li><li>将ch赋给T-&gt;data；</li><li>递归创建T的左子树；</li><li>递归创建T的右子树；</li></ul></li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">CreateBiTree</span><span class="hljs-params">(BiTree &amp;T)</span> &#123;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;ch;<br>    <span class="hljs-comment">// 递归结束，创建空树</span><br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;#&#x27;</span>) T=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">// 递归创建二叉树</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 生成根结点</span><br>        T=new BiTNode;<br>        <span class="hljs-comment">// 根结点数据域置为ch</span><br>        T-&gt;data=ch;<br>        <span class="hljs-comment">// 递归创建左子树</span><br>        CreateBiTree(T-&gt;lchild);<br>        <span class="hljs-comment">// 递归创建右子树</span><br>        CreateBiTree(T-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>复制二叉树</p></blockquote><p>复制二叉树就是利用已有的一棵二叉树复制得到另外一棵与其完全相同的二叉树。</p><p>根据二叉树的特点，复制步骤如下：若二叉树不空，则首先复制根结点，这相当于二叉树先序遍历算法中访问根结点的语句；然后分别复制二叉树根结点的左子树和右子树，这相当于先序遍历中递归遍历左子树和右子树的语句。因此，复制函数的实现与二叉树先序遍历的实现非常类似。该算法的实现步骤为：</p><ul><li>如果是空树，递归结束，否则执行以下操作：<ul><li>申请一个新节点空间，复制根结点</li><li>递归复制左子树；</li><li>递归复制右子树；</li></ul></li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Copy</span><span class="hljs-params">(BiTree T, BiTree &amp;NewT)</span> &#123;<br>    <span class="hljs-comment">// 如果为空树，递归结束</span><br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) &#123;<br>        NewT=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        NewT=new BiTNode;<br>        <span class="hljs-comment">// 复制根结点</span><br>        NewT-&gt;data=T-&gt;data;<br>        <span class="hljs-comment">// 递归复制左子树</span><br>        Copy(T-&gt;lchild, NewT-&gt;lchild);<br>        <span class="hljs-comment">// 递归复制右子树</span><br>        Copy(T-&gt;rchild, NewT-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>计算二叉树的深度</p></blockquote><p>二叉树的深度为树中结点的最大层次，二叉树的深度为左右子树深度的较大者加1。该算法的实现步骤为：</p><ul><li>递归计算左子树的深度记为m；</li><li>递归计算右子树的深度记为n；</li><li>如果m大于n，二叉树的深度为m+1，否则为n+1。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Depth</span><span class="hljs-params">(BiTree T)</span> &#123;<br>    <span class="hljs-comment">// 如果是空树，深度为0，递归结束</span><br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 递归计算左子树的深度记为m</span><br>        m=Depth(T-&gt;lchild);<br>        <span class="hljs-comment">// 递归计算右子树的深度记为n</span><br>        n=Depth(T-&gt;rchild);<br>        <span class="hljs-comment">// 二叉树的深度为m与n的较大者加1</span><br>        <span class="hljs-keyword">if</span>(m&gt;n) <span class="hljs-keyword">return</span>(m+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>(n+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，计算二叉树的深度是在后序遍历二叉树的基础上进行的运算。</p><blockquote><p>统计二叉树中结点的个数</p></blockquote><p>如果是空树，则结点个数为0；否则，结点个数为左子树的结点个数加上右子树的结点个数再加上1。相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">NodeCount</span><span class="hljs-params">(BiTree T)</span> &#123;<br>    <span class="hljs-comment">// 如果是空树，则结点个数为0，递归结束</span><br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 否则结点个数为左子树的结点个数 + 右子树的结点个数 + 1</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>根据遍历序列确定二叉树</p></blockquote><p>从二叉树的遍历可知，若二叉树中各结点的值均不相同，任意一棵二叉树结点的先序序列、中序序列和后序序列都是唯一的。反过来，若已知二叉树遍历的任意两种序列，能否确定这棵二叉树呢？这样确定的二叉树是否是唯一的呢？</p><p>由二叉树的先序序列和中序序列，或由其后序序列和中序序列均能唯一地确定一棵二叉树。</p><p>根据定义，二叉树的先序遍历是先访问根结点，其次再按先序遍历方式遍历根结点的左子树，最后按先序遍历方式遍历根结点的右子树。这就是说，在先序序列中，第一个结点一定是二叉树的根结点。</p><p>另一方面，中序遍历是先遍历左子树，然后访问根结点，最后再遍历右子树。这样，根结点在中序序列中必然将中序序列分割成两个子序列，前一个子序列是根结点的左子树的中序序列，而后一个子序列是根结点的右子树的中序序列。根据这两个子序列，可以在先序序列中找到对应的左子序列和右子序列。</p><p>在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。这样，就确定了二叉树的三个结点。同时，左子树和右子树的根结点又可以分别把左子序列和右子序列划分成两个子序列，如此递归下去，当取尽先序序列中的结点时，便可以得到一棵二叉树。</p><p>同理，由二叉树的后序序列和中序序列也可唯一地确定一棵二叉树。因为，依据后序遍历和中序遍历的定义，后序序列的最后一个结点，就如同先序序列的第一个结点一样，可将中序序列分成两个子序列，分别为这个结点左子树的中序序列和右子树的中序序列，再拿出后序序列的倒数第二个结点，并继续分割中序序列，如此递归下去，当倒着取尽后序序列中的结点时，便可以得到一棵二叉树。</p><h2 id="二、线索二叉树">二、线索二叉树</h2><h3 id="2-1、基本概念">2.1、基本概念</h3><p>所谓线索二叉树，是指二叉链表中的每个结点添加了指向其直接前驱和直接后继的指针。</p><p>遍历二叉树是以一定规则将二叉树中的结点排列成一个线性序列，得到二叉树中结点的先序序列、中序序列或后序序列。这实质上是对一个非线性结构进行线性化操作，使每个结点（除第一个和最后一个外）在这些线性序列中有且仅有一个直接前驱和直接后继。</p><p>当以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接得到结点在任一序列中的前驱和后继信息，这种信息只有在遍历的动态过程中才能得到，为此引入线索二叉树来保存这些在动态过程中得到的有关前驱和后继的信息。</p><p>虽然可以在每个结点中增加两个指针域来存放在遍历时得到的有关前驱和后继信息，但这样做使得结构的存储密度大大降低。由于有n个结点的二叉链表中必定存在n+1个空链域，因此可以充分利用这些空链域来存放结点的前驱和后继信息。</p><p>在线索二叉树中，为了区分一个结点的左、右孩子指针域是指向其孩子的指针还是指向其前趋或后继的线索，可在结点结构中增加两个线索标志域，一个是左线索标志域，用ltag表示，另一个是右线索标志域，用rtag表示。ltag和rtag的取值只能是0和1。在增加了线索标志域以后，结点的结构如下：</p><p><img src="/img/image-20240128110436001.png" alt="image-20240128110436001"></p><p>其中：</p><ul><li>ltag=0，表示lchild域指向结点的左孩子</li><li>ltag=1，表示lchild域指向结点的前驱</li><li>rtag=0，表示rchild域指向结点的右孩子</li><li>rtag=1，表示rchild域指向结点的后继</li></ul><p>在C语言中，线索二叉树的类型描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiThrNode</span> &#123;</span><br>    TElemType data;<br>    <span class="hljs-comment">// 左右孩子指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiThrNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span><br>    <span class="hljs-comment">// 左右标志域</span><br>    <span class="hljs-type">int</span> LTag,RTag;<br>&#125;BiThrNode, *BiThrTree;<br></code></pre></td></tr></table></figure><p>以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索链表，其中指向结点前驱和后继的指针，叫做线索。加上线索的二叉树称之为线索二叉树（Threaded Binary Tree）。对二叉树以某种次序遍历使其变为线索二叉树的过程叫做线索化。</p><h3 id="2-2、构造线索二叉树">2.2、构造线索二叉树</h3><p>由于线索二叉树构造的实质是将二叉链表中的空指针改为指向前驱或后继的线索，而前驱或后继的信息只有在遍历时才能得到，因此线索化的过程就是在遍历的过程中修改空指针的过程，可用递归算法。</p><p>对二叉树按照不同的遍历次序进行线索化，可以得到不同的线索二叉树，包括先序线索二叉树、中序线索二叉树和后序线索二叉树。下面重点介绍中序线索化的算法。</p><p>为了记下遍历过程中访问结点的先后关系，附设一个指针pre始终指向刚刚访问过的结点，而指针p指向当前访问的结点，由此记录下遍历过程中访问结点的先后关系。</p><p>首先，我们给出对树中任意一个以结点p为根的子树中序线索化的过程，其算法步骤为：</p><ul><li>如果p非空，递归线索化左子树。</li><li>如果p的左孩子为空，则给p加上左线索，将其LTag置为1，让p的左孩子指针指向pre（即其前驱）；否则将p的LTag置为0。</li><li>如果pre的右孩子为空，则给pre加上右线索，将其RTag置为1，让pre的右孩子指针指向p（即其后继）；否则将pre的RTag置为0。</li><li>将pre指向刚访问过的结点p，即pre=p。</li><li>递归线索化右子树。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InThreading</span><span class="hljs-params">(BiThrTree p)</span> &#123;<br>    <span class="hljs-keyword">if</span>(p) &#123;<br>        <span class="hljs-comment">// 递归线索化左子树</span><br>        InThreading(p-&gt;lchild);<br><br>        <span class="hljs-comment">// p的左孩子为空，给p加上左线索</span><br>        <span class="hljs-keyword">if</span>(!p-&gt;lchild) &#123;<br>            <span class="hljs-comment">// 将LTag置为1</span><br>            p-&gt;LTag=<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// p的左孩子指向其前驱pre</span><br>            p-&gt;lchild=pre;<br>        &#125; <span class="hljs-keyword">else</span> p-&gt;LTag=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// pre的右孩子为空，给pre加右线索</span><br>        <span class="hljs-keyword">if</span>(!pre-&gt;child) &#123;<br>            <span class="hljs-comment">// 将RTag置为1</span><br>            pre-&gt;RTag=<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// p的右孩子指向其后继p</span><br>            pre-&gt;rchild=p;<br>        &#125; <span class="hljs-keyword">else</span> p-&gt;RTag=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// pre始终指向p的前驱</span><br>        pre=p;<br>        <br>        <span class="hljs-comment">// 递归线索化右子树</span><br>        InThreading(p-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后再通过调用该算法完成对整个二叉树的中序线索化。相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 带头结点的二叉树中序线索化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InOrderThreading</span><span class="hljs-params">(BiThrTree &amp;Thrt, BiThrTree T)</span> &#123;<br>    <span class="hljs-comment">// 申请头结点</span><br>    Thrt=new BiThrNode;<br>    <span class="hljs-comment">// 头结点有左孩子，若树非空，则其左孩子为树根</span><br>    Thrt-&gt;LTag=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 头结点的右孩子指针为右线索，初始化时右指针指向自己</span><br>    Thrt-&gt;RTag=<span class="hljs-number">1</span>;<br>    Thrt-&gt;rchild=Thrt;<br>    <span class="hljs-comment">// 若树为空，则左指针也指向自己</span><br>    <span class="hljs-keyword">if</span>(!T) Thrt-&gt;lchild=Thrt;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 头结点的左孩子指向根，pre初始值指向头结点</span><br>        Thrt-&gt;child=T;<br>        pre=Thrt;<br>        <span class="hljs-comment">// 对以T为根的二叉树进行中序线索化</span><br>        InThreading(T);<br>        <span class="hljs-comment">// 中序线索化结束后，pre为最右结点，pre的右线索指向头结点</span><br>        pre-&gt;RTag=<span class="hljs-number">1</span>;<br>        pre-&gt;rchild=Thrt;<br>        <span class="hljs-comment">// 头结点的右线索指向pre</span><br>        Thrt-&gt;rchild=pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3、查找某结点的前驱和后继">2.3、查找某结点的前驱和后继</h3><p>在有了结点的前驱和后继信息后，在指定次序下查找结点的前驱和后继算法将变得简单。因此，若需经常查找结点在某种遍历序列中的前驱和后继，则应采用线索链表作为存储结构。</p><p>下面分3种情况讨论在线索二叉树中如何查找结点的前驱和后继。</p><blockquote><p>在中序线索二叉树中查找</p></blockquote><p>查找指针p所指结点的前驱：</p><ul><li>若p-&gt;LTag为1，则p的左链指向其前驱；</li><li>若p-&gt;LTag为0，则说明p有左子树，结点的前驱是遍历左子树时最后访问的一个结点（左子树中最右下的结点）</li></ul><p>查找指针p所指结点的后继：</p><ul><li>若p-&gt;RTag为1，则p的右链指示其后继；</li><li>若p-&gt;RTag为0，说明p有右子树。根据中序遍历的规律可知，结点的后继应该是遍历其右子树时访问的第一个结点，即右子树中最左下的结点。</li></ul><blockquote><p>在先序线索二叉树中查找</p></blockquote><p>查找指针p所指结点的前驱：</p><ul><li>若p-&gt;LTag为1，则p的左链指向其前驱；</li><li>若p-&gt;LTag为0，则说明p有左子树。此时p的前驱有以下两种情况：<ul><li>若p所指结点是其双亲的孩子，则其前驱为其双亲结点；</li><li>否则应是其双亲的左子树上先序遍历最后访问到的结点。</li></ul></li></ul><p>查找指针p所指结点的后继：</p><ul><li>若p-&gt;RTag为1，则p的右链指示其后继；</li><li>若p-&gt;RTag为0，说明p有右子树。按先序遍历的规律可知，其后继必为其左子树根（若存在）或右子树根。</li></ul><blockquote><p>在后序线索二叉树中查找</p></blockquote><p>查找指针p所指结点的前驱：</p><ul><li>若p-&gt;LTag为1，则p的左链指向其前驱；</li><li>若p-&gt;LTag为0，则p的前驱要分两种情况进行讨论：<ul><li>当p-&gt;RTag为0，说明p有左右子树。根据后序遍历的规律可知，结点的前驱应是遍历其右子树时最后访问的那个结点，即右子树根，也就是p的右链所指向的结点；</li><li>当p-&gt;RTag为1，说明p有左子树，没有右子树。根据后序遍历的规律可知，结点的前驱应是遍历其左子树时最后访问的那个结点，即左子树根，也就是p的左链所指向的结点；</li></ul></li></ul><p>查找指针p所指结点的后继，该运算比较复杂，要分以下情况讨论：</p><ul><li>若p所指结点是二叉树的根，则其后继为空；</li><li>若p所指结点是其双亲的右孩子，则其后继为双亲结点；</li><li>若p所指结点是其双亲的左孩子，且p所指结点没有右兄弟，则其后继为双亲结点；</li><li>若p所指结点是其双亲的左孩子，且p所指结点有右兄弟，则其后继为其双亲的右子树上按后序遍历访问的第一个结点，即右子树中“最左下”的叶子结点。</li></ul><p>综上所述，在先序线索二叉树上查找前驱或在后序线索二叉树上查找后继都比较复杂。此时若有需要，可直接建立含4个指针的线索链表。</p><h3 id="2-4、遍历线索二叉树">2.4、遍历线索二叉树</h3><p>由于有了结点的前驱和后继的信息，线索二叉树的遍历操作无需设栈，避免了频繁的进栈、出栈，因此在时间和空间上都较遍历二叉树节省。</p><p>遍历某种次序的线索二叉树，只要从该次序下的根结点出发，反复查找其在该次序下的后继，直到叶子结点。下面以遍历中序线索二叉树为例介绍该算法。</p><p>遍历中序线索二叉树的算法步骤为：</p><ul><li>指针p指向根结点</li><li>p为非空树或遍历未结束时，循环执行以下操作：<ul><li>沿左孩子向下，找到最左下的叶子结点*p，即中序遍历的第一结点；</li><li>访问*p；</li><li>沿右线索反复查找当前结点*p的后继结点并访问后继结点，直至右线索为0或遍历结束。</li></ul></li><li>转向p的右子树</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InOrderTraverse_Thr</span><span class="hljs-params">(BiThrTree T)</span> &#123;<br>    <span class="hljs-comment">// p指向根结点</span><br>    p=T-&gt;lchild;<br>    <br>    <span class="hljs-comment">// 空树或遍历结束时，p==T</span><br>    <span class="hljs-keyword">while</span>(p!=T) &#123;<br>        <span class="hljs-comment">// 沿左孩子向下</span><br>        <span class="hljs-keyword">while</span>(p-&gt;LTag==<span class="hljs-number">0</span>) p=p-&gt;lchild;<br>        <span class="hljs-comment">// 访问其左子树为空的结点</span><br>        count&lt;&lt;p-&gt;data;<br>        <span class="hljs-comment">// 沿右线索访问后继结点</span><br>        <span class="hljs-keyword">while</span>(p-&gt;Rtag==<span class="hljs-number">1</span> &amp;&amp; p-&gt;rchild!=T) &#123;<br>            p=p-&gt;rchild;<br>            count&lt;&lt;p-&gt;data;<br>        &#125;<br>        <span class="hljs-comment">// 转向p的右子树</span><br>        p=p-&gt;rchild;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历线索二叉树的时间复杂度为O(n)，空间复杂度为O(1)，这是因为线索二叉树的遍历不需要使用栈来实现递归操作。</p><h2 id="三、小结">三、小结</h2><p>二叉树的遍历算法是其他运算的基础。通过遍历得到了二叉树中结点访问的线性序列，实现了非线性结构的线性化。根据访问结点的次序不同有三种遍历方法：先序遍历、中序遍历、后序遍历，时间复杂度均为O(n)。</p><p>线索二叉树利用二叉链表中的n+1个空指针域来存放指向某种遍历次序下的前驱结点和后继结点的指针，这些附加的指针就称为“线索”。引入二叉线索树的目的是加快查找结点前驱或后继的速度。</p><p><img src="/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.jpeg" alt="img"></p><h2 id="四、参考">四、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p><p><a href="https://book.douban.com/subject/35474931/">《数据结构与算法之美》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：树的基本概念</title>
    <link href="/2024/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>树结构是一类重要的非线性数据结构。直观来看，树是以分支关系定义的层次结构。</p><p>树结构在客观世界中广泛存在，如人类社会的族谱和各种社会组织机构都可用树来形象表示。树在计算机领域中也得到广泛应用，尤以二叉树最为常用。如在操作系统中，用树来表示文件目录的组织结构，在编译系统中，用树来表示源程序的语法结构，在数据库系统中，树结构也是信息的重要组织形式之一。</p><p>树这种非线性结构比线性结构要复杂得多，内容也比较多，所以这部分知识会分多篇文章来讨论。接下来，我们先从树的基本概念开始讲起。</p><h2 id="一、树">一、树</h2><h3 id="1-1、定义">1.1、定义</h3><p>树（Tree）是n（n&gt;=0）个结点的有限集，它或为空树，或为非空树。对于非空树T：</p><ul><li>有且仅有一个称之为根的结点；</li><li>除根结点以外的其余结点可分为m（m&gt;0）个互不相交的有限集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，…，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">T_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。</li></ul><p>树的结构定义是一个递归的定义，即在树的定义中又用到树的定义。如下图所示：图（a）是只有一个根结点的树；图（b）是有13个结点的树，其中A是根，其余结点可分成3个互不相交的子集：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>={B, E, F, K, L}，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>={C, G}，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">T_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>={D, H, I, J, M}。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">T_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>都是根A的子树，且本身也是一棵树。比如，在树<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中，B是根，其余结点可分成2个互不相交的子集：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>11</mn></msub></mrow><annotation encoding="application/x-tex">T_{11}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>={E, K, L}，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>12</mn></msub></mrow><annotation encoding="application/x-tex">T_{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>={F}。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>11</mn></msub></mrow><annotation encoding="application/x-tex">T_{11}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>12</mn></msub></mrow><annotation encoding="application/x-tex">T_{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>都是B的子树；而在树<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>11</mn></msub></mrow><annotation encoding="application/x-tex">T_{11}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中，E是根，{K}和{L}是E的两棵互不相交的子树，其本身又是只有一个根结点的树。</p><p><img src="/img/%E6%A0%91%E7%9A%84%E7%A4%BA%E4%BE%8B-1705826866686.jpeg" alt="img"></p><h3 id="1-2、表示方法">1.2、表示方法</h3><p>树的表示方法，除了前面所使用的树形表示法之外，还有三种常用的表示方法：嵌套集合表示法、广义表表示法和凹形表示法。如下图所示：图（a）采用的是嵌套集合表示法，即一些集合的集体，对于其中任何两个集合，或者不相交，或者一个包含另一个；图（b）采用的是广义表表示法，根作为表的名字写在表的左边；图（c）采用的是凹形表示法，类似书的编目。</p><p><img src="/img/0507d6bb3bd30e39170ce61b02491ba7-1705826872789.jpg" alt="img"></p><p>表示方法的多样化，说明了树结构在日常生活中及计算机程序设计中的重要性。一般来说，分等级的分类方案都可用层次结构来表示，也就是说，都可由一个树结构来表示。</p><h3 id="1-2、基本术语">1.2、基本术语</h3><p><img src="/img/image-20240120174516210-1705826877797.png" alt="image-20240120174516210"></p><p>下面，以上图为例，介绍树结构中的一些基本术语：</p><ul><li>结点：树中的一个独立单元。例如，在上图中有A、B、C、D等13个结点。</li><li>结点的度：结点拥有的子树数。例如，上图中A的度为3，C的度为1，F的度为0。</li><li>树的度：树内结点度的最大值。例如，上图所示树的度为3。</li><li>结点的层次：从根开始定义，根为第一层，根的孩子为第二层。树中任一结点的层次等于其双亲结点的层次加1。</li><li>树的深度（高度）：树中结点层次的最大值。例如，上图所示树的深度为4。</li><li>终端结点（叶子节点）：度为0的结点。例如，上图中的结点K、L、F、G、M、I、J都是树的叶子。</li><li>非终端结点（分支结点）：度不为0的结点。例如，上图中除K、L、F、G、M、I、J之外的结点都是非终端结点。</li><li>内部结点：除根结点和叶子结点之外的结点。例如，上图中除A、K、L、F、G、M、I、J之外的结点都是内部结点。</li><li>双亲和孩子：结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。例如，在上图中B是A的孩子，A是B的双亲。</li><li>兄弟：双亲相同的结点之间是兄弟关系。例如，上图中H、I和J互为兄弟，它们的双亲都是D。</li><li>堂兄弟：双亲互为兄弟的结点之间是堂兄弟关系。例如，上图中G与E、F、H、I、J互为堂兄弟。</li><li>祖先：从根到该结点所经分支上的所有结点。例如，上图中A、D和H都是M的祖先。</li><li>子孙：以某结点为根的子树中的任一结点都称为该结点的子孙。例如，上图中E、K、L和F都是B的子孙。</li><li>有序树和无序树：如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。</li><li>森林：m（m&gt;=0）棵互不相交的树的集合。对于树中每个结点而言，其子树的集合即为森林。</li></ul><p>就逻辑结构而言，任何一棵树都是一个二元组Tree=(root, F)，其中root是数据元素，称作树的根结点；F是m（m&gt;=0）棵树的森林，F=(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,…,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">T_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">F_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)称作根root的第i棵子树；当m≠0时，在树根和其子树森林之间存在下列关系：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mi>F</mi><mo>=</mo><mo stretchy="false">{</mo><mo>&lt;</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo>&gt;</mo><mi mathvariant="normal">∣</mi><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">(</mo><mi>m</mi><mo>&gt;</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">RF=\{ &lt;root,r_i&gt;|i=1,2,...,m(m&gt;0) \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">roo</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)}</span></span></span></span></span></p><h2 id="二、二叉树">二、二叉树</h2><h3 id="2-1、定义">2.1、定义</h3><p>二叉树（Binary Tree）是n个结点所构成的集合，它或为空树；或为非空树，对于非空树T：</p><ul><li>有且仅有一个称之为根的结点；</li><li>除根结点以外的其余结点可分为两个互不相交的子集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，分别称为T的左子树和右子树，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>本身又都是二叉树。</li></ul><p>二叉树与树一样具有递归性质，二叉树与树的区别主要有以下两点：</p><ul><li>二叉树中每个结点最多只有两颗子树（即二叉树中不存在度大于2的结点）；</li><li>二叉树的子树有左右之分，其次序不能任意颠倒。</li></ul><p>二叉树的递归定义表明二叉树或为空，或是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。由于这两棵子树也是二叉树，则由二叉树的定义可知，它们也可以是空树。由此，二叉树可以有5种基本形态，如下图所示：</p><p><img src="/img/image-20240120180029418-1705826882820.png" alt="image-20240120180029418"></p><h3 id="2-2、性质">2.2、性质</h3><blockquote><p>性质1：在二叉树的第i层上最多有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>（i&gt;=1）个结点</p></blockquote><p>该性质可用归纳法证得：</p><ul><li>当i=1时，只有一个根结点。显然，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>=1，命题成立。</li><li>现假定对所有的j（1&lt;=j&lt;i），命题是成立的，即在第j层上最多有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>个结点。那么，可以证明j=i时，命题也成立。</li><li>由归纳假设，第i-1层上最多有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>个结点。由于二叉树中每个结点的度最多2，故在第i层上结点数的最大值为第i-1层上结点数的最大值的2倍，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> * 2 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>。</li></ul><blockquote><p>性质2：在深度为k的二叉树中最多有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>（k&gt;=1）个结点</p></blockquote><p>在深度为k的二叉树中，结点数的最大值应该是该二叉树中每一层上结点数最大值的总和。由性质1可知，在深度为k的二叉树中，结点数的最大值为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup><mo>+</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo>+</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^0+2^1+···+2^{k-1}=\sum_{i=1}^k 2^{i-1}=2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9474em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9824em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord">+</span><span class="mpunct">⋅⋅⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">+</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.1138em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8747em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9824em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><blockquote><p>性质3：对任何一棵二叉树T，如果度为0的结点数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，度为2的结点数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+1</p></blockquote><p>假设在二叉树T中，度为1的结点数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。因为二叉树中所有结点的度均小于或等于2，所以二叉树T的结点总数为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>n</mi><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(公式1)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">n=n_0+n_1+n_2 \tag{公式1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord cjk_fallback">公式</span><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></p><p>再看二叉树中的分支数。除了根结点外，其余结点都有一个分支进入，假设二叉树T的分支总数为B，则n<br>=B+1。由于这些分支是由度为1或2的结点射出的，所以又有B=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+2<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。于是可得：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>n</mi><mo>=</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mn>2</mn><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(公式2)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">n=n_1+2n_2+1 \tag{公式2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span><span class="tag"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord cjk_fallback">公式</span><span class="mord">2</span></span><span class="mord">)</span></span></span></span></span></span></p><p>由公式1和公式2可得：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0=n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><blockquote><p>满二叉树</p></blockquote><p>满二叉树：一棵深度为k且有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>-1个结点的二叉树。如下图所示，是一棵深度为4的满二叉树。</p><p><img src="/img/image-20240121105800301-1705826887020.png" alt="image-20240121105800301"></p><p>满二叉树的特点是：每一层上的结点数都达到最大值，即每一层i的结点数都具有最大值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>。这也就是说，在满二叉树中，不存在度数为1的结点，且所有叶子结点都在第k层上。</p><blockquote><p>完全二叉树</p></blockquote><p>完全二叉树：若一棵深度为k的二叉树，其前k-1层是一棵满二叉树，而在第k层上所有结点都集中在该层最左边的若干位置上，则称此二叉树为完全二叉树。如下图所示，是一棵深度为4的完全二叉树。</p><p><img src="/img/image-20240121110037379-1705826890442.png" alt="image-20240121110037379"></p><p>而下图所示的两棵二叉树都不是完全二叉树。在图（a）中，最下面一层上的结点6和7都不在最左边的位置上。在图（b）中，最下面一层上的结点6不在最左边的位置上。</p><p><img src="/img/image-20240121111606790-1705826893148.png" alt="image-20240121111606790"></p><p>完全二叉树的特点是：</p><ul><li>叶子结点只可能在层次最大的两层上出现；</li><li>对任一结点，若其右分支下的子孙的最大层次为m，则其左分支下的子孙的最大层次必为m或m+1。</li></ul><blockquote><p>性质4：具有n个结点的完全二叉树的深度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor \log_2n \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⌋</span></span></span></span> + 1</p></blockquote><p>假设二叉树的深度为k，则根据完全二叉树的定义可知，它的前k-1层是深度为k-1的满二叉树，共有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{k-1}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>个结点。由于二叉树的深度为k，所以第k层上还有结点，因此该二叉树的节点数n&gt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{k-1}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。再由性质2可知n&lt;=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，所以有：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo>&lt;</mo><mi>n</mi><mo>&lt;</mo><mo>=</mo><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{k-1}-1&lt;n&lt;=2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9824em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9824em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><p>由此可推出：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>&lt;</mo><mo>=</mo><mi>n</mi><mo>&lt;</mo><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^{k-1}&lt;=n&lt;2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9382em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8991em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span></p><p>三项取对数后有k-1&lt;=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">\log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span>&lt;k，因为k为整数，所以k=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor \log_2n \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⌋</span></span></span></span> + 1</p><blockquote><p>性质5：如果对一棵有n个结点的完全二叉树（其深度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor \log_2n \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⌋</span></span></span></span> + 1）的结点按层序编号（从第1层到第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor \log_2n \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⌋</span></span></span></span> + 1层，每层从左到右），则对任一结点i（1&lt;=i&lt;=n），以下结论均成立：</p><ul><li>如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲PARENT(i)是结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mi>i</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor i/2 \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal">i</span><span class="mord">/2</span><span class="mclose">⌋</span></span></span></span>。</li><li>如果2i&gt;n，则结点i无左孩子，即结点i为叶子结点；否则其左孩子LCHILD(i)是结点2i。</li><li>如果2i+1&gt;n，则结点i无右孩子；否则其右孩子RCHILD(i)是结点2i+1。</li></ul></blockquote><p>该性质可通过下图所描述的结点与编号的对应关系直观地看出：</p><p><img src="/img/image-20240121161800426-1705826896573.png" alt="image-20240121161800426"></p><h3 id="2-3、存储结构">2.3、存储结构</h3><p>和线性表类似，二叉树的存储结构也可采用顺序存储和链式存储两种方式。</p><h4 id="2-3-1、顺序存储结构">2.3.1、顺序存储结构</h4><p>在C语言中，二叉树的顺序存储结构的类型描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 二叉树的结点数最大值</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><br><span class="hljs-comment">// 0号单元存储根结点</span><br><span class="hljs-keyword">typedef</span> TElemType SqBiTree[MAXSIZE];<br><br>SqBiTree bt;<br></code></pre></td></tr></table></figure><p>顺序存储结构使用一组地址连续的存储单元来存储数据元素，为了能够在存储结构中反映出结点之间的逻辑关系，必须将二叉树中的结点依照一定的规律安排在这组单元中。</p><p>对于完全二叉树，只要从根起按层序存储即可，依次自上而下、从左至右存储结点元素，即将完全二叉树上编号为i的结点元素存储在一维数组中下标为i−1的分量中。例如，下图（b）是下图（a）所示完全二叉树的顺序存储结构。</p><p><img src="/img/image-20240121124012724-1705826899766.png" alt="image-20240121124012724"></p><p>对于一般二叉树，采用顺序存储时，为了使用结点在数组中的相对位置来表示结点之间的逻辑关系，就必须增加一些虚结点使其成为完全二叉树的形式。例如，下图（b）是下图（a）所示一般二叉树的顺序存储结构，图中以“0”表示不存在此结点。</p><p><img src="/img/image-20240121124520361-1705826902212.png" alt="image-20240121124520361"></p><p>由此可见，顺序存储结构仅适用于完全二叉树。因为，在最坏的情况下，一个深度为k且只有k个结点的单支树（树中不存在度为2的结点）却需要长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>的一维数组。这造成了存储空间的极大浪费，所以对于一般二叉树，更适合采用链式存储结构。</p><h4 id="2-3-2、链式存储结构">2.3.2、链式存储结构</h4><p>设计不同的结点结构可构成不同形式的链式存储结构。</p><p><img src="/img/image-20240121142533136-1705826905108.png" alt="image-20240121142533136"></p><p>由二叉树的定义可知，二叉树的结点（见上图a）由一个数据元素和分别指向其左、右子树的两个分支构成，则表示二叉树的链表中的结点至少包含3个域（见上图b）：数据域和左、右指针域。有时，为了便于找到结点的双亲，还可以在结点结构中增加一个指向其双亲结点的指针域（见上图c）。使用这两种结点结构所得到的二叉树的存储结构分别称之为二叉链表和三叉链表。例如，下图a为单支树的二叉链表，下图b为非单支树的二叉链表，下图c为非单支树的三叉链表。其中，链表的头指针均指向二叉树的根结点。</p><p><img src="/img/743ce757a2413be3232e50152c78f521-1705826907901.jpg" alt="img"></p><p>二叉链表是一种常用的二叉树存储结构，在二叉树上的有关运算一般都是采用这种链式存储结构。在C语言中，二叉树的二叉链表存储结构的类型描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> &#123;</span><br>    <span class="hljs-comment">// 结点数据域</span><br>    TElemType data;<br>    <span class="hljs-comment">// 左、右孩子指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span><br>&#125;BiTNode, *BiTree;<br></code></pre></td></tr></table></figure><p>注：在不同的存储结构中，实现二叉树的操作方法也不同，如找结点x的双亲PARENT(T, e)，在三叉链表中很容易实现，而在二叉链表中则需从根指针出发巡查。由此，在具体应用中采用什么存储结构，除根据二叉树的形态之外还应考虑需进行何种操作。</p><h2 id="三、小结">三、小结</h2><p>树是一种具有层次关系的非线性数据结构。二叉树是一种最常用的树形结构，而满二叉树和完全二叉树又是两种特殊形态的二叉树；二叉树具有一些特殊的性质；二叉树有两种存储表示：顺序存储和链式存储。</p><p><img src="/img/%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.jpeg" alt="img"></p><h2 id="四、参考">四、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/35474931/">《数据结构与算法之美》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：数组和广义表</title>
    <link href="/2023/12/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
    <url>/2023/12/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>我们之前讨论的线性结构，比如顺序表、链表、栈、队列和字符串，表中的元素都只能是单个数据元素，而不能是具有某种结构的数据。其实，在众多的数据结构中，还有一类线性结构其数据元素可以是具有某种结构的数据。比如，我们今天要讨论的数组和广义表，它们都可以看成是对线性表的一种扩充。</p><h2 id="一、数组">一、数组</h2><h3 id="1-1、定义">1.1、定义</h3><p>数组是由类型相同的数据元素构成的有序集合。数组中的每个元素受n（n&gt;=1）个线性关系的约束，每个元素在n个线性关系中的序号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">i_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">i_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，…，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">i_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>称为该元素的下标，可以通过下标访问该数据元素。</p><p>数组可以看成是线性表的推广，其特点是结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型。例如，一维数组可以看成是一个线性表，二维数组可以看成数据元素是线性表的线性表。如下图所示的二维数组可以看成一个线性表：</p><p><img src="/img/image-20240114145346103.png" alt="image-20240114145346103"></p><p>其中，每个数据元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是一个行向量形式的线性表：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mn>0</mn></mrow></msub><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mspace width="1em"/><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>i</mi><mo>&lt;</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_i=(a_{i0},a_{i1},...,a_{i,n-1}) \quad 0&lt;=i&lt;m-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><p><img src="/img/image-20240114145739867.png" alt="image-20240114145739867"></p><p>或者<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>是一个列向量形式的线性表：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mn>0</mn><mi>j</mi></mrow></msub><mo separator="true">,</mo><msub><mi>a</mi><mrow><mn>1</mn><mi>j</mi></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo stretchy="false">)</mo><mspace width="1em"/><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>j</mi><mo>&lt;</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_j=(a_{0j},a_{1j},...,a_{m-1,j}) \quad 0&lt;=j&lt;n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><p><img src="/img/image-20240114145858183.png" alt="image-20240114145858183"></p><p>在C语言中，一个二维数组类型可以定义为其分量类型为一维数组类型的一维数组类型，也就是说，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> ElemType Array2[m][n];<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> ElemType Array1[n];<br><span class="hljs-keyword">typedef</span> Array1 Array2[m];<br></code></pre></td></tr></table></figure><p>同理，一个n维数组类型可以定义为其数据元素为n−1维数组类型的一维数组类型。</p><h3 id="1-2、存储结构">1.2、存储结构</h3><p>数组一般不做插入或删除操作，也就是说，一旦建立了数组，则结构中的数据元素个数和元素之间的关系就不再发生变动。因此，采用顺序存储结构表示数组比较合适。</p><p>由于存储单元是一维的结构，而数组可能是多维的结构，则用一组连续存储单元存放数组的数据元素就有次序约定问题。通常地，对二维数组可有两种存储方式，一种是以行序为主序的存储方式：</p><p><img src="/img/image-20240114160617132.png" alt="image-20240114160617132"></p><p>另一种是以列序为主序的存储方式：</p><p><img src="/img/image-20240114161247407.png" alt="image-20240114161247407"></p><p>对于数组，一旦规定了其维数和各维的长度，便可为它分配存储空间。反之，只要给出一组下标便可求得相应数组元素的存储位置。下面仅用以行序为主序的存储结构为例予以说明。假设，数组中每个数据元素占L个存储单元，则二维数组A[0… m−1, 0… n−1]（即下标从0开始，共有m行n列）中任一元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的存储位置可由下式确定：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mi>o</mi><mi>c</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mi>o</mi><mi>c</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">Loc(i,j)= Loc(0,0) + (n*i+j)*L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">oc</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">oc</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span></span></p><p>其中，Loc(i,j)是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的存储位置；Loc(0,0)是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>00</mn></msub></mrow><annotation encoding="application/x-tex">a_{00}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">00</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的存储位置，即二维数组A的起始存储位置，也称为基地址或基址。</p><h3 id="1-3、特殊矩阵的压缩存储">1.3、特殊矩阵的压缩存储</h3><p>矩阵是很多科学与工程计算问题中研究的数学对象，矩阵用二维数组来表示是最自然的方法。但是，在数值分析中经常出现一些阶数很高的矩阵，同时在矩阵中有很多值相同的元素或者是零元素。有时为了节省存储空间，可以对这类矩阵进行压缩存储。</p><p>所谓压缩存储，是指为多个值相同的元只分配一个存储空间，对零元不分配空间。</p><p>特殊矩阵，是指矩阵中值相同的元素或者零元素的分布有一定规律。特殊矩阵主要包括对称矩阵、三角矩阵和对角矩阵等，下面我们重点讨论这三种特殊矩阵的压缩存储。</p><h4 id="1-3-1、对称矩阵">1.3.1、对称矩阵</h4><p>若n阶矩阵A中的元满足下述性质：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>a</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub><mspace width="1em"/><mo stretchy="false">(</mo><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>&lt;</mo><mo>=</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_{ij}=a_{ji} \quad(1&lt;=i,j&lt;=n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ji</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p><p>则称其为n阶对称矩阵。</p><p>对于对称矩阵，可以为每一对对称元分配一个存储空间，则可将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>个元压缩存储到n(n+1)/2个元的空间中，不失一般性，可以行序为主序存储其下三角（包括对角线）中的元。</p><p>假设以一维数组sa[n(n+1)/2]作为n阶对称矩阵A的存储结构，则sa[k]和矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>之间存在着一一对应的关系：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>+</mo><mi>j</mi><mo>−</mo><mn>1</mn><mspace width="1em"/><mtext>当</mtext><mi>i</mi><mo>&gt;</mo><mo>=</mo><mi>j</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mrow><mi>j</mi><mo stretchy="false">(</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>+</mo><mi>i</mi><mo>−</mo><mn>1</mn><mspace width="1em"/><mtext>当</mtext><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">k = \begin{cases} \frac{i(i-1)}{2}+j-1\quad当i&gt;=j \\ \frac{j(j-1)}{2}+i-1\quad当i&lt;j \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.692em;"><span style="top:-3.692em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">当</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">当</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.192em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>对于任意给定的一组下标(i,j)，均可在sa中找到矩阵元<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>；反之，对所有的k=0，1，2，…，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{n(n+1)}{2}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，都能确定sa[k]中的元在矩阵中的位置(i,j)。由此，称sa[n(n+1)/2]为n阶对称矩阵A的压缩存储。</p><p><img src="/img/333b26c22242cbd4345db21b757a71ea.jpg" alt="img"></p><h4 id="1-3-2、三角矩阵">1.3.2、三角矩阵</h4><p>以主对角线划分，三角矩阵有上三角矩阵和下三角矩阵两种。上三角矩阵是指矩阵下三角（不包括对角线）中的元均为常数c或零的n阶矩阵，下三角矩阵与之相反。对三角矩阵进行压缩存储时，除了和对称矩阵一样，只存储其上（下）三角中的元素之外，再加一个存储常数c的存储空间即可。</p><p>在上三角矩阵中，sa[k]和矩阵元<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>之间的对应关系为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>+</mo><mi>j</mi><mo>−</mo><mi>i</mi><mspace width="1em"/><mtext>当</mtext><mi>i</mi><mo>&lt;</mo><mo>=</mo><mi>j</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mspace width="1em"/><mtext>当</mtext><mi>i</mi><mo>&gt;</mo><mi>j</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">k = \begin{cases} \frac{(i-1)(2n-i+2)}{2}+j-i\quad当i&lt;=j \\ \frac{n(n+1)}{2}\quad当i&gt;j \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.692em;"><span style="top:-3.692em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">当</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">当</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.192em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>在下三角矩阵中，sa[k]和矩阵元<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>之间的对应关系为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>+</mo><mi>j</mi><mo>−</mo><mn>1</mn><mspace width="1em"/><mtext>当</mtext><mi>i</mi><mo>&gt;</mo><mo>=</mo><mi>j</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mspace width="1em"/><mtext>当</mtext><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">k = \begin{cases} \frac{i(i-1)}{2}+j-1\quad当i&gt;=j \\ \frac{n(n+1)}{2}\quad当i&lt;j \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.692em;"><span style="top:-3.692em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">当</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">当</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.192em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h4 id="1-3-3、多对角线矩阵">1.3.3、多对角线矩阵</h4><p>在多对角线矩阵中，所有非零元都集中在以主对角线为中心的带状区域中，即除了主对角线上和直接在对角线上、下方若干条对角线上的元之外，所有其他的元皆为零，如下图所示。</p><p><img src="/img/8f52d609f8153d5aef7df5bbd9ec14a8.jpg" alt="img"></p><h2 id="二、广义表">二、广义表</h2><p>广义表，也称列表，它是线性表的推广。线性表的元素仅限于原子项，即每个数据元素只能是一个数或一个记录，如果放松对线性表的这种限制，允许它们自身具有结构，由此就产生了广义表的概念。</p><p>广泛地用于人工智能等领域的表处理语言LISP语言，把广义表作为基本的数据结构，就连程序也表示为一系列的广义表。</p><h3 id="2-1、定义">2.1、定义</h3><p>广义表是由n个元素组成的有限序列，一般记作</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mi>S</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LS=(a_1,a_n,...,a_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>其中，LS是广义表(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,…,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)的名称，n是其长度。在线性表的定义中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(1&lt;=i&lt;=n)只能是单个元素；而在广义表的定义中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可以是单个元素，也可以是广义表，分别称为广义表LS的原子和子表。习惯上，用大写字母表示广义表的名称，用小写字母表示原子。</p><p>广义表的定义是一个递归的定义，因为在描述广义表时又用到了广义表的概念。下面，列举一些广义表的例子。</p><ul><li>A=()，A是一个空表，其长度为0。</li><li>B=(e)，B只有一个原子e，其长度为1。</li><li>C=(a, (b, c, d))，C的长度为2，两个元素分别为原子a和子表(b, c, d)。</li><li>D=(A, B, C)，D的长度为3，3个元素都是广义表。显然，将子表的值代入后，则有D=((), (e), (a, (b, c, d)))。</li><li>E=(a, E)，E的长度为2，它是一个递归的表，相当于一个无限的广义表E=(a, (a, (a, …)))。</li></ul><p>从上述定义和例子可推出广义表的如下3个重要结论。</p><ul><li><p>广义表的元素可以是子表，而子表的元素还可以是子表……由此，广义表是一个多层次的结构，可以用图形象地表示。例如，下图表示的是广义表D，图中以圆圈表示广义表，以方块表示原子。</p><p><img src="/img/image-20240118083606712.png" alt="image-20240118083606712"></p></li><li><p>广义表可为其他广义表所共享。例如在上述例子中，广义表A、B和C为D的子表，则在D中可以不必列出子表的值，而是通过子表的名称来引用。</p></li><li><p>广义表可以是一个递归的表，即广义表也可以是其本身的一个子表。例如，表E就是一个递归的表。</p></li></ul><p>由于广义表的结构比较复杂，其各种运算的实现也不如线性表简单，其中，最重要的两个运算如下。</p><ul><li>取表头GetHead(LS)：取出的表头为非空广义表的第一个元素，它可以是一个单原子，也可以是一个子表。</li><li>取表尾GetTail(LS)：取出的表尾为除去表头之外，由其余元素构成的表。即表尾一定是一个广义表。</li></ul><p>例如：</p><ul><li>GetHead(B)=e</li><li>GetTail(B)=()</li><li>GetHead(D)=A</li><li>GetTail(D)=(B, C)</li></ul><p>由于(B, C)为非空广义表，则可继续分解得到：</p><ul><li>GetHead(B, C)=B</li><li>GetTail(B, C)=©</li></ul><p>这里需要注意的是，广义表( )和(( ))不同。前者为空表，长度n=0；后者长度n=1，可分解得到其表头、表尾均为空表( )。</p><h3 id="2-2、存储结构">2.2、存储结构</h3><p>由于广义表中的数据元素可以有不同的结构（或是原子，或是列表），因此难以用顺序存储结构表示，通常采用链式存储结构。常用的链式存储结构有两种，头尾链表的存储结构和扩展线性链表的存储结构。</p><h4 id="2-2-1、头尾链表的存储结构">2.2.1、头尾链表的存储结构</h4><p>由于广义表中的数据元素可能为原子或广义表，因此需要两种结构的结点：一种是原子结点，用以表示原子；一种是表结点，用以表示广义表。其中，一个原子结点由2个域组成：标志域和值域；一个表结点由3个域组成：标志域、指示表头的指针域和指示表尾的指针域。它们的结构如下图所示，其中tag是标志域，值为0时表示结点是原子，值为1时表示结点是子表。对于一个非空的广义表来说，它可以被分解成表头和表尾，因此，一对确定的表头和表尾可唯一确定广义表。</p><p><img src="/img/image-20240119092345537.png" alt="image-20240119092345537"></p><p>在C语言中，广义表的头尾链表存储结构的类型描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ATOM==0:原子</span><br><span class="hljs-comment">// LIST==1:子表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span>&#123;</span>ATOM,LIST&#125; ElemTag;<br><br><span class="hljs-comment">// 广义表类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GLNode</span> &#123;</span><br>    <span class="hljs-comment">// 公共部分，用于区分原子结点和表结点</span><br>    ElemTag tag;<br>    <br>    <span class="hljs-comment">// 原子结点和表结点的联合部分</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-comment">// atom是原子结点的值域，AtomType由用户定义</span><br>        AtomType atom;<br>        <span class="hljs-comment">// ptr是表结点的指针域，ptr.hp和ptr.tp分别指向表头和表尾</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GLNode</span> *<span class="hljs-title">hp</span>, *<span class="hljs-title">tp</span>;</span><br>        &#125;ptr;<br>    &#125;;<br>&#125;*GList;<br></code></pre></td></tr></table></figure><p>前面列举的广义表的例子，它们的头尾链表存储结构是这样的：</p><p><img src="/img/image-20240119095639443.png" alt="image-20240119095639443"></p><p>说明：</p><ul><li>除空表的表头指针为空外，对于任何非空广义表来说，其表头指针均指向一个表结点，且该结点中的hp域指示广义表表头（或为原子结点，或为表结点），tp域指向广义表表尾（除非表尾为空，则指针为空，否则必为表结点）。</li><li>在这种存储结构中，易分清广义表中原子和子表所在层次。比如，在广义表D中，原子a和e在同一层次上，而b、c和d在同一层次且比a和e低一层，B和C是同一层的子表。</li><li>最高层的表结点个数即为广义表的长度。</li></ul><h4 id="2-2-2、扩展线性链表的存储结构">2.2.2、扩展线性链表的存储结构</h4><p>在这种结构中，无论是原子结点还是表结点均由三个域组成，其结点结构如下图所示：</p><p><img src="/img/image-20240119092753520.png" alt="image-20240119092753520"></p><p>前面列举的广义表的例子，它们的扩展线性链表存储结构是这样的：</p><p><img src="/img/image-20240119095539126.png" alt="image-20240119095539126"></p><h2 id="三、小结">三、小结</h2><p>数组可以看成是线性表的推广，其特点是结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型。一个n维数组实质上是n个线性表的组合，其每一维都是一个线性表。数组一般采用顺序存储结构，因为物理存储是一维的，故存储多维数组时，应先将其转换为一维结构（按行转换或按列转换）。科学与工程计算中的矩阵通常用二维数组来表示，为了节省存储空间，对于几种常见形式的特殊矩阵，比如对称矩阵、三角矩阵和对角矩阵，在存储时可进行压缩存储，即为多个值相同的元只分配一个存储空间，对零元不分配空间。</p><p>广义表是另一种线性表的推广形式，表中的元素可以是称为原子的单个元素，也可以是一个子表。线性表可以看成广义表的特例，表中的元素都是称为原子的单个元素。。广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、树和有向图等各种常用的数据结构。广义表的常用操作有取表头和取表尾。广义表通常采用链式存储结构：头尾链表的存储结构和扩展线性链表的存储结构。</p><p><img src="/img/%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8.jpeg" alt="img"></p><h2 id="四、参考">四、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：字符串</title>
    <link href="/2023/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p>在计算机系统中，非数值对象大部分是字符串数据。然而，现今所使用的计算机硬件结构是面向数值计算的需要而设计的，因此，在处理字符串数据时要比处理整数和浮点数复杂得多。想要有效地处理字符串数据，就必须对字符串这个数据结构有深入的了解。</p><h2 id="一、串的定义">一、串的定义</h2><p>字符串(string)简称串，是由零个或多个字符组成的有限序列，一般记为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>s</mi><mo>=</mo><mtext>“</mtext><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>n</mi></msub><mtext>”</mtext><mo stretchy="false">(</mo><mi>n</mi><mo>&gt;</mo><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s=“a_1a_2...a_n” (n&gt;=0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">“</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">”</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span></p><p>其中，s是串的名字，用双引号括起来的字符序列是串的值；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(1&lt;=i&lt;=n)可以是字母、数字或其他字符；串中字符的个数n称为串的长度。零个字符的串称为空串（null string），其长度为零。</p><p>串中任意个连续的字符组成的子序列称为该串的子串，包含子串的串相应地称为主串。通常称字符在序列中的序号为该字符在串中的位置。子串在主串中的位置则以子串的第一个字符在主串中的位置来表示。例如，假设有如下4个串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">a=<span class="hljs-string">&quot;BEI&quot;</span>;<br>b=<span class="hljs-string">&quot;JING&quot;</span>;<br>c=<span class="hljs-string">&quot;BEIJING&quot;</span>;<br>d=<span class="hljs-string">&quot;BEI JING&quot;</span>;<br></code></pre></td></tr></table></figure><p>它们的长度分别为3、4、7和8；并且a和b都是c和d的子串，a在c和d中的位置都是1，而b在c中的位置是4，在d中的位置则是5。</p><p>当两个串的值相等时，就称这两个串是相等的。这里的相等，指的是两个串的长度相等，并且各个位置上的字符都相等。例如，上例中的串a、b、c和d彼此都不相等。</p><p>一般情况下，空格也是串中的一个元素，可以出现在其他字符中间。由一个或多个空格（“ ”）组成的串称为空格串（blank string），其长度为串中空格字符的个数。它不同于空串，为了清楚起见，通常用符号“Ø”来表示“空串”。</p><h2 id="二、串的存储结构">二、串的存储结构</h2><p>与线性表类似，串也有两种存储结构：顺序存储和链式存储。但考虑到存储效率和算法的方便性，串多采用顺序存储结构。</p><h3 id="2-1、顺序存储">2.1、顺序存储</h3><p>串的顺序存储，是指用一组地址连续的存储单元存储串值的字符序列。按照预定义的大小，为每个串变量分配一个固定长度的存储区，则可用定长数组如下描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 串的最大长度</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 255</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">// 存储串值的一维数组</span><br>    <span class="hljs-type">char</span> ch[MAXLEN+<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 串的当前长度</span><br>    <span class="hljs-type">int</span> length;<br>&#125;SString;<br></code></pre></td></tr></table></figure><p>其中，MAXLEN表示串的最大长度，ch是存储字符串的一维数组，每个分量存储一个字符，length表示字符串的当前长度。为了便于说明，在后续的算法描述当中，所用到的字符串的顺序存储都是从下标为1的数组分量开始存储的，下标为0的分量闲置不用。</p><p>上述定义方式是静态的，在编译时刻就确定了串空间的大小。而多数情况下，串的操作是以串的整体形式参与的，串变量之间的长度相差较大，在操作中字符串长度的变化也较大，这样为串变量设定固定大小的空间不尽合理。因此最好是根据实际需要，在程序执行过程中动态地分配和释放字符数组空间。</p><p>在C语言中，存在一个称之为“堆”（Heap）的自由存储区，可以用它为每个新产生的串动态分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基址，同时为了以后处理方便，约定串长也作为存储结构的一部分。这种字符串的存储方式也称为串的堆式顺序存储结构，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">// 若是非空串，则按串长分配存储区，否则ch为NULL</span><br>    <span class="hljs-type">char</span> *ch;<br>    <span class="hljs-comment">// 串的当前长度</span><br>    <span class="hljs-type">int</span> length;<br>&#125;HString;<br></code></pre></td></tr></table></figure><h3 id="2-2、链式存储">2.2、链式存储</h3><p>我们知道，顺序存储结构的插入和删除操作不方便，需要移动大量的字符。因此，可采用单链表存储串。</p><p>由于串结构的特殊性——结构中的每个数据元素是一个字符，则在用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。例如，下图（a）所示的结点大小为4（即每个结点存放4个字符），下图（b）所示的结点大小为1。当结点大小大于1时，由于串长不一定是结点大小的整倍数，则链表中的最后一个结点不一定全被串值占满，此时通常补上“#”或其他的非串值字符（通常“#”不属于串的字符集，是一个特殊的符号）。</p><p><img src="/img/ff36b52ee092a3b53ef832eea7e2da87.jpg" alt="img"></p><p>为了便于进行串的操作，当以链表存储串值时，除了设置头指针外，还可以附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度。采用这种方式定义的串存储结构被称为块链结构，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHUNKSIZE 80</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span>&#123;</span><br>    <span class="hljs-type">char</span> ch[CHUNKSIZE];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span> *<span class="hljs-title">next</span>;</span><br>&#125;Chunk;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">// 串的头、尾指针</span><br>    Chunk *head, *tail;<br>    <span class="hljs-comment">// 串的当前长度</span><br>    <span class="hljs-type">int</span> length;<br>&#125;LString;<br></code></pre></td></tr></table></figure><p>在链式存储方式中，结点大小的选择直接影响着串处理的效率。在各种串的处理系统中，所处理的串往往很长或很多，比如一本书的几百万个字符，情报资料的成千上万个条目，这就要求考虑串值的存储密度。显然，存储密度小（如结点大小为1时），运算处理方便，然而，存储占用量大。</p><p>如果在处理串的过程中，需进行内、外存交换的话，则会因为内、外存交换操作过多而影响处理的总效率。所以，串的字符集的大小也是一个重要因素。一般来说，字符集小，则字符的机内编码就短，这也影响串值存储方式的选取。</p><p>串值的链式存储结构对某些串操作，如联接操作等，有一定方便之处，但总地说来，不如顺序存储结构灵活，它占用存储量大且操作复杂。此外，采用链式存储结构时，串操作的实现和线性表在链表存储结构中的操作类似，故在此不作详细讨论。之后的模式匹配算法将采用串的定长顺序存储结构实现。</p><h2 id="三、串的模式匹配算法">三、串的模式匹配算法</h2><p>串的模式匹配，又称串匹配，它是一种子串定位运算。假设有两个字符串S和T，其中，S为主串，也称正文串；T为子串，也称为模式。在主串S中查找与模式T相匹配的子串，如果匹配成功，则返回相匹配的子串中的第一个字符在主串S中出现的位置。</p><p>串的模式匹配应用非常广泛。比如，在搜索引擎、拼写检查、语言翻译、数据压缩等应用中，都需要进行串匹配。著名的模式匹配算法有BF算法和KMP算法，接下来，我们将详细介绍这两种算法。</p><h3 id="3-1、BF算法">3.1、BF算法</h3><p>BF算法中的BF是Brute Force的缩写，将它翻译成中文就是暴力匹配算法。</p><p>BF算法是最简单、最直观的模式匹配算法。其思想可以用一句话来概括，那就是：在主串中，检查起始位置分别是1、2、3、…、n-m+1，且长度为m的n-m+1个子串，看是否有跟模式串匹配的（注：这里的n为主串的长度，m为模式串的长度）。</p><p>如下图，展示了模式T=“abcac”和主串S=“ababcabcacbab”的匹配过程：</p><p><img src="/img/image-20240106170202096.png" alt="image-20240106170202096"></p><p>说明：</p><ul><li>第1趟匹配，从主串的第1个字符开始比较，在主串的第3个字符处遇到不匹配，因此，进行第2趟匹配；</li><li>第2趟匹配，从主串的第2个字符开始比较，在主串的第2个字符处遇到不匹配，因此，进行第3趟匹配；</li><li>第3趟匹配，从主串的第3个字符开始比较，在主串的第7个字符处遇到不匹配，因此，进行第4趟匹配；</li><li>第4趟匹配，从主串的第4个字符开始比较，在主串的第4个字符处遇到不匹配，因此，进行第5趟匹配；</li><li>第5趟匹配，从主串的第5个字符开始比较，在主串的第5个字符处遇到不匹配，因此，进行第6趟匹配；</li><li>第6趟匹配，从主串的第6个字符开始比较，一直比较到模式串的末尾，也没遇到不匹配，因此匹配成功，返回。</li></ul><h4 id="3-1-1、算法描述">3.1.1、算法描述</h4><p>BF算法的实现步骤为：</p><ul><li><p>分别利用计数指针i和j指示主串S和模式T中当前正待比较的字符位置，i初值为pos，j初值为1。（注：模式匹配不一定是从主串的第一个位置开始，可以在主串中指定查找的起始位置pos。）</p></li><li><p>如果两个串均未比较到串尾，即i和j均分别小于等于S和T的长度时，则循环执行以下操作：</p><ul><li><a href="http://xn--S-c48b182h.ch">比较S.ch</a>[i]<a href="http://xn--S-re9a.ch">和S.ch</a>[j]，若相等，则i和j分别指示串中下一个位置，继续比较后续字符；</li><li>若不等，则指针后退重新进行下一趟，即从主串的下一个字符（i=i-j+2）起再重新和模式的第一个字符（j=1）比较。</li></ul></li><li><p>如果j&gt;T.length，说明模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则匹配成功，返回和模式T中第一个字符相等的字符在主串S中的序号（i-T.length）；否则称匹配不成功，返回0。</p></li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 从主串S的第pos个字符开始，查找第一次出现模式T的位置。若不存在，则返回值为0</span><br><span class="hljs-comment">// 其中，T非空，1&lt;=pos&lt;=S.length</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Index_BF</span><span class="hljs-params">(SString S, SString T, <span class="hljs-type">int</span> pos)</span> &#123;<br>    <span class="hljs-comment">// i初始为pos，j初始为1</span><br>    i=pos; j=<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// 两个串均未比较到串尾</span><br>    <span class="hljs-keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length) &#123;<br>        <span class="hljs-comment">// 继续比较后续字符</span><br>        <span class="hljs-keyword">if</span>(S.ch[i]==T.ch[j]) &#123;++i;++j;&#125;<br>        <span class="hljs-comment">// 出现不匹配，指针后退，进行下一趟匹配</span><br>        <span class="hljs-keyword">else</span> &#123;i=i-j+<span class="hljs-number">2</span>;j=<span class="hljs-number">1</span>;&#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 匹配成功</span><br>    <span class="hljs-keyword">if</span>(j&gt;T.length) <span class="hljs-keyword">return</span> i-T.length;<br>    <span class="hljs-comment">// 匹配失败</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-2、复杂度分析">3.1.2、复杂度分析</h4><p>BF算法的匹配过程易于理解，且在某些应用场合效率也较高。在匹配成功的情况下，考虑以下两种极端情况。</p><p>（1）最好情况下，每趟不成功的匹配都发生在模式串的第一个字符与主串中相应字符的比较。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">S=<span class="hljs-string">&quot;aaaaaba&quot;</span>;<br>T=<span class="hljs-string">&quot;ba&quot;</span>;<br></code></pre></td></tr></table></figure><p>设主串的长度为n ，子串的长度为m ，假设从主串的第i 个位置开始与模式串匹配成功，则在前i −1趟匹配中字符总共比较了i −1次；第i 趟成功的字符比较次数为m ，则总比较次数为i −1+m 。对于成功匹配的主串，其起始位置的范围是1到n −m +1，假定这n −m +1个起始位置上的匹配成功概率相等，则最好的情况下匹配成功的平均比较次数为</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow></munderover><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow></munderover><mi>i</mi><mo>−</mo><mn>1</mn><mo>+</mo><mi>m</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{i=1}^{n-m+1} p_i(i-1+m) = \frac{1}{n-m+1}\sum_{i=1}^{n-m+1} i-1+m = \frac{1}{2} (n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">m</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">m</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span></p><p>即最好情况下的平均时间复杂度是O(n+m)。</p><p>（2）最坏情况下，每趟不成功的匹配都发生在模式串的最后一个字符与主串中相应字符的比较。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">S=<span class="hljs-string">&quot;aaaaaab&quot;</span>;<br>T=<span class="hljs-string">&quot;aab&quot;</span>;<br></code></pre></td></tr></table></figure><p>假设从主串的第i 个位置开始与模式串匹配成功，则在前i −1趟匹配中字符总共比较了(i −1) *m 次；第i 趟成功的字符比较次数为m ，则总比较次数i*m 。因此最坏情况下匹配成功的平均比较次数为</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow></munderover><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow></munderover><mi>i</mi><mo>∗</mo><mi>m</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>m</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{i=1}^{n-m+1} p_i(i*m) = \frac{1}{n-m+1}\sum_{i=1}^{n-m+1} i*m = \frac{1}{2}m*(n-m+2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">m</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">m</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span></p><p>即最坏情况下的平均时间复杂度是O(n*m)。</p><h4 id="3-1-3、小结">3.1.3、小结</h4><p>BF算法思路直观简明。但当匹配失败时，主串的指针i 总是回溯到i-j+2位置，模式串的指针总是恢复到首字符位置j=1，因此，算法时间复杂度高。</p><p>尽管理论上，BF 算法的时间复杂度很高，是 O(n*m)，但在实际的开发中，它却是一个比较常用的字符串匹配算法。为什么这么说呢？原因有两点。</p><ul><li>第一，实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把 m 个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是 O(n*m)，但是，统计意义上，大部分情况下，算法执行效率接近于O(n+m )。</li><li>第二，暴力字符串匹配算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有 bug 也容易暴露和修复。在工程中，在满足性能要求的前提下，简单是首选。这也是我们常说的KISS（Keep it Simple and Stupid）设计原则。</li></ul><h3 id="3-2、KMP算法">3.2、KMP算法</h3><p>KMP算法是由克努特（Knuth）、莫里斯（Morris）和普拉特（Pratt）共同设计实现的，因此简称为KMP算法。</p><h4 id="3-2-1、核心思想">3.2.1、核心思想</h4><p>KMP算法的核心思想是：每当一趟匹配过程中出现字符比较不等时，不回溯主串指针，而是利用已经得到的“部分匹配”的结果将模式串向右“滑动”尽可能远的一段距离后，继续进行比较。</p><p>下面，我们先从具体的例子看起。</p><p><img src="/img/image-20240106170202096.png" alt="image-20240106170202096"></p><p>回顾BF算法中的匹配示例，在第三趟匹配中，当i=7、j=5字符比较不等时，又从i=4、j=1重新开始比较。</p><p>经仔细观察可发现，i=4和j=1，i=5和j=1，以及i=6和j=1这3次比较都是不必进行的。因为从第三趟的部分匹配结果就可得出，主串中第4个、第5个和第6个字符必然是“b”、“c”和“a”（即模式串中第2个、第3个和第4个字符）。而模式中的第一个字符是“a”，所以它无需再和这3个字符进行比较，仅需将模式向右滑动3个字符的位置继续进行i=7、j=2时的字符比较即可。</p><p>同理，在第一趟匹配中出现字符不等时，仅需将模式向右移动两个字符的位置继续进行i=3、j=1时的字符比较。由此，在整个匹配过程中，指针i没有回溯。整个匹配过程如下所示：</p><p><img src="/img/image-20240106210250239.png" alt="image-20240106210250239"></p><h4 id="3-2-2、基本原理">3.2.2、基本原理</h4><p>现在讨论一般情况。假设主串为&quot;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">s_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">s_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>…<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">s_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> &quot;，模式串为&quot;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>…<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">t_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> &quot;，从上面的分析可知，为了实现改进算法，需要解决一个问题：当匹配过程中产生“失配”（即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>不等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ）时，模式串可“向右滑动”的距离有多远。换句话说，当主串中第i个字符与模式串中第j个字符“失配”（即比较不等）时，主串中第i个字符应与模式串中的哪个字符再比较？</p><p>假设此时应与模式串中第k（k&lt;j ）个字符继续比较，则模式串中前k - 1个字符子串必须满足下列关系式，且不可能存在k’ &gt;k 满足下列关系式：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>“</mtext><msub><mi>s</mi><mrow><mi>i</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>s</mi><mrow><mi>i</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>s</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mtext>”</mtext><mo>=</mo><mtext>“</mtext><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mtext>”</mtext></mrow><annotation encoding="application/x-tex">“s_{i-k+1}s_{i-k+2}...s_{i-1}”=“t_{1}t_{2}...t_{k-1}”</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9028em;vertical-align:-0.2083em;"></span><span class="mord">“</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord">”</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9028em;vertical-align:-0.2083em;"></span><span class="mord">“</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord">”</span></span></span></span></span></p><p>而已经得到的“部分匹配”的结果是</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>“</mtext><msub><mi>s</mi><mrow><mi>i</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>s</mi><mrow><mi>i</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>s</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mtext>”</mtext><mo>=</mo><mtext>“</mtext><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mtext>”</mtext></mrow><annotation encoding="application/x-tex">“s_{i-k+1}s_{i-k+2}...s_{i-1}”=“t_{j-k+1}t_{j-k+2}...t_{j-1}”</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9028em;vertical-align:-0.2083em;"></span><span class="mord">“</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord">”</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord">“</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">”</span></span></span></span></span></p><p>由以上两式可推得下列等式</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>“</mtext><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mtext>”</mtext><mo>=</mo><mtext>“</mtext><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mtext>”</mtext></mrow><annotation encoding="application/x-tex">“t_{1}t_{2}...t_{k-1}”=“t_{j-k+1}t_{j-k+2}...t_{j-1}”</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9028em;vertical-align:-0.2083em;"></span><span class="mord">“</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord">”</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord">“</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">”</span></span></span></span></span></p><p>这也就是说，若模式串中存在两个子串满足该关系式，则当匹配过程中，主串中第i个字符与模式串中第j个字符比较不等时，仅需将模式串向右滑动至模式串中第k个字符和主串中第i个字符对齐，此时，模式串中前k −1个字符的子串&quot;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>…<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">t_{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8234em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> &quot;必定与主串中第i个字符之前长度为k −1的子串“<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>i</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">t_{i-k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8234em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>i</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">t_{i-k+2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8234em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>…<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">t_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8234em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>”相等，由此，匹配仅需从模式串中第k个字符与主串中第i个字符开始，依次向后进行比较。</p><p>若令next[j]=k，则next[j]表明当模式串中第j个字符与主串中相应字符“失配”时，在模式串中需重新和主串中该字符进行比较的字符的位置。由此，可引出模式串的next函数的定义：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mspace width="1em"/><mo stretchy="false">(</mo><mtext>“部分匹配”结果为空，即</mtext><msub><mi>t</mi><mn>1</mn></msub><mtext>与</mtext><msub><mi>s</mi><mi>i</mi></msub><mtext>不等，下一步进行</mtext><msub><mi>t</mi><mn>1</mn></msub><mtext>与</mtext><msub><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mtext>的比较</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mspace width="1em"/><mo stretchy="false">(</mo><mtext>“部分匹配”结果中，不存在相同的子串，下一步进行</mtext><msub><mi>t</mi><mn>1</mn></msub><mtext>和</mtext><msub><mi>s</mi><mi>i</mi></msub><mtext>的比较</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mi>k</mi><mi mathvariant="normal">∣</mi><mn>1</mn><mo>&lt;</mo><mi>k</mi><mo>&lt;</mo><mi>j</mi><mo stretchy="false">}</mo><mspace width="1em"/><mo stretchy="false">(</mo><mtext>“部分匹配”结果中，存在相同的子串，且</mtext><mi>k</mi><mtext>满足“</mtext><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mtext>”</mtext><mo>=</mo><mtext>“</mtext><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mtext>”，下一步进行</mtext><msub><mi>t</mi><mi>k</mi></msub><mtext>与</mtext><msub><mi>S</mi><mi>i</mi></msub><mtext>的比较）</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">next[j] = \begin{cases} 0\quad(“部分匹配”结果为空，即t_1与s_i不等，下一步进行t_1与s_{i+1}的比较) \\ 1\quad(“部分匹配”结果中，不存在相同的子串，下一步进行t_1和s_i的比较) \\ Max\{k|1&lt;k&lt;j\}\quad(“部分匹配”结果中，存在相同的子串，且k满足“t_{1}t_{2}...t_{k-1}”=“t_{j-k+1}t_{j-k+2}...t_{j-1}”，下一步进行t_k与S_i的比较） \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.91em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em;"><span style="top:-2.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.192em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.316em" style="width:0.8889em" viewBox="0 0 888.89 316" preserveAspectRatio="xMinYMin"><path d="M384 0 H504 V316 H384z M384 0 H504 V316 H384z"/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.316em" style="width:0.8889em" viewBox="0 0 888.89 316" preserveAspectRatio="xMinYMin"><path d="M384 0 H504 V316 H384z M384 0 H504 V316 H384z"/></svg></span></span><span style="top:-4.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord">“</span><span class="mord cjk_fallback">部分匹配</span><span class="mord">”</span><span class="mord cjk_fallback">结果为空，即</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">与</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">不等，下一步进行</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">与</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">的比较</span><span class="mclose">)</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord">“</span><span class="mord cjk_fallback">部分匹配</span><span class="mord">”</span><span class="mord cjk_fallback">结果中，不存在相同的子串，下一步进行</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">和</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">的比较</span><span class="mclose">)</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">∣1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">}</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord">“</span><span class="mord cjk_fallback">部分匹配</span><span class="mord">”</span><span class="mord cjk_fallback">结果中，存在相同的子串，且</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">满足</span><span class="mord">“</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord">”</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">“</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">”</span><span class="mord cjk_fallback">，下一步进行</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">与</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">的比较）</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>由此定义可推出模式串的next函数值，如下示例：</p><p><img src="/img/%E6%A8%A1%E5%BC%8F%E4%B8%B2.jpeg" alt="img"></p><p>说明：</p><ul><li>当j=1时，“部分匹配”结果为空，因此下一步进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">s_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>的比较；</li><li>当j=2时，“部分匹配”结果中不存在相同的子串，因此下一步进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的比较；</li><li>当j=3时，“部分匹配”结果中不存在相同的子串，因此下一步进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的比较；</li><li>当j=4时，“部分匹配”结果中存在一个最长前缀子串”a“和一个最长后缀子串&quot;a&quot;相等，因此下一步进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的比较；</li><li>当j=5时，“部分匹配”结果中存在一个最长前缀子串”a“和一个最长后缀子串&quot;a&quot;相等，因此下一步进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的比较；</li><li>当j=6时，“部分匹配”结果中存在一个最长前缀子串”ab“和一个最长后缀子串&quot;ab&quot;相等，因此下一步进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">t_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的比较；</li><li>当j=7时，“部分匹配”结果中不存在相同的子串，因此下一步进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的比较；</li><li>当j=8时，“部分匹配”结果中存在一个最长前缀子串”a“和一个最长后缀子串&quot;a&quot;相等，因此下一步进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的比较；</li></ul><h4 id="3-2-3、算法描述">3.2.3、算法描述</h4><p>有了模式串的next函数之后，匹配过程可按如下步骤进行：</p><ul><li>以指针i和j分别指示主串和模式串中正待比较的字符，令i的初值为pos，j 的初值为1；</li><li>如果两个串均未比较到串尾，即i和j均分别小于等于主串和模式串的长度时，则循环执行以下操作：<ul><li>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">t_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>，则i和j分别增1，</li><li>否则，i不变，而j退到next[j]的位置再比较；再比较时若相等，则指针各自增1，否则j再退到下一个next值的位置；依次类推，直至下列两种情况：<ul><li>j 退到某个next值时字符比较相等，则指针各自增1，继续进行匹配</li><li>j 退到值为零（即模式串的第一个字符“失配”），则此时需将模式串继续向右滑动一个位置，即从主串的下一个字符<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">s_{i +1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> 起和模式串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>重新开始匹配。</li></ul></li></ul></li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 利用模式串T的next函数求T在主串S中第pos个字符之后的位置</span><br><span class="hljs-comment">// 其中，T非空，1&lt;=pos&lt;=S.length</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Index_KMP</span><span class="hljs-params">(SString S, SString T, <span class="hljs-type">int</span> pos)</span> &#123;<br>    i=pos; j=<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=S.length) &#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span> || S.ch[i]==T.ch[j]) &#123;++i;++j;&#125;<br>        <span class="hljs-keyword">else</span> j=next[j];<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(j&gt;T.length) <span class="hljs-keyword">return</span> i-T.length;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>KMP算法在形式上和BF算法极为相似。不同之处仅在于：当匹配过程中产生“失配”时，指针i不变，指针j退回到next[j]所指示的位置上重新进行比较，并且当指针j退至零时，指针i和指针j需同时增1，即若主串的第i个字符和模式的第1个字符不等，应从主串的第i+1个字符起重新进行匹配。KMP算法的匹配过程如下所示：</p><p><img src="/img/image-20240107145814399.png" alt="image-20240107145814399"></p><p>说明：</p><ul><li>在第1趟匹配中，从i=1，j=1开始进行匹配，当i=2，j=2时出现不匹配，因此，进行第2趟匹配；</li><li>第2趟匹配，从i=2（指针i不变），j=1(next[2]=1)开始匹配，当i=2，j=1时出现不匹配，因此，进行第3趟匹配；</li><li>因为在第2趟匹配中，j=1时出现不匹配，所以第3趟匹配从i=3（指针i不变），j=1开始，直到i=8，j=6时出现不匹配，因此，进行第4趟匹配；</li><li>第4趟匹配，从i=8（指针i不变），j=3(next[6]=1)开始匹配，一直比较到了模式串的末尾，匹配成功，返回。</li></ul><h4 id="3-2-4、next函数">3.2.4、next函数</h4><p>KMP算法是在已知模式串的next函数值的基础上执行的，那么，该如何求得模式串的next函数值呢？</p><p>从上述讨论可知，next函数值仅取决于模式串本身，和相匹配的主串无关。因此，可从分析next函数的定义出发，用递推的方法求得next函数值。</p><p>由定义可知：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(等式1)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">next[1]=0 \tag{等式1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span><span class="tag"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord cjk_fallback">等式</span><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></p><p>设next[j]=k，这表明在模式串中存在下列关系：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>“</mtext><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mtext>”</mtext><mo>=</mo><mtext>“</mtext><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mtext>”</mtext></mrow><annotation encoding="application/x-tex">“t_{1}t_{2}...t_{k-1}”=“t_{j-k+1}t_{j-k+2}...t_{j-1}”</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9028em;vertical-align:-0.2083em;"></span><span class="mord">“</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord">”</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord">“</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">”</span></span></span></span></span></p><p>其中k 为1&lt;k &lt;j 的某个值，并且不可能存在k '&gt;k 满足该等式。此时next[j+1]的值可能有以下两种情况。</p><p>（1）若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">t_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">t_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> ，则表明在模式串中</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>“</mtext><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><mi>k</mi></msub><mtext>”</mtext><mo>=</mo><mtext>“</mtext><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><mi>j</mi></msub><mtext>”</mtext></mrow><annotation encoding="application/x-tex">“t_{1}t_{2}...t_k”=“t_{j-k+1}t_{j-k+2}...t_j”</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord">“</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">”</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord">“</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">”</span></span></span></span></span></p><p>并且不可能存在k '&gt;k 满足该等式，这就是说next[j+1]=k+1，即</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(等式2)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">next[j+1]=next[j]+1 \tag{等式2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span><span class="tag"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord cjk_fallback">等式</span><span class="mord">2</span></span><span class="mord">)</span></span></span></span></span></span></p><p>（2）若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">t_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ≠<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">t_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>  ，则表明在模式串中</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>“</mtext><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><mi>k</mi></msub><mtext>”</mtext><mo mathvariant="normal">≠</mo><mtext>“</mtext><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><mi>j</mi></msub><mtext>”</mtext></mrow><annotation encoding="application/x-tex">“t_{1}t_{2}...t_k”≠“t_{j-k+1}t_{j-k+2}...t_j”</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">“</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">”</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord">“</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">”</span></span></span></span></span></p><p>此时可把求next函数值的问题看成是一个模式匹配的问题，整个模式串既是主串又是模式串，而在当前的匹配过程中，已有&quot;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">t_{j-k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">t_{j-k+2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>…<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">t_{j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> &quot;=&quot;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>…<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">t_{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8234em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> &quot;，则当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">t_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> ≠<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">t_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时应将模式串向右滑动至以模式串中的第next[k]个字符和主串中的第j个字符相比较。</p><p>若next[k]=k’ ，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">t_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> =<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><msup><mi>k</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub></mrow><annotation encoding="application/x-tex">t_{k&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，则说明在主串中第j+1个字符之前存在一个长度为k’ （即next[k]）的最长子串，和模式串中从首字符起长度为k '的子串相等，即</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mtext>“</mtext><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><msup><mi>k</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mtext>”</mtext><mo>=</mo><mtext>“</mtext><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><msup><mi>k</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><msup><mi>k</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>+</mo><mn>2</mn></mrow></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><mi>j</mi></msub><mtext>”</mtext><mspace width="1em"/><mo stretchy="false">(</mo><mn>1</mn><mo>&lt;</mo><msup><mi>k</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>&lt;</mo><mi>k</mi><mo>&lt;</mo><mi>j</mi><mo stretchy="false">)</mo></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(等式3)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">“t_{1}t_{2}...t_{k&#x27;}”=“t_{j-k&#x27;+1}t_{j-k&#x27;+2}...t_j”\quad(1&lt;k&#x27;&lt;k&lt;j) \tag{等式3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord">“</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">”</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord">“</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">”</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.841em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span><span class="tag"><span class="strut" style="height:1.088em;vertical-align:-0.2861em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord cjk_fallback">等式</span><span class="mord">3</span></span><span class="mord">)</span></span></span></span></span></span></p><p>这也就是说next[j +1]=k’ +1，即</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(等式4)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">next[j+1] = next[k]+1 \tag{等式4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span><span class="tag"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord cjk_fallback">等式</span><span class="mord">4</span></span><span class="mord">)</span></span></span></span></span></span></p><p>同理，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">t_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>≠<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><msup><mi>k</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub></mrow><annotation encoding="application/x-tex">t_{k&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，则将模式串继续向右滑动直至模式串中第next[k’]个字符和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">t_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>对齐，…，依次类推，直至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">t_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>和模式串中某个字符匹配成功或者不存在任何k’  (1&lt;k’ &lt;j ) 满足等式3，则</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(等式5)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">next[j+1]=1 \tag{等式5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span><span class="tag"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord cjk_fallback">等式</span><span class="mord">5</span></span><span class="mord">)</span></span></span></span></span></span></p><p>如下所示的模式串，已求得前6个字符的next函数值，现求next[7]，因为next[6]=3，又因<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">t_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>≠<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">t_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，则需比较<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">t_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（因为next[3]=1），这相当于将子串模式向右滑动。由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">t_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>≠<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，且next[1]=0，所以next[7]=1，而因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>7</mn></msub></mrow><annotation encoding="application/x-tex">t_7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则next[8]=2。</p><p><img src="/img/fb68196cb43b1678931b9a55cabab5e2.jpg" alt="img"></p><p>根据上述分析所得结果(即等式1、等式2、等式4和等式5)，仿照KMP算法，可得到求next函数值的算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 求模式串T的next函数值，并将其存入数组next</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_next</span><span class="hljs-params">(SString T, <span class="hljs-type">int</span> next[])</span> &#123;<br>    i=<span class="hljs-number">1</span>; next[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>; j=<span class="hljs-number">0</span>;<br>    <br>    whlie(i&lt;T.length) &#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span> || T.ch[i]==T.ch[j]) &#123;++i;++j;next[i]=j;&#125;<br>        <span class="hljs-keyword">else</span> j=next[j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该算法的时间复杂度为O(m)。通常，模式串的长度m比主串的长度n要小得多，因此，对整个匹配算法来说，增加的这点时间是值得的。</p><p>这里我们要注意的是，上述next函数在某些情况下存在效率问题。例如模式串“aaaab”在和主串“aaabaaaab”匹配时，当i=4、<a href="http://j=4%E6%97%B6s.ch">j=4时s.ch</a>[4]<a href="http://xn--t-tfo.ch">≠t.ch</a>[4]，根据next[j]的值还需进行i=4和j=3、i=4和j=2、i=4和j=1这3次比较。但实际上，因为在模式串中第1～3个字符和第4个字符都相等，因此模式串中第1～3个字符不需要再和主串中第4个字符相比较，而可以将模式串连续向右滑动4个字符的位置直接进行i=5、j=1时的字符比较。</p><p>这就是说，若按上述定义得到next[j]=k ，而模式中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">t_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">t_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，则当主串中字符<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">t_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>比较不等时，不需要再和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">t_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>进行比较，而直接和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow></msub></mrow><annotation encoding="application/x-tex">t_{next[k]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9703em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">t</span><span class="mopen mtight">[</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span></span></span></span>进行比较，换句话说，此时的next[j]应和next[k]相同。由此可得计算next函数修正值的算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 求模式串T的next函数修正值，并将之存入数组nextval</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_nextval</span><span class="hljs-params">(SString T, <span class="hljs-type">int</span> nextval[])</span> &#123;<br>    i=<span class="hljs-number">1</span>; nextval[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>; j=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(i&lt;T.length) &#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span> || T.ch[i]==T.ch[j]) &#123;<br>            ++i;++j;<br>            <span class="hljs-keyword">if</span>(T.ch[i]!=T.ch[j]) nextval[i]=j;<br>            <span class="hljs-keyword">else</span> nextval[i]=nextval[j];<br>        &#125; <br>        <span class="hljs-keyword">else</span> j=nextval[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如下示例，是next函数修正值的计算结果：</p><p><img src="/img/61dc27765d7e9f9cd7b7f5d9c1e2b8f5.jpg" alt="img"></p><h4 id="3-2-5、复杂度分析">3.2.5、复杂度分析</h4><p>KMP 算法只需要一个额外的 next 数组，数组的大小跟模式串相同。所以空间复杂度是 O(m)，m 表示模式串的长度。</p><p>KMP 算法包含两部分，第一部分是构建 next 数组，第二部分才是借助 next 数组匹配。所以，关于时间复杂度，我们要分别从这两部分来分析。</p><ul><li>计算next数组的代码的时间复杂度和模式串的长度（假设为m）有关，其时间复杂度是 O(m)。</li><li>借助next数组匹配的时间复杂度和主串的长度（假设为n）有关，其时间复杂度是 O(n)。</li></ul><p>所以，综合两部分的时间复杂度，KMP算法的时间复杂度就是O(m+n)。</p><h4 id="3-2-6、小结">3.2.6、小结</h4><p>KMP算法仅当模式与主串之间存在许多“部分匹配”的情况下，才显得比BF算法快得多。KMP算法的最大特点是指示主串的指针不需回溯，整个匹配过程中，对主串仅需从头至尾扫描一遍，这对处理从外设输入的庞大文件很有效，可以边读入边匹配，而无需回头重读。</p><h2 id="四、总结">四、总结</h2><p>串是一种特殊的线性表，其特殊性体现在数据元素是一个字符，也就是说，串是一种内容受限的线性表，它限定了表中的元素为字符。串有两种基本存储结构：顺序存储和链式存储，但多采用顺序存储结构。串的常用算法是模式匹配算法，主要有BF算法和KMP算法。BF算法实现简单，但存在回溯，效率低，时间复杂度为O(m*n)。KMP算法对BF算法进行改进，消除回溯，提高了效率，时间复杂度为O(m+n)。</p><p><img src="/img/%E5%AD%97%E7%AC%A6%E4%B8%B2.jpeg" alt="img"></p><h2 id="五、参考">五、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/35474931/">《数据结构与算法之美》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：队列</title>
    <link href="/2023/12/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E9%98%9F%E5%88%97/"/>
    <url>/2023/12/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>和栈类似，队列也是一个特殊的线性表。队列在计算机系统中也有着广泛的应用。例如，在操作系统中，队列可以用于进程调度，确保按照先来先服务的原则进行任务分配。在网络通信中，队列可以用于缓存数据包，以平衡发送和接收之间的速度差异。在计算机算法中，队列可以用于广度优先搜索等算法的实现。</p><p>队列是一个很基础的数据结构，因此也需掌握。</p><h2 id="一、定义和特点">一、定义和特点</h2><p>队列（Queue）是限定在表头删除、表尾插入的线性表。对于队列来说，允许删除的一端称为队头（front），允许插入的一端称为队尾（rear）。</p><p>队列的操作具有先进先出的特点。因此，队列又被称作FIFO（First In First Out）表。假设队列Q=(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, …, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)，若队列中元素是按<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, …, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的顺序依次入队的，则称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为队头元素，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为队尾元素。其出队次序也只能<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, …, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的次序进行，也就是说，只有在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, …, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>都离开队列之后，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>才能出队。队列的这个特点，和日常生活中的排队场景是一致的，最早进入队的最先离开。</p><p><img src="/img/43f90e5e7bf767520fb277962235718c.jpg" alt="img"></p><p>同样地，队列也有两种存储结构，分别是顺序队列和链式队列。</p><h2 id="二、顺序队列">二、顺序队列</h2><p>顺序队列，是指采用顺序存储结构实现的队列。</p><p>在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队头到队尾的元素之外，还需附设两个整型变量front和rear分别指示队头元素及队尾元素的位置。通常，front被称为头指针，rear被称为尾指针。</p><p>在C语言中，顺序队列的类型描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 队列可能达到的最大长度</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">// 存储空间的基地址</span><br>    QElemType *base;<br>    <span class="hljs-comment">// 头指针</span><br>    <span class="hljs-type">int</span> front;<br>    <span class="hljs-comment">// 尾指针</span><br>    <span class="hljs-type">int</span> rear;<br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><p>为了描述方便起见，在此约定：初始化创建空队列时，令front=rear=0，每当插入新的队尾元素时，尾指针rear增1；每当删除队头元素时，头指针front增1。因此，在非空队列中，头指针始终指向队头元素，而尾指针始终指向队尾元素的下一个位置，其结构如下图所示：</p><p><img src="/img/image-20231223175506541.png" alt="image-20231223175506541"></p><p>假设当前队列分配的最大空间为6，则当队列处于上图（d）所示的状态时，就不可再继续插入新的队尾元素，否则会出现溢出现象，即因数组越界而导致程序的非法操作错误。事实上，此时队列的实际可用空间并未占满，所以这种现象称为“假溢出”。这是由“队尾入队，队头出队”这种受限制的操作造成的。</p><p>那么，如何解决这种“假溢出”问题呢？一个较巧妙的办法是将顺序队列变为一个环状的空间，使之成为一个循环队列。</p><p><img src="/img/edf37fb6e05c4b266011746af5060a08.jpg" alt="img"></p><p>和顺序队列一样，在循环队列中，头、尾指针以及队列元素之间的关系不变。只是，头、尾指针增1的操作用“模”运算来实现。通过取模，头指针和尾指针就可以在顺序表空间内以头尾衔接的方式“循环”移动。</p><p><img src="/img/image-20231223180634481.png" alt="image-20231223180634481"></p><p>在上图（a）中，队头元素是J5，在元素J6入队之前，Q.rear的值为5，而当元素J6入队之后，通过“模”运算<code>Q.rear=(Q.rear+1)%6</code>，得到Q.rear的值为0。这样就不会出现“假溢出”现象。</p><p>上图（b）是J7、J8、J9、J10相继进入图（a）所示队列后的状态：队列空间被占满，此时头、尾指针相同。上图（c）是J5、J6相继从图（a）所示的队列中出队后的状态：队列为空，头、尾指针的值也是相同的。由此可见，对于循环队列不能以头、尾指针的值是否相同来判别队列空间是“满”还是“空”。在这种情况下，如何区别队满还是队空呢？通常有以下两种处理方法：</p><ul><li>少用一个元素空间。当队列空间大小为m时，有m-1个元素就认为是队满。这样判断队空的条件不变，即当头、尾指针的值相同时，则认为队空；而当尾指针在循环意义上加1后是等于头指针，则认为队满。因此，在循环队列中队空和队满的条件是：<ul><li>队空的条件：<code>Q.rear==Q.front</code></li><li>队满的条件：<code>(Q.rear+1)%MAXQSIZE==Q.front</code>。如上图（d）是J7、J8、J9进入图（a）所示的队列后d的状态，<code>(Q.rear+1)%MAXQSIZE</code>的值等于Q.front，此时认为队满。</li></ul></li><li>另设一个标志位。就是单独设置一个区别队列是“空”还是“满”的标志位。</li></ul><p>一般情况下，真正使用的顺序队列是循环队列。循环队列的类型定义和顺序队列的类型定义是相同的。下面，以“少用一个元素空间”的方法为例，实现循环队列的一些操作。</p><h3 id="2-1、初始化">2.1、初始化</h3><p>循环队列的初始化操作就是动态分配一个预定义大小为MAXQSIZE的数组空间。该算法步骤为：</p><ul><li>为队列分配一个最大容量为MAXQSIZE的数组空间，base指向数组空间的首地址。</li><li>头指针和尾指针置为零，表示队列为空。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span> &#123;<br>    Q.base=new QElemType[MAXQSIZE];<br>    <span class="hljs-keyword">if</span>(!Q.base) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    Q.front=Q.rear=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2、求队列长度">2.2、求队列长度</h3><p>对于非循环队列，尾指针和头指针的差值便是队列长度，而对于循环队列，差值可能为负数，所以需要将差值加上MAXQSIZE，然后与MAXQSIZE求余。相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">QueueLength</span><span class="hljs-params">(SqQueue Q)</span> &#123;<br>    <span class="hljs-keyword">return</span> (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3、入队">2.3、入队</h3><p>入队操作是指在队尾插入一个新的元素。该算法步骤为：</p><ul><li>判断队列是否满，若满则返回ERROR。</li><li>将新元素插入队尾。</li><li>队尾指针加1。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 插入元素e为Q的新的队尾元素</span><br>Status <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q, QElemType e)</span> &#123;<br>    <span class="hljs-comment">// 尾指针在循环意义上加1后等于头指针，表明队满</span><br>    <span class="hljs-keyword">if</span>((Q.rear+<span class="hljs-number">1</span>)%MAXQSIZE==Q.front)<br>        <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-comment">// 新元素插入队尾</span><br>    Q.base[Q.rear]=e;<br>    <span class="hljs-comment">// 队尾指针加1</span><br>    Q.rear=(Q.rear+<span class="hljs-number">1</span>)%MAXQSIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4、出队">2.4、出队</h3><p>出队操作是将队头元素删除。该算法步骤为：</p><ul><li>判断队列是否为空，若空则返回ERROR。</li><li>保存队头元素。</li><li>队头指针加1。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q, QElemType &amp;e)</span> &#123;<br>    <span class="hljs-comment">// 队空</span><br>    <span class="hljs-keyword">if</span>(Q.front==Q.rear) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">// 保存队头元素</span><br>    e=Q.base[Q.front];<br>    <span class="hljs-comment">// 队头指针加1</span><br>    Q.front=(Q.front+<span class="hljs-number">1</span>)%MAXQSIZE;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5、取队头元素">2.5、取队头元素</h3><p>当队列非空时，返回当前队头元素的值，队头指针保持不变。相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">SElemType <span class="hljs-title function_">GetHead</span><span class="hljs-params">(SqQueue Q)</span> &#123;<br>    <span class="hljs-keyword">if</span>(Q.front!=Q.rear)<br>        <span class="hljs-keyword">return</span> Q.base[Q.front]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、链式队列">三、链式队列</h2><p>链式队列，是指采用链式存储结构实现的队列。</p><p>通常链队用单链表来表示。一个链队需要两个分别指示队头和队尾的指针（分别称为头指针和尾指针）才能唯一确定。和单链表类似，为了简化边界条件的处理，给链队添加一个头结点，并使头指针指向此结点。</p><p><img src="/img/image-20231223171616439.png" alt="image-20231223171616439"></p><p>在C语言中，链式队列的类型描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 链式队列的结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Qnode</span> &#123;</span><br>    QElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Qnode</span> *<span class="hljs-title">next</span>;</span><br>&#125;QNode, *QueuePtr;<br><br><span class="hljs-comment">// 链式队列</span><br>typdef <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">// 队头指针</span><br>    QueuePtr front;<br>    <span class="hljs-comment">// 队尾指针</span><br>    QueuePtr rear;<br>&#125;LinkQueue;<br></code></pre></td></tr></table></figure><p>链式队列的操作是单链表插入和删除操作的特殊情况。下面给出链队初始化、入队、出队操作的实现。</p><h3 id="3-1、初始化">3.1、初始化</h3><p>链队的初始化操作就是构造一个只有头结点的空队列。</p><p><img src="/img/image-20231230153915116.png" alt="image-20231230153915116"></p><p>该算法步骤为：</p><ul><li>生成新结点作为头结点，队头和队尾指针指向此结点。</li><li>头结点的指针域置空。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span> &#123;<br>    Q.front=Q.rear=new QNode;<br>    Q.front-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2、入队">3.2、入队</h3><p>和循环队列的入队操作不同，链队在入队前不需要判断队是否满，仅需为入队元素动态分配一个结点空间。</p><p><img src="/img/image-20231230160822345.png" alt="image-20231230160822345"></p><p>该算法步骤为：</p><ul><li>为入队元素分配结点空间，用指针p指向。</li><li>将新结点数据域置为e。</li><li>将新结点插入到队尾。</li><li>修改队尾指针为p。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q, QElemType e)</span> &#123;<br>    p=new QNode;<br>    p-&gt;data=e;<br>    p-&gt;next=<span class="hljs-literal">NULL</span>;<br>    Q.rear-&gt;next=p;<br>    Q.rear=p;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3、出队">3.3、出队</h3><p>和循环队列一样，链队在出队前也需要判断队列是否为空，不同的是，链队在出队后需要释放队头元素的所占空间。</p><p><img src="/img/image-20231230162124519.png" alt="image-20231230162124519"></p><p>该算法步骤为：</p><ul><li>判断队列是否为空，若空则返回ERROR。</li><li>临时保存队头元素的空间，以备释放。</li><li>修改头结点的指针域，使其指向下一个结点。</li><li>判断出队元素是否为最后一个元素，若是，则将队尾指针指向头结点。</li><li>释放原队头元素的空间。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q, QElemType &amp;e)</span> &#123;<br>    <span class="hljs-keyword">if</span>(Q.front==Q.rear) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    p=Q.front-&gt;next;<br>    e=p-&gt;data;<br>    <br>    Q.front-&gt;next=p-&gt;next;<br>    <span class="hljs-keyword">if</span>(Q.rear==p) Q.rear=Q.front;<br>    <br>    <span class="hljs-built_in">free</span>(p);<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4、取队头元素">3.4、取队头元素</h3><p>与循环队列一样，当队列非空时，此操作返回当前队头元素的值，队头指针保持不变。相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">SElemType <span class="hljs-title function_">GetHead</span><span class="hljs-params">(LinkQueue Q)</span> &#123;<br>    <span class="hljs-keyword">if</span>(Q.front!=Q.rear)<br>        <span class="hljs-keyword">return</span> Q.front-&gt;next-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、小结">四、小结</h2><p>队列也是一种操作受限的线性表，它只允许在表头进行删除操作、在表尾进行插入操作。队列最大的特点是先进先出，因此也被称为FIFO表。队列也有两种存储结构，分别是顺序队列和链式队列。队列的主要操作是进队和出队，对于顺序队列（更准确地来说是循环队列）的进队和出队操作要注意判断队满或队空。凡是涉及队头或队尾指针的修改都要将其对MAXQSIZE求模。</p><p><img src="/img/image-20231231102950568.png" alt="image-20231231102950568"></p><h2 id="五、参考">五、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p><p><a href="https://book.douban.com/subject/35474931/">《数据结构与算法之美》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：栈</title>
    <link href="/2023/12/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%88/"/>
    <url>/2023/12/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>线性结构，除了最基础的线性表外，还有一类特殊的线性表。本篇文章要讨论的栈就是一个特殊的线性表，它在计算机系统中有着举足轻重的作用，比如，在函数调用的实现过程中就用到了栈这个数据结构。栈是一个非常基础的数据结构，因此也需重点掌握。</p><h2 id="一、定义与特点">一、定义与特点</h2><p>栈（Stack）是限定仅在表尾进行插入和删除操作的线性表。对于栈来说，插入、删除的一端（即表尾）称为栈顶（top），另一端则称为栈底（bottom）。</p><p>栈的操作是按后进先出的原则进行的。因此，栈又被称为后进先出（Last in First Out, LIFO）的线性表。假设栈S=(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, …, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)，若栈中元素是按<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, …, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的顺序依次进栈的，则称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为栈底元素，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为栈顶元素，而其退栈的次序则是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, …, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。栈的这个特点可用铁路调度站形象地表示。</p><p><img src="/img/ad42e3b50a98b4f1aa9dd2955f1acf49.jpg" alt="img"></p><p>在日常生活中，有很多类似栈的例子。例如，洗盘子时，总是将已经洗好的盘子逐个往上叠放，而用盘子时则是从上往下逐个取用。栈就是对上述场景的抽象。在程序设计中，如果需要按照保存数据时相反的顺序来使用数据，则可以利用栈来实现。</p><p>和线性表类似，栈也有两种存储结构，分别是顺序栈和链栈。</p><h2 id="二、顺序栈">二、顺序栈</h2><p>顺序栈，是指采用顺序存储结构实现的栈。</p><p>顺序栈也是用数组实现的。因为栈顶位置是随着进栈和出栈操作而变化的，所以需要用一个指针top指示栈顶元素在顺序栈中的位置，这里的top通常被称为栈顶指针。又因为栈底位置是固定不变的，故可以将栈底位置设置在数组的最低端。</p><p>鉴于C语言中数组的下标约定从0开始，则当以C语言作描述语言时，上述设定会带来很大不便，因此另设指针base指示栈底元素在顺序栈中的位置。当top和base的值相等时，表示空栈。</p><p><img src="/img/926046e8b6db1fc65468c075ea4b9eec.jpg" alt="img"></p><p>在C语言中，顺序栈的类型描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 栈空间的大小应根据实际需要来定义，这里假设为100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><br><span class="hljs-comment">// SElemType的类型可根据实际情况而定，这里假设为char</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> SElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">// 栈顶指针</span><br>    SElemType *top;<br>    <span class="hljs-comment">// 栈底指针</span><br>    SElemType *base;<br>    <span class="hljs-comment">// 栈可用的最大容量</span><br>    <span class="hljs-type">int</span> stacksize;<br>&#125;SqStack;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>base为栈底指针，初始化完成后，栈底指针base始终指向栈底的位置，若base的值为NULL，则表明栈结构不存在。</li><li>top为栈顶指针，其初值指向栈底。每当插入新的栈顶元素时，指针top增1；删除栈顶元素时，指针top减1。因此，栈空时，top和base的值相等，都指向栈底；栈非空时，top始终指向栈顶元素的上一个位置。</li><li>stacksize指示栈可使用的最大容量，初始化操作会为顺序栈动态分配MAXSIZE大小的数组空间，将stacksize置为MAXSIZE。</li></ul><h3 id="2-1、初始化">2.1、初始化</h3><p>初始化，就是为顺序栈动态分配一个预定义大小的数组空间。该算法的步骤为：</p><ul><li>为顺序栈动态分配一个最大容量为MAXSIZE的数组空间，使base指向这段空间的基地址，即栈底。</li><li>栈顶指针top初始为base，表示栈为空。</li><li>stacksize置为栈的最大容量MAXSIZE。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 构造一个空栈S</span><br>Status <span class="hljs-title function_">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span> &#123;<br>    <span class="hljs-comment">// 为顺序栈动态分配一个最大容量为MAXSIZE的数组空间</span><br>    S.base=(SElemType *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(SElemtype) * MAXSIZE);<br>    <span class="hljs-comment">// 存储分配失败</span><br>    <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    <span class="hljs-comment">// top初始为base</span><br>    S.top=S.base;<br>    <span class="hljs-comment">// stacksize置为栈的最大容量MAXSIZE</span><br>    S.stacksize=MAXSIZE;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2、入栈">2.2、入栈</h3><p>入栈，是指在栈顶插入一个新的元素。该算法的步骤为：</p><ul><li>判断栈是否满，若满则返回ERROR。</li><li>将新元素压入栈顶，栈顶指针加1。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">Push</span><span class="hljs-params">(SqStack &amp;S, SElemType e)</span> &#123;<br>    <span class="hljs-comment">// 栈满</span><br>    <span class="hljs-keyword">if</span>(S.top-S.base==S.stacksize) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-comment">// 元素e压入栈顶，栈顶指针加1</span><br>    *S.top++=e;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3、出栈">2.3、出栈</h3><p>出栈，是将栈顶元素删除。该算法的步骤为：</p><ul><li>判断栈是否空，若空则返回ERROR。</li><li>栈顶指针减1，栈顶元素出栈。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">Pop</span><span class="hljs-params">(SqStack &amp;S, SElemType &amp;e)</span> &#123;<br>    <span class="hljs-comment">// 栈空</span><br>    <span class="hljs-keyword">if</span>(S.top==S.base) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-comment">// 栈顶指针减1，将栈顶元素赋给e</span><br>    e=*--S.top;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4、取栈顶元素">2.4、取栈顶元素</h3><p>当栈非空时，返回当前栈顶元素的值，栈顶指针保持不变。相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">SElemType <span class="hljs-title function_">GetTop</span><span class="hljs-params">(SqStack s)</span> &#123;<br>    <span class="hljs-keyword">if</span>(S.top!=S.base)<br>        <span class="hljs-keyword">return</span> *(S.top<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5、溢出问题">2.5、溢出问题</h3><p>在顺序栈中，常常会发生溢出问题。当栈满时，再做进栈操作，就会溢出，简称“上溢”；当栈空时，再做出栈操作，也会溢出，简称“下溢”。</p><p>在实际应用中，可能同时使用多个栈。为了防止溢出，需要为每个栈分配一个较大的空间，而这往往会产生空间上的浪费。因为当某一个栈发生溢出的同时，其余的栈还可能有很多的未用空间。如果将多个栈分配在同一个顺序存储空间内，即让多个栈共享存储空间，则可以相互进行调节，即节约了空间，又可降低发生溢出的频率。</p><p>当程序中同时使用两个栈时，可以将两个栈的栈底分别设在顺序存储空间的两端，让两个栈顶各自向中间延伸。当一个栈中的元素较多而栈使用的空间超过共享空间的一半时，只要另一个栈中的元素不多，就可以让第一个栈占用第二个栈的部分存储空间。只有当整个存储空间被两个栈占满时（即两栈顶相遇），才会产生溢出。</p><p>为了克服顺序栈存在的溢出和空间浪费问题，可以采用链式存储结构来存储栈。</p><h2 id="三、链栈">三、链栈</h2><p>链栈，是指采用链式存储结构实现的栈。</p><p>由于栈的主要操作是在栈顶插入和删除，显然以链表的头部作为栈顶是最方便的，而且没必要像单链表那样为了操作方便附加一个头结点。</p><p><img src="/img/image-20231223154248446.png" alt="image-20231223154248446"></p><p>在C语言中，链栈的类型描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span> &#123;</span><br>    SElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;StackNode, *LinkStack;<br></code></pre></td></tr></table></figure><h3 id="3-1、初始化">3.1、初始化</h3><p>链栈的初始化操作就是构造一个空栈，因为不用设头结点，所以直接将栈顶指针置空即可。相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 构造一个空栈S，栈顶指针置空</span><br>Status <span class="hljs-title function_">InitStack</span><span class="hljs-params">(LinkStack &amp;S)</span> &#123;<br>    S=<span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2、入栈">3.2、入栈</h3><p>和顺序栈的入栈操作不同，链栈在入栈前不需要判断栈是否满，只需要为入栈元素动态分配一个结点空间。</p><p><img src="/img/image-20231223155328524.png" alt="image-20231223155328524"></p><p>该算法步骤为：</p><ul><li>为入栈元素e分配空间，用指针p指向。</li><li>将新结点数据域置为e。</li><li>将新结点插入栈顶。</li><li>修改栈顶指针为p。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">Push</span><span class="hljs-params">(LinkStack &amp;S, SElemType e)</span> &#123;<br>    p=(SElemType *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(SElemtype));<br>    p-&gt;data=e;<br>    p-&gt;next=S;<br>    S=p;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3、出栈">3.3、出栈</h3><p>和顺序栈一样，链栈在出栈前也需要判断栈是否为空，不同的是，链栈在出栈后需要释放出栈元素的栈顶空间。</p><p><img src="/img/image-20231223160342887.png" alt="image-20231223160342887"></p><p>该算法步骤为：</p><ul><li>判断栈是否为空，若空则返回ERROR。</li><li>将栈顶元素赋给e。</li><li>临时保存栈顶元素的空间，以备释放。</li><li>修改栈顶指针，指向新的栈顶元素。</li><li>释放原栈顶元素的空间。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">Pop</span><span class="hljs-params">(LinkStack &amp;S, SElemType &amp;e)</span> &#123;<br>    <span class="hljs-keyword">if</span>(S==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    e=S-&gt;data;<br>    p=S;<br>    S=S-&gt;next;<br>    <span class="hljs-built_in">free</span>(p);<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4、取栈顶元素">3.4、取栈顶元素</h3><p>与顺序栈一样，当栈非空时，返回当前栈顶元素的值，栈顶指针S保持不变。相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">SElemType <span class="hljs-title function_">GetTop</span><span class="hljs-params">(LinkStack S)</span> &#123;<br>    <span class="hljs-keyword">if</span>(S!=<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> S-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、栈与递归">四、栈与递归</h2><p>栈有一个重要应用是在程序设计语言中实现递归。所谓递归，是指在一个函数、过程或者数据结构定义的内部又直接（或间接）地出现本身。递归函数，就是一个直接（或间接）调用自己的函数。</p><h3 id="4-1、采用递归算法求解的场景">4.1、采用递归算法求解的场景</h3><p>在以下3种情况中，常常会使用递归的方法。</p><ul><li>定义是递归的</li><li>数据结构是递归的</li><li>问题的解法是递归的</li></ul><h4 id="4-1-1、定义是递归的">4.1.1、定义是递归的</h4><p>在数学中，有很多函数是递归定义的。比如，阶乘函数，其定义如下：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">Fact</span>(<span class="hljs-built_in">n</span>)=<span class="hljs-built_in">n</span>*<span class="hljs-built_in">Fact</span>(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>)，其中f(<span class="hljs-number">0</span>)=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>该函数就可用递归来求解，相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">Fact</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> &#123;<br>    <span class="hljs-comment">// 递归终止条件</span><br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 递归步骤</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> n*Fact(n<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如下图，是主程序调用函数Fact (4)的执行过程：</p><p><img src="/img/image-20231216151834942.png" alt="image-20231216151834942"></p><p>在执行过程中，依次以参数4、3、2、1、0执行递归调用。最后一次递归调用时，因参数n为0执行if语句，递归终止，逐步返回，返回时依次计算1*1、2*1、3*2、4*6，最后将计算结果24返回给主程序。</p><h4 id="4-1-2、数据结构是递归的">4.1.2、数据结构是递归的</h4><p>有些数据结构其本身具有递归的特性。</p><p>比如，在单链表中，结点LNode的定义由数据域data和指针域next组成，其中指针域next是一种指向LNode类型的指针，也即LNode的定义中又用到了其自身，所以，链表是一种递归的数据结构。</p><p>对于递归的数据结构，相应算法可采用递归的方法来实现。如下，是从前向后遍历输出链表结点的递归算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">TraverseList</span><span class="hljs-params">(LinkList p)</span> &#123;<br>    <span class="hljs-comment">// 递归终止条件</span><br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 输出当前结点的数据域</span><br>        con&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-comment">// 递归输出后继结点</span><br>        TraverseList(p-&gt;next);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用此递归函数时，参数p指向单链表的首元结点，在递归过程中，p不断指向后继结点，直到p为NULL时递归结束。</p><h4 id="4-1-3、问题的解法是递归的">4.1.3、问题的解法是递归的</h4><p>还有一类问题，虽然问题本身没有明显的递归结构，但用递归求解比用迭代求解更简单。</p><p>比如，Hanoi塔问题。如下图，假设有3个分别命名为A、B和C的塔座，在塔座A上插有n个直径大小各不相同，依小到大编号为1，2，…，n的圆盘。</p><p><img src="/img/image-20231216154749448.png" alt="image-20231216154749448"></p><p>现要求将塔座A上的n个圆盘移至塔座C上，并仍按同样顺序叠排，圆盘移动时必须遵循下列规则：</p><ul><li><p>每次只能移动一个圆盘；</p></li><li><p>圆盘可以插在A、B和C中的任一塔座上；</p></li><li><p>任何时刻都不能将一个较大的圆盘压在较小的圆盘之上。</p></li></ul><p>如何实现移动圆盘的操作呢？可以用递归方法来解决这个问题。设A柱上最初的盘子总数为n，则当n=1时，只要将编号为1的圆盘直接从塔座A移至塔座C上即可；否则，执行以下三步：</p><ul><li><p>用C柱做过渡，将A柱上的(n-1)个盘子移到B柱上；</p></li><li><p>将A柱上最后一个盘子直接移到C柱上；</p></li><li><p>用A柱做过渡，将B柱上的（n-1）个盘子移到C柱上。</p></li></ul><p>在这个解法中，如何将n−1个圆盘从一个塔座移至另一个塔座的问题是一个和原问题具有相同特征属性的问题，只是问题的规模小1，因此可以用同样的方法求解。该解法的移动过程如下所示（图中n=4）：</p><p><img src="/img/image-20231216155517429.png" alt="image-20231216155517429"></p><p>上述解法的算法步骤为：</p><ul><li>如果n=1，则直接将编号为1的圆盘从A移到C，递归结束。</li><li>否则：<ul><li>递归，将A上编号为1至n-1的圆盘移到B，C做辅助塔；</li><li>直接将编号为n的圆盘从A移到C；</li><li>递归，将B上编号为1至n-1的圆盘移到C，A做辅助塔。</li></ul></li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 为了便于描述算法，将搬动操作定义为move(A,n,C)，即将编号为n的圆盘从A移到C，同时设一个初值为0的全局变量m，对搬动进行计数。</span><br><span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">char</span> A, <span class="hljs-type">int</span> n, <span class="hljs-type">char</span> C)</span> &#123;<br>    count&lt;&lt;++m&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;A&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;C&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-comment">// 将塔座A上的n个圆盘按规则搬到C上，B做辅助塔</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> A, <span class="hljs-type">char</span> B, <span class="hljs-type">char</span> C)</span> &#123;<br>    <span class="hljs-comment">// 将编号为1的圆盘从A移到C</span><br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) move(A, <span class="hljs-number">1</span>, C);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 将A上编号为1至n-1的圆盘移到B，C做辅助塔</span><br>        Hanoi(n<span class="hljs-number">-1</span>, A, C, B);<br>        <span class="hljs-comment">// 将编号为n的圆盘从A移到C</span><br>        move(A, n, C);<br>        <span class="hljs-comment">// 将B上编号为1至n-1的圆盘移到C，A做辅助塔</span><br>        Hanoi(n<span class="hljs-number">-1</span>, B, A, C);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如下图，是Hanoi(3)的执行过程：</p><p><img src="/img/image-20231217171409729.png" alt="image-20231217171409729"></p><h4 id="4-1-4、小结">4.1.4、小结</h4><p>上述问题其实都采用了一种分解-求解的策略，即将一个复杂问题，分解成几个相对简单且解法相同或类似的子问题来求解。比如，在阶乘函数中，计算4!时，先计算3!。</p><p>分解-求解的策略又被称为“分治法”。通常，一个问题若能采用“分治法”进行递归求解，就必须同时满足以下三个条件：</p><ul><li>这个问题的解，能被分解成多个子问题的解。</li><li>子问题和原问题，除了数据规模不同，求解思路完全一样。</li><li>存在递归终止条件（调用自己前，必须有终止条件）。</li></ul><p>相应算法的一般形式可以描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">p</span><span class="hljs-params">(参数表)</span> &#123;<br>    <span class="hljs-keyword">if</span>(递归终止条件成立) 直接求解；<br>    <span class="hljs-keyword">else</span> p(较小的参数);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2、递归过程与递归工作栈">4.2、递归过程与递归工作栈</h3><p>递归函数在执行过程中，需进行多次自我调用。那么，这个递归函数是如何执行的呢？</p><h4 id="4-2-1、嵌套调用">4.2.1、嵌套调用</h4><p>在回答上述问题之前，我们先看任意两个函数之间进行调用的情形。通常，当一个函数在运行期间调用另一个函数时，在运行被调用函数之前，系统需先完成3件事：</p><ul><li><p>保存调用函数的所有参数、返回地址等信息；</p></li><li><p>为被调用函数的局部变量分配存储区；</p></li><li><p>将控制转移到被调用函数的入口。</p></li></ul><p>而从被调用函数返回调用函数之前，系统也应完成3件工作：</p><ul><li>保存被调用函数的计算结果；</li><li>释放被调用函数的数据区；</li><li>依照被调用函数保存的返回地址将控制转移到调用函数。</li></ul><p>当有多个函数构成嵌套调用时，按照“后调用先返回”的原则，上述函数之间的信息传递和控制转移必须通过“栈”来实现，即系统将整个程序运行时所需的数据空间安排在一个栈中，每当调用一个函数时，就为它在栈顶分配一个存储区，每当从一个函数退出时，就释放它的存储区，则当前正运行的函数的数据区必在栈顶。</p><p>下面，我们通过具体示例来理解上述内容，假设有如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">first</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">second</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> m,n;<br>    ...<br>    first(m,n);<br>    RetLoc1: ...<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">first</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    ...<br>    second(i);<br>    RetLoc2: ...<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">second</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span> &#123;<br>    <span class="hljs-type">int</span> x, y;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中，主函数main中调用了函数first（调用完之后的返回地址是RetLoc1），而在函数first中又调用了函数second（调用完之后的返回地址是RetLoc1）。如下图，左图是执行函数second中某个语句时栈的状态，右图是从函数second退出之后，执行函数first中某个语句时的状态：</p><p><img src="/img/image-20231217121805487.png" alt="image-20231217121805487"></p><h4 id="4-2-2、递归调用">4.2.2、递归调用</h4><p>递归函数的运行过程类似于多个函数的嵌套调用，只是调用函数和被调用函数是同一个函数，因此，和每次调用相关的一个重要概念是递归函数运行的“层次”。</p><p>假设调用递归函数的主函数为第0层，则从主函数调用递归函数为进入第1层；从第i层递归调用本函数为进入“下一层”，即第i+1层。反之，退出第i层递归应返回至“上一层”，即第i−1层。</p><p>为了保证递归函数正确执行，系统需设立一个“递归工作栈”作为整个递归函数运行期间使用的数据存储区。每一层递归所需信息构成一个工作记录，其中包括所有的实参、所有的局部变量，以及上一层的返回地址。每进入一层递归，就产生一个新的工作记录压入栈顶。每退出一层递归，就从栈顶弹出一个工作记录，则当前执行层的工作记录必是递归工作栈栈顶的工作记录，称这个记录为“活动记录”。</p><p>下面以阶乘函数Fact(4)为例，介绍递归过程中递归工作栈和活动记录的使用。为说明方便起见，将算法改写为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">Fact</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> &#123;<br>    <span class="hljs-type">long</span> temp;<br>    <br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 这里假设调用Fact(n-1)之后的返回地址为RetLoc2</span><br>    <span class="hljs-keyword">else</span> temp=n*Fact(n<span class="hljs-number">-1</span>);<br>    <br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> n;<br>    <span class="hljs-comment">// 这里假设调用Fact(4)之后的返回地址为RetLoc1</span><br>    n=Fact(<span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>主函数执行后依次启动了5个函数调用。如下图，为每次函数调用时活动记录的进栈情况。主程序main()调用Fact(4)的活动记录在栈底，Fact (1)调用Fact (0)进栈的活动记录在栈顶。</p><p><img src="/img/image-20231217162153418.png" alt="image-20231217162153418"></p><p>递归结束条件出现于函数Fact(0)的内部，执行Fact(0)引起了返回语句的执行。退出栈顶的活动记录，根据返回地址，返回到上一层Fact(1)的调用递归处，继续执行语句temp=1*1，接着执行return temp又引起新的退栈操作。此退栈过程直至Fact(4)执行完毕后，将控制权转移给main为止，该过程如下所示：</p><p><img src="/img/image-20231217162528908.png" alt="image-20231217162528908"></p><p>最后，当递归调用结束后，控制返回到RetLoc1，在此处n被赋值为24。</p><h3 id="4-3、递归算法的效率分析">4.3、递归算法的效率分析</h3><h4 id="4-3-1、时间复杂度分析">4.3.1、时间复杂度分析</h4><p>迭代法是求解递归方程的一种常用方法，其基本步骤是迭代地展开递归方程的右端，使之成为一个非递归的和式，然后通过对和式的估计来达到对方程左端（即方程的解）的估计。下面，以阶乘的递归函数Fact(n)为例，说明如何通过迭代法求解递归方程来计算递归函数的时间复杂度。</p><p>假设Fact(n)的执行时间是T(n)。在该递归函数中，语句<code>if(n==0) return 1;</code>的执行时间是O(1)，递归调用Fact(n-1)的执行时间是T(n-1)，所以<code>else return n*Fact(n-1);</code>的执行时间是O(1)+T(n-1)。其中，设两数相乘和赋值操作的执行时间为O(1)。则可以得出如下递归方程（其中C、D均常数）：</p><p><img src="/img/4301461e4ba6137b8a5493c7f53acc45.jpg" alt="img"></p><p>设n&gt;2，利用上式对T(n-1)展开，即在上式中用n-1代替n，可得到：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>) = C + <span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>-<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>将其带入<code>T(n)=C+T(n-1)</code>中，则有：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>) = <span class="hljs-number">2</span>C + <span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>-<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>同理，当n&gt;3时，有：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>) = <span class="hljs-number">3</span>C + <span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>-<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>以此类推，当n&gt;i时，有：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>) = iC + <span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>-i)<br></code></pre></td></tr></table></figure><p>最后，当i=n时，有</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">T</span><span class="hljs-params">(n)</span></span> = nC + <span class="hljs-built_in">T</span>(<span class="hljs-number">0</span>) = nC + D<br></code></pre></td></tr></table></figure><p>综上，求得阶乘的递归函数Fact(n)的时间复杂度为：T(n) = O(n)。采用这种方法计算Hanoi塔问题递归算法的时间复杂度为O(2^n^)。</p><h4 id="4-3-2、空间复杂度分析">4.3.2、空间复杂度分析</h4><p>递归函数在执行时，系统需设立一个“递归工作栈”存储每一层递归所需的信息，此工作栈是递归函数执行的辅助空间，因此，分析递归算法的空间复杂度需要分析工作栈的大小。对于递归算法，其空间复杂度为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">S</span><span class="hljs-params">(n)</span></span>=<span class="hljs-built_in">O</span>(<span class="hljs-built_in">f</span>(n))<br></code></pre></td></tr></table></figure><p>其中，f(n)为“递归工作栈”中工作记录的个数与问题规模n的函数关系。根据这种分析方法不难得到，前面讨论的阶乘问题、Hanoi塔问题的递归算法的空间复杂度均为O(n)。</p><h3 id="4-4、利用栈将递归转换为非递归的方法">4.4、利用栈将递归转换为非递归的方法</h3><p>对于一般的递归过程，仿照递归算法执行过程中递归工作栈的状态变化可直接写出相应的非递归算法。这种利用栈消除递归过程的步骤如下。</p><ul><li><p>设置一个工作栈存放递归工作记录（包括实参、返回地址及局部变量等）。</p></li><li><p>进入非递归调用入口（即被调用程序开始处）将调用程序传来的实参和返回地址入栈（递归程序不可以作为主程序，因而可认为初始是被某个调用程序调用）。</p></li><li><p>进入递归调用入口：当不满足递归结束条件时，逐层递归，将实参、返回地址及局部变量入栈，这一过程可用循环语句来实现——模拟递归分解的过程。</p></li><li><p>递归结束条件满足，将到达递归出口的给定常数作为当前的函数值。</p></li><li><p>返回处理：在栈不空的情况下，反复退出栈顶记录，根据记录中的返回地址进行题意规定的操作，即逐层计算当前函数值，直至栈空为止——模拟递归求值过程。</p></li></ul><p>通过以上步骤，可将任何递归算法改写成非递归算法。但改写后的非递归算法和原来比较起来，结构不够清晰，可读性差，有的还需要经过一系列的优化。</p><h2 id="五、总结">五、总结</h2><p>栈是一种操作受限的线性表，它只能在表尾进行插入和删除操作。栈最大的特点是后进先出，因此栈也被称为LIFO表。栈也有两种存储结构，分别是顺序栈和链栈，在顺序栈中要留意栈空和栈满的判断。栈的一个重要应用是在程序设计语言中实现递归。</p><p><img src="/img/image-20231223161421362.png" alt="image-20231223161421362"></p><h2 id="六、参考">六、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p><p><a href="https://book.douban.com/subject/35474931/">《数据结构与算法之美》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：线性表</title>
    <link href="/2023/12/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2023/12/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>一个好的算法是建立在一个好的数据结构基础之上的。可以说，数据结构是算法设计的基础。根据数据元素之间逻辑关系和操作运算的不同，可以划分出多种数据结构，常用的数据结构如下图所示：</p><p><img src="/img/image-20231209111631626.png" alt="image-20231209111631626"></p><p>在这些数据结构中，线性表是最基本和最常用的一种数据结构，同时也是其它数据结构的基础，尤其是链表，它会贯穿整个数据结构课程的始终。本篇文章将重点讨论线性表这个最基础的数据结构。</p><h2 id="一、线性表">一、线性表</h2><h3 id="1-1、定义和特点">1.1、定义和特点</h3><p>线性表，是由n个具有相同特性的数据元素构成的有限序列。其中，数据元素的个数n是线性表的长度，当n为零时称为空表。</p><p>对于一个非空的线性表（或线性结构）来说，其特点如下：</p><ul><li>仅有一个被称作“第一个”的数据元素；</li><li>仅有一个被称作”最后一个“的数据元素；</li><li>除第一个元素之外，表中的每个数据元素均只有一个直接前驱；</li><li>除最后一个元素之外，表中的每个数据元素均只有一个直接后继。</li></ul><p>在日常生活中，线性表的例子比比皆是。例如，26个英文字母的字母表就是一个线性表，表中的数据元素是单个字母。在稍复杂的线性表中，一个数据元素可以包含若干个数据项。例如，在一张学生基本信息表中，每个学生的基本信息为一个数据元素，包括学号、姓名、性别、籍贯、专业等数据项。</p><h3 id="1-2、存储结构">1.2、存储结构</h3><p>存储结构，也称物理结构，指的是数据对象在计算机中的存储表示。把数据对象存储到计算机时，不仅要存储各数据元素的数据，还要存储数据元素之间的逻辑关系。数据元素在计算机中有两种基本的存储结构，分别是顺序存储结构和链式存储结构。</p><h4 id="1-2-1、顺序存储">1.2.1、顺序存储</h4><p>顺序存储，是指用一组地址连续的存储单元存放数据元素。其特点是，逻辑上相邻的数据元素，其物理位置也是相邻的。采用这种存储方法的线性表被称为顺序表（Sequential List）。</p><p><img src="/img/image-20231209113140075.png" alt="image-20231209113140075"></p><p>顺序存储借助数据元素在存储器中的相对位置来表示数据元素之间的逻辑关系。在顺序表中，每个数据元素的存储地址是该数据元素在表中位置的线性函数。假设，在一个线性表中，第一个数据元素的存储地址是LOC(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)，每个数据元素的大小是s，那么第i个数据元素的存储地址LOC(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)就为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mi>O</mi><mi>C</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mi>O</mi><mi>C</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">LOC(a_i) = LOC(a_1) + (i-1)*s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">OC</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">OC</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span></span></p><p>这也就是说，只要知道了第一个数据元素的存储地址（也称基地址）和每个数据元素的大小，就能求出任一数据元素的存储地址，所以顺序表是一种支持随机存取的数据结构。</p><h4 id="1-2-2、链式存储">1.2.2、链式存储</h4><p>链式存储，是指用一组地址任意的存储单元存放数据元素。其特点是，逻辑上相邻的两个元素，其物理位置可以是连续的，也可以是不连续的。采用这种存储方法的线性表被称为链表。</p><p><img src="/img/image-20231209113422454.png" alt="image-20231209113422454"></p><p>在链式存储结构中，为了表示数据元素之间的逻辑关系，在存储数据时，不仅要存储数据元素本身，还要存储其直接前驱（或后继）的位置等信息。所以，链表中的每个数据元素（通常称为结点）由数据域和指针域这两部分信息共同构成。其中，数据域用于存储数据元素本身的信息；指针域用于存储直接前驱（或后继）的位置等信息。</p><p><img src="/img/image-20231209113613036.png" alt="image-20231209113613036"></p><p>链表中各个元素的存储位置都是随意的。也就是说，链表是非随机存取的存储结构，要取得第i个数据元素必须顺链进行寻找，因此，链表也被称为顺序存取的存储结构。</p><h2 id="二、顺序表">二、顺序表</h2><p>在高级程序设计语言中，数组具有随机访问的特性。因此，通常用数组来描述顺序表。在C语言中，可用动态分配的一维数组表示顺序表，相应的描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 顺序表的最大长度（应该根据实际需要来定，这里假设为100）</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><br><span class="hljs-comment">// 表中数据元素的类型（应根据实际情况而定，这里假设为int）</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-comment">// 定义顺序表类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-comment">// 存储空间的基地址</span><br>  ElemType* elem;<br>  <span class="hljs-comment">// 表的当前长度（即实际存储的数据元素个数）</span><br>  <span class="hljs-type">int</span> length;<br>&#125;SeqList;<br></code></pre></td></tr></table></figure><p>有了该定义，顺序表的一些操作就可轻松实现。因为表的长度是顺序表的一个”属性“，所以可通过返回length的值实现求表长的操作，也可通过length的值是否为0判断表是否为空，实现这些操作的算法的时间复杂度都是O(1)。下面重点讨论顺序表其他几个主要操作的实现。</p><h3 id="3-1、初始化">3.1、初始化</h3><p>初始化，就是构造一个空的顺序表。该算法步骤为：</p><ul><li><p>为顺序表L动态分配一个预定义大小的数组空间，使elem指向这段空间的基地址。</p></li><li><p>将表的当前长度设为0。</p></li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 构造一个空的顺序表</span><br>Status <span class="hljs-title function_">InitList</span><span class="hljs-params">(SeqList &amp;L)</span> &#123;<br>    <span class="hljs-comment">// 为顺序表分配一个大小为MAXSIZE的数组空间</span><br>    L.elem=(ElemType *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ElemType) * MAXSIZE);<br>    <span class="hljs-comment">// 空间分配失败，退出</span><br>    <span class="hljs-keyword">if</span>(!L.elem) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    <span class="hljs-comment">// 空表的长度为0</span><br>    L.length=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2、取值">3.2、取值</h3><p>取值，是指根据指定的位置序号i，获取顺序表中第i个数据元素的值。由于顺序存储结构具有随机存取的特点，因此可以直接通过数组下标定位第i个数据元素，即第i个数据元素可通过elem[i-1]获取。该算法步骤为：</p><ul><li>判断位置序号i值是否合理（i值的合法范围是1&lt;=i&lt;=L.length），若不合理，则返回ERROR。</li><li>若i值合理，则将第i个数据元素L.elem[i-1]赋给参数e，通过e返回第i个数据元素的值。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取顺序表L的第i个数据元素的值</span><br>Status <span class="hljs-title function_">GetElem</span><span class="hljs-params">(SeqList L, ini i, ElemType &amp;e)</span> &#123;<br>    <span class="hljs-comment">// 判断i值是否合理，若不合理，返回ERROR</span><br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length)<span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-comment">// 获取第i个数据元素</span><br>    e=E.elem[i<span class="hljs-number">-1</span>];<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，顺序表取值算法的时间复杂度为O(1)。</p><h3 id="3-3、查找">3.3、查找</h3><p>查找，是指根据指定的元素值e，查找顺序表中第1个值与e相等的元素。若查找成功，则返回该元素在表中的位置序号；若查找失败，则返回0。该算法步骤为：</p><ul><li>从第一个元素起，依次和e相比较，若找到与e相等的元素L.elem[i]，则查找成功，返回该元素的序号i+1。</li><li>若查遍整个顺序表都没有找到，则查找失败，返回0。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在顺序表L中查找值为e的数据元素，返回其序号</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">LocateElem</span><span class="hljs-params">(SeqList L, ElemType e)</span> &#123;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;L.length;i++) &#123;<br>        <span class="hljs-comment">// 查找成功，返回该元素的序号i+1</span><br>        <span class="hljs-keyword">if</span>(L.elem[i]==e) <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 查找失败，返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在顺序表中查找一个数据元素时，其时间主要耗费在数据的比较上，而比较的次数取决于被查元素在线性表中的位置。显然，该算法要分析其平均时间复杂度，在等概率情况下，其平均复杂度为O(n)。</p><h3 id="3-4、插入">3.4、插入</h3><p>插入，是指在表的第i个位置上插入一个新的数据元素e，使线性表的长度由n变为n+1。</p><p><img src="/img/image-20231209170722757.png" alt="image-20231209170722757"></p><p>由于在顺序表中逻辑上相邻的数据元素在物理位置上也是相邻的，因此，除非i=n+1，否则必须移动数据元素。一般情况下，在第i（1≤i≤n）个位置插入一个元素时，需从最后一个元素即第n个元素开始，将每个元素向后移动一个位置，直至第i个元素。该算法步骤为：</p><ul><li>判断插入位置i是否合法（i值的合法范围是1≤i≤n+1），若不合法则返回ERROR。</li><li>判断顺序表的存储空间是否已满，若满则返回ERROR。</li><li>将最后一个元素至第i个位置的元素依次向后移动一个位置，空出第i个位置（i=n+1时无需移动）。</li><li>将要插入的新元素e放入第i个位置。</li><li>表长加1。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将新元素e插入到顺序表L的第i个位置</span><br>Status <span class="hljs-title function_">ListInsert</span><span class="hljs-params">(SeqList &amp;L, <span class="hljs-type">int</span> i, ElemType e)</span> &#123;<br>    <span class="hljs-comment">// i值不合法</span><br>    <span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L.length+<span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">// 当前存储空间已满</span><br>    <span class="hljs-keyword">if</span>(L.length==MAXSiZE) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">// 从最后一个元素开始，依次将每个元素向后移动一个位置，直到第i元素为止</span><br>    <span class="hljs-keyword">for</span>(j=L.length<span class="hljs-number">-1</span>; j&gt;=i<span class="hljs-number">-1</span>; j--) &#123;<br>        L.elem[j+<span class="hljs-number">1</span>]=L.elem[j];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 将新元素e插入到第i个位置</span><br>    L.elem[i<span class="hljs-number">-1</span>]=e;<br>    <br>    <span class="hljs-comment">// 表长加1</span><br>    ++L.length;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>在顺序表中某个位置上插入一个数据元素时，其时间主要耗费在移动元素上，而移动元素的个数取决于插入元素的位置。显然，该算法要分析其平均时间复杂度，在等概率情况下，其平均复杂度为O(n)。</p><h3 id="3-5、删除">3.5、删除</h3><p>删除，是指将表的第i个元素删去，使线性表的长度由n变为n-1。</p><p><img src="/img/image-20231209171141352.png" alt="image-20231209171141352"></p><p>与插入操作类似，除非i=n，否则必须移动数据元素。一般情况下，删除第i（1≤i≤n）个元素时，需将第i+1个至第n个元素依次向前移动一个位置（i=n时无需移动）。该算法步骤为：</p><ul><li>判断删除位置i是否合法（合法值为1≤i≤n），若不合法则返回ERROR。</li><li>将第i+1个至最后一个元素依次向前移动一个位置（i=n时无需移动）。</li><li>表长减1。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在顺序表L中删除第i个元素</span><br>Status <span class="hljs-title function_">ListDelete</span><span class="hljs-params">(SeqList &amp;L, <span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-comment">// i值不合法</span><br>    <span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L.length)) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">// 从第i+1个元素开始，依次将每个元素向前移动一个位置，直到最后一个元素为止</span><br>    <span class="hljs-keyword">for</span>(j=i;j&lt;=L.length<span class="hljs-number">-1</span>;j++) &#123;<br>        L.elem[j<span class="hljs-number">-1</span>]=L.elem[j];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 表长减1</span><br>    --L.length;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>当在顺序表中某个位置上删除一个数据元素时，其时间主要耗费在移动元素上，而移动元素的个数取决于删除元素的位置。显然，该算法也要分析其平均时间复杂度，在等概率情况下，其平均复杂度为O(n)。</p><h3 id="3-6、小结">3.6、小结</h3><p>顺序表可以随机存取表中任一元素，其存储位置可用一个线性函数来表示。然而，从另一方面来看，这个特点也造成了这种存储结构的缺点：在进行插入或删除操作时，需移动大量元素。另外，由于数组长度是固定的，当表中数据元素个数较多且变化较大时，不仅会使操作变复杂，还会导致存储空间的浪费。而所有这些问题，都可以通过链表来解决。</p><h2 id="三、链表">三、链表</h2><p>根据结点指针域的不同，可将链表分为单链表、循环链表、双向链表、二叉链表、十字链表、邻接表、邻接多重表等。其中，单链表、循环链表和双向链表用于实现线性表的链式存储结构，其他形式多用于实现树和图等非线性结构。接下来，我们重点讨论前者。</p><h3 id="3-1、单链表">3.1、单链表</h3><p>单链表，是指链表中每个节点的指针域只包含一个指向其直接后继结点的指针。</p><p><img src="/img/image-20231209151644489.png" alt="image-20231209151644489"></p><p>在单链表中，由于第一个结点无直接前趋，所以通常会设立头指针指向链表中第一个结点。又由于最后一个结点无直接后继，所以最后一个结点的指针域为空，即NULL。如果单链表中一个数据元素也没有，则为空表，即L==NULL。</p><p>在C语言中，可用”结构体指针“来描述单链表，相应的描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 表中元素的类型应根据实际情况而定，这里假设为int</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-comment">// 定义单链表的节点类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    <span class="hljs-comment">// 结点的数据域</span><br>    ElemType data;<br>    <span class="hljs-comment">// 结点的指针域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125;LNoe,*LinkList;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li><p>在单链表中，每个结点的存结构由两部分组成：存储数据的数据域data，其类型用通用类型标识符ElemType表示；存储后继结点位置的指针域next，其类型为指向结点的指针类型LNode*。</p></li><li><p>LinkList和LNode *，两者在本质上是等价的。它们是不同名字的同一结构体指针类型，取名不同是为了在概念上更明确。通常，习惯上用LinkList定义单链表，强调定义的是某个单链表的头指针；用LNode *定义指向单链表中任意结点的指针变量。比如，若定义LinkList L，则L为单链表的头指针，若定义LNode *p，则p为指向单链表中某个结点的指针。</p></li><li><p>单链表是由头指针唯一确定的，因此单链表可以用头指针的名字来命名。若头指针名是L，则简称该链表为表L。</p></li></ul><p>一般情况下，为了处理方便，会在单链表的第一个结点之前附设一个结点（称之为头结点），并使头指针指向该结点。增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针。</p><p><img src="/img/image-20231209154415756.png" alt="image-20231209154415756"></p><p>在带头结点的单链表中，有3个容易混淆的概念，它们分别是：</p><ul><li><p>首元结点，指链表中存储第一个数据元素的结点。</p></li><li><p>头指针，指向链表中的第一个结点。若链表设有头结点，则头指针所指结点为线性表的头结点；若链表不设头结点，则头指针所指结点为线性表的首元结点。</p></li><li><p>头结点，是在首元结点之前附设的一个结点，其指针域指向首元结点。头结点的数据域可以不存储任何信息，也可存储与数据元素类型相同的其他附加信息。例如，当数据元素为整数型时，头结点的数据域中可存放该线性表的长度。</p></li></ul><h4 id="3-1-1、初始化">3.1.1、初始化</h4><p>初始化，就是构造一个空的单链表。该算法步骤为：</p><ul><li>生成新结点作为头结点，用头指针L指向头结点。</li><li>头结点的指针域置空。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 构造一个空的单链表</span><br>Status <span class="hljs-title function_">InitList</span><span class="hljs-params">(LinkList &amp;L)</span> &#123;<br>    <span class="hljs-comment">// 生成新结点作为头结点，并用头指针L指向头结点</span><br>    L=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    <span class="hljs-comment">// 头结点的指针域置空</span><br>    L-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-2、取值">3.1.2、取值</h4><p>和顺序表不同，链表中逻辑相邻的结点，在物理存储上并不相邻。这样，根据给定的结点位置序号i，在链表中获取该结点的值不能像顺序表那样随机访问，而只能从链表的首元结点出发，顺着链域next逐个结点向后访问。该算法步骤为：</p><ul><li>用指针p指向首元结点，用j做计数器初值赋为1。</li><li>从首元结点开始依次顺着链域next向下访问，只要指向当前结点的指针p不为空（NULL），并且没有到达序号为i的结点，则循环执行以下操作：<ul><li>p指向下一个结点；</li><li>计数器j加1。</li></ul></li><li>退出循环时，如果指针p为空，或者计数器j大于i，说明指定的序号i值不合法（i大于表长n或i小于等于0），取值失败返回ERROR；否则取值成功，此时j=i时，p所指的结点就是要找的第i个结点，用参数e保存当前结点的数据域，返回OK。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在带头结点的单链表L中根据序号i获取元素的值，用e返回L中第i个数据元素的值</span><br>Status <span class="hljs-title function_">GetElem</span><span class="hljs-params">(LinkList L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span> &#123;<br>    <span class="hljs-comment">// p指向首元结点，计数器j初值赋为1</span><br>    p=L-&gt;next;j=<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// 顺链域向后扫描，直到p为空或p指向第i个元素</span><br>    <span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;i) &#123;<br>        <span class="hljs-comment">// p指向下一个结点</span><br>        p=p-&gt;next;<br>        <span class="hljs-comment">// p指向下一个结点</span><br>        ++j;<br>    &#125;<br>    <br>    <span class="hljs-comment">// i值不合法i&gt;n或i≤0</span><br>    <span class="hljs-keyword">if</span>(!p || j&gt;i) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">// 取第i个结点的数据域</span><br>    e=p-&gt;data;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>该算法的基本操作是比较j和i并后移指针p，while循环体中的语句频度与位置i有关。显然，该算法要分析其平均时间复杂度，在等概率情况下，其平均复杂度为O(n)。</p><h4 id="3-1-3、查找">3.1.3、查找</h4><p>链表的按值查找过程和顺序表类似，从链表的首元结点出发，依次将结点值和给定值e进行比较，返回查找结果。该算法步骤为：</p><ul><li>用指针p指向首元结点。</li><li>从首元结点开始依次顺着链域next向下查找，只要指向当前结点的指针p不为空，并且p所指结点的数据域不等于给定值e，则循环执行以下操作：<ul><li>p指向下一个结点。</li></ul></li><li>返回p。若查找成功，p此时即为结点的地址值，若查找失败，p的值即为NULL。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在带头结点的单链表L中查找值为e的元素</span><br>LNode *<span class="hljs-title function_">LocateElem</span><span class="hljs-params">(LinkList L, ElemType e)</span> &#123;<br>    <span class="hljs-comment">// p指向首元结点</span><br>    p=L-&gt;next;<br>    <br>    <span class="hljs-comment">// 顺链域向后扫描，直到p为空或p所指结点的数据域等于e</span><br>    <span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;data!=e) &#123;<br>        <span class="hljs-comment">// p指向下一个结点</span><br>        p=p-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 查找成功返回值为e的结点地址p，查找失败p为NULL</span><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>该算法的执行时间与待查找的值e的位置有关，需要分析其平均时间复杂度，在等概率情况下，其平均复杂度为O(n)。</p><h4 id="3-1-4、插入">3.1.4、插入</h4><p>插入，是指将值为e的新结点插入到表的第i个结点的位置上，即插入到结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>与结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之间。</p><p><img src="/img/image-20231209175741080.png" alt="image-20231209175741080"></p><p>其算法步骤为：</p><ul><li>查找结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>并由指针p指向该结点。</li><li>生成一个新结点*s。</li><li>将新结点*s的数据域置为e。</li><li>将新结点*s的指针域指向结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li><li>将结点*p的指针域指向新结点*s。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在带头结点的单链表L中第i个位置插入值为e的新结点</span><br>Status <span class="hljs-title function_">ListInsert</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i, ElemType e)</span> &#123;<br>    p=L;j=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 查找第i−1个结点，p指向该结点</span><br>    <span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;i<span class="hljs-number">-1</span>) &#123;<br>        p=p-&gt;next;<br>        ++j;<br>    &#125;<br>    <br>    <span class="hljs-comment">// i值不合法（i&gt;n+1或者i&lt;1）</span><br>    <span class="hljs-keyword">if</span>(!p || j&gt;i<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">// 生成新结点*s</span><br>    s=new LNode;<br>    <span class="hljs-comment">// 将结点*s的数据域置为e</span><br>    s-&gt;data=e;<br>    <span class="hljs-comment">// 将结点*s的指针域指向结点ai</span><br>    s-&gt;next=p-&gt;next;<br>    <span class="hljs-comment">// 将结点*p的指针域指向结点*s</span><br>    p-&gt;next=s;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>单链表的插入操作虽然不需要像顺序表的插入操作那样需要移动元素，但其平均时间复杂度仍为O(n)。这是因为，为了在第i个结点之前插入一个新结点，必须首先找到第i−1个结点，在等概率情况下，该操作的平均复杂度为O(n)。</p><h4 id="3-1-5、删除">3.1.5、删除</h4><p>删除，是指将第i个结点从链表中删去，即将链表第i-1个结点的指针指向第i+1个结点。</p><p><img src="/img/image-20231209180949369.png" alt="image-20231209180949369"></p><p>其步骤为：</p><ul><li>查找结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>并由指针p指向该结点。</li><li>临时保存待删除结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的地址在q中，以备释放。</li><li>将结点*p的指针域指向<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的直接后继结点。</li><li>释放结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的空间。</li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在带头结点的单链表L中，删除第i个元素</span><br>Status <span class="hljs-title function_">ListDelete</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i)</span> &#123;<br>    p=L;j=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(p&gt;next &amp;&amp; j&lt;i<span class="hljs-number">-1</span>) &#123;<br>        p=p-&gt;next;<br>        ++j;<br>    &#125;<br>    <br>    <span class="hljs-comment">// i值不合法（i&gt;n或者i&lt;1）</span><br>    <span class="hljs-keyword">if</span>(!(p-&gt;next) || (j&gt;i<span class="hljs-number">-1</span>)) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-comment">// 临时保存被删结点的地址以备释放</span><br>    q=p-&gt;next;<br>    <span class="hljs-comment">// 改变删除结点前驱结点的指针域</span><br>    p-&gt;next=q-&gt;next;<br>    <span class="hljs-comment">// 释放删除结点的空间</span><br>    <span class="hljs-built_in">free</span>(q);<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似于插入算法，删除算法的平均时间复杂度亦为O(n)。</p><h4 id="3-1-6、创建单链表">3.1.6、创建单链表</h4><p>初始化操作是创建一个只有头结点的空链表，而前面的一些算法都是假定链表已经存在多个结点。那么，该如何建立一个包括若干个结点的链表呢？</p><p>链表和顺序表不同，它是一种动态结构。整个可用存储空间可为多个链表共同享用，每个链表占用的空间不需预先分配划定，而是由系统按需即时生成。因此，建立线性表的链式存储结构的过程就是一个动态生成链表的过程。即从初始的空表状态起，依次生成各元素结点，并逐个插入链表。</p><p>根据结点插入位置的不同，链表的创建方法可分为前插法和后插法。</p><h5 id="3-1-6-1、前插法">3.1.6.1、前插法</h5><p>前插法，是指通过将新结点逐个插入到链表的头部（头结点之后）来创建链表。每次申请一个新结点，读入相应的数据元素值，然后将新结点插入到头结点之后。如下图，是采用前插法创建线性表(a,b,c,d,e)的过程。因为每次是在链表的头部插入，所以应该逆位序输入数据，即应该依次输入e、d、c、b、a。</p><p><img src="/img/image-20231210144242367.png" alt="image-20231210144242367"></p><p>该算法步骤为：</p><ul><li>创建一个只有头结点的空链表。</li><li>根据待创建链表中的元素个数n，循环n次执行以下操作：<ul><li>生成一个新结点*p；</li><li>输入元素值赋给新结点*p的数据域；</li><li>将新结点*p插入到头结点之后。</li></ul></li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//逆位序输入n个元素的值，建立带表头结点的单链表L</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateList_H</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 先建立一个带头结点的空链表</span><br>    L=(LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    L-&gt;next=<span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<br>        <span class="hljs-comment">// 生成新结点*p</span><br>        p=(LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>        <span class="hljs-comment">// 输入元素值赋给新结点*p的数据域</span><br>        <span class="hljs-built_in">cin</span>&gt;&gt;p-&gt;data;<br>        <span class="hljs-comment">// 将新结点*p插入到头结点之后</span><br>        p-&gt;next=L-&gt;next;<br>        L-&gt;next=p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，该算法的时间复杂度与数据规模n有关，其时间复杂度为O(n)。</p><h5 id="3-1-6-2、后插法">3.1.6.2、后插法</h5><p>后插法，是指通过将新结点逐个插入到链表的尾部来创建链表。同前插法一样，每次申请一个新结点，读入相应的数据元素值。不同的是，为了使新结点能够插入到表尾，需要增加一个尾指针r指向链表的尾结点。如下图，是采用后插法创建线性表(a,b,c,d,e)的过程。</p><p><img src="/img/image-20231210145028960.png" alt="image-20231210145028960"></p><p>该算法步骤为：</p><ul><li><p>创建一个只有头结点的空链表。</p></li><li><p>尾指针r初始化指向头结点。</p></li><li><p>根据待创建链表中的元素个数n，循环n次执行以下操作：</p><ul><li>生成一个新结点*p；</li><li>输入元素值赋给新结点*p的数据域；</li><li>将新结点*p插入到尾结点*r之后；</li><li>尾指针r指向新的尾结点*p。</li></ul></li></ul><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 正位序输入n个元素的值，建立带表头结点的单链表L</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateList_R</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 先建立一个带头结点的空链表</span><br>    L=(LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    L-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">// 尾指针r指向头结点</span><br>    r=L;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<br>        <span class="hljs-comment">// 生成新结点</span><br>        p=(LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>        <span class="hljs-comment">// 输入元素值赋给新结点*p的数据域</span><br>        <span class="hljs-built_in">cin</span>&gt;&gt;p-&gt;data;<br>        <span class="hljs-comment">// 将新结点*p插入尾结点*r之后</span><br>        p-&gt;next=<span class="hljs-literal">NULL</span>;<br>        r-&gt;next=p;<br>        <span class="hljs-comment">// r指向新的尾结点*p</span><br>        r=p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，该算法的时间复杂度与数据规模n有关，其时间复杂度为O(n)。</p><h4 id="3-1-7、头节点的作用">3.1.7、头节点的作用</h4><p>看到这里，我们可能会有一个疑问，在链表中，为什么要设置头节点？在回答这个问题之前，我们先来看看，在不设头节点的情况下，如何通过尾插法建立单链表。话不多说，我们直接上代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 正位序输入n个元素的值，建立带表头结点的单链表L</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateList_R</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 先将链表置空，即头尾指针都为NULL</span><br>    L=<span class="hljs-literal">NULL</span>;<br>    r=<span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<br>        <span class="hljs-comment">// 生成新结点</span><br>        p=(LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>        <span class="hljs-comment">// 输入元素值赋给新结点*p的数据域</span><br>        <span class="hljs-built_in">cin</span>&gt;&gt;p-&gt;data;<br>p-&gt;next=<span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 链表为空时，将头指针指向新结点</span><br><span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>) L=p;<br><span class="hljs-comment">// 链表非空时，将新节点插入到尾节点之后</span><br><span class="hljs-keyword">else</span> r-&gt;next=p;<br>  <br>        <span class="hljs-comment">// r指向新的尾结点*p</span><br>        r=p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对比前面带头节点的尾插法，我们不难看出，对于首元节点，该算法要进行特殊处理，代码逻辑会变得复杂，且不易理解。概括来讲，在链表中增加头节点，有两个重要的作用：</p><ul><li><p>便于首元结点的处理。在带头结点的链表中，首元结点的地址保存在头结点的指针域中，这样对链表的第一个数据元素的操作与其他数据元素相同，无需进行特殊处理。</p></li><li><p>便于空表和非空表的统一处理。假设L为单链表的头指针，当链表不设头结点时，头指针应该指向首元结点，如果链表为空，则头指针为空，判定空表的条件为：L==NULL。增加头结点后，若链表为空，则头结点的指针域为空，判定空表的条件为：L-&gt;next ==NULL，而这和非空表的处理是一致的。</p></li></ul><h3 id="3-2、循环链表">3.2、循环链表</h3><p>循环链表（Circular Linked List），是指链表中最后一个结点的指针域不为空，而是指向链表的头结点，使整个链表形成一个环。因此，从表中任一结点出发，都能访问到表中的其他结点。</p><p><img src="/img/image-20231209163315032.png" alt="image-20231209163315032"></p><p>在单循环链表中，为了使空表和非空表的处理一致，通常也会设置头结点。单循环链表的结点类型与单链表完全相同，在操作上也与单链表基本一致。差别仅在于，算法中循环的结束判断条件不再是p==NULL或p-&gt;next==NULL，而是它们是否等于头指针。</p><p>在某些情况下，若在循环链表中设立尾指针而不设头指针，可使一些操作简化。</p><p><img src="/img/e3e64278595946c9c5e5d4278b62944e.jpg" alt="img"></p><p>例如，在将两个线性表合并成一个表时，仅需将第一个表（假设为A）的尾指针指向第二个表（假设为B）的第一个结点，第二个表的尾指针指向第一个表的头结点，然后释放第二个表的头结点。这个操作仅需改变两个指针值即可，主要语句如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 保存第二个表的第一个结点</span><br>p=B-&gt;next-&gt;next;<br><span class="hljs-comment">// 将第二个表的尾指针指向第一个表的头结点</span><br>B-&gt;next=A-&gt;next;<br><span class="hljs-comment">// 将第一个表的尾指针指向第二个表的第一个结点</span><br>A-&gt;next=p;<br></code></pre></td></tr></table></figure><h3 id="3-3、双向链表">3.3、双向链表</h3><p>双向链表，是在单链表的基础上增加一个指向其直接前趋的指针域prior，其结构如下：</p><p><img src="/img/image-20231209203952780.png" alt="image-20231209203952780"></p><p>在单链表中，只有一个指示直接后继的指针域，由此，从某个结点出发只能顺指针向后寻查其他结点。若要寻查结点的直接前驱，则必须从表头指针出发。换句话说，在单链表中，查找直接后继结点的执行时间为O(1)，而查找直接前驱的执行时间为O(n)。为克服单链表这种单向性的缺点，可使用双向链表（Double Linked List）。</p><p>和单链表的循环表类似，双向链表也由头指针唯一确定。为了使某些操作方便，双向链表也会增设一个头结点。双向链表也可以有循环表。其结构如下：</p><p><img src="/img/image-20231209210832745.png" alt="image-20231209210832745"></p><p>在C语言中，双向链表的描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 双向链表的存储结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DuLNode</span> &#123;</span><br>    <span class="hljs-comment">// 数据域</span><br>    ElemType data;<br>    <span class="hljs-comment">// 前驱指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DuLNode</span> *<span class="hljs-title">prior</span>;</span><br>    <span class="hljs-comment">// 后继指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DuLNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;DuLNode, *DuLinkList;<br></code></pre></td></tr></table></figure><p>在双向链表中，有些操作（如ListLength、GetElem和LocateElem等）仅需涉及一个方向的指针，它们的算法描述和单链表的操作相同，但在插入、删除时有很大的不同。接下来，我们重点讨论这两种操作。</p><h4 id="3-3-1、插入">3.3.1、插入</h4><p>在插入结点时需要修改四个指针，操作过程如下：</p><p><img src="/img/image-20231214090952590.png" alt="image-20231214090952590"></p><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在带头结点的双向链表L中第i个位置之前插入元素e</span><br>Status <span class="hljs-title function_">ListInsert_DuL</span><span class="hljs-params">(DuLinkList &amp;L, <span class="hljs-type">int</span> i, ElemType e)</span> &#123;<br>    <span class="hljs-comment">// 指针p指向链表中第i个位置的元素</span><br>    <span class="hljs-keyword">if</span>(!(p=GetEem_DuL(L,i))) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">// 生成新结点*s</span><br>    s=(DuLNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DuLNode));<br>    <span class="hljs-comment">// 将e赋给新结点的数据域</span><br>    s-&gt;data=e;<br>    <span class="hljs-comment">// 插入新结点</span><br>    s-&gt;prior=p-&gt;prior;<br>    p-&gt;prior-&gt;next=s;<br>    s-&gt;next=p;<br>    p-&gt;prior=s;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>该算法主要有两个操作：设置指针和获取第i个数据元素。前者的时间复杂度为O(1)，而后者需要分析其平均时间复杂度，在等概率情况下，该操作的平均复杂度为O(n)。</p><h4 id="3-3-2、删除">3.3.2、删除</h4><p>在删除结点时需要修改两个指针，操作过程如下：</p><p><img src="/img/image-20231214091059956.png" alt="image-20231214091059956"></p><p>相应的算法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 删除带头结点的双向链表L中的第i个元素</span><br>Status <span class="hljs-title function_">ListDelete_DuL</span><span class="hljs-params">(DuLinkList &amp;L, <span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-comment">// 指针p指向链表中第i个位置的元素</span><br>    <span class="hljs-keyword">if</span>(!(p=GetElem_DuL(L,i))) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    p-&gt;prior-&gt;next=p-&gt;next;<br>    p-&gt;next-&gt;prior=p-&gt;prior;<br>    <br>    delete p;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>与插入类似，在等概率情况下，该操作的平均复杂度为O(n)。</p><h3 id="3-4、小结">3.4、小结</h3><p>单链表、循环链表和双向链表是线性链表的三种不同形式，它们有不同的应用场合。下表，对三者的几项有差别的基本操作进行了比较。</p><p><img src="/img/image-20231210113147496.png" alt="image-20231210113147496"></p><h2 id="四、顺序表-vs-链表">四、顺序表 vs 链表</h2><p>在实际应用中，不能笼统地说，顺序表和链表哪种存储结构更好。它们各有优缺点，选用哪种存储结构，应根据具体问题作具体分析，通常会从空间性能和时间性能两个方面作比较分析。</p><h3 id="4-1、空间性能比较">4.1、空间性能比较</h3><h4 id="4-1-1、存储空间的分配">4.1.1、存储空间的分配</h4><p>顺序表的存储空间必须预先分配，元素个数扩充受一定限制，易造成存储空间浪费或空间溢出现象；而链表不需要为其预先分配空间，只要内存空间允许，链表中的元素个数就没有限制。</p><p>基于此，当线性表的长度变化较大，难以预估存储规模时，宜采用链表作为存储结构。</p><h4 id="4-1-2、存储密度的大小">4.1.2、存储密度的大小</h4><p>所谓存储密度是指数据元素本身所占用的存储量和整个结点结构所占用的存储量之比，即</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>存储密度</mtext><mo>=</mo><mfrac><mtext>数据元素本身占用的存储量</mtext><mtext>结点结构占用的存储量</mtext></mfrac></mrow><annotation encoding="application/x-tex">存储密度 = \frac{数据元素本身占用的存储量}{结点结构占用的存储量}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">存储密度</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">结点结构占用的存储量</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">数据元素本身占用的存储量</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>一般来说，存储密度越大，存储空间的利用率就越高。显然，顺序表的存储密度为1，而链表的存储密度小于1。</p><p>链表的每个结点除了设置数据域用来存储数据元素外，还要额外设置指针域，用来存储指示元素之间逻辑关系的指针。如果每个元素数据域占据的空间较小，则指针域会占整个结点的大部分空间，这样存储密度会变小。</p><p>例如，若单链表的结点数据均为整数，指针所占用的空间和整型量相同，则单链表的存储密度为0.5。因此，如果不考虑顺序表中的空闲区，则顺序表的存储空间利用率为100%，而单链表的存储空间利用率仅为50%。</p><p>基于此，当线性表的长度变化不大，易于事先确定其大小时，为了节约存储空间，宜采用顺序表作为存储结构。</p><h3 id="4-2、时间性能比较">4.2、时间性能比较</h3><h4 id="4-2-1、存储元素的效率">4.2.1、存储元素的效率</h4><p>顺序表是由数组实现的，它是一种随机存取结构，指定任意一个位置序号i，都可以在O(1)时间内直接存取该位置上的元素，即取值操作的效率高；而链表是一种顺序存取结构，按位置访问链表中第i个元素时，只能从表头开始依次向后遍历链表，直到找到第i个位置上的元素，时间复杂度为O(n)，即取值操作的效率低。</p><p>基于此，若线性表的主要操作是和元素位置紧密相关的这类取值操作，很少做插入或删除时，宜采用顺序表作为存储结构。</p><h4 id="4-2-2、插入和删除操作的效率">4.2.2、插入和删除操作的效率</h4><p>对于链表，在确定插入或删除的位置后，插入或删除操作无需移动数据，只需要修改指针，时间复杂度为O(1)。而对于顺序表，进行插入或删除时，平均要移动表中近一半的结点，时间复杂度为O(n)。尤其是当每个结点的信息量较大时，移动结点的时间开销就相当可观。</p><p>基于此，对于频繁进行插入或删除操作的线性表，宜采用链表作为存储结构。</p><h2 id="五、总结">五、总结</h2><p>线性表是最基础的数据结构，也是其它许多复杂数据结构的实现基础，因此需要重点掌握。本篇文章的主要内容如下：</p><p><img src="/img/image-20231210125028700.png" alt="image-20231210125028700"></p><h2 id="六、参考">六、参考</h2><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p><p><a href="https://book.douban.com/subject/35474931/">《数据结构与算法之美》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：算法的分析方法</title>
    <link href="/2023/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/"/>
    <url>/2023/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>著名计算机科学家沃斯（Wirth）教授曾提出：数据结构 + 算法 = 程序。</p><p>简单来说，程序设计的实质就是：针对实际问题，选择一种好的数据结构，并在此结构基础上施加一种好的算法。</p><p>一个“好”的程序，需要具备两个特性：“快”和“省”。即代码不仅运行快，而且还省存储空间。这也就是说，执行效率是衡量算法的主要指标。</p><p>那么，该如何衡量一个算法的执行效率呢？这就是本篇文章要讨论的内容：时间和空间复杂度分析。</p><h2 id="一、时间复杂度分析">一、时间复杂度分析</h2><p>时间复杂度，也称渐进时间复杂度（asymptotic time complexity），它表示的是算法的执行时间与数据规模之间的增长关系。通常用大O表示：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></span></p><p>其中，n是数据规模，f(n)表示代码的执行次数，T(n)表示代码的执行时间，O表示代码的执行时间T(n)与代码的执行次数f(n)成正比。</p><h3 id="1-1、分析方法">1.1、分析方法</h3><p>表示方法有了，具体该如何分析一段代码的时间复杂度呢？ 有一个比较实用的分析法则，关注执行次数最多的一段代码。下面我们来看几个具体示例。</p><h4 id="1-1-1、示例1">1.1.1、示例1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>   <span class="hljs-type">int</span> sum_1 = <span class="hljs-number">0</span>;<br>   <span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span> (; p &lt; <span class="hljs-number">100</span>; ++p) &#123;<br>     sum_1 = sum_1 + p;<br>   &#125;<br><br>   <span class="hljs-type">int</span> sum_2 = <span class="hljs-number">0</span>;<br>   <span class="hljs-type">int</span> q = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span> (; q &lt; n; ++q) &#123;<br>     sum_2 = sum_2 + q;<br>   &#125;<br> <br>   <span class="hljs-keyword">return</span> sum_1 + sum_2;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中，for循环前的赋值语句都是常量级的执行时间，并不会影响时间复杂度。第一个for循环，执行了100次，与n的规模无关，所以也是一个常量级的执行时间。需要重点关注的是第二个for循环，因为它的执行次数最多，且与n的大小有关，所以这段代码的时间复杂度就是O(n)。</p><p>这里我们要知道的是，大O时间复杂度表示法，描述的是代码执行时间随数据规模增长的变化趋势。在实际使用中，通常会忽略掉常量、低阶和系数这些不左右增长趋势的部分，只需要记录一个最大阶的量级。所以，在分析一个算法（或一段代码）时，只需要关注执行次数最多的一段代码。</p><h4 id="1-1-2、示例2">1.1.2、示例2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>   <span class="hljs-type">int</span> sum_1 = <span class="hljs-number">0</span>;<br>   <span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span> (; p &lt; <span class="hljs-number">100</span>; ++p) &#123;<br>     sum_1 = sum_1 + p;<br>   &#125;<br><br>   <span class="hljs-type">int</span> sum_2 = <span class="hljs-number">0</span>;<br>   <span class="hljs-type">int</span> q = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span> (; q &lt; n; ++q) &#123;<br>     sum_2 = sum_2 + q;<br>   &#125;<br> <br>   <span class="hljs-type">int</span> sum_3 = <span class="hljs-number">0</span>;<br>   <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>   <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span> (; i &lt;= n; ++i) &#123;<br>     j = <span class="hljs-number">1</span>; <br>     <span class="hljs-keyword">for</span> (; j &lt;= n; ++j) &#123;<br>       sum_3 = sum_3 +  i * j;<br>     &#125;<br>   &#125;<br> <br>   <span class="hljs-keyword">return</span> sum_1 + sum_2 + sum_3;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中，第一个for循环，执行了100次，与n的规模无关，所以是一个常量级的执行时间；第二个for循环，执行次数与n有关，其时间复杂度为O(n)。第三个for循环，执行次数与n有关，其时间复杂度为O(n^2^)。综合整这三个for循环的时间复杂度，取其中最大的量级。所以，整段代码的时间复杂度就为 O(n^2^)。也就是说：代码的复杂度就等于量级最大的那段代码的时间复杂度。</p><p>这里我们需要注意的是，不管常量的执行次数多大，都可以忽略掉，因为它本身对增长趋势并没有影响。比如，在第一个for循环中，即便循环了10000 次、100000 次，只要是一个已知的数，跟 n 无关，照样也是常量级的执行时间。</p><h4 id="1-1-3、示例3">1.1.3、示例3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>  <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt; n; ++i) &#123;<br>    sum = sum + i;<br>  &#125; <br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>  <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>; <br>  <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt; n; ++i) &#123;<br>    ret = ret + f(i);<br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中，函数main调用了函数f，如果函数f只是一个复杂度为O(1)的简单函数，那么这段代码的时间复杂度就是O(n)。但实际上，函数f是一个复杂度为O(n)的函数，所以这段代码的时间复杂度应该是O(n^2^)，也就是嵌套内外代码复杂度的乘积。</p><h3 id="1-2、常见的复杂度量级">1.2、常见的复杂度量级</h3><p>在实际应用中，虽然代码千差万别，但常见的复杂度量级并不多。无外乎以下几种（按量级递增）：</p><ul><li>常量阶O(1)</li><li>对数阶O(logn)</li><li>线性阶O(n)</li><li>线性对数阶O(nlogn)</li><li>次方阶O(n^2^)、O(n^3^)、···</li><li>指数阶O(2^n^)</li><li>阶乘阶O(n!)</li></ul><p>这些复杂度量级，可粗略地分为两类：多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2^n^)和O(n!)。我们把时间复杂度为非多项式量级的算法问题叫作NP（Non-Deterministic Polynomial，非确定多项式）问题。当数据规模n越来越大时，非多项式量级算法的执行时间会急剧增加，也即代码的执行时间会无限增长。因此，可以说非多项式时间复杂度的算法其实是非常低效的算法。</p><h4 id="1-2-1、O-1">1.2.1、O(1)</h4><p>对于复杂度O(1)，我们需要知道的是，它只是常量级时间复杂度的一种表示方法，并非指只执行了一行代码。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-number">6</span>;<br><span class="hljs-type">int</span> sum = i + j;<br></code></pre></td></tr></table></figure><p>这段代码虽然有3行，但它的时间复杂度是O(1)，而不是O(3)。可以这样说，只要代码的执行时间不随数据规模n的增大而增长，那么代码的时间复杂度都记作O(1)。或者说，一般情况下，只要代码中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度就是O(1)。</p><h4 id="1-2-2、O-log-n-、O-nlog-n">1.2.2、O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">log_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)、O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">nlog_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</h4><p>O(logn)和O(nlogn)都属于对数阶时间复杂度。对数阶时间复杂度是最常见的一种时间复杂度，同时也是最难分析的一种时间复杂度。下面，我们通过几段简单代码，来熟悉如何分析此类时间复杂度。</p><p>首先，我们来看一个简单的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">i=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &lt;= n)  &#123;<br>  i = i * <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中，while循环的执行次数最多。因此，只要计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。从代码中，我们可以看出，变量i的值从1开始取，每循环一次就乘以2。当i大于n时，循环结束。如果把循环过程列出来，应该是这个样子的：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>* <span class="hljs-number">2</span> * <span class="hljs-number">2</span> * ··· * <span class="hljs-number">2</span> &gt; n<br></code></pre></td></tr></table></figure><p>可以看出，变量i的取值会构成一个等比数列。循环次数与n的关系为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mn>2</mn><mrow><mo stretchy="false">(</mo><mtext>循环次数</mtext><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>&gt;</mo><mi>n</mi><mtext>等价于</mtext><msup><mn>2</mn><mi>x</mi></msup><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2^{(循环次数-1)} &gt; n 等价于 2^x &gt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9771em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord cjk_fallback mtight">循环次数</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7535em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mord cjk_fallback">等价于</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span></p><p>由此可知，这段代码的执行次数就是x的取值。而x=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>，所以，这段代码的时间复杂度就是O()<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>。</p><p>然后，我们再来分析下面这段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">i=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &lt;= n)  &#123;<br>  i = i * <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据前面的分析，我们可以很快得出，这段代码的时间复杂度是O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>3</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_3 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>)。</p><p>这里，我们需要知道的是，不管是以2为底，还是以10为底，对于对数阶的时间复杂度，我们都记作O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">log_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)。而这又是为什么呢？</p><p>因为在采用大O表示法标记时间复杂度时，可以忽略系数，即O(C * f(n)) = O(f(n))。而我们知道，对数之间是可以互相转换的，比如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>3</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_3 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span> 就等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>3</mn></msub><mn>2</mn></mrow><annotation encoding="application/x-tex">log_3 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">2</span></span></span></span> * <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>。所以O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>3</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_3 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>) = O(C * <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>)，其中C = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>3</mn></msub><mn>2</mn></mrow><annotation encoding="application/x-tex">log_3 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">2</span></span></span></span>是一个常量，可以忽略，也就是O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>3</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_3 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>) = O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>)。因此，在表示对数阶时间复杂度时，可以忽略对数的“底”，统一表示为O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">log_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)。</p><p>理解了O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">log_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)，那O(n<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">log_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)就很容易理解了。在前面我们说过，嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。如果一段代码的时间复杂度为O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">log_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)，把这段代码循环n遍，其时间复杂度就是O(n<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">log_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)了。常用的排序算法，比如归并排序、快速排序等的时间复杂度都是O(n<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">log_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)。</p><h4 id="1-2-3、O-m-n-、O-m-n">1.2.3、O(m+n)、O(m*n)</h4><p>在有些情况下，我们不能直接使用前面提到的分析方法。比如，下面这段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>  <span class="hljs-type">int</span> sum_1 = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt; m; ++i) &#123;<br>    sum_1 = sum_1 + i;<br>  &#125;<br><br>  <span class="hljs-type">int</span> sum_2 = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; j &lt; n; ++j) &#123;<br>    sum_2 = sum_2 + j;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> sum_1 + sum_2;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中，时间复杂度由两个数据规模m和n来决定。因为我们无法事先评估m和n谁的量级大，所以不能直接使用前面的分析方法。也就是说，这段代码的时间复杂度，即不是O(m)，也不是O(n)，而是O(m + n)。</p><p>需要注意的是，如果在一个算法中，两个数据规模不同的代码之间是嵌套关系，那么乘法法则依然有效。</p><h3 id="1-3、分析方法进阶">1.3、分析方法进阶</h3><p>掌握了前面的内容，就能轻松分析出多数代码的时间复杂度。然而，仅仅掌握这些知识是不够的。比如，下面这段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// n表示数组array的长度</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span>[] <span class="hljs-built_in">array</span>, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> pos = <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i] == x) &#123;<br>       pos = i;<br>       <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> pos;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码的功能是，在一个无序数组中，查找变量x出现的位置。如果没有找到，就返回-1。此时，问题来了，这段代码的时间复杂度是多少？是O(1)？还是O(n)？我们该如何分析它？</p><p>显然，这段代码的时间复杂度无法用之前提到的方法来分析。因为，要查找的变量x可能出现在数组的任意位置。如果数组中第一个元素正好是要查找的变量x，那就不需要继续遍历剩下的n-1个数据了，此时的时间复杂度就是O(1)。但如果数组中不存在变量x，那我们就需要把整个数组遍历一遍，此时的时间复杂度就成了O(n)。所以，在不同的情况下，这段代码的时间复杂度是不一样的。</p><p>为了表示在不同情况下代码的时间复杂度，我们需要引入三个概念：最好、最坏情况时间复杂度，平均情况时间复杂度和均摊时间复杂度。</p><h4 id="1-3-1、最好、最坏情况时间复杂度">1.3.1、最好、最坏情况时间复杂度</h4><p>顾名思义，最好情况时间复杂度，是指在最理想的情况下，代码的时间复杂度。比如，在上面的find函数中，最理想的情况是，要查找的变量x正好是数组的第一个元素，此时的时间复杂度就是最好情况时间复杂度为O(1)。</p><p>同理，最坏情况时间复杂度，是指在最糟糕的情况下，代码的时间复杂度。我们还是以上面的find函数为例，其最糟糕的情况是，数组中没有要查找的变量x，需要把整个数组遍历一遍，此时的时间复杂度就是最坏情况时间复杂度为O(n)。</p><p>这里，我们需要知道的是，最好情况时间复杂度和最坏情况时间复杂度，都是极端情况下的时间复杂度，发生的概率其实并不大，不具备代表性。为了更好地表示普遍情况下的时间复杂度，需要引入另一个概念：平均情况时间复杂度。</p><h4 id="1-3-2、平均情况时间复杂度">1.3.2、平均情况时间复杂度</h4><p>平均情况时间复杂度，简称为平均时间复杂度。这里我们先不解释它的具体含义，直接以前面的find函数为例，熟悉如何分析代码的平均时间复杂度。</p><p>我们知道，要查找的变量x在数组中的位置，一共会有n+1种情况：x不在数组中和x在数组0~n-1的某个位置上。把每种情况下查找需要遍历的元素个数累加起来，然后再除以n+1，就可以得到需要遍历的元素个数的平均值，即：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mi>n</mi><mo>+</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo>+</mo><mi>n</mi><mo>+</mo><mi>n</mi></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1+2+3+n+···+n+n}{n+1}=\frac{n(n+3)}{2(n+1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0908em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">n</span><span class="mord">+</span><span class="mpunct">⋅⋅⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">+</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>我们知道，在大O表示法中，可以省略掉系数、低阶和常量。所以，把这个公式简化之后，得到的平均时间复杂度是O(n)。虽然这个计算过程没有问题，但其结论并不准确。因为上述的n+1种情况出现的概率是不一样的。所以，在分析时，需要考虑每种情况出现的概率。</p><p>我们知道，要查找的变量x，那么在数组中，要么不在数组中。这两种情况下的概率统计起来很麻烦，为了方便理解，我们假设其概率都为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。而要查找的数据出现在0~n-1这n个位置的概率是一样的，为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。因此，根据概率乘法法则，要查找的数据出现在0~n-1中任意位置的概率为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。综上，在考虑了每种情况发生的概率后，平均时间复杂度为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>1</mn><mo>∗</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><mo>+</mo><mn>2</mn><mo>∗</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><mo>+</mo><mn>3</mn><mo>∗</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><mo>+</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo>+</mo><mi>n</mi><mo>∗</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><mo>+</mo><mi>n</mi><mo>∗</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mn>3</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>4</mn></mfrac></mrow><annotation encoding="application/x-tex">1*\frac{1}{2n}+2*\frac{1}{2n}+3*\frac{1}{2n}+···+n*\frac{1}{2n}+n*\frac{1}{2}=\frac{3n+1}{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">+</span><span class="mpunct">⋅⋅⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">+</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。引入概率之后，前面那段代码的加权平均值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>3</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>4</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{3n+1}{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。</p><p>实际上，在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。只有当同一块代码在输入不同的情况下，时间复杂度有量级差距时，才会用这三种复杂度表示法来区分。</p><h4 id="1-3-3、均摊时间复杂度">1.3.3、均摊时间复杂度</h4><p>除了上述的最好、最坏、平均三种复杂度之外，其实还有一种时间复杂度：均摊时间复杂度。最好、最坏和平均复杂度只在某些特殊情况下才会用到，而均摊时间复杂度的应用场景则更加特殊和有限。话不多说，我们还是直接看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// array表示一个长度为n的数组</span><br><span class="hljs-comment">// 代码中的array.length就等于n</span><br><span class="hljs-type">int</span>[] <span class="hljs-built_in">array</span> = new <span class="hljs-type">int</span>[n];<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>   <span class="hljs-keyword">if</span> (count == <span class="hljs-built_in">array</span>.length) &#123;<br>      <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">array</span>.length; ++i) &#123;<br>         sum = sum + <span class="hljs-built_in">array</span>[i];<br>      &#125;<br>      <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] = sum;<br>      count = <span class="hljs-number">1</span>;<br>   &#125;<br><br>   <span class="hljs-built_in">array</span>[count] = val;<br>   ++count;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码实现了往一个数组中插入数据的功能。当数组满了（即count == array.length 时）之后，用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。那这段代码的时间复杂度是多少呢？</p><p>最好的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 O(1)。</p><p>最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。</p><p>那平均时间复杂度是多少呢？答案是 O(1)。我们还是可以通过概率论的方法来分析。假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>1</mn><mo>∗</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>+</mo><mn>1</mn><mo>∗</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>+</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo>+</mo><mn>1</mn><mo>∗</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>+</mo><mi>n</mi><mo>∗</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1*\frac{1}{n+1} + 1*\frac{1}{n+1} +···+ 1*\frac{1}{n+1} + n*\frac{1}{n+1}= O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0908em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0908em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">+</span><span class="mpunct">⋅⋅⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">+</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0908em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0908em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><p>但其实这个例子里的平均复杂度分析并不需要这么复杂，可以不引入概率论的知识。如果对比一下这个 insert() 的例子和前面的find() 例子，我们就会发现这两者有很大差别。</p><ul><li><p>首先，find() 函数在极端情况下，复杂度才为 O(1)。但 insert() 在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，复杂度才比较高，为 O(n)。这是 insert()区别于 find() 的第一个地方。</p></li><li><p>第二个不同的地方是，对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的时间前后关系，一般都是在一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。</p></li></ul><p>针对这样一种特殊场景的复杂度分析，可以不用平均复杂度分析法，而是用一种更加简单的分析方法：摊还分析法。通过摊还分析得到的时间复杂度，我们将其称之为均摊时间复杂度。那究竟如何使用摊还分析法来分析算法的均摊时间复杂度呢？</p><p>以上面的insert函数为例。每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是均摊分析的大致思路。</p><p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。通常，在能够使用均摊时间复杂度分析的场合中，均摊时间复杂度往往就等于最好情况时间复杂度。</p><p>最后，我们需要知道的是，均摊时间复杂度和摊还分析的应用场景比较特殊，并不会经常用到。</p><h2 id="二、空间复杂度分析">二、空间复杂度分析</h2><p>空间复杂度，也称渐进空间复杂度（asymptotic space complexity），它表示的是算法的存储空间与数据规模之间的增长关系。用大O表示就是：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(n)=O(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></span></p><p>一般情况下，一个程序在计算机上执行时，所占用的存储空间通常由三部分组成：算法本身所占用的存储空间、算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间。</p><p>在分析算法的空间复杂度时，只需关注算法在运行过程中临时占用的存储空间。这是因为，算法本身所占用的存储空间是很有限的，基本可以忽略不计，而输入输出数据所占用的存储空间取决于问题本身，与算法无关，所以也无需考虑。如果算法在运行过程中临时占用的存储空间相对于输入数据量而言是一个常数，则称这个算法为原地算法，其空间复杂度记作O(1)。下面我们来看一个简单示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 算法1</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n/<span class="hljs-number">2</span>;i++) &#123;<br>    t=a[i];<br>    a[i]=a[n-i<span class="hljs-number">-1</span>];<br>    a[n-i<span class="hljs-number">-1</span>]=t;<br>&#125;<br><br><span class="hljs-comment">// 算法2</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>    b[i]=a[n-i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>    a[i]=b[i]<br>&#125;<br></code></pre></td></tr></table></figure><p>上述这两个算法实现的功能是相同的，将数组a中的n个数逆序存放到原数组中。其中，算法1仅需借助一个临时变量t，与问题规模n的大小无关，所以其空间复杂度为O(1)；算法2需要借助一个大小为n的临时数组b，所以其空间复杂度为O(n)。</p><p>对于空间复杂度，我们要知道的是，与时间复杂度相比，空间复杂度分析要简单很多。常见的空间复杂度就是 O(1)、O(n)、O(n^2^)，像 O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">log_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)、O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">nlog_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) 这样的对数阶复杂度几乎用不到。</p><h2 id="三、总结">三、总结</h2><p>对于一个算法，其时间复杂度和空间复杂度往往是相互影响的，当追求一个较好的时间复杂度时，可能会导致占用较多的存储空间，即空间复杂度的性能可能会变差，反之亦然。</p><p>通常情况下，鉴于运算空间较为充足，常常会以算法的时间复杂度作为衡量算法优劣的核心指标。</p><p><img src="/img/image-20231203171554996.png" alt="image-20231203171554996"></p><h2 id="四、参考">四、参考</h2><p><a href="https://book.douban.com/subject/35474931/">《数据结构与算法之美》</a></p><p><a href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p><p><a href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条件状语从句和虚拟语气</title>
    <link href="/2022/07/31/%E6%9D%A1%E4%BB%B6%E7%8A%B6%E8%AF%AD%E4%BB%8E%E5%8F%A5%E5%92%8C%E8%99%9A%E6%8B%9F%E8%AF%AD%E6%B0%94/"/>
    <url>/2022/07/31/%E6%9D%A1%E4%BB%B6%E7%8A%B6%E8%AF%AD%E4%BB%8E%E5%8F%A5%E5%92%8C%E8%99%9A%E6%8B%9F%E8%AF%AD%E6%B0%94/</url>
    
    <content type="html"><![CDATA[<p>条件状语从句分为两大类：</p><ul><li>真实条件状语从句，是指可能会发生的事情（大概率事件）。比如，如果我明天发了工资，我就请你吃饭。</li><li>虚拟语气，是指几乎不可能发生的事情（小概率事件）。比如，如果明天我彩票中了500万，我就请你吃饭。</li></ul><p>在汉语中，这两类句子很好区分，然而在英语中则不然，一定要通过动词的变化，来达到不同的意思。</p><h2 id="一、真实条件状语从句">一、真实条件状语从句</h2><h3 id="1-1、if（如果…）">1.1、if（如果…）</h3><p>if后面可以加then，如果then省略了，也隐含在句子的意思里。if引导的条件状语从句，主要用来表示客观事实和将来可能发生的情况。</p><p>在表示客观事实时，从句用一般现在时，主句用一般现在时或现在进行时，即“主现从现”。</p><ul><li>If I eat too much, I feel uncomfortable.</li><li>If you can’t beat them, join them</li><li>If you drink and drive, you are breaking the law.</li></ul><p>在表示将来可能发生的情况时，从句用一般现在时，主句用一般将来时，即“主将从现”。此时主句的will表示肯定或很可能发生的事情。</p><ul><li><p>If you park your car in the wrong place, a traffic policeman will soon find it.</p></li><li><p>You will be very lucky if he lets you go without a ticket.</p></li><li><p>If she comes, she will get a surprise.</p><p>注：如果主句的肯定程度不是很高，就可以用别的情态助动词代替will</p></li><li><p>Are you successful in language learning? If it is less successful, you should do well to try the above ways.</p></li><li><p>If they are not brought to the surface soon they may lose their lives.</p></li><li><p>If the students are interested in sports, they can join different sports clubs.</p></li></ul><p>如果在条件状语从句中出现了will，不是将来时，而是表示意愿。</p><ul><li>If I will prepare, my chance will come someday.</li><li>If a man will not seek knowledge, it will not seek him.</li></ul><h3 id="1-2、unless（除非…）">1.2、unless（除非…）</h3><p>unless引导的条件状语从句，时态通常都是一般现在时，而且主句常常是否定句。</p><ul><li>All dreams are of no value unless they are followed by action.</li><li>I won’t call you, unless something unexpected happens.</li></ul><h3 id="1-3、其它比较常用的连接副词">1.3、其它比较常用的连接副词</h3><p>下面是一些比较常用的连接副词：</p><ul><li>suppose / supposing (that)</li><li>on condition that</li><li>so long as / as long as</li><li>providing / provided (that)</li><li>assuming</li><li>once</li><li>in case</li></ul><p>例句：</p><ul><li>In case you fail, don’t be discouraged. Keep trying.（从句一般现在时，主句一般现在时）</li><li>Suppose you make some mistakes, it’s not the end of the world.（从句一般现在时，主句一般现在时）</li><li>We can do whatever we wish to do provided (that) our wish is strong.（从句一般现在时，主句一般现在时）</li><li>Assuming you are willing to work hard, I see a great future waiting for you.（从句一般现在时，主句一般现在时）</li><li>So long as there’s something to identify, we will give people there money back.（从句一般现在时，主句一般将来时）</li><li>My parents don’t mind what job I do as long as I am happy.（从句一般现在时，主句一般现在时）</li><li>You’ll like her once you get to know her.（从句一般现在时，主句一般将来时）</li></ul><h3 id="1-4、only-if（只有…才）-if-only（只要…就）">1.4、only if（只有…才） &amp; if only（只要…就）</h3><ul><li>He can continue to support himself and his family only if he produces a surplus.</li><li>Only if I get a job will I have enough money to go to school.（only if放句首，主句要倒装）</li><li>The Almighty has given men arms long enough to reach the stars if only they would put them out.</li></ul><p>注：only if前可以加上but</p><ul><li>I’ll do that, but only if we set a few rules.</li></ul><h3 id="1-5、翻译练习">1.5、翻译练习</h3><ul><li>如果我熬夜（stay up）过半夜，第二天早上起来看起来就很糟。</li><li>如果你接受这份昂贵的礼物，就是在受贿了（take a bribe）。</li><li>如果明天下雨，我们将取消这个活动。</li><li>你们大火如果形成团队（team up），可能有助于形成一个双赢的（win-win）局面。</li><li>除非你加紧用功，否则你就不能通过考试。</li></ul><h2 id="二、虚拟语气的常规用法">二、虚拟语气的常规用法</h2><p>在汉语中，虚拟语气是通过语境实现的。而在英语中，则是通过谓语动词的变化实现的。虚拟语气的常规构成方式如下：</p><ul><li>现在虚拟：从句一般过去时（be用were），主句过去将来时（would可改成should，might，could）</li><li>过去虚拟：从句过去完成时，主句过去将来完成时（would可改成should，might，could）</li><li>将来虚拟：从句should + 动词原形，主句过去将来时（would可改为should，might，could）</li></ul><h3 id="2-1、现在虚拟：从句一般过去时，主句过去将来时">2.1、现在虚拟：从句一般过去时，主句过去将来时</h3><p>现在虚拟中的“现在‘，不一定是发生在现在的事情，也可能是”常态“，也就是对客观事实的虚拟。比如”如果太阳从西边出来，中国队就能打败巴西队“。</p><ul><li>‘Young man,’ she answered, ‘if you ate more and tallked less, we would both enjoy our dinner!’</li><li>The tunnel would be well-ventilated if tall chimneys were built above sea-level.</li><li>This would solve the problem of ventilation, for if a train entered this tunnel, it would draw in fresh air behind it.</li><li>If they knew how difficult it was to drill through the hard rock, they would lose heart.</li></ul><h3 id="2-2、过去虚拟：从句过去完成时，主句过去将来完成时">2.2、过去虚拟：从句过去完成时，主句过去将来完成时</h3><p>在描述过去时，做一个假设。比如“如果不是因为那时英国人害怕入侵，隧道早已建成了。”</p><ul><li>If, at the time, the British had not feared invasion, the tunnel, would have been completed.</li><li>If the Houses of Parliament had not been burned down in 1834, the great clock would never have been erected.</li><li>If there had not been a hard layer of rock beneth the soil, they would have completed the job in a few hours.</li></ul><h3 id="2-3、将来虚拟：从句should-动词原形，主句过去将来时">2.3、将来虚拟：从句should + 动词原形，主句过去将来时</h3><p>表示在未来发生的事情， 表达一种可能性，比较少见的用法。</p><p>If peter should come again, I would throw him out.</p><h3 id="2-4、翻译练习">2.4、翻译练习</h3><ul><li>如果当时你帮助我的话，我就可以完成任务了。</li><li>要是我是你，我会坐地铁去那儿。</li><li>如果我有100万美元，我就会买一套豪华别墅。</li><li>万一火山爆发了，有可能造成一场可怕的灾难。</li></ul><h2 id="三、条件状语从句转化为分词短语">三、条件状语从句转化为分词短语</h2><p>当分词短语表条件时，但从分词短语本身，是看不出真实和虚拟的，只有从句的时态才能看出来。</p><ul><li>Cooked in wine, snails are a great luxury in various parts of the world.（因为主句是一般现在时，所以本句的分词短语是真实条件，相当于真实条件状语从句If snails are cooked in wine, …）</li><li>Weather permitting, we’ll go fishing.（因为主句是一般将来时，所以本句的分词独立主格结构是真实条件，相当于真实条件状语从句If weather permits, we’ll go fishing.）</li><li>Added to steel, chromium increases the metal’s hardness.（相当于真实条件状语从句If chromium is added to steel, it increases the metal’s hardness.）</li><li>Given more time, I would be able to complete it.（相当于虚拟条件状语从句If I were given more time, I would be able to complete it.）</li><li>Given the right kind of training, these teenage soccer players may one day grew the international stars.</li></ul><h2 id="四、虚拟语气的特殊用法">四、虚拟语气的特殊用法</h2><p>与客观真理相反的强烈虚拟语气，从句用were to + 动词原形，主句用过去将来时（would可改为should，might，could）</p><ul><li>If I were to live my life over again, I would have you as my wife.</li><li>If the sun were to rise in the west, I would marry you.</li></ul><p>主观意志动词之后的宾语从句，要使用助动词should（可省略）。这类动词主要有3大类：“建议（suggest，advise，propose）”，“要求（demand，require，request，insist）”，“命令（order，command）”</p><ul><li>He suggested that a double railway tunnel (should) be built.</li><li>In life, your goals may require that you (should) try different approaches and persevere.</li></ul><p>should (ought to) have + 过去分词，表示与过去事实相反的推测，译为“早应，本应该…”</p><ul><li><p>He should have known that the police would never allow this sort of thing.</p></li><li><p>Those who failed to get in need not have felt disappointed as many of the artistes who should have appeared did not come.</p></li><li><p>A policeman approached Jimmy and told him he ought to have gone along a side-street as Jumbo was holding up  the traffic.</p><p>注：这里绝对不能说he ought to go along，它的意思是“只是他做某件事情”。</p></li></ul><p>whether引导的让步状语从句，可用虚拟语气</p><ul><li><p>Whether it be bird, fish or beast, the porpoise is intrigued with anything that is alive.</p></li><li><p>After all, all living creatures live by feeding on something else, whether it be plant or animal, dead or alive.</p><p>注：这种句型也可倒装，即去掉whether，把be放到从句句首。</p></li><li><p>Be it bird, fish or beast, the porpoise is intrigued with anything that is alive.</p></li><li><p>Be it a rock or a grain of sand, they sink as the same in water.</p></li><li><p>All students of English, be they native speakers or those who are studying English as a second language, will profit from this book.</p></li></ul><p>wish后面的宾语从句，必须使用虚拟语气</p><ul><li>I wish he were here.（现在虚拟，用一般过去时）</li><li>I wish I had kept faithful to my childhood dreams.（过去虚拟，用过去完成时）</li><li>I wish you would keep on trying to improve your English.（将来虚拟，用过去将来时。would可改为should，might，could）</li></ul><p>if only用于虚拟，表示“要是…该多好啊！”（时态变化同wish一样）</p><ul><li>If only he were here.</li><li>If only I had known it earlier.</li><li>If only I would make a lot of money.</li></ul><p>as if / as though用于虚拟，表示“就像…一样”（时态变化同wish一样）</p><ul><li>He acted as if he had never lived in England before.</li><li>I do not turn for protection to dreary cliches about respect of elders – as if mere age were a reason for respect.</li><li>I felt as if I had stumbled into a nightmare country, as you sometimes do in dreams.</li><li>It looks as if there would be an exciting race across the Channel.</li></ul><p>would rather / would sooner用于虚拟，表示”宁可…“。现在和将来虚拟，均用一般过去时。过去虚拟，用过去完成时。</p><ul><li>I would rather you had more health than wealth.（过去虚拟）</li><li>I would rather my father kept his mind and body active after he retires in three years.（将来虚拟）</li><li>I would rather my son had become a doctor, but he became a teacher after graduating.（过去虚拟）</li></ul><p>lest / in case / for fear的虚拟，表示“以防…”，谓语均要使用should（可省略） + 动词原形</p><ul><li>Weigh well your words lest they (should) be swords.</li><li>Take time when time comes, in case it (should) steal away.</li><li>We must not promise what we should not, for fear that we (should) be called on to perform what we cannot.</li></ul><p>what if …？如果…会怎么样呢？</p><ul><li>What if he doesn’t agree?</li><li>But what if your data do not support your hypothesis? Perhaps different experiments are needed.</li></ul><p>翻译练习：</p><ul><li>你若中了一亿美元，你可能会做什么？</li><li>如果我五年前遇到她，今天她可能就是我的妻子了。</li><li>我建议你把这篇作文撕掉，再从头开始写。</li><li>我们几个月前就该预见到这一困难。</li><li>既然已完成了工作，你本就应该好好休息一下。</li><li>所有物质，不论是气体、液体、或固体，都是由原子构成的。</li><li>我希望我能改掉吸烟的习惯。</li><li>我倒希望你当初别把这一切都告诉我。</li><li>我多么希望你妹妹能在这儿。</li><li>太疲倦了。如果明天能不上班多好。</li><li>玛丽对着我微笑，仿佛他已经了解我想要什么。</li><li>我们小声说话以免吵醒婴儿。</li><li>我要是没有买这栋房子又会怎么样呢？</li></ul>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不定式短语</title>
    <link href="/2022/07/24/%E4%B8%8D%E5%AE%9A%E5%BC%8F%E7%9F%AD%E8%AF%AD/"/>
    <url>/2022/07/24/%E4%B8%8D%E5%AE%9A%E5%BC%8F%E7%9F%AD%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们已经讲解了前两种非谓语动词，分词和动名词。接下来，我们来看最后一种，不定式。</p><h2 id="一、不定式短语">一、不定式短语</h2><p>不定式，即to的后面加动词。表示动作还没有定下来，它可能发生在未来，也可能不发生。</p><p>不定式有“逻辑将要”的含义，故其动作发生在前面的动词之后，而且多表达意愿、目的、企图等。</p><p>不定式同时具有与分词和动名词类似的功能。</p><h3 id="1-1、名词从句的化简">1.1、名词从句的化简</h3><h4 id="1-1-1、作主语">1.1.1、作主语</h4><p>不定式和动名词作主语一般可以通用。但在表达还没有做一件事时，使用不定式会更加准确。</p><ul><li><p>To make large sums of money is my dream.</p><p>That I will make large sums of money is my dream.</p><p>挣大钱是我的梦想。</p><p>注：如果本句用Making large sums of money is my dream.也是对的，但是用不定式暗示“我要去挣钱”，但目前没有挣到钱。</p></li></ul><p>不定式作主语时，可用形式主语It取代，然后将不定式放在句子主干之后。</p><ul><li><p>It was his job to repair bicycles and at that time he used to work fourteen hours a day.</p><p>It was his job that he repaired bicycles and at that time he used to work fourteen hours a day.</p><p>他那是的工作是修理自行车，并且通常是一天工作14个小时。</p></li><li><p>So, it comes as a surprise to learn that giant fish are terrifying the divers on North Sea oil rigs.</p><p>So, it comes as a surprise that we learn giant fish are terrifying the divers on North Sea oil rigs.</p><p>因此，听说北海石油钻井平台上的潜水员受到巨型鱼类的恐吓，确实很让人吃惊。</p></li></ul><p>不定式短语作主语时，一律视为第三人称单数。但and连接的两个不定式短语作主语时，视为复数。</p><ul><li><p>To become a great scientist is his ultimate goal.</p><p>成为伟大的科学家是他的终极目标。</p></li><li><p>To study and to play are equally important.</p><p>学习和玩耍同样重要。</p></li></ul><p>造句练习（注：鼠标选中空白处有惊喜哦）：</p><ul><li><p>成为职业篮球选手是我的抱负之一。</p><p><font color="#ffffff"> To become a professional basketball player is one of my ambitions. </font><br><font color="#ffffff"> It is one of my ambitions to become a professional basketball player. </font></p></li><li><p>精通一门外语需要不断的努力。</p><p><font color="#ffffff"> To master a foreign language takes constant effort. </font><br><font color="#ffffff"> It takes constant effort to master a foreign language. </font></p></li><li><p>提高我们的生产力是我们今年的主要目标。</p><p><font color="#ffffff"> To increase our productivity is our main goal this year. </font><br><font color="#ffffff"> It is our main goal this year to increase our productivity. </font></p></li><li><p>对于某些人而言，活着就是受苦。</p><p><font color="#ffffff"> For some people, to live is to suffer. </font><br><font color="#ffffff"> It is suffering for some people to live. </font></p></li><li><p>一天大笑三次有意健康。</p><p><font color="#ffffff"> It is good for your health to laugh three times a day. </font><br><font color="#ffffff"> To laugh three times a day it is good for your health. </font></p></li><li><p>犯错是人之常情，宽恕则超凡入圣。</p><p><font color="#ffffff"> To err is human, to forgive is divine. </font></p></li><li><p>知道做什么是智慧，知道怎么做是技能。</p><p><font color="#ffffff"> To know what to do is wisdom, To know how to do it is skill. </font></p></li><li><p>让自己的孩子诚实是教育的开端。</p><p><font color="#ffffff"> To make your children capable of honesty is the beginning of education. </font></p></li><li><p>爱是世界上最美的动词。</p><p><font color="#ffffff"> To love is the most beautiful verb in the world. </font></p></li><li><p>人生得一知己足矣。</p><p><font color="#ffffff"> It is enough to have one close friend in one’s life. </font></p></li><li><p>诅咒黑暗不如点亮一支蜡烛。（临渊羡鱼，不如退而结网）</p><p><font color="#ffffff"> It is better to light a candle than to curse the darkness. </font></p></li></ul><h4 id="1-1-2、作宾语">1.1.2、作宾语</h4><p>大部分及物动词，其后既可以用不定式，也可以用动名词，比如begin doing = begin to do。但是，表示“企图”或者“意愿”的及物动词，其宾语是“将要发生的事情”，所以，通常只能用不定式作宾语。</p><p>这类动词有：attempt企图、choose选择、decide决定、expect期望、hope希望、intend打算、manage设法、offer/volunteer主动提议、plan计划、want要、wish希望、endeavor努力</p><p>另外，需要注意的是，不定式绝对不能作介词的宾语。</p><ul><li><p>Debbie is only eleven years old and she hopes to set up a new world record.</p><p>Debbie is only eleven years old and she hopes that she can set up a new world record.</p><p>黛比只有11岁，她希望创一项新的世界纪录。</p></li><li><p>Last Christmas, the circus owner, Jimmy Gates, decided to take some presents to a children’s hospital.</p><p>Last Christmas, the circus owner, Jimmy Gates, decided that he could take some presents to a children’s hospital.</p><p>去年圣诞节，马戏团老板吉米·盖茨决定送些礼物给儿童医院。</p></li><li><p>It has four Rolls-Royce Merlin engines, but the group will need to have only three of them rebuilt.</p><p>It has hour Rolls-Royce Merlin engines, but the group will need that they will have only three of them rebuilt.</p><p>该飞机装配有4台罗尔斯·罗伊斯的默林发动机，但是他们只需要修复其中的3台。</p></li><li><p>The pilot managed to circle the balloon for some time.</p><p>The pilot managed that he circled the balloon for some time.</p><p>飞行员设法绕着气球飞了一阵。</p></li></ul><p>在第四大句型中，不定式作不完全及物动词的宾语时，必须用形式宾语it取代，加上宾语补语之后，再加不定式。比如，“某人认为做某事是怎么样的”，即：sb. + think/believe/find/deem/consider + it + (to be) + 名词或形容词（补语） + 不定式（宾语），此时to be可省略。</p><ul><li><p>I think it necessary to drink a lot of water.</p><p>I think it necessary that I should drink a lot of water.</p><p>我人为每天多喝水很有必要。</p></li><li><p>I consider it a great honor to be invited to dinner.</p><p>我认为能被邀请参加晚宴是很大的荣幸。</p></li><li><p>I deem it a great honor to serve you.</p><p>我认为为您服务是一项光荣。</p></li><li><p>A Frenchman, for instance, might find it hard to laugh at a Russian joke.</p><p>例如，法国人听完一则俄国笑话可能很难发笑。</p></li></ul><p>和名词从句不同，不定式短语可以和动词make组成宾补句型，用于表示“使某种事情变得怎么样”，即：make + it + (to be) + 名词或形容词（补语） + 不定式（宾语）</p><ul><li><p>The invention of computers has made it possible to free man from the complex labor.</p><p>计算机的发明使得人们有可能从繁杂劳动中解放出来。</p></li><li><p>I made it my business to know all about them.</p><p>我把了解他们作为我的业务。</p></li></ul><p>造句练习（注：鼠标选中空白处有惊喜哦）：</p><ul><li><p>我主动提议帮玛丽忙，但她拒绝了（take sb. down）。</p><p>I offered to give Mary a hand, but she turned me down.</p></li><li><p>我们企图说服约翰戒烟，但没有效果。</p><p>We attempted to persuade John to quit smoking, but in vain.</p></li><li><p>我不觉得理解VOA的慢速英语节目有难度。</p><p>I don’t think it difficult to understand the VOA Special English.</p></li><li><p>虽然声音被听得很清楚，但费了我很长时间才作出反应。</p><p>Though the sound could be heard clearly, it took me a long time to react.</p></li></ul><p>补充：有些及物动词，即可以用动名词也可以用不定式作宾语，但是意义不同。要区分很简单，动名词表示已经做过的事情，不定式表示正打算做的事情。比如说：</p><ul><li><p>stop doing（停止做某事）</p><p>stop to do（停下来去做某事）</p></li><li><p>remember doing（记得做过某事）</p><p>remember to do（记得去做某事）</p></li><li><p>forget doing（忘记做过某事）</p><p>forget to do（忘记去做某事）</p></li></ul><h4 id="1-1-3、作表语">1.1.3、作表语</h4><p>不定式作表语时，通常是名词性的表语。</p><ul><li><p>The only way to do this was to operate.</p><p>做这件事唯一的办法就是手术。</p></li><li><p>My hope is to become a scientist like Einstein.</p><p>我的理想就是做一个像爱因斯坦那样的科学家。</p></li></ul><p>当主语是人时，用不定式作表语，表示一定会发生的情况（如计划，命令，肯定推测等）。</p><ul><li><p>I am to realize the goal of life.（肯定推测）</p><p>我一定要实现人生的目标。</p></li><li><p>You are to be back by 10 o’clock.（命令）</p><p>你必须十点以前回来。</p></li><li><p>You are not to smoke in the reading-room.（用于否定句表示“禁止”）</p><p>你不能在阅读室吸烟。</p></li></ul><p>特征动词（seem似乎是、appear看起来是、prove被证明是、turn out结果是）的表语，通常用不定式，此时to be可省略。</p><ul><li><p>These birds seem (to be) unaffected by climate.</p><p>这些鸟似乎不受气候的影响。</p></li><li><p>He appears (to be) a perfectly normal person.</p><p>他看上去是一个完全正常的人。</p></li><li><p>The search proved (to be) difficult.</p><p>这次搜索被证明是很困难的。</p></li><li><p>He turned out (to be) right.</p><p>结果他是对的。</p></li></ul><h4 id="1-1-4、作宾语补语">1.1.4、作宾语补语</h4><p>当不定式作宾语补语或被动语态的主语补语时，如果不定式是to be，则可以省略。</p><ul><li><p>She wanted him to repair their son’s bicycle!</p><p>她希望他修理孙子的自行车。</p></li><li><p>When it was eventually brought to shore, it was found (to be) over thirteen feet long.</p><p>当终于把它弄上岸后，人们发现它身长超过了13英尺。</p></li></ul><h4 id="1-1-5、作同位语">1.1.5、作同位语</h4><p>不定式还可以作同位语。</p><ul><li><p>My plan to visit the town was refused.</p><p>My plan that I will visit the town was refused.</p><p>我参观小镇的计划被拒绝了。</p></li></ul><h4 id="1-1-6、疑问句-不定式">1.1.6、疑问句 + 不定式</h4><p>当疑问词和不定式，构成名词短语时，用法和名词相同。</p><ul><li><p>I was just wondering how to spend the morning.</p><p>I was just wondering how I would spend the morning.</p><p>我正不知道怎么消磨这一上午呢。</p></li></ul><h3 id="1-2、状语从句的化简">1.2、状语从句的化简</h3><p>不定式作状语，只能表目的和结果。</p><h4 id="1-2-1、作目的状语">1.2.1、作目的状语</h4><ul><li><p>Fifteen policemen had to push very hard to get him off the main street.</p><p>Fifteen policemen had to push very hard so that they could get him off the main street.</p><p>15个警察不得不用很大的力气把它推离主要街道。</p></li><li><p>When the bull got close to him, he clumsily stepped aside to let it pass.</p><p>When the bull got close to him, he clumsily stepped aside so that he could let it pass.</p><p>当公牛逼近他时，他踉跄地往旁边一闪，牛扑空了。</p><p>注：由于let是不完全及物动词，故此不定式短语类似第四大句型，it是不定式to let的宾语，pass是宾语补语</p></li><li><p>It was not long before a helicopter arrived on the scene to rescue the survivors of the plane crash.</p><p>It was not long before a helicopter arrived on the scene so that it could rescue the survivors of the plane crash.</p><p>不久，一架直升飞机抵达飞机失事现场，来搭救这几个幸存者。</p></li><li><p>Specially-made lanterns are hung outside each house to help the dead to find their way.</p><p>Specially-made lanterns are hung outside each house so that they could help the dead to find their way.</p><p>特制的灯笼在各家的门外，为的是帮助亡灵看清道路。</p></li></ul><p>有时候，为了强调目的状语，可以将不定式放在句首。</p><ul><li><p>To acquire knowledge, one must study; but to acquire wisdom, one must observe.</p><p>要想获得知识，就必须学习。但要想获得智慧，就必须学会观察。</p></li><li><p>To be really happy and really safe, one ought to have at least two or three hobbies, and they must all be real.</p><p>要想真正幸福和平安，一个人至少应该有两三种业余爱好，而且必须是真正的爱好。</p></li></ul><h4 id="1-2-2、作结果状语">1.2.2、作结果状语</h4><p>分词短语表示意料之中的结果，而不定式表示意料之外的结果。</p><ul><li><p>Farm laborers said that they always woke up to find the work had been done overnight.</p><p>农场工人们说，常常一早起来却发现有人在夜里把活干了。</p></li><li><p>The small company has beaten other big companies, to win the title of best business-class service.</p><p>这个小航空公司击败了其他大公司从而赢得了最佳商务舱服务奖。</p></li></ul><h4 id="1-2-3、造句练习">1.2.3、造句练习</h4><p>注：鼠标选中空白处有惊喜哦</p><ul><li><p>憎恨别人，犹如为了除掉一只老鼠而烧掉自己的房子。</p><p><font color="#ffffff"> Hating people is like burning down your own house to get rid of a rat. </font></p></li><li><p>为了赢得这个奖，你应该很努力地奋斗。</p><p><font color="#ffffff"> To win the award, you should work very hard. </font></p></li></ul><h3 id="1-3、定语从句的化简">1.3、定语从句的化简</h3><h4 id="1-3-1、关系代词作主语">1.3.1、关系代词作主语</h4><p>关系代词作主语引导的定语从句，可以化简为不定式短语，此时的先行词，通常被绝对性形容词修饰</p><ul><li><p>I have no friend to advise me.</p><p>I have no friend who can advise me.</p><p>我没有可以给我忠告的朋友。</p><p>注：因为本句中有绝对性形容词no，所以用不定式作定语，而不用分词</p></li><li><p>He was the first person to greet me when I arrive there.</p><p>He was the first person who greet me when I arrive there.</p><p>当我到那儿的时候，他是第一个来迎接我的人。</p><p>注：因为本句中有绝对性形容词first，所以用不定式作定语，而不用分词。</p></li></ul><h4 id="1-3-2、关系代词作宾语">1.3.2、关系代词作宾语</h4><p>关系代词作宾语引导的定语从句，可以化简为不定式短语，此时的不定式动词必须是及物动词或者及物动词短语，表示“有某事要做”</p><ul><li>I have a letter to write.（我有一封信要写）</li><li>I will write a letter.（我要写一封信）</li></ul><p>上面这两句话的中文意思和英文意思是一样的。需要注意的是，这里的不定式to write作定语，修饰名词letter，不定式动词write是及物动词，其修饰的名词letter是不定式的逻辑宾语。</p><ul><li><p>He never has anything to do.</p><p>He never has anything that he can do.</p></li></ul><p>我们不能说，He is a nice man to work.因为这里的work是不及物动词，不能接宾语man。所以，必须改为，He is a nice man to work with.</p><h4 id="1-3-3、关系副词">1.3.3、关系副词</h4><p>关系副词引导的定语从句，可以化简为不定式短语，此时不定式动词必须是不及物动词，或者及物动词+宾语</p><ul><li><p>The time to go is July.（不及物动词go）</p><p>The time when we should go is July.</p><p>应该在7月份去。</p></li><li><p>It is time to draw a conclusion.（及物动词draw + 宾语conclusion）</p><p>到下结论的时间了。</p></li><li><p>A good place to eat food is the Sichuan restaurant around the corner.</p><p>A good place where we can eat food is the Sichuan restaurant around the corner.</p><p>一个吃饭的好地方就是拐角的那家川菜馆。</p></li><li><p>The only way to do this was to operate.</p><p>The only way in which they can do this was to operate.</p><p>做这件事唯一的办法就是手术。</p></li></ul><h4 id="1-3-4、造句练习">1.3.4、造句练习</h4><p>注：鼠标选中空白处有惊喜哦</p><ul><li><p>我有一封信要写。</p><p>I have a letter to write.</p></li><li><p>他是做最后决定的最佳人选。</p><p>He is the best man to make the final choice.</p></li><li><p>在天黑前，我们还有很长的路要走。</p><p>We had a long journey to make before nightfall.</p></li><li><p>她有四个孩子要照顾。</p><p>She has hour children to take care of.</p></li><li><p>下一列到达的火车是从纽约开过来的。</p><p>The next train to arrive is from New York.</p></li><li><p>克林顿是这次空难中唯一的幸存者。</p><p>Clinton is the only person to survive the air crash.</p></li><li><p>角色扮演（role playing）是一种有效而且自得其乐的英语学习方法。</p><p>Role playing is an effective and enjoyable way to learn English.</p></li></ul><h2 id="二、不定式短语的逻辑主语">二、不定式短语的逻辑主语</h2><p>当不定式短语的逻辑主语和句子的主语不一致的时候，通常用这样的结构：for + 名词 + 不定式</p><ul><li><p>He expects for his sister to meet you.</p><p>He expects that his sister can meet you.</p><p>他期望他妹妹认识你。</p></li><li><p>There is no need for you to go.</p><p>你没有必要去。</p></li><li><p>Dentists always ask questions when it is impossible for you to answer.</p><p>牙科医生总是在你无法作出回答的时候向你提出问题。</p></li><li><p>Chinese parents wanted their children to be successful, while American parents expressed a desire for their children to be happy.</p><p>中国父母希望孩子成功，而美国的父母表达了他们的愿望，那就是希望他们孩子幸福。</p></li></ul><p>当代词作不定式的逻辑主语时，要用宾格</p><ul><li><p>My sister told me that she would love for me to babysit for her.</p><p>姐姐告诉我她很想要我帮她照顾小孩。</p></li></ul><p>当我们想表达“对于···来说做某事是怎么样的”，通常都可以采用不定式带上逻辑主语的结构：It is + 形容词 + for sb. to do sth.</p><ul><li><p>It is necessary for him to study English every day.</p><p>对他来说，每天学习英语是很有必要的。</p></li></ul><p>在It is + 形容词 + for sb. to do sth.句型中，当表示人物性格的形容词（聪明，善良，粗心，愚蠢等）和不定式连用时，要用of代替for</p><ul><li><p>It’s wise of you not to argue with our boss.</p><p>明智的做法是不和你的老板争吵。</p></li><li><p>It was very careless of him to make such silly mistakes.</p><p>他太粗心了，居然犯了如此愚蠢的错误。</p></li></ul><p>造句练习（注：鼠标选中空白处有惊喜哦）：</p><ul><li><p>此刻，我很难表达我的心情。</p><p><font color="#ffffff"> It’s very difficult for me to express my feelings at this moment. </font></p></li><li><p>你有必要亲自去那里一趟。<br><font color="#ffffff"> It’s necessary for you to go there in person. </font></p></li><li><p>他很慷慨，把它的车借给了我。</p><p><font color="#ffffff"> It’s generous of him to lend me his car. </font></p></li></ul><h2 id="三、不定式短语的时态和语态变化">三、不定式短语的时态和语态变化</h2><p>不定式短语，没有“时”的变化，而只有“态”的变化。</p><p>不定式有4态，即一般态、完成态、进行态和完成进行态。其构成也非常简单，就是to + 4态。</p><p>不定式的被动语态，就是to + 4态的被动语态。但进行态和完成进行态很少用被动语态。</p><p>以动词do为例：</p><ul><li>一般态：主动语态为to do，被动语态为to be done</li><li>完成态：主动语态为to have done，被动语态为to have been done</li><li>进行态：主动语态为to be doing，一般不用被动语态</li><li>完成进行态：主动语态为to have been doing，一般不同被动语态</li></ul><p>通常，不定式的一般态是最常用的：</p><ul><li><p>He wanted some photographs to be taken when he visited Taiwan.（一般态，被动语态）</p><p>他在台湾参观的时候想找人拍几张照片。</p></li></ul><p>不定式的完成态，表示不定式的动作发生在谓语动作之前：</p><ul><li><p>Fishermen and sailors sometimes claim to have seen monsters in the sea.（完成态，主动语态）</p><p>渔夫和水手们有时声称自己看到过海里的妖怪。</p></li><li><p>This building was said to have been build from their own designs.（完成态，被动语态）</p><p>这就说是他们自行设计建造的。</p></li></ul><p>不定式的进行态，表示不定式的动作与谓语动作同时发生。不定式的进行态不常用，通常只用于seem/appear，happen等动词之后，表达“似乎正在做某事”，“碰巧正在做某事”等等。</p><ul><li><p>A pilot noticed a balloon which seemed to be making for a Royal Air Force Station nearby.</p><p>一个飞行员发现了一只气球，它像是正飞往附近的一个皇家空军基地。</p></li></ul><p>不定式的完成进行态，是完成态的延续动词用法（少见用法）。</p><ul><li><p>They are said to have been collecting stamps.</p><p>They are said to have collected stamps.</p><p>据说他们一直在收集邮票。</p></li></ul><p>需要注意的是，以下是常见的固定搭配，即只能用不定式，而不能用分词或动名词：</p><ul><li>claim to do（声称…）</li><li>be said to do（据说…）</li><li>be supposed/thought/expected to do（应该…）</li><li>seem / appear（似乎…）</li></ul><p>例句：</p><ul><li><p>Everyone went to the funeral, for the ‘ghost’ was none other than Eric Cox, a third brother who was supposed to have died as a young man.</p><p>大家都去参加了葬礼，因为那“鬼”不是别人，正是农场主的兄弟埃里克·考科斯。人们以为埃里克年轻时就死了。</p></li><li><p>When I was a boy, my grandfather tole me how a German taxi driver, Franz Bussman, found a brother who was thought to have been killed twenty years before.</p><p>当我是个孩子的时候，我祖父给我讲了一位德国出租汽车司机弗朗兹·巴斯曼如何找到了据信已在20年前死去的兄弟的事。</p></li></ul><p>造句练习（注：鼠标选中空白处有惊喜哦）：</p><ul><li><p>他想要找人立刻把这些信打印出来。</p><p><font color="#ffffff"> he wanted the letters to be typed at once. </font></p></li><li><p>我很抱歉在这个时候还用这么多问题来打扰你。</p><p><font color="#ffffff"> I’m sorry to have bothered you with so many questions on such an occasion. </font></p></li><li><p>她妈妈走进来的时候，他假装正在睡觉。</p><p><font color="#ffffff"> He pretended to be sleeping when his mother came in. </font></p></li><li><p>那个小女孩今晚好像一直在看电视。</p><p><font color="#ffffff"> The little girl seems to have been watching TV all this evening. </font></p></li></ul><h2 id="四、小结">四、小结</h2><p>最后，小结一下今天的内容，我们还是直接看图：</p><p><img src="/img/image-20221225180918456.png" alt="image-20221225180918456"></p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动名词短语</title>
    <link href="/2022/07/24/%E5%8A%A8%E5%90%8D%E8%AF%8D%E7%9F%AD%E8%AF%AD/"/>
    <url>/2022/07/24/%E5%8A%A8%E5%90%8D%E8%AF%8D%E7%9F%AD%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<p>在前面我们已经讲解了第一种非谓语动词，分词。今天我们继续来看第二种非谓语动词，动名词。</p><h2 id="一、动名词短语">一、动名词短语</h2><p>所谓动名词，就是动词的ing形式。在句子中我们常称之为动名词短语。</p><p>动名词短语，相当于名词从句中that从句的简化。任何一个that从句，都可以用动名词短语代替。</p><p>动名词具有名词的性质。名词能作什么，动名词就能作什么。比如，</p><ul><li>Many people pretend that they understand modern art.</li></ul><p>在这句话中，宾语从句可以改为动名词短语。</p><ul><li>Many people pretend understanding modern art.</li></ul><p>在改成动名词短语后，动名词的逻辑主语可以很清楚的看出就是people。</p><h3 id="1-1、动名词作主语">1.1、动名词作主语</h3><p>动名词具有名词的性质，在没有特指是谁发出这个动作的情况下，可以不考虑其逻辑主语。因为在语境中一眼就能看出是谁发出的动作。</p><ul><li><p>Working 12 hours a day exhausts me completely.</p><p>That I work 12 hours a day exhausts me completely.</p><p>每天工作12小时让我筋疲力尽。</p></li><li><p>Playing football is my favorite sport.</p><p>That I play football is my favorite sport.</p><p>踢足球是我最喜欢的运动。</p></li></ul><p>动名词作主语时，和名词从句一样，也可用形式主语It取代，然后将动名词放在句子主干之后（尤其是动名词短语比较长时）。但只有在it is no use结构中，真正的主语仍为动名词。在其它结构中，真正的主语是不定式短语。</p><ul><li><p>It was no use pretending that I had not seen him, so I waved to him.</p><p>Pretending that I had not seen him was no use, so I waved to him.</p><p>That I pretend that I had not seen him was no use, so I waved to him.</p><p>若再装作没看见他已是没有用了，我只好向他招手。</p></li></ul><p>动名词短语作主语时，一律视为第三人称单数。但当and连接两个动名词短语作主语时，视为复数。</p><ul><li><p>Singing with you guys is a lot of fun.</p><p>和你们一伙人唱歌很有趣。</p></li><li><p>Learning English and listening to music are my hobbies.</p><p>学英语和唱歌是我的爱好。</p></li></ul><p>造句练习（注：鼠标选中空白处有惊喜哦）：</p><ul><li><p>慢跑是保持健康的好方法。</p><p><font color="#ffffff"> Jogging is a good way to stay health/fit. </font><br><font color="#ffffff"> That you jog is a good way to say health/fit. </font></p></li><li><p>与你共事一直以来都是越快的经历。（用完成进行态）</p><p><font color="#ffffff"> Working with you has been a pleasant experience. </font><br><font color="#ffffff"> It has been a pleasant experience to work with you. </font></p></li><li><p>说是一回事，做又是另一回事。</p><p><font color="#ffffff"> Saying is one thing, doing is another. </font><br><font color="#ffffff"> That you say is noe thing, that you do is another. </font></p></li><li><p>出国旅游有助于增长你的见识。</p><p><font color="#ffffff"> Travelling abroad helps broaden your horizons. </font><br><font color="#ffffff"> That your Travel abroad helps broaden your horizons. </font></p></li><li><p>做家务和照顾我们的小孩是我老婆每天做的事。</p><p><font color="#ffffff"> Doing the housework and taking care of our children are what my wife does every day. </font><br><font color="#ffffff"> It’s what my wife does every day to do the housework and take care of our children. </font></p></li><li><p>学而不思则罔，思而不学则殆。</p><p><font color="#ffffff"> Learning without thinking is useless, thinking without learning is dangerous. </font><br><font color="#ffffff"> That you learn without that you think is useless, That you think without that you learn is dangerous. </font></p></li><li><p>相信自己是成功的秘诀！</p><p><font color="#ffffff"> Believing in yourself is the secret of success. </font><br><font color="#ffffff"> That you believe in yourself is the secret of success. </font></p></li><li><p>拥有知己本身就是一种幸福。</p><p><font color="#ffffff"> Having intimate friends is happiness in itself. </font></p></li><li><p>取胜并不重要，但努力去赢得胜利却是重要的。</p><p><font color="#ffffff"> Winning is not everything, but trying to win is everything. </font></p></li><li><p>拥有目标是一种幸福的状态。</p><p><font color="#ffffff"> Having a goal is a state of happniess. </font></p></li><li><p>牛奶已撒，哭也没用。</p><p><font color="#ffffff"> It is no use crying over spilt milk. </font></p></li><li><p>光学习不实践是没用的。</p><p><font color="#ffffff"> It is no use learning without practice. </font></p></li><li><p>从事自己喜欢的事情没用，你必须喜欢自己从事的事情。</p><p><font color="#ffffff"> It is no use doing what you like, you have got to like what you do. </font></p></li></ul><h3 id="1-2、动名词作宾语">1.2、动名词作宾语</h3><p>作及物动词的宾语</p><ul><li><p>I love traveling in the country, but I don’t like losing my way.</p><p>I love that I travel in the country, but I don’t like that I lose my way.</p><p>我喜欢在乡间旅行，但是不喜欢迷路。</p></li><li><p>Losers avoid becoming self-responsible.</p><p>Losers avoid that they become self-responsible.</p><p>失败者逃避为自己负责。</p></li></ul><p>作介词的宾语</p><ul><li><p>My friends kept on offering me cigarettes and cigars.（on和后面的动名词短语一起，作kept的宾语）</p><p>My friends kept on that they offer me cigarettes and cigars.</p><p>我的朋友们不断地向我递香烟和雪茄。</p></li><li><p>Some children can cover the whole length of the pool without coming up for breath even once.</p><p>Some children can cover the whole length of the pool without that they come up for breath even once.</p><p>有些孩子能够跑完游泳池的全长而不用露出水面换气。</p></li></ul><p>以下动词，其后只能用动名词作宾语，而不能用不定式。</p><ul><li>懂得欣赏 克制想象。“懂得”即understand，“欣赏”即appreciate（该词还可作“感激”之意解），“克制”即deny（该词也可作“否认”、“拒绝”之意），“想象”即imagine。</li><li>喜欢实践 逃避抵抗。“喜欢”即enjoy，“实践”即practice，“逃避”即avoid/escape，“抵抗”即resist。</li><li>介意打扰 讨厌原谅。“介意”即mind，“打扰”即excuse，“讨厌”即dislike/hate，“原谅”即pardon。</li><li>支持建议 推迟考虑。“支持”即favor（该词也可作“赞成”，“宠爱”），“建议”即suggest，“推迟”即delay / postpone，“考虑”即consider。</li><li>情不自禁 完成冒险。“错过”即miss，“盼望”即look forward to，“完成”即finish，“冒险”即risk。</li></ul><p>以下含有介词to的动词短语，也是只能用动名词作宾语。</p><ul><li>look forward to期待</li><li>object to反对</li><li>be/get used to习惯于</li></ul><p>造句练习（注：鼠标选中空白处有惊喜哦）：</p><ul><li><p>大多数小朋友喜欢看卡通。</p><p><font color="#ffffff"> Most children enjoy watching cartoons. </font></p></li><li><p>很多大学毕业生正考虑在寻找工作前先去度个假。</p><p><font color="#ffffff"> A lot of college graduates are considering taking a vacation before their job hunting. </font></p></li><li><p>我每晚睡前都练习弹钢琴一个小时。</p><p><font color="#ffffff"> I practice playing the piano for an hour before I go to bed every night. </font></p></li><li><p>你能想象被困在交通阻塞中超过3小时吗？</p><p><font color="#ffffff"> Can you imagine being caught in traffic jam for over three hours? </font></p></li><li><p>我盼望不久再见到您。再见。</p><p><font color="#ffffff"> I look forward to seeing you again soon. Goodbye. </font></p></li></ul><h3 id="1-3、动名词作表语">1.3、动名词作表语</h3><ul><li><p>The subject of life is making choices.</p><p>The subject of life is that people make choices.</p><p>人生的课题就是做选择。</p></li><li><p>Courage is doing what you’re afraid to do.</p><p>勇气就是去做自己害怕做的事情。</p></li></ul><p>补充：动名词也可作同位语（较少见的用法）</p><ul><li><p>Many people admire his special ability, learning three languages at the same time.</p><p>很多人都羡慕他的特殊能力，同时学习3中预言。</p></li><li><p>My hobby swimming dates from my childhood.</p><p>我的业余爱好游泳源于我的童年。</p></li></ul><h2 id="二、动名词短语的逻辑主语">二、动名词短语的逻辑主语</h2><p>当动名词短语的主语和句子的主语不一致时，就必须加上动名词的逻辑主语。动名词短语的逻辑主语的构成方式为：所有格 + 动名词。比如，</p><ul><li>I remember that he promised to help these poor students.</li></ul><p>如果将这个句子改成，</p><ul><li>I remember promising to help these poor students.</li></ul><p>就是一个错误的句子。因为在这样的语境中，promising这个动名词，会被默认为是“我”发出的动作，这显然是不符合句意的。此时，必须给动名词加上逻辑主语，</p><ul><li>I remember his promising to help these poor students.</li></ul><p>原则上，如果主语是代词，通常用所有格，但如果主语是名词，则用所有格和普通格都正确。</p><ul><li><p>His not finishing the work disappointed me.</p><p>That he not finished the work disappointed me.</p><p>他未能准时完成工作让我失望。</p></li><li><p>Would you mind my coming with you?</p><p>Wold you mind that I come with you?</p><p>你介意我和你一起去吗?</p></li><li><p>Excuse my interrupting you.</p><p>Excuse that I interrupting you.</p><p>请原谅我打断你。</p></li></ul><p>注：在美式英语中，可以使用主格（动名词作主语），或宾格（动名词作宾语）代替所有格。所以，上述3个例句可以改成：</p><ul><li>He not finishing the work disappointed me.</li><li>Would you mind me coming with you?</li><li>Excuse me interrupting you.</li></ul><p>当出现下列情况时，即使是在正式文体中，动名词的逻辑主语也习惯使用普通格：</p><ul><li><p>逻辑主语为名词指物。</p><p>The children are looking forward to spring coming.</p><p>孩子们期待着春天的到来。</p></li><li><p>逻辑主语为多个名词。</p><p>Do you remember Mary and her mother coming to see us last June？</p><p>你还记得玛丽和她的妈妈去年6月来看我们吗？</p></li><li><p>逻辑主语是以“s”结尾的名词。</p><p>It’s a disaster the bosses shutting all those factories.</p><p>老板关掉了所有的工厂这简直是一场灾难。</p></li><li><p>逻辑主语与动名词分离。</p><p>I remember mother once telling us a story about the fox.</p><p>我记得妈妈曾经给我们讲过一个关于狐狸的故事。</p></li><li><p>逻辑主语为不定代词，如：someone, everything, something。</p><p>They complained about everything going wrong.</p><p>他们抱怨所有的事情都出错了。</p></li></ul><p>造句练习（注：鼠标选中空白处有惊喜哦）：</p><ul><li><p>我记得他曾经承诺，一旦我们遇到麻烦（get into trouble）他就会来帮助我们。</p><p><font color="#ffffff"> I remember his/him once promising to help us if we got into trouble. </font></p></li><li><p>老师拒绝接受我的建议让我很恼火。</p><p><font color="#ffffff"> My teacher’s refusing to accept my suggestion upset me. </font></p></li></ul><h2 id="三、动名词短语的时态和语态变化">三、动名词短语的时态和语态变化</h2><p>动名词短语，没有“时”的变化，只有“态”的变化，而且也只有一般态和完成态。此外，和分词短语一样，动名词短语也有主动和被动两种语态。</p><p>当动名词的动作和主句主语的动作同时发生时，用一般态。如果是表示被动的含义，则要用被动语态。（注：动名词短语如果是being，任何时候都不能省略）</p><ul><li><p>No one can avoid being influenced by advertisements.（一般态，被动语态）</p><p>没有人能避免受广告的影响。</p></li><li><p>Everyone appreciates being appreciated.（一般态，被动语态）</p><p>每个人都喜欢得到赞赏。</p></li><li><p>There is only one thing in the world worst than being talked about, and that is not being talked about.</p><p>世界上比被人议论更糟糕的一件事，就是根本没人去议论。</p></li><li><p>Being deeply loved by someone gives you strength, while loving someone deeply gives you courage.</p><p>人爱着有力，爱人者勇。</p></li></ul><p>当动名词的动作，发生在主句动作之前时，要用完成态。（但动名词具有名词性质，时态要求没有分词那么严格，此时用一般态也不算错误）</p><ul><li><p>No good thing can be enjoyed by us, without having cost labor.（完成态，主动语态）</p><p>No good thing can be enjoyed by us, without costing labor.</p><p>不付出辛劳，我们就不能享受任何美好的事物。</p></li><li><p>I appreciate having been given the opportunity to study abroad two years ago.（完成态，被动语态）</p><p>我很感激两年前得到一次出国留学的机会。</p></li></ul><p>下面两个短语为固定搭配，虽然是主动形式，但却是被动含义。</p><ul><li><p>sth. need doing（某事需要被做）</p><p>The classroom is so dirty that it needs cleaning thoroughly.</p><p>教室很脏，需要彻底清洁。</p></li><li><p>sth. be worth doing（某事值得被做）</p><p>By this time, a Lancaster bomber in reasonable condition was worth rescuing.</p><p>这个时候，一架状态良好的lancaster轰炸机是值得被救的。</p></li></ul><p>以下为特殊句型需要注意：</p><ul><li><p>Would  you mind + V-ing?（不需要注意时态）</p><p>Would you mind my opening the window? It’s very hot in here.</p><p>你介意我打开窗户吗？这里太热了！</p></li><li><p>Do you mind + V-ing?（不需要注意时态）</p><p>Do you mind hading me that book?</p><p>你介意把那本书给我吗？</p></li><li><p>Would you mind if + 句子（虚拟语气：一般过去时）</p><p>Would you mind if I smoked here?</p><p>你介意我在这里抽烟吗？</p></li><li><p>Do you mind if + 句子（真实语气：一般现在时）</p><p>Do you mind if I smoke here?</p><p>你介意我在这里抽烟吗？</p></li></ul><p>造句练习（注：鼠标选中空白处有惊喜哦）：</p><ul><li><p>这台电视机开关的声音在大街上都能被听到。</p><p><font color="#ffffff"> The noise of the television being opened and closed can be heard in the street. </font></p></li><li><p>我一直后悔上学时没有更加努力的学习。</p><p><font color="#ffffff"> I have always regretted not having sudied harder at school. </font></p></li><li><p>墙角处的那个人承认对这家公司的经理撒了谎（tell a lie）。</p><p><font color="#ffffff"> The man in the corner confessed to having told a lie to the manager of company. </font></p></li><li><p>马克每次违反交通规则（break traffic regulation）以后都常常试图逃避被罚款。</p><p><font color="#ffffff"> Mark often attempts to escape being fined whenever he breaks traffic regulations. </font></p></li><li><p>我们的现代文明决不能被认为（be thought of as）是短期内建立的。</p><p><font color="#ffffff"> Our modern civilization must not be thought as having been created in a short period of time. </font></p></li><li><p>你介意我提一个建议吗？</p><p><font color="#ffffff"> Would you mind my/me making a suggestion. </font></p></li></ul><h2 id="四、小结">四、小结</h2><p>最后，小结一下今天的内容，我们还是直接看图：</p><p><img src="/img/image-20221211214918094.png" alt="image-20221211214918094"></p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分词短语</title>
    <link href="/2022/07/23/%E5%88%86%E8%AF%8D%E7%9F%AD%E8%AF%AD/"/>
    <url>/2022/07/23/%E5%88%86%E8%AF%8D%E7%9F%AD%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<p>非谓语动词，是指句子中不是谓语的动词，它由动词变化而来，主要有三种，分词、动名词和不定式。今天我们主要来看第一种，分词。</p><h2 id="一、分词短语">一、分词短语</h2><p>分词，指的是动词的另外两种形式，现在分词和过去分词。比如，eat这个动词，它的现在分词是eating，它的过去分词是ate。而我们常说的分词短语，则主要是指现在分词，也就是动词的ing形态。</p><p>分词短语，是指在现在分词的后面加上名词或介词短语，它其实是一个简化的句子。</p><h3 id="1-1、并列句的简化">1.1、并列句的简化</h3><h4 id="1-1-1、并列句">1.1.1、并列句</h4><p>并列句实质上就是两个简单句放在一起，并无主次之分。比如：</p><ul><li>We are sitting by the sea.</li><li>We can see the beautiful sunrise.</li></ul><p>如果将这两个句子，放在一起，形成并列句，那就是：</p><ul><li>We are sitting by the sea and we can see the beautiful sunrise.</li></ul><p>注：这里的连词and绝对不能换成逗号。</p><h4 id="1-1-2、如何化简并列句">1.1.2、如何化简并列句</h4><blockquote><p>化简并列句时，通常简化哪一个单句呢？</p></blockquote><p>要强调哪个句子，就把哪个句子作为主句，另一个不重要的，则化简为分词短语。比如，</p><ul><li><p>如果认为前面的句子不重要，上节中的并列句化简后的结果是：</p><p>Sitting by the sea, we can see the beautiful sunrise.</p></li><li><p>如果认为后面的句子不重要，上节中的并列句化简后的结果是：</p><p>We are sitting by the sea seeing the beautiful sunrise.</p></li></ul><p>并列句变成的分词短语，我们称之为“伴随状语”。如果分词短语在主句前，一定要加上逗号；如果分词短语在主句后，逗号可要可不要。</p><h4 id="1-1-3、化简规则">1.1.3、化简规则</h4><p>当两句主语相同时，被化简句子的主语要删除，而当两句主语不同时，被化简句子的主语要保留。</p><p>比如，“He glanced at her scornfully and he told her that the dress was sold.”是一个并列句，两个分句的主语都是he，所以可以将其中任意一个分句，化简为分词短语。</p><ul><li>Glancing at her scornfully, he told her that the dress was sold.</li><li>He glanced at her scornfully telling her that the dress was sold.</li></ul><p>再比如，“We tried three new meals and the tastiest meal was the Thai dish.”也是一个并列句，第一个分句的主语是We，第二个分句的主语是the tastiest meal。此时两个分句的主语不同，所以都要保留下来。</p><ul><li>We trying three new meals, the tastiest meal was Thai dish.</li><li>We tried three new meals, the tastiest meal being Thai dish.</li></ul><p>如果被化简句子的动词是be动词（主系表句型，或被动语态），此时be动词化简为being，而且可以将being省略。</p><ul><li>She is a pop fan and she likes Jay Chou most.</li><li>Being a pop fan, she likes Jay Chou most.</li><li>A pop fan, she likes Jay Chou most.</li></ul><p>需要注意的是，在进行时态中，be动词不是系动词，而是助动词，不能简化成being。比如，</p><ul><li>He was playing basketball and he had a good time.</li></ul><p>在这个句子中，前面分句的动词是play，而不是was。所以只能改成</p><ul><li>Playing basketball, he had a good time.</li></ul><h4 id="1-1-4、例句">1.1.4、例句</h4><ul><li><p>Following in his father’s footsteps many years later, Donald, also set up a world record.</p><p>Donald followed in his father’s footsteps many years later and Donald also set up a world record.</p><p>很多年之后，马尔科姆爵士的儿子唐纳德踏着父亲的足迹，也创造了一项世界纪录。</p></li><li><p>Working rapidly in the darkness, he soon changed into the dead man’s clothes.</p><p>He worked rapidly in the darkness and he soon changed into the dead man’s clothes.</p><p>他在黑暗中忙活了一阵儿，很快就换上了死者的衣服。</p></li><li><p>The Channel Tunnel was officially opened on March 7, 1994, finally connecting Britain to the European continent.</p><p>The Channel Tunnel was officially opened on March 7, 1994 and The Channel Tunnel finally connected Britain to the European continent.</p><p>英法海底隧道于1994年3月7日正式开通，将英国与欧洲大陆连到了一起。</p></li><li><p>When it grew dark, she turned a suitcase into a bed and put the children inside it, covering them with all the clothes she could find.</p><p>When it grew dark, she turned a suitcase into a bed and put the children inside it and she covered them with all the clothes she could find.</p><p>天黑下来的时候，她把提箱当作小床，把两个孩子放了进去，又把所有能找到的衣服都盖在孩子们身上。</p></li><li><p>Thousands of lanterns slowly drift out to sea guiding the dead on their return journey to the other world.</p><p>Thousands of lanterns slowly drift out to sea and guide the dead on their return journey to the other world.</p><p>成千上万只灯笼慢慢飘向大海，指引着亡灵返回另一个世界。</p></li><li><p>This is a moving spectacle, for crowds of people stand on the shore watching the lanterns drifting away until they can be seen no more.</p><p>This is a moving spectacle, for crowds of people stand on the shore and watch the lanterns drifting away until they can be seen no more.</p><p>这是一个感人的场面，人们成群地伫立在海岸上，注视着灯笼远去，直到再也看不见为止。</p></li><li><p>Sensitive to criticism, the bull forgot all about the matador and charged at the drunk.</p><p>The bull was sensitive to criticism and the bull forgot all about the matador and charged at the drunk.</p><p>Being sensitive to criticism and the bull forgot all about the matador and charged at the drunk.</p><p>这头公牛对批评很敏感，它忘了斗牛士，冲向了酒鬼。</p></li><li><p>Now, dressed in a blue uniform and with a rifle over his shoulder, the prisoner marched boldly up and down in front of the camp.</p><p>Now, the prisoner was dressed in a blue uniform and with a rifle over his shoulder, the prisoner marched boldly up and down in front of the camp.</p><p>Now, being dressed in a blue uniform and with a rifle over his shoulder, the prisoner marched boldly up and down in front of the camp.</p><p>现在他身穿蓝军装，肩抗步枪，在军营门前大胆地来回走看。</p></li></ul><h4 id="1-1-5、造句练习">1.1.5、造句练习</h4><p>分别用并列句和分词短语造句（注：鼠标选中空白处有惊喜哦）：</p><ul><li><p>日本发生强烈地震，造成重大伤亡（heavy losses）。</p><p><font color="#ffffff"> A strong earthquake took place in Japan and caused heavy losses. </font></p><p><font color="#ffffff"> A strong earthquake took place in Japan causing heavy losses. </font></p></li><li><p>然后他跳进车里，以最快的速度把车开走了（drive off）。</p><p><font color="#ffffff"> Then, he jumped into the car and drove off as quickly as he could. </font></p><p><font color="#ffffff"> Then, jumping into the car, he drove off as quickly as he cloud. </font></p></li><li><p>这位女演员很开心能演这个角色，于是答应主演这部电影。</p><p><font color="#ffffff"> The actress was happy to play the role and accepted the offer to star in the film. </font></p><p><font color="#ffffff"> (Being) happy to play the role, the actress accepted the offer to star in the film. </font></p></li><li><p>然后，她拿着画板走进我的房间，同时唱着流行歌曲。</p><p><font color="#ffffff"> Then she marched into my room with her drawing board and sang a popular song. </font></p><p><font color="#ffffff"> Then she marched into my room with her drawing board, singing a popular song. </font></p></li><li><p>我环视了一下身旁，惊奇地发现车里就只剩我一个乘客了。</p><p><font color="#ffffff"> I looked round and realized with a shock that I was the only passenger left on the bus. </font></p><p><font color="#ffffff"> Looing round, I realized with a shock that I was the only passenger left on the bus. </font></p></li></ul><h3 id="1-2、状语从句的简化">1.2、状语从句的简化</h3><p>在时间、原因、目的、方式、结果、让步、条件等状语从句中，当从句的主语与主句的主语相同时，从句可化简为现在分词短语（being可省略）。</p><ul><li><p>Hearing the joke, we burst out laughing.（时间状语从句）</p><p>When we hard the joke, we burst out laughing.</p><p>听到这个笑话，我们大笑起来。</p></li><li><p>Not realizing who she was, the assistant was eager to serve her this time.（原因状语从句）</p><p>Because the assistant didn’t realize who she was, the assistant eager to serve her this time.</p><p>那个售货员没有认出她是谁，这一回接待她的态度非常殷勤。</p><p>注：否定分词结构，not要放在分词前面</p></li><li><p>Tired of sleeping on the floor, a young man in Teheran saved up for years to buy a real bed.（原因状语从句）</p><p>Because he was tired of sleeping on the floor, a young man in Teheran saved up for years to bus a real bed.<br>德黑兰的一个年轻人由于对睡地板感到厌倦，于是积蓄多年买了一张真正的床。</p></li><li><p>Not wanting to frighten the poor man, Mrs. Richards quickly hid in the small storeroom under the stairs.（原因状语从句）</p><p>Because Mrs. Richards didn’t want to frighten the poor man, she quickly hid in the small storeroom under the stairs.</p><p>理查兹夫人不想吓到这个可伶的人，便赶紧躲到了楼梯下的小储藏室里。</p></li><li><p>It rained for two weeks on end, completely ruining our holiday.（结果状语从句）</p><p>It rained for two weeks on end, so that it completely ruined our holiday.</p><p>我们假期的最后两个星期都在下雨，把我们的假期全毁了。</p></li><li><p>She tried to explain the situation, saying ‘It’s only me’, but it was too late.（结果状语从句）</p><p>She tried to explain the situation, so that she said ‘It’s only me’, but it was too late.</p><p>她试图解释现在的情况，于是说“是我，别怕”，但是太迟了。</p></li><li><p>The Titanic turned just in time, narrowly missing the immense wall of ice which rose over 100 feet out of the water beside her.（结果状语从句）</p><p>The Titanic turned just in time, so that it missed the immense wall of ice which rose over 100 feet out of the water beside her.</p><p>“泰坦尼克”拐弯很及时，紧贴着高出海面100英尺的巨大的冰墙插过去。</p></li><li><p>Her first impulse was to go round all the rooms looking for the thieves.（结果状语从句）</p><p>Her first impulse was to go round all the rooms, so that she can look for the thieves.</p><p>她的第一冲动是走遍所有房间，去寻找小偷。</p></li><li><p>Your time is limited, so don’t waste it living someone else’s life. Don’t let the noise of other’s opinions drown out your own inner voice.（目的状语从句）</p><p>Your time is limited, so don’t waste it so that you can live someone else’s life. Don’t let the noise of other’s opinions drown out your own inner voice.</p><p>你的时间有限，所以不要浪费时间去过别人的生活。不要让别人的意见淹没了你内心的声音。</p></li><li><p>I bound the base of the tree with sticky tape, making it impossible for the ants to reach the aphides.（目的状语从句）</p><p>I bound the base of the tree with sticky tape, so that I could make it impossible for the ants to reach the aphides.</p><p>我用一条胶带把桃树底部包上，不让蚂蚁接近蛀虫。</p></li><li><p>I crossed the street to avoid meeting him, but he saw me and came running towards me.（方式状语从句）</p><p>I crossed the street to avoid meeting him, but he saw me and came the way he ran to wards me.</p><p>我穿过马路以便避开他，但他看到我并朝我跑过来。</p></li><li><p>He and his staff began throwing furniture out of the window. Chairs and tables went flying into the arcade.（方式状语从句）</p><p>He and his staff began throwing furniture out of the window. Chairs and tables went  the way they flew into the arcade.</p><p>他与店员动手向窗外投掷家具，椅子和桌子飞落到拱廊街上。</p></li><li><p>He had a very sad look on his face. He walked looking only at the ground.（方式状语从句）</p><p>He had a very sad look on his face. He walked the way he looked only at the ground.</p><p>他的脸色看起来非常悲伤。他走路时只看着地面。</p></li><li><p>Every morning, he left home dressed in a smart black suit.（方式状语从句）</p><p>Every morning, he left home the way he was dressed in a smart black suit.</p><p>每天早晨，他穿上一身漂亮的黑色西装离家上班。</p></li><li><p>She enjoyed herself making the assistant bring almost everything in the window before finally buying the dress she had first asked for.（方式状语从句）</p><p>She enjoyed herself the way she made the assistant bring almost everything in the window before finally buying the dress she had first asked for.</p><p>她开心地迫使那位售货员把橱窗里几乎所有的东西都拿了出来，最后才买下了她最先要看的那一件。</p></li><li><p>Mocked at by everybody, he had my sympathy.（让步状语从句）</p><p>Though he was mocked at by everybody, he had my sympathy.</p><p>尽管大家嘲笑他，但是我很同情他。</p></li></ul><p>when、while、after、before、for、once、if、unless、though这些副词连词引导的状语从句，在化简为分词短语时，可以保留这些副词连词。其中，before和after不能省略。</p><ul><li><p>They have all been put to shame by a boy who, while playing truant, traveled 1,600 miles.（时间状语从句）</p><p>They have all been put to shame by a boy who, while he played truant, traveled 1,600 miles.</p><p>有那么一个小男孩，他在逃学期间旅行了1,600英里，从而是上述所有逃学的孩子们都相形见绌了。</p></li><li><p>Even the bull seemed to feel sorry for him, for it looked on sympathetically until the drunk was out of the way before once more turning its attention to the matador.（时间状语从句）</p><p>Even the bull seemed to feel sorry for him, for it looked on sympathetically until the drunk was out of the way before it once more turned its attention to the matador.</p><p>好像连牛也在为他感到遗憾，因为它一直同情地看着醉汉，直到他的背影消逝，才重新将注意力转向斗牛士。</p></li><li><p>He was sent to prison for failing to pay his debts and died in poverty in 1836.（原因状语从句）</p><p>He was sent to prison for he failed to pay his debts and died in poverty in 1836.</p><p>他因无力还债而被捕入狱，最后于1836年在贫困中死去。</p></li><li><p>It is important that I do not despair when faced with difficulties.（时间状语从句）</p><p>It is important that I do not despair when I am faced with difficulties.</p><p>重要的是，当我面对困难的时候我不会绝望。</p></li><li><p>Though a little suspicious this time, the policeman gave him the same answer.（让步状语从句）</p><p>Though the policeman was a little suspicious this time, the policeman gave him the same answer.</p><p>虽然那位警察这次有点疑心，但还是对他作了同样的回答。</p></li></ul><p>造句练习（分别用状语从句和分词短语造句）：</p><p>注：鼠标选中空白处有惊喜哦</p><ul><li><p>我没事做， 所以感到很无聊。</p><p><font color="#ffffff"> Because I have nothing to do, I felt bored. </font><br><font color="#ffffff"> Having nothing to do, I felt bored. </font></p></li><li><p>你尚未满18岁，不能在便利店购买烟和酒。</p><p><font color="#ffffff"> Because you are not eighteen years old yet, you can’t but cigarettes or wine at a convenience store. </font><br><font color="#ffffff"> Not (being) eighteen years old yet, you can’t buy cigarettes or wine at a convenience store. </font></p></li><li><p>因为不满意工资，很多工人罢工了。</p><p><font color="#ffffff"> Because they are not satisfied with their wages, many workers went on strike. </font><br><font color="#ffffff"> Not (being) statisfied with their wages, many workers went on strike. </font></p></li><li><p>除非收到邀请，否则你不可以参加明晚的聚会。</p><p><font color="#ffffff"> Unless you are invited, you may not attend the party tomorrow night. </font><br><font color="#ffffff"> Unless (being) invited, you may not attend the party tomorrow night. </font></p></li><li><p>虽然我们都知道真相，却保持沉默。</p><p><font color="#ffffff"> Although we all know the truth, we remain silent. </font><br><font color="#ffffff"> Although knowing the truth, we all remain silent. </font></p></li><li><p>那位渔民意识到这不是一条普通的鱼，于是千方百计不让它受到丝毫伤害。</p><p><font color="#ffffff"> Because the fisherman realized that this was no ordinary fish, he made every effort not to damange it in any way. </font><br><font color="#ffffff"> Realizing that this was no ordinary fish, the fisherman made every effort not to damage it in any way. </font></p></li><li><p>当地的屠户Sam Benton在把存款送往邮局的途中把钱包丢了。</p><p><font color="#ffffff"> Sam Benton, the local butcher, had lost his wallet while he was taking his savings to the post-office. </font><br><font color="#ffffff"> Sam Benton, the local butcher, had lost his wallet while taking his savings to the post-office. </font></p></li><li><p>尽管查尔斯不懂汉语，但是还是能够和我们交流。</p><p><font color="#ffffff"> Though he didn’t understand Chinese, Charles was able to communicate with us. </font><br><font color="#ffffff"> Though not understanding Chinese, Charles was able to communicate with us. </font></p></li><li><p>这部电影深刻解释了东西方文化的差异，结果引起了美国观众的强烈反响。</p><p><font color="#ffffff"> The film exposes cultural differences between the East and the West, so that it aroused tremendous response in American audiences. </font><br><font color="#ffffff"> The film exposes cultural differences between the East and the West, arousing tremendous response in American audiences. </font></p></li><li><p>听到这个消息时，他们都高兴得跳了起来。</p><p><font color="#ffffff"> When they heard the news, they all jumped with joy. </font><br><font color="#ffffff"> Hearing the news, the all jumped with joy. </font></p></li></ul><h3 id="1-3、定语从句的简化">1.3、定语从句的简化</h3><p>在定语从句中，关系代词作主语时，从句可化简为现在分词短语。法则是：删除关系代词，其后动词变成现在分词。</p><ul><li><p>Some children were playing games on the bank and there were some people rowing on the river.</p><p>Some children were playing games on the bank and there were some people who rowed on the river.</p><p>河岸上有些孩子正在玩耍，河面上有些人正在划船。</p></li><li><p>Built in 1885, it was the oldest car taking part.</p><p>Built in 1885, it was the oldest car which took part.</p><p>该车造于1885年，是参赛车中最老的一辆。</p></li><li><p>I had all the usual symptoms of someone giving up smoking: a bad temper and an enormous appetite.</p><p>I had all the usual symptoms of someone who give up smoking: a bad temper and an enormous appetite.</p><p>我具备了戒烟者通常表现出来的所有症状：脾气暴躁和食欲旺盛。</p></li><li><p>On a recent blog, Mr. Belinda wrote about VOA’s rules demanding accuracy and objectivity.</p><p>On a recent blog, Mr. Belinda wrote about VOA’s rules which demand accuracy and objectivity.</p><p>最近的一篇博客中，贝林达先生写了关于VOA要求客观性和准确性的规则。</p></li></ul><p>如果定语从句是被动语态，或者主系表句型，be动词变成being后，可省略。</p><ul><li><p>The ‘taxi’ is a small Swiss aeroplance called a ‘Pilatus Porter’.</p><p>The ‘taxi’ is a small Swiss aeroplance which is called a ‘Pilatus Porter’.</p><p>这辆“出租汽车”是一架小型瑞士飞机，叫“皮勒特斯·波特”号。</p></li><li><p>Looking round, I realized with a shock that I was the only passenger left on the bus.</p><p>Looking round, I realized with a shock that I was the only passenger who was left on the bus.</p><p>我环视了一下身旁，惊奇地发现车里就只剩我一个乘客了。</p></li><li><p>Like this father, he was driving a car called Bluebird.</p><p>Like this father, he was driving a car which is called Bluebird.</p><p>同他父亲一样，他也驾驶者一辆名叫“蓝鸟”的汽车。</p></li><li><p>After reading an article entitled ‘Cigarette Smoking and Your Health’ I lit a cigarette to calm my nerves.</p><p>After reading an article which is entitled ‘Cigarette Smoking and Your Health’ I lit a cigarette to calm my nerves.</p><p>读完一篇题为《吸烟与健康》的文章之后，我点上了一支香烟，来镇定一下自己紧张的神经。</p></li><li><p>I know an actor suitable for the part.</p><p>I know an actor who is suitable for the part.</p><p>我认知一个适合扮演这个角色的演员。</p></li></ul><p>造句练习（分别用定语从句和分词短语造句）：</p><p>注：鼠标选中空白处有惊喜哦</p><ul><li><p>乔治打开一个装着所有运动器材的大箱子。</p><p><font color="#ffffff"> George opened a big box which contained all of his sports equipment. </font></p><p><font color="#ffffff"> George opened a big box containing all of his sports equipment. </font></p></li><li><p>房主把贵重物品放在（keep）墙里边藏着的一个保险箱里。</p><p><font color="#ffffff"> The owner of the house keeps his valuables in a safe which is hidden in the wall. </font><br><font color="#ffffff"> The owner of the house keeps his valuables in a safe hidden in the wall. </font></p></li><li><p>那边那位正在同约翰说话的高个子男人是我的爸爸。</p><p><font color="#ffffff"> The tall man who is talking to John over there is my fahter. </font><br><font color="#ffffff"> The tall man talking to John over there is my father. </font></p></li></ul><h2 id="二、分词短语的逻辑主语">二、分词短语的逻辑主语</h2><p>当分词短语的主语和主句主语不相同时，分词短语的主语必须保留。此时，所形成的分词结构，称为分词的独立主格结构。</p><ul><li><p>Nobody having any more to say, the meeting was closed.（句子的主语是the meeting，分词短语的主语是Nobody）</p><p>谁都无话可说，会议就结束了。</p></li><li><p>The village seemed deserted, the only sign of life being an ugly-looking black goat tied to a tree on a short length of rope in a field nearby.（句子的主语是The village，分词短语的主语是sign）</p><p>村里似乎无人居住，唯一的生命迹象是附近田里一只面目可憎的黑山羊，用一截短绳栓在树上。</p></li><li><p>Because our 3D television installed, the whole family went into the living room.（注：installed前面省略了being。句子的主语是the whole family，分词短语的主语是television）</p><p>Because our 3D television was installed, the whole family went into the living room.</p><p>Because our 3D television being installed, the whole family went into the living room.</p><p>因为我们的3D电视安装好了，全家人都进了客厅。</p></li></ul><p>独立主格结构也可由with引导，用于表示原因、伴随状况或补充说明、具体举例等。</p><ul><li><p>It is possible that upon such an occasion a battle ensued, with the sharks being driven away or killed.</p><p>It is possible that upon such an occasion a battle ensued, so that the sharks were driven away or killed.（so that引导的结果状语从句）</p><p>双方可能随之发生搏斗，搏斗的结果是海豚赶走或咬死鲨鱼。</p></li><li><p>A car roared past, with smoke pouring from the exhaust.</p><p>A car roared past, the way smoke poured from the exhaust.（the way引导的方式状语从句）</p><p>一辆小汽车呼啸而过，排气管冒出了一团团黑烟。</p></li><li><p>The silence was suddenly broken when a large car, with its headlights on and its horn blaring, roared down the arcade.</p><p>The silence was suddenly broken when a large car, roared down the arcade, the way its headlights on and its born blared.（the way引导的方式状语从句）</p><p>宁静突然被打破，一辆大轿车亮着前灯，响着喇叭，呼啸着冲进了拱廊街。</p></li></ul><p>在独立主格结构中，当分词为being的时候，可以省略，形成with的复合结构。</p><ul><li><p>Last year, we were traveling across the Channel and Jane put a piece of paper with her name and address on it into a bottle.（her name and address后面省略了分词being，整个独立主格结构作定语修饰paper）</p><p>Last year, we were traveling across the Channel and Jane put a piece of paper with her name and address being on it into a bottle.</p><p>去年，我我们横渡英吉利海峡时，简把写有她姓名和住址的一张纸条装进了一只瓶子。</p></li><li><p>In the struggle, the strap broke and, with the bag in their possession, both men started running through the trees.（the bag后面省略了分词being，整个独立主格结构作原因状语）</p><p>In the struggle, the strap broke and, because the bag was in their possession, both men started running through the trees.</p><p>In the struggle, the strap broke and, with the bag being in their possession, both men started running through the trees.</p><p>在争抢中，手提包的带断了，包落入这两个人手里，他们拔腿跑进了树林。</p></li><li><p>She returned to the shop the following morning dressed in a fur coat, with a handbag in one hand and a long umbrella in the other.（handbag和umbrella后面均省略了分词being，整个独立主格结构作伴随状语）</p><p>She returned to the shop the following morning dressed in a fur coat, with a handbag being in one hand and a long umbrella being in the other.</p><p>第二天上午，她又来到这家商店，穿了一件裘皮大衣，一只手拎着一只手提包，另一只手拿着一把长柄伞。</p></li><li><p>I sat down on one of those modern chairs with holes in it and waited.（holes后面省略了分词being，整个独立主格结构作定语，修饰chairs）</p><p>I sat down on one of those modern chairs which had holes in it.</p><p>I sat down on one of those modern chairs with holes being in it and waited.</p><p>我坐在一个新式的满是网眼儿的椅子上，等待着。</p></li><li><p>At that moment, a large black car with four officers inside it, stopped at the camp gates.</p><p>At that moment, a large black car, stopped at the camp gates and four officers inside it.</p><p>At that moment, a large black car with four officers being inside it, stopped at the camp gates.</p><p>正在此时，一辆黑色大轿车在军营门口停了下来。里面做了4个军官。</p></li></ul><p>并列句简化为独立主格时，和普通分词短语一样，重要的分句作主句，次要的作为独立主格。比如，</p><ul><li><p>He came in and carried a book</p><p>可以简化为分词短语</p><p>He came in carrying a book</p><p>也可以简化为独立主格</p><p>He came in with a book (being) in his hand.</p></li></ul><p>下列几个独立主格结构已经形成了固定用法（前面的主语we省略了）</p><ul><li><p>Frankly speaking（坦白说）</p><p>Frankly speaking, it is difficult for me to understand what he is saying.</p><p>We speak frankly, it is difficult for me to understand what he is saying.</p><p>坦白地说，理解他正在说的事情时很困难的。</p></li><li><p>Broadly speaking（泛泛地说）</p><p>Broadly speaking, human beings may be divided into three classes.</p><p>We speak broadly and human beings may be divided into three classes.</p><p>泛泛地说，人可以分为3类。</p></li><li><p>Judging from（由…看来）</p><p>Judging from her accent, she mush be from the North.</p><p>We judges from her accent, and she must be from the North.</p><p>从她的口音判断，她一定是北方人。</p></li><li><p>Speaking of（说道）</p><p>Speaking of his lover, his eyes sparkled.</p><p>When he was speaking of his lover, his eyes sparkled.</p><p>谈到他的情人时，他的双眼闪烁着光芒。</p></li><li><p>Considering（考虑到）</p><p>Considering her age, the girl’s letter is very well put together.</p><p>Because we considered her age,  the girl’s letter is very well put together.</p></li></ul><p>造句练习（注：鼠标选中空白处有惊喜哦）：</p><ul><li><p>由于房间很小，我们得站得非常靠近。</p><p><font color="#ffffff"> Because the room is so small, we have to stand very close togehter. </font></p><p><font color="#ffffff"> The room being so small, we have to stand very close together. </font></p></li><li><p>我们昨天吃了三顿饭，最好吃的是泰国料理。</p><p><font color="#ffffff"> We had three meals yestarday and the tastiest was the Thai dish. </font></p><p><font color="#ffffff"> We had three meals yestarday, the tastiest being the Thai dish. </font></p></li><li><p>这个男孩经常逃学，他爸爸很生气。</p><p><font color="#ffffff"> The boy often play truant from school and his father get angry. </font></p><p><font color="#ffffff"> The boy often playing truant from shcool, his father gets angry. </font></p></li><li><p>宁静突然被打破，一个凶恶的家伙（tough guy）瞪着眼睛拿着枪，闯进了（break into）银行。</p><p><font color="#ffffff"> The silence was suddenly broken, when a tough guy whose eyes glared and who took a gun, broke into the bank. </font></p><p><font color="#ffffff"> The silence was sudeenly broken, when a tough guy, with his eyes glaring and gun (being) in his hand, broke into the bank. </font></p></li></ul><h2 id="三、分词短语的时态和语态变化">三、分词短语的时态和语态变化</h2><p>不管简化前的句子是什么时态，简化为分词短语时都是V-ing形式。也就是说，不管简化之前的句子是什么“时”，简化之后，通通不考虑其“时”，而只考虑其“态”。</p><p>分词短语没有“时”，只有两种“态”，即一般态和完成态。另外，定语从句简化为分词短语以后，是绝对不能用完成态的，绝对没有分词的完成态作定语的情况。</p><p>以动词do为例：</p><ul><li>一般态，主动语态为doing，被动语态为being done</li><li>完成态，主动语态为having done，被动语态为having been done</li></ul><p>我们看下面两句话：</p><ul><li>Singing a song, he sat down.（唱歌的时候，他就坐下了。）</li><li>Having sung a song, he sat down.（唱完歌以后，他坐下了。）</li></ul><p>在第一句话中，分词是一般态，表示“唱歌”这个动作和“坐下”这个动作是同时发生的。在第二句话中，分词是完成态，表示“唱歌”这个动作先发生。</p><p>构成分词短语的动词，不管是延续动词，还是非延续动词，简化成完成态以后都是having done。分词是没有进行态和完成进行态的。</p><ul><li><p>Having watered the garden, he began to mow the lawn.</p><p>浇完花园以后，他开始修剪草坪。</p></li><li><p>Not having done his homework, the boy went outside to play.</p><p>虽然这个男孩没有写完作业，他还是跑出去玩。</p></li><li><p>Having been bitten twice, the postman refused to deliver our letters unless we chained our dog up.</p><p>被狗咬了两次以后，这个邮递员拒绝给我们送信，除非我们把狗锁起来。</p></li></ul><p>造句练习（注：鼠标选中空白处有惊喜哦）：</p><ul><li><p>已经失败了3次，他不想再尝试了。</p><p><font color="#ffffff"> Because he has failed three times, he didn’t want to try again. </font><br><font color="#ffffff"> Having failed three times, he didn’t want to try again. </font></p></li><li><p>因为在飓风中失去了他的货物，这个船长到达港口以后面临破产（bankruptcy）。</p><p><font color="#ffffff"> Because he had lost his cargo in a hurricane, the captain faced bankruptcy after his vessel reached port. </font><br><font color="#ffffff"> Having lost his cargo in a hurricane, the captain faced bankruptcy after his vessel reached port. </font></p></li><li><p>接到关于地震的警告，他把小孩留在了学校。</p><p><font color="#ffffff"> He have been warned about the earthquake, he left his child in school. </font><br><font color="#ffffff"> Haveing been warned about the earthquake, he left his child in school. </font></p></li></ul><h2 id="四、小结">四、小结</h2><p>最后，小结一下今天的内容吧，我们还是直接看图：</p><p><img src="/img/image-20221204214216095.png" alt="image-20221204214216095"></p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>语态</title>
    <link href="/2022/07/17/%E8%AF%AD%E6%80%81/"/>
    <url>/2022/07/17/%E8%AF%AD%E6%80%81/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们详细讲解了英语中的16种时态，今天我们来看下一个知识点，语态。</p><h2 id="一、语态">一、语态</h2><p>英语中语态有两种，主动语态和被动语态。主动语态表示主语是动作的执行者，被动语态表示主语是动作的承受者。比如，我打他，是主动语态，我是打这个动作的执行者；而他被我打了，是被动语态，他是打这个动作的承受者。</p><p>只有及物动词才有被动语态，不及物动词没有被动语态。而判断一个动词是否为及物动词，最好的方法是查字典，标有vt字样的动词就是及物动词，标有vi字样的动词就是不及物动词。</p><p>及物动词后面要加宾语，因此既有主动语态，又有被动语态。比如，动词eat就是一个及物动词。</p><ul><li>主动语态：I eat meat.</li><li>被动语态：the meat is eaten by me.</li></ul><p>不及动词后面不可以加宾语，因此没有被动语态。比如，动词apper就是一个不及物动词。</p><ul><li>主动语态：I appear.</li></ul><h2 id="二、主动语态变成被动语态的方式">二、主动语态变成被动语态的方式</h2><p>在将主动语态变成被动语态时，有以下几个要点：</p><ul><li><p>原句的宾语作主语</p></li><li><p>be动词（根据16种时态变化） + 过去分词</p></li><li><p>原句的主语省略（如果保留主语，需要在主语前面加上介词by作状语）</p></li></ul><p>比如，I eat meat，它的被动语态是，the meat is eaten或者the meat is eaten by me。</p><h2 id="三、被动语态的时态">三、被动语态的时态</h2><p>注：被动语态，其实是一种特殊的主系表句型，即主语 + be动词 + 过分分词，在这里过去分词作表语。</p><h3 id="3-1、一般态：be动词-过去分词">3.1、一般态：be动词 + 过去分词</h3><ul><li><p>Our clavichord is kept in the living-room.（一般现在时）</p><p>Someone keep our clavichord in the living-room.</p><p>我们的这架古钢琴放在起居室里。</p></li></ul><p>在这句话中，clavichord是主语，is是系动词，kept是表语，in the living-room是状语。</p><ul><li><p>The instrument was bought by my grandfather many years ago.（一般过去时）</p><p>My grandfather bought the instrument many years ago.</p><p>这件乐器是我祖父在很多年以前买的。</p></li></ul><p>在这句话中，instrument是主语，was是系动词，bought是表语，by my grandfather和many years ago是状语。</p><ul><li><p>The Olympic Games will be held in our country in four year’s time.（一般将来时）</p><p>The government will hold the Olympic Games in our country in four year’s time.</p><p>4年以后，奥林匹克运动会将在我们国家举行。</p></li></ul><p>在这句话中，Games是主语，will be是系动词，held是表语，in our country和in four year’s time是状语。</p><p>注：当被动语态中出现情态动词时，用法同will。比如：</p><ul><li><p>The work must be finished in one way or another.</p><p>这件事必须设法做好。</p></li><li><p>This passage may be given several interpretations.</p><p>这段文字可以有不同的解释。</p></li></ul><h3 id="3-2、进行态：be动词-being-过去分词">3.2、进行态：be动词 + being + 过去分词</h3><ul><li><p>It is being repaired by a friend of my father’s.（现在进行时）</p><p>A friend of my father’s is repairing it.</p><p>父亲的一个朋友正在修理它。</p></li></ul><p>在这句话中，it是主语，is being是系动词，repaired是表语。</p><ul><li><p>I was being tested for a driving licence for the third time.（过去进行时）</p><p>Somebody was testing me for a driving licence for the third time.</p><p>我第3次接受驾驶执照考试。</p></li></ul><p>在这句话中，I是主语，was being 是系动词，tested是表语。</p><ul><li><p>He will be being examined when we get there.（将来进行时）</p><p>Somebody will be examming him when we get there.</p><p>当我们到那儿时，他将在被检查。</p></li></ul><p>在这句话中，He是主语，will be being是系动词，examined是表语。</p><h3 id="3-3、完成态：have-has-had-been-过去分词">3.3、完成态：have/has/had + been + 过去分词</h3><ul><li><p>The fantastic modern buildings have been designed by Kurt Gunter.（现在完成时）</p><p>Kurt Gunter has designed the fantastic modern buildings.</p><p>这些巨大的现代化建筑是由库尔特·刚特设计的。</p></li></ul><p>在这句话中，buildings是主语，have been是系动词，designed是表语。</p><ul><li><p>I had been asked to drive in heavy traffic.（过去完成时）</p><p>Somebody had asked me to drive in heavy traffic.</p><p>我按照要求在车辆拥挤的路上驾驶。</p></li></ul><p>在这句话中，I是主语，had been是系动词，asked是表语。</p><ul><li><p>Your character will have been completed by the time your life comes to an end.（将来完成时）</p><p>It will have completed your character by the time your list comes to an end.</p><p>当生命走到尽头的时候，你的人格才变得完全。</p></li></ul><p>在这句话中，character是主语，will have been是系动词，completed是表语。</p><h2 id="四、被动语态的使用场景">四、被动语态的使用场景</h2><p>使用被动语态的场景主要有以下两个：</p><ul><li>为了突出受动者，即主动语态中的宾语<ul><li><p>A hero is distinguished in difficult circumstances.</p><p>困境之中显英雄。</p></li><li><p>A liar is not believed when he tells the truth.</p><p>撒谎的人讲真理也没人相信。</p></li></ul></li><li>施动者（主动语态的主语）不明确或不必指明时<ul><li><p>Then in 1989, twenty-six years after the crash, the plane was accidentally rediscovered in an aerial survey of the island.</p><p>于是，到了1989年，飞机失事26年后，在对小岛的一次航空勘查中那架飞机被意外地发现了。</p></li><li><p>Once a year, a race is held for old cars.</p><p>旧式汽车的比赛每年举行一次。</p></li></ul></li></ul><h2 id="五、造句练习">五、造句练习</h2><p>注：鼠标选中空白处有惊喜哦</p><ul><li><p>欧元在大部分欧洲国家都被使用。</p><p><font color="#ffffff"> The euro is uesd in most European countries. </font></p></li><li><p>这些电脑是在台湾制造的。</p><p><font color="#ffffff"> These computers were manufactured in Taiwan. </font></p></li><li><p>2012年的奥运会将在伦敦举行。</p><p><font color="#ffffff"> The 2012 Olypic Games will be held in London. </font></p></li><li><p>一名应聘者正被我们的人事经理面试着。</p><p><font color="#ffffff"> An applicant is being interviewed by our personnel manager. </font></p></li><li><p>那栋旧大楼已被拆除（tear down）。</p><p><font color="#ffffff"> The old building has been torn down. </font></p></li><li><p>我们办公室的房间都是每天打扫的。</p><p><font color="#ffffff"> Our office rooms are cleanead up every day. </font></p></li><li><p>汤姆昨天被一只狗咬到，所幸无大碍。</p><p><font color="#ffffff"> Tom was bitten by a dog yersterday. Fortunately, it was nothing seriuos. </font></p></li><li><p>因为经济不景气（the economic recession），大约5000名员工将被裁员（lay off）。</p><p><font color="#ffffff"> Because of the economic recession, about 5,000 employees will be laid off. </font></p></li><li><p>六个人被困在矿井里已有17个小时了。</p><p><font color="#ffffff"> Six mem have been trapped in a mine for serventeen hours. </font></p></li><li><p>这场地震结束的时候有多少建筑被毁坏了？</p><p><font color="#ffffff"> How many buildings had been destroyed when the earthquake ended? </font></p></li></ul><h2 id="六、小结">六、小结</h2><p>最后，小结一下今天的内容吧，我们还是直接看图：</p><p><img src="/img/image-20221127093741619.png" alt="image-20221127093741619"></p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时态</title>
    <link href="/2022/07/17/%E6%97%B6%E6%80%81/"/>
    <url>/2022/07/17/%E6%97%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<p>在说和写英语时，时态是我们很多人的难点。今天我们最主要的就是攻克这一大难点，系统的学习一下英文中的16种时态。</p><h2 id="一、时态的本质">一、时态的本质</h2><p>时态 = tense and aspect = 时间 + 状态</p><h3 id="1-1、时间">1.1、时间</h3><p>一般来说，时间分为三时，现在、过去、将来。比如：</p><ul><li>现在时：She walks to school</li><li>过去时：She walked to school</li><li>将来时：She will walk to school</li></ul><p>在英文中，还存在一个过去将来时，因为并不常用，我们简单了解即可。此外，需要注意的是，时态里的“现在”并不是一个固定的时间点，而是一种“常态”。比如说“他每天早上都要跑步”，这里的“每天早上”，虽然是一个个分开的时间点，但是我们还是认为这是现在时。</p><h3 id="1-2、状态">1.2、状态</h3><p>谓语动词的状态分为四种：</p><ul><li>一般（simple）态：强调动作发生的时间。比如，I play basketball，我打篮球。这里只说一般情况，并不强调是正在进行，还是已经完成等状态。</li><li>进行（continuous）态：强调动作的过程。比如，I am playing basketball，我正在打篮球。这里是在描绘一个动作，表达出生动性。</li><li>完成（perfect）态：强调动作的结果。比如，I have played basketball，我打完篮球了。这里是在强调动作已经完成了这个状态。</li><li>完成进行（perfect continuous）态：同时强调动作的结果和过程。比如，I have been playing basketball，我一直都有打篮球。这里不仅是在表达这个动作已经完成，而且还想描绘这个动作，并表达出生动性。</li></ul><h3 id="1-3、时态">1.3、时态</h3><p>在英语中，一共有16种时态。</p><ul><li><p>一般态：</p><ul><li>一般现在时：我学习</li><li>一般过去时：我以前学习</li><li>一般将来时：我将来会学习的</li></ul></li><li><p>进行态：</p><ul><li>现在进行时：现在我在学习</li><li>过去进行时：昨天我在学习</li><li>将来进行时：明天我在学习</li></ul></li><li><p>完成态：</p><ul><li>现在完成时：我已经学习了</li><li>过去完成时：昨天我已经学习了</li><li>将来完成时：明天我已经学习了</li></ul></li><li><p>完成进行态：</p><ul><li>现在完成进行时：我已经学习一天了，还将继续学习下去</li><li>过去完成进行时：昨天我已经学习一天了，还将继续学习下去</li><li>将来完成进行时：明天我已经学习一天了，还将继续学习下去</li></ul></li><li><p>过去将来时：</p><ul><li>一般过去将来时</li><li>过去将来进行时</li><li>过去将来完成时</li><li>过去将来完成进行时</li></ul></li></ul><h3 id="1-4、词形">1.4、词形</h3><p>不同的时态，在词形上是不同，一般遵循如下规律：</p><ul><li>一般态：动词（按时间及主语人称变化）</li><li>进行态：be + 现在分词（be按时间及主语人称变化）</li><li>完成态：have + 过去分词（have按时间及主语人称变化）</li><li>完成进行态：have been + 现在分词（have按时间及主语人称变化）</li></ul><p>下面以动词do为例，看看它的16种时态：</p><ul><li><p>一般现在时：do/dose</p></li><li><p>一般过去时：did</p></li><li><p>一般将来时：will do</p></li><li><p>现在进行时：am/are/is doing</p></li><li><p>过去进行时：was/were doing</p></li><li><p>将来进行时：will be doing</p></li><li><p>现在完成时：have/has done</p></li><li><p>过去完成时：had done</p></li><li><p>将来完成时：will have done</p></li><li><p>现在完成进行时：have/has been doing</p></li><li><p>过去完成进行时：had been doing</p></li><li><p>将来完成进行时：will have been doing</p></li><li><p>一般过去将来时：would do</p></li><li><p>过去将来进行时：would be doing</p></li><li><p>过去将来完成时：would have done</p></li><li><p>过去将来完成进行时：would have been doing</p></li></ul><h2 id="二、一般态">二、一般态</h2><p>一般态，只强调动作发生的时间，不强调动作的状态。也就是说，只关心动作是发生在现在、过去还是将来，不关心这件事做得怎样。</p><p>比如，I walk to school，我走路去学校，这个句子只强调一般情况，不强调动作的状态是怎样的。而I’m walking to school，我正在去学校，强调的就是动作本身，我现在正在路上。</p><h3 id="2-1、一般现在时">2.1、一般现在时</h3><p>表示现在的情况或状态（主系表句型）</p><ul><li><p>I am a doctor.</p><p>我是一个医生。</p></li><li><p>You are an unrepeatable miracle.</p><p>你是一个无法重复的奇迹。</p></li></ul><p>表示常态，即经常性、习惯性的动作（常有表频率的时间副词修饰，如never、often、always）</p><ul><li><p>I never get up early on Sundays. I sometimes stay in bed until lunch time.</p><p>星期天我从不早起，有时我要一直躺到吃午饭的时候。</p></li><li><p>Winners often seek opportunity when losers want security.</p><p>失败者寻求安全的时候，成功者寻求机遇。</p></li><li><p>Do you always get up so late? lt’s one o’clock!</p><p>你总是起得这么晚吗？现在已经1点钟了。</p></li></ul><p>表示客观真理或格言</p><ul><li><p>Time flies.</p><p>时光飞逝。</p></li><li><p>The early bird catches then worm.</p><p>早起的鸟儿有虫吃。</p></li><li><p>Failure is the mother of success.</p><p>失败是成功之母。</p></li></ul><h3 id="2-2、一般过去时">2.2、一般过去时</h3><p>表示过去的动作、事实、习惯</p><ul><li><p>Last Sunday I got up very late. I looked out of the window. It was dark outside.</p><p>在上个星期天，我起得很晚。我望望窗外，外面一片昏暗。</p></li><li><p>Last summer, I went to Italy.</p><p>去年夏天，我去了意大利。</p></li><li><p>Colubus discovered America in 1742.</p><p>哥伦布于1742年发现了美洲。</p></li></ul><p>注：一般过去时，是英语中最常用的时态。在这样的句子中，一定会出现表示过去具体时间的副词，比如yesterday、last week、two years ago、in 1998等</p><h3 id="2-3、一般将来时">2.3、一般将来时</h3><p>表示将来发生的动作、状态或倾向（will译为“将要”）</p><ul><li><p>He will soon visit Darwin. From there, he will fly to Perth.</p><p>他不久还将到达尔文去，从那里，他再飞往伯斯。</p></li><li><p>People will run into problems in their lives.</p><p>人们在生活中总会遇到问题。</p></li><li><p>A small leak will sink a great ship.</p><p>小裂缝可以沉大船。</p></li></ul><p>be going to + 动词原形，也表将来时，但多表示“计划”，故其主语多是“人”</p><p>will表示“意愿”时，主语是“人”。此时可以跟be going to互换。但其也可以表示“预测”，主语为“物”</p><ul><li><p>Debbie Hart is going to swim across the English Channel tomorrow.</p><p>黛比哈特准备明天横渡英吉利海峡。</p></li><li><p>She is going to set out from the French coast at five o’clock in the morning.</p><p>她打算早上5点钟从法国海岸出发。</p></li><li><p>Mr. Thompson is going to sell it because it is haunted.</p><p>汤普森先生之所以想卖它，是因为那里常闹鬼。</p></li></ul><p>be about to + 动词原形，表示即将…</p><ul><li><p>He is about to leave for Shenyang.</p><p>他将要离开去沈阳。</p></li></ul><h3 id="2-4、造句练习">2.4、造句练习</h3><p>注：鼠标选中空白处有惊喜哦</p><ul><li><p>这家便利店全天24小时营业。</p><p><font color="#ffffff"> This convenience store is open 24 hours a day. </font></p></li><li><p>我爷爷每天早上都在公园里散步。</p><p><font color="#ffffff"> My grandfather takes a walk in the park every morning. </font></p></li><li><p>昨天我很无聊，便跟着几个朋友看电影去了。</p><p><font color="#ffffff"> I felt bored yesterday, so I went to the movies with several friends. </font></p></li><li><p>他明天将要去纽约。</p><p><font color="#ffffff"> He will go to New York tomorrow. </font></p></li><li><p>看！那艘船快要沉没了。（be about to）</p><p><font color="#ffffff"> Look! The boat is about to sink. </font></p></li><li><p>我们马上就要吃午餐了。</p><p><font color="#ffffff"> We are going to have lunch soon. </font></p></li><li><p>太阳东升西落。</p><p><font color="#ffffff"> The Sun rises in the east and sets in the west. </font></p></li><li><p>我每周去两次健身房。</p><p><font color="#ffffff"> I go to the gym twich a week. </font></p></li><li><p>我昨天早上在图书馆看到他。</p><p><font color="#ffffff"> I saw him in the library yesterday morning. </font></p></li><li><p>我准备学习计算机科学。</p><p><font color="#ffffff"> I am going to learn the computer science. </font></p></li></ul><h2 id="三、进行态">三、进行态</h2><p>进行态，强调动作的过程，也就是所谓的描绘、生动性。</p><p>在英语中，按照动作发生时间长短，动词可分为延续性动词和瞬间动词，其中瞬间动词是没有进行态的。</p><p>比如，结婚就是一个瞬间动作，交换仪式之后，就是结婚了。所以，不能说They were marrying last week，只能说They married last week。</p><h3 id="3-1、现在进行时">3.1、现在进行时</h3><p>表示现在正在做的动作，此时be动词译为“正在”</p><ul><li><p>He is playing basketball.</p><p>他正在打篮球。</p></li><li><p>It’s raining heavily now.</p><p>现在正在下大雨。</p><p>注：主系表句型，在口语中，通常用一般现在时，但如果要强调此时此刻的状态，可以用现在进行时。比如，Your are being very rude就要比You are very rude生动很多。</p></li></ul><p>表示即将发生的动作（通常是表示“位移”的短暂性动词。比如，come、go、arrive、leave、start、begin、return、die、take），此时be动词译为“即将”</p><ul><li><p>“A new play is coming to ‘The Globe’ soon,” I said. “Will you be seeing it?”</p><p>“一出新剧要来‘环球剧场’上演了”我说，“您去看吗？”</p></li><li><p>‘We are going back now,’ said the conductor.</p><p>“我们现在要返回去”售票员说。</p></li></ul><h3 id="3-2、过去进行时">3.2、过去进行时</h3><p>表示过去某时正在进行的事情</p><ul><li><p>A man was lying in the box during the flight.</p><p>那个航班上，有一个人正躺在箱子里。</p></li><li><p>I was having dinner at a restaurant when Tony Steele came in.</p><p>我正在一家饭馆吃饭，托尼斯蒂尔走了进来。</p></li></ul><h3 id="3-3、将来进行时">3.3、将来进行时</h3><p>表示将来某时将进行的事情</p><ul><li><p>The will be arriving here tomorrow.</p><p>他们明天就要到达此地。</p></li><li><p>Tomorrow evening they will be singing at the Workers’ Club.</p><p>明晚他们将在工人俱乐部演出。</p></li><li><p>The Greenwood Boys will be staying for five days.</p><p>“绿林少年”准备在此逗留5天。</p></li><li><p>They will be trying to keep order.</p><p>他们将设法维持秩序。</p></li><li><p>The shuttle Endeavour will be taking the astronauts to the Hubble.</p><p>“奋进”号航天飞机将把宇航员送上哈勃。</p></li></ul><h3 id="3-4、小结">3.4、小结</h3><p>进行态，其实是一般态的生动模式。任何一个进行态的句子，都可以改成一般态。但一般态却不一定能改成进行态，只有延续动词才能改。</p><p>比如，I looked out of the window，可以改成I was looking out of the window，因为look是延续的。而I never get up leary on Sundays，不能改成I was never getting up early on Sundays，因为get up是短暂的。</p><h3 id="3-5、造句练习">3.5、造句练习</h3><p>注：鼠标选中空白处有惊喜哦</p><ul><li><p>你在桌子下面做什么？</p><p><font color="#ffffff"> What are you doing under the table? </font></p></li><li><p>我正梦见你时，电话铃响了。（dream about）</p><p><font color="#ffffff"> I was dreaming about you when the telephone rang. </font></p></li><li><p>明天早上这个时候，我爸爸将正在修建草坪。（mow the lawn）</p><p><font color="#ffffff"> My dad will be mowning the lawn at this time tomorraw morning. </font></p></li><li><p>我女儿正在学习，所以你最好别去烦她。</p><p><font color="#ffffff"> My daugher is studing, so you’d better not bother her. </font></p></li><li><p>明年这个时候我将在美国念书。</p><p><font color="#ffffff"> I’ll be sutding in the United States at this time next year. </font></p></li></ul><h2 id="四、完成态">四、完成态</h2><p>完成态，强调动作的结果，主要看动作是否完成。</p><h3 id="4-1、现在完成时">4.1、现在完成时</h3><h4 id="4-1-1、用法">4.1.1、用法</h4><p>表示到现在为止，已完成的动作（发生时间不明）</p><ul><li><p>I have just received a letter from my brother, Tim.</p><p>我刚刚收到弟弟蒂姆的来信。</p></li><li><p>He has just bought an Australian car and has gone to Alice Springs, a small town in the centre of Australia.</p><p>他刚买了一辆澳大利亚小汽车，现在去了澳大利亚中部的小镇艾利斯斯普林斯。</p></li><li><p>Since then, he has developed another bad habit.</p><p>从那以后，它养成了另外一种坏习惯。</p></li><li><p>He has gone to Shanghai.</p><p>他去了上海。</p></li></ul><p>表示持续到现在的状态（或动作），而且有可能继续持续下去。动词通常是延续性动词（注，be动词是可延续的）</p><ul><li><p>She has lived here for 10 years.</p><p>她住在这里10年了。</p></li><li><p>He has been there for six months.</p><p>他在那儿已经住了6个月了。</p></li><li><p>I have been to the Great Wall.</p><p>我去过长城。</p></li></ul><h4 id="4-1-2、时间副词">4.1.2、时间副词</h4><p>现在完成时常用的时间副词：</p><ul><li><p>since + 时间点，自从…</p></li><li><p>for + 时间段，有若干时间之久…</p></li><li><p>so far / up to now，到目前为止…</p></li><li><p>recently / lately，最近…</p></li><li><p>once / twice / a few times / many times，一次 / 两次 / 几次 / 多次…</p></li><li><p>over/during/for + the last/past + 数字 + years/months/days，过去若干年/月/日以来…</p></li></ul><h4 id="4-1-3、例句">4.1.3、例句</h4><p>对应上面的时间副词，我们来看一些具体的例句：</p><ul><li><p>Since then, Captain Fawcett has flown passengers to many unusual places.</p><p>从那时开始，弗西特机长已经载送乘客到过许多不寻常的地方。</p></li><li><p>Mr. Hart has trained his daughter for years.</p><p>哈特先生训练她的女儿已经多年了。</p></li><li><p>But so far, the public has expressed its gratitude to the students in letters to the Press.</p><p>但到目前为止，公众已经向新闻界写信表达他们对学生们的感激之情了。</p></li><li><p>Up to now, Mr. Scott has sent a great many requests for spare parts and other urgent messages from one garage to the other.</p><p>到目前为止，斯科特先生从一个汽车修理部向另一个发送了大量索取备件的信件和其他紧急函件。</p></li><li><p>Have you talked to Jane lately?</p><p>你最近有没有和Jane说过话？</p></li><li><p>Jack has read the novel three times.</p><p>这本小说杰克已经看过三遍了。</p></li><li><p>Over the last three months, oil prices have reached a record high.</p><p>过去三个月以来，油价创了历史新高。</p></li></ul><h4 id="4-1-4、易错点">4.1.4、易错点</h4><p>尝试翻译以下几个句子：</p><ul><li>他去北京3天了。</li><li>他结婚已经3年了。</li><li>他已经死了3年了。</li></ul><p>错误的翻译：</p><ul><li><p>He has gone to Beijing for 3 days.</p></li><li><p>He has married for 3 years.</p></li><li><p>He has died for 3 years.</p></li></ul><p>这里的go、marry、die都是短暂动词，其后不能加时间副词，我们只能说：</p><ul><li>He has gone to Beijing.</li><li>He has married.</li><li>He has died.</li></ul><p>想要表达出瞬间动词持续的状态，必须使用对应的主系表句型，因为系动词是可以延续的。即用主系表句型表示状态，才能加表示一段时间的状语。正确的说法是：</p><ul><li><p>He has been to Beijing for 3 days.</p></li><li><p>He has been married for 3 years.</p></li><li><p>He has been dead for 3 years.</p></li></ul><p>此时，句子的动词是be动词，后面的to Beijing（介词短语）、married、dead（形容词）为表语。</p><h3 id="4-2、过去完成时">4.2、过去完成时</h3><p>表示截止到过去某时为止，已完成的动作或经验。它不能单独存在，要与另一个使用一般过去时的句子，或者表示过去的副词短语连用。had译为“已经”或“曾经”</p><ul><li><p>My old friend, Harrison, had lived in the Mediterranean for many years before he returned to England.</p><p>我的老朋友哈里森在回到英国以前曾多年居住在地中海地区。</p></li><li><p>A short time before, great trees had covered the countryside for miles around.</p><p>就在不久之前，参天大树还覆盖方圆数英里的土地。</p></li><li><p>By then, however, in many places the grass had already taken root.</p><p>然而到那时，很多地方的草已经生了根。</p></li></ul><h3 id="4-3、将来完成时">4.3、将来完成时</h3><p>表示到将来某时为止，将完成或仍继续的动作或经验等。常与介词by构成的时间状语连用，表示“到…的时候”</p><ul><li><p>Workers will have completed the new roads by the end of this year.</p><p>工人们将在今年年底前把新路铺好。</p></li><li><p>By the of next year, they will have finished work on the new stadium.</p><p>到明年年底，他们将把新体育场建成。</p></li></ul><h3 id="4-4、造句练习">4.4、造句练习</h3><p>注：鼠标选中空白处有惊喜哦</p><ul><li><p>彼得去过香港很多次。</p><p><font color="#ffffff"> People has been to HongKong many times. </font></p></li><li><p>进入初中以来，我对英语很狂热。（be razy about）</p><p><font color="#ffffff"> I have been razy about English since I entered junior high school. </font></p></li><li><p>到目前为止，我已经完成这项计划的三分之二。</p><p><font color="#ffffff"> So far, I have finished two third of the project. </font></p></li><li><p>我最近很忙，恐怕要到下周一我才有空。</p><p><font color="#ffffff"> I have been very busy recently. I’m afraid that I won’t be free until next Monday. </font></p></li><li><p>过去5年来，这个好孩子都尽力照顾他生病的母亲。</p><p><font color="#ffffff"> Over the past 5 years, the good boy has tried his best to take care of his ill mother. </font></p></li><li><p>斯密斯先生搬来这里之前已经在加拿大住了20年。</p><p><font color="#ffffff"> Mr. Smith had lived in Canada for 20 years before he moved here. </font></p></li><li><p>等到到达车站时，火车已经开走了。</p><p><font color="#ffffff"> By the time I got to the station, the train had left. </font></p></li><li><p>玛丽昨天告诉我她很久以来一直想出国旅游。</p><p><font color="#ffffff"> Mary told me yesterday that she had long wanted to travel abroad. </font></p></li><li><p>我很生气，因为我女朋友对我爽约了。（stand sb. up）</p><p><font color="#ffffff"> I was very angry because my girlfriend had stood me up again. </font></p></li><li><p>明天这个时候，约翰将已经达到芝加哥了。</p><p><font color="#ffffff"> John will have arrived in Chicago by this time tomorrow. </font></p></li></ul><h2 id="五、完成进行态">五、完成进行态</h2><p>完成进行态，同时强调动作的结果和过程。</p><p>动词只能是延续性动词，瞬间动词不能用在完成进行态中。</p><p>比如，我收到一封信，只能说I have received a letter，不能说I have been receiving a letter。这是因为，receive这个动词，是一瞬间完成的，不能延续，我们不可能一直不停地收同一封信。</p><p>再比如，我住在广州3年了，可以说I have lived in Guangzhou for three years，也可以说I have been living in Guangzhou for three years。这两句话意思完全相同，但第二句更加生动形象。</p><h3 id="5-1、现在完成进行时">5.1、现在完成进行时</h3><p>表示一直持续到现在，且有可能持续下去的动作。通常和表示时间段的副词连用，如for、since、all morning等</p><ul><li><p>We have just moved into a new house and I have been working hard all morning.</p><p>我们刚刚搬进一所新房子，我辛辛苦苦地干了整整一个上午。</p></li><li><p>If you haven’t discovered your dream, probably you’ve been missing too much.</p><p>如果你还没有发现梦想，或许一直以来你失去的太多了。</p></li></ul><h3 id="5-2、过去完成进行时">5.2、过去完成进行时</h3><p>表示一直持续到过去某时，而当时仍然在继续的动作。在句中必须有表示过去的时间状语</p><ul><li><p>Firemen had been fighting the forest fire for nearly three weeks before they could get it under control.</p><p>消防队员们同那场森林大火搏斗了将近3个星期最后才把火势控制住。</p></li><li><p>The planes had been planting seed for nearly a month when it began to rain.</p><p>飞机播撒了近一个月后，开始下起雨来。</p></li><li><p>Bleriot had been making planes since 1905 and this was his latest model.</p><p>布莱里奥从1905年起便开始研制飞机，这架飞机是他制作的最新型号。</p></li></ul><h3 id="5-3、将来完成进行时">5.3、将来完成进行时</h3><p>表示一直持续到将来某时，且可能继续下去的动作。在句中必须有表示将来的时间状语。</p><ul><li><p>The day before his retirement, Mr. Page will have been teaching for a total of forty years.</p><p>佩奇先生退休的前一天正好是他执教满40年的日子。</p></li><li><p>By the time you come back tonight, I will have been sleeping for five hours.</p><p>等你今晚回来时，我已经持续睡了5个小时了。</p></li></ul><h3 id="5-4、小结">5.4、小结</h3><p>任何完成进行态，都能改成完成态。但是完成态不一定能改成完成进行态，必须是延续动词才能改。</p><h3 id="5-5、造句练习">5.5、造句练习</h3><p>注：鼠标选中空白处有惊喜哦</p><ul><li><p>约翰自去年起就一直学日语。他希望去日本留学。</p><p><font color="#ffffff"> John has been learning Japanese since last year. He expects to study in Japan in the future. </font></p></li><li><p>Lulu的车子抛锚时，她已经持续开了8个小时了。</p><p><font color="#ffffff"> By the time her car broke down, Lulu had been driving for 8 hours. </font></p></li><li><p>到今年年底，王老师教英语有10年了。</p><p><font color="#ffffff"> Mr. Wang will have been teaching English for 10 years by the end of this year. </font></p></li></ul><h2 id="六、过去将来时">六、过去将来时</h2><p>过去将来时，是指从过去某一时刻看，以后要发生的动作或状态。多用于叙述性故事和间接引语中，比较少见，不是很常用。</p><h3 id="6-1、一般态">6.1、一般态</h3><ul><li><p>A few hours earlier, someone had told the police that thieves would try to steal the diamonds.</p><p>数小时之前，有人向警方报告，说有人企图偷走这些钻石。</p></li><li><p>Then he smiled and told me I would receive an extra thousand pounds a year!</p><p>然后他微笑了一下告诉我说，我每年将得到1,000英镑的额外收入。</p></li><li><p>He said that it would be possible to build a platform in the centry of the Channel.</p><p>他说，可以在隧道中央建造一座平台。</p></li></ul><h3 id="6-2、进行态">6.2、进行态</h3><ul><li><p>She said she would be setting off on the 10 o’clock train.</p><p>她说她将乘10点钟的火车走。</p></li></ul><h3 id="6-3、完成态">6.3、完成态</h3><ul><li><p>I guessed that Helen would have told her something.</p><p>我猜海伦会告诉她一些情况。</p></li></ul><h3 id="6-4、完成进行态">6.4、完成进行态</h3><ul><li><p>He told me that by the end of the year he would have been living there for thirty years.</p><p>他告诉我到今年末他已经住在那儿30年了。</p></li></ul><h3 id="6-5、造句练习">6.5、造句练习</h3><p>注：鼠标选中空白处有惊喜哦</p><ul><li><p>在信中她说她明年将到英国来。</p><p><font color="#ffffff"> In her letter, she said that she would come to England next year. </font></p></li><li><p>他问我明天上午10点我将干什么。</p><p><font color="#ffffff"> He asked me what I would be doing at 10 a.m. the next day. </font></p></li><li><p>他告诉我们他会在8点以前干完工作。</p><p><font color="#ffffff"> He told us he would have finished the work by 8 o’clock. </font></p></li></ul><h2 id="七、小结">七、小结</h2><p>最后，小结一下今天的内容吧，我们还是直接看图：</p><p><img src="/img/image-20221120165251190.png" alt="image-20221120165251190"></p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定语从句</title>
    <link href="/2022/07/17/%E5%AE%9A%E8%AF%AD%E4%BB%8E%E5%8F%A5/"/>
    <url>/2022/07/17/%E5%AE%9A%E8%AF%AD%E4%BB%8E%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>在前面我们已经讨论了三大从句中前两种，名词性从句和状语从句。今天我们来看最难的从句，定语从句。</p><h2 id="一、定语从句">一、定语从句</h2><p>所谓定语从句，就是一个句子，在另一个句子中，作定语。</p><p>定语从句，其实是两个并列句的合并。比如：</p><ul><li>Captain Fawcett’s first passenger was a doctor who flew from Birmingham to a lonely village in the Welsh mountains.</li></ul><p>在这句话中，who指的是主句提到的the doctor。如果按照传统的语法来翻译就是：Fawcett机长的第一个乘客是一个从伯明翰飞到南威尔士一个偏僻村子去的医生。</p><ul><li>Captain Fawcett’s first passenger was a doctor and the doctor flew from Birmingham to a lonely village in the Welsh mountains.</li></ul><p>在这句话中，后面分句中的the doctor，其实就是主句中的doctor。所以，后面那个句子的the doctor可以改成who，然后去掉and，就变成了定语从句。在这里，the doctor是先行词（定语从句要修饰的词），who则是关系词（定语从句的引导词）。</p><h2 id="二、（非）限定性定语从句">二、（非）限定性定语从句</h2><h3 id="2-1、限定性-vs-非限定性">2.1、限定性 vs 非限定性</h3><p>所谓限定性定语从句，就是对所修饰的内容进行限制，即缩小范围。</p><p>例如，在“What is the name of the tall man who/that just came in?”这句话中，说话的人问那个刚刚进来的高个子男生叫什么名字？“刚刚进来的”就是限定，不可以省略，否则就会变成问所有的高个子男生叫什么名字了，会影响前面整个句子的完整性。</p><p>所谓非限定性定语从句，则是对所修饰的内容进行补充，即增加信息。</p><p>例如，在“They bring suggestions and tradeoffs to the table, some of which are included in the revised spec.”这句话中，逗号后面的some of which···补充说明他们提出的建议，有些还会加到新版的设计规范文件里面去。逗号后面这部分信息可有可无，即使省略，也不影响前面主句意思的完整性。</p><p>我们可以比较下面这两句话，体会一下它们之间的区别。</p><ul><li>She married a man that she met on a bus.</li><li>She married a very nice young engineer from Chicago, whom she met on a bus.</li></ul><h3 id="2-2、两者在形式上的区别">2.2、两者在形式上的区别</h3><p>从形式上看，限定性定语从句可以用that引导，并且引导词有时可以省略，此外，主句与从句不需要用逗号隔开；而非限定性定语从句不可以用that引导，并且引导词不可以省略，此外，主句与从句必须用逗号隔开。</p><p>我们来看两组例句。</p><p>第一组：</p><ul><li>Have you got a book which/that is realy easy to read?（可以用that引导，没有逗号）</li><li>I lent him the Old Man and the Sea, which is realy easy to read.（不可以用that代替which，必须用逗号隔开）</li></ul><p>第二组：</p><ul><li>Did you like the wine we drank last night？（引导词可以省略）</li><li>I poured him a glass of wine, which he drank at once.（引导词不可以省略）</li></ul><p>这里，我们需要知道的是，在限定性定语从句中，如果关系代词作及物动词的宾语，则该关系代词可省略。若作介词的宾语，则可以将介词放在句尾，再省略关系代词。</p><ul><li>It is one of the ugliest faces (that) I have ever semm.（定语从句前可以省略掉作宾语的关系代词that）</li><li>That was all (that) she remembered.（定语从句前可以省略掉作宾语的关系代词that）</li><li>The pictures (that / which) is sent us were very disppointing because its main mirror was faulty!（定语从句前可以省略掉作直接宾语的关系代词that或which）</li><li>Peter is man (whom) I enjoy working with.（定语从句前可以省略掉作介词with的定语的关系代词whom）</li></ul><h3 id="2-3、两者所修饰的对象">2.3、两者所修饰的对象</h3><p>限定性定语从句只能修饰先行词，遵循就近原则。非限定性定语从句既可以修饰先行词，也可以修饰整个句子或句子的一部分。我们可以比较下面两句话：</p><ul><li>We had some ice-cream which was very unusual.</li><li>We had some ice-cream, which was very unusual.</li></ul><p>第一句话是限定性定语从句，只能修饰先行词ice-cream，说明这个冰淇淋不一般、很难得。</p><p>第二句话是非限定性定语从句，即可以修饰先行词，也可以修饰整个句子。所以这里就有可能产生歧义，一种理解和第一句一样，还有一种理解就是从句修饰We had some ice-cream这件事，强调我们不太吃冰淇淋，所以吃冰淇淋这件事情很少见、非同寻常。但是既然专门用了非限定性定语从句，一般作者的意图就是第二种解释。</p><p>此外，还需要注意的是，当先行词为专有名词（人名或地名）或独一性名词（如father、mother···）时，因为名词本身就具有特殊性，其后关系代词引导的定语从句，必须是非限定性定语从句。比如，</p><ul><li>Einstein, who was a great scientist, create the theory of relativity.</li><li>Beijing, which is the capital of China, has developed into an international city.</li><li>Among them will be Debbie’s mother, who swam the Channel herself when she was a girl.</li></ul><h2 id="三、关系词">三、关系词</h2><p>定语从句的引导词，即关系词，主要可分为两大类：</p><ul><li>代词类关系词<ul><li>关系代词</li><li>关系代词所有格</li><li>复合关系代词</li></ul></li><li>副词类关系词<ul><li>关系副词</li></ul></li></ul><h3 id="3-1、关系代词">3.1、关系代词</h3><p>关系代词，就是代替前面的先行词，在从句中作主语、宾语、表语。代替人时，作主语用主格who，作宾语用宾格whom；代替物，或代替整个句子，无论作主语还是宾语，均用which。我们来看一些具体的例句：</p><ul><li><p>Captain Fawcett’s first passenger was a doctor who flew from Birminghan to a lonely village in the Welsh mountains.（（who作主语，代替doctor）</p><p>弗西特机长的第一名乘客是位医生，他从伯明翰飞往威尔士山区一个偏僻的村庄。</p></li><li><p>He is a man whom we should respect.（whom作宾语，代替man；在美式英语中，关系代词作宾语时，也可用who）</p><p>他是一个我们应该尊重的人。</p></li><li><p>In a few years the small workshop had become a large factory which employed 728 people.（which作主语，代替factory）</p><p>几年之后，小铺子已经发展成了一个雇有728人的大工厂。</p></li><li><p>Forest fires are ofen caused by cigarette ends which people carelessly throw away.（which作宾语，代替cigarette ends）</p><p>森林火灾时常由人们随手扔掉的香烟头引起。</p></li><li><p>In 1948， he went to Lake Kivu to observe a new volcano which he later named Kituro.（which作宾语，代替volcano，Kituro是宾补）</p><p>1948年他去了基伍湖，对一座后来被他命名为基图罗的新火山进行观察。</p></li></ul><p>关系代词也可以作介词的宾语，此时可以将介词放到关系词的后面。但是，在正式的书面语中，要把介词放在关系代词之前。此外，如果代替的是人，则只能用whom。</p><ul><li><p>Peter is a man whom I enjoy working with.</p><p>Peter is a man with whom I enjoy working.</p></li><li><p>The city which I live in is very large.</p><p>The city in which I live is very large.</p></li></ul><p>that也可作关系代词，取代who、whom、which，但that前不能有逗号（即只能引导限定性定语从句），也不能有介词。</p><ul><li><p>This is the sort of thing that Jeremy loves.</p><p>This is the sort of thing which Jeremy loves.</p><p>这正是杰里米喜欢做的事情。</p></li><li><p>A game that is very popular with these young swimmers is the underwater tricycle race.</p><p>A game which is very popular with these young swimmers is the underwater tricycle race.</p><p>这些幼小的游泳运动员非常喜爱的一种游戏是水下三轮车比赛。</p></li></ul><p>需要注意的是，以下情况只能用that作关系词：</p><ul><li><p>先行词同时出现“人”和“物”。此时，先行词通常是一个复合型名词。</p><p>The scientist and his inventions that the article deals with are quite familiar to us.</p><p>这篇文章里说的那位科学家和他的发明，我们都比较熟悉。</p></li><li><p>先行词是不定代词。如，something、anything、nothing、everything等</p><p>I would much rather receive something that made me laugh.</p><p>我更愿意接受能让我高兴的东西。</p><p>A variable is something that can be changed and controlled.</p><p>变量是能够被改变和控制的东西。</p></li><li><p>先行词被绝对性形容词修饰。如，序数词、形容词的最高级、the very、the only、all、every、no等修饰时。</p><p>Of course, the Hubble is above the earth’s atmosphere, so it will soon be sending us the clearest pictures that we have ever seen.</p><p>当然，哈勃位于地球的大气层之外，因此，它很快就会给我们传送我们所见到过的、有关行星和远距离星系的最清晰的照片。</p><p>All the students that are studying in our class is hardworking.</p><p>我们班上的学生都很努力。</p></li><li><p>句中有两个相同关系代词引导的定语从句，为避免重复，其中一个用that。</p><p>He works hard, which is a fact that is known to us.</p><p>他很用功，这时我们都知道的事实。</p><p>My best friend was devastated by the letter which she received that rejected her application to university.</p><p>我最好的朋友被那封她收到的拒绝她入大学申请的信打击了。</p><p>There was no trace of fingerprints, but the inspector found a dirty red bundle that contained jewellery which the old lady said was not hers.</p><p>巡官没有发现指纹，却发现了一个装有珠宝的、肮脏的红包袱。老妇人说那不是她的。</p></li></ul><p>造句练习（注：鼠标选中空白处有惊喜哦）：</p><ul><li><p>双语人士（bilingual）就是能说两种语言一样好的人。</p><p><font color="#ffffff"> A bilingual is a person who can speak tow languages equally well. </font></p></li><li><p>不要和自己了解不充分的人交朋友。</p><p><font color="#ffffff"> Don’t make friends with those whom you do not know well. </font></p></li><li><p>要参加比赛的人必须在本周五之前报名（sign up）。</p><p><font color="#ffffff"> People who want to attend the competition must sign up by this Friday. </font></p></li><li><p>Lulu买了那件她想要的价值不菲的裙子。</p><p><font color="#ffffff"> Lulu bought that expensive skirt which she wanted. </font></p></li><li><p>我把我银行账户里边的最后一美元花掉了。</p><p><font color="#ffffff"> I spent the last dollar that I had left in my bank account. </font></p></li><li><p>我喜欢我的学校，它以优良的设施闻名。</p><p><font color="#ffffff"> I like my shcool, which is famou for its excellent facilities. </font></p></li><li><p>我在聚会上遇到很多小学同学，其中一些我都认不出来了。</p><p><font color="#ffffff"> I met many elementary shcoolmates at the party, some of whom I didn’t recognize. </font></p></li><li><p>彼得是个非常优秀的工程师，这点我们都知道。</p><p><font color="#ffffff"> Peter is a very excellent engineer, which we all know. </font></p></li><li><p>这位是我的女朋友，她英语说得非常流利。</p><p><font color="#ffffff"> This is my girlfriend, who can speak fluent English. </font></p></li></ul><h3 id="3-2、关系代词所有格">3.2、关系代词所有格</h3><p>关系代词所有格，是由代词所有格（his、her、their、my、your、its）变化而来的。它和后面的名词一起，共同作定语从句的主语、宾语。</p><p>无论是代替人还是代替物，关系代词所有格均可用whose；代替物时，也可用of which；当先行词为代词的时候，不能用whose，而要用of whom。我们来看具体的例句：</p><ul><li><p>Many people whose home are in town want to live in the country.（whose代替人）</p><p>很多家在城里的人都想住在乡下。</p></li><li><p>Success is a journey whose initial step is paved with an inner stirring.（whose代替物）</p><p>Sucess is a journey of which the initial step is paved with an inner stirring.</p><p>Sucess is a journery, the initial step of which is paved with an inner stirring.</p><p>成功是一段旅程，第一步是由内心的热情铺就的。</p></li></ul><p>名词/代词 + of + whom/which这种结构，属于非限定性定语从句，表示从属关系。</p><ul><li><p>Light is the fastest thing in the world, the speed of which is 300.000 kilometers per second.（这里的先行词speed是名词，所以可以改成whose speed …）</p><p>Light is the fastest thing in the world, whose speed is 300.000 kilometers per second.</p><p>光是世界上最快的东西，它的速度是每秒30万公里。</p></li><li><p>The old man has three sons, one of whom is a doctor.（这里的先行词one是代词，所以不能改成whose one …）</p><p>这个男人有三个儿子，其中一个是医生。</p></li><li><p>There are 300 college students in the small hall, most of whom are freshmen.（这里的先行词most是代词，所以也不能改成whose most …）</p><p>这个小厅里边有300个大学生，他们中的大多数是大一学生。</p></li></ul><p>造句练习（注：鼠标选中空白处有惊喜哦）：</p><ul><li><p>这是玛丽，她的爸爸是我们学校的校长。</p><p><font color="#ffffff"> This is Mary whose father is the headmaster of our school. </font></p></li><li><p>我们住在一栋老房子里，它的屋顶可能随时会崩塌（collapse）。</p><p><font color="#ffffff"> We live in an old house whose roof may collapse anytime.  </font></p></li><li><p>这就是那台硬盘中病毒的电脑。</p><p><font color="#ffffff"> This is the computer whose hard disk is infected with a virus. </font></p></li></ul><h3 id="3-3、复合关系代词">3.3、复合关系代词</h3><p>最常用的符合关系代词是what。它是先行词和关系代词融为一体，形成的关系代词，相当于the thing that。所以，符合关系代词引导的定语从句，前面绝对没有先行词。</p><ul><li><p>What john said may be true.</p><p>The thing that John said may be true.</p><p>What was said by John may be true.</p><p>约翰说的可能是真的。</p></li><li><p>He was astonished at what he found.</p><p>看到的情景使他吃惊。</p></li></ul><p>what也可由all that取代：</p><ul><li><p>Now all that was needed were the parents, but they were absent.</p><p>Now what was needed were the parents, but they were absent.</p><p>现在，我们需要我们的父母，但是他们却不在。</p></li><li><p>All that Billy told us a year ago has become true.</p><p>What Billy told us a year ago has become true.</p><p>Billy一年前告诉我们的事情成真了。</p></li></ul><p>造句练习（注：鼠标选中空白处有惊喜哦）：</p><ul><li><p>我没有听到你刚才说的，能再说一遍吗？</p><p><font color="#ffffff"> I didn’t hear what you just said. Could you say that again? </font></p></li><li><p>我知道你的意思，但是我不同意。</p><p><font color="#ffffff"> I know what you mean but I can’t agree with you. </font></p></li></ul><p>此外，还有一些不太常用的复合关系代词，它们分别是：</p><ul><li>代替人：whoever = anybody who（凡是…的人）；whomevery = anybody whom（凡是…的人）</li><li>代替物：whatever = anything which（…的任何东西）</li><li>代替人或物：whichever = any one which/who（三者以上同类的任何一个） = either which/who（二者同类的任何一个）</li></ul><p>代词whoever有时也可以视为复合关系代词，相当于anybody who</p><ul><li><p>Whoever plays with fire gets burnt.</p><p>Anybody who plays with fire gets burnt.</p><p>玩火者必自焚。</p></li><li><p>I’II teach English to whoever wants to learn it.</p><p>I’II teach English to anybody who wants to learn it.</p><p>谁想学英文，我就教他。</p></li></ul><p>代词whatever是what的强调形式，相当于anything which</p><ul><li><p>She would do whatever she wanted to.</p><p>She would do anything which she wanted to.</p><p>她想要做什么就做什么。</p></li></ul><h3 id="3-4、关系副词">3.4、关系副词</h3><p>关系副词一共有3种，均由“介词 + 关系代词which”变化而来：</p><ul><li><p>when = in which、on which、at which代替表时间的名词</p></li><li><p>where = in which、on which、at which代替表地方的名词</p></li><li><p>why = for which代替the reason</p></li></ul><p>在限定性定语从句中，where不能省略，when和why可以省略</p><ul><li><p>There will be moments in life when you are confronted with new options.（when = in these moments = in which，在从句中作时间状语）</p><p>There will be moments in life you are confronted with new options.</p><p>人生中总会有面对新选择的时候。</p></li><li><p>Mrs. Brabante is talking to the manager of the local factory where the crop is processed.（where = in the factory = in which，在从句中作地点状语）</p><p>布拉班特太太现在正和负责通心粉加工的本地加工厂的经理交谈。</p></li><li><p>Unsuccessful people can always find reasons why they are not doing well.（why = for these reasons = for which，在从句中作原因状语）</p><p>Unsuccessful people can always find reasons they are not doing well.</p><p>注：这里不仅可以省略why，还可以保留why，省略reasons，这时就变成了一个宾语从句</p><p>Unsuccessful people can always find why they are not doing well.</p><p>不成功的人总能找到自己表现不好的理由。</p></li></ul><p>当where、when代替的先行词作be动词的表语时，可省略先行词，保留关系副词</p><ul><li><p>This is the place where he was born.</p><p>This is where he was born.</p><p>这是他出生的地方。</p></li><li><p>That is the day when he will come.</p><p>That is when he will come.</p><p>那就是他要来的日子。</p></li></ul><p>当先行词是名词the way的时候，后面的关系副词是in which或that，而且可以省略</p><ul><li><p>The assistant who served her did not like the way she was dressed.（the way后面省略了in which/that）</p><p>接待她的售货员不喜欢她的那副打扮。</p></li><li><p>I liked the way she organized the meeting.（the way后面省略了in which/that）</p><p>我喜欢她组织会议的方法。</p></li><li><p>I hate the way in which he stares at me.</p><p>我讨厌他那样盯着我。我讨厌他那样盯着我。</p></li><li><p>The only way what they can preserve their history is to recount it as sagas.</p><p>他们保存历史的唯一方法是将历史当作传说讲述。</p></li></ul><p>注：这些句型中的the way （in which/that）可被how取代，变成宾语从句，意思不变。但用的不多，仅需了解。例如：</p><ul><li>The assistant who served her did not like how she was dressed.</li><li>I liked how she organized the meeting.</li><li>I hate how he stares at me.</li></ul><p>the way也可作副词连词引导方式状语从句：</p><ul><li>I admire the way you speak to your students.（定语从句）</li><li>You should do it the way you were taught.（方式状语从句）</li></ul><p>此外，一些表示时间的名词短语（by the time、at the time、next time、every time、the first time、the day …），后面接着没有引导词的句子，其实就是省略了关系副词when。</p><ul><li><p>Every time (when) he wanted to come into the garden he would bark until someone opened the gate.</p><p>每当它想到花园里来时，便汪汪叫个不停，直到有人把门打开。</p></li><li><p>By the time (when) you read this, the Hubble’s eagle eye will have sent us thousands and thousands of wonderful pictures.</p><p>等到你读到这篇文章时，敏锐的哈勃望远镜已经为我们送来了成千上万张精彩的照片。</p></li></ul><p>造句练习（注：鼠标选中空白处有惊喜哦）：</p><ul><li><p>上午11点是考试结束时间，那时所有学生都必须放下笔（put down）。</p><p><font color="#ffffff"> Eleven a.m. is the tiem when the exam will be over and all student must put their pens down. </font></p></li><li><p>我想知道你今天上午上学迟到的原因。</p><p><font color="#ffffff"> I want to know the reason why you were late to school thi morning. </font></p></li><li><p>月球上有一个地方，是Neil Armstrong所踏出的第一步。</p><p><font color="#ffffff"> There is a spot on the moon where Nei Armstrong took his first step. </font></p></li><li><p>这是他处理问题的方法。</p><p><font color="#ffffff"> This is the way he handled problems. / This is how he handled problems. </font></p></li><li><p>我们有时把荒岛想象成某种阳光终日普照的天堂。</p><p><font color="#ffffff"> We sometimes imagine a desert island to be a sort of paradise where the sun always shines. </font></p></li></ul><h2 id="四、小结">四、小结</h2><p>最后，小结一下今天的内容，我们还是直接看图：</p><p><img src="/img/image-20221113173340343.png" alt="image-20221113173340343"></p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状语从句</title>
    <link href="/2022/07/16/%E7%8A%B6%E8%AF%AD%E4%BB%8E%E5%8F%A5/"/>
    <url>/2022/07/16/%E7%8A%B6%E8%AF%AD%E4%BB%8E%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>在前面我们学习了最简单的复合句，名词性从句。今天，我们来看稍微复杂一点的内容，状语从句。</p><h2 id="一、什么是状语从句">一、什么是状语从句</h2><p>所谓状语从句，就是一个句子，在另一个句子中作状语。状语从句可以视为副词，常用来修饰主句。比如，“我完成工作以后，看了一部电影”。这里的“我完成工作以后”，是一个时间状语从句，而它本身也是一个完成的句子。</p><p>状语从句在句中的位置是这样的，如果置于主句之前，主句和从句之间通常有逗号，而如果置于主句之后，则主句和从句之间通常没有逗号。</p><p>状语从句一般由副词连词引导。根据其作用可分为时间、地点、原因、目的、方式、结果、让步、条件和比较等从句。下面，我们主要来看前7中类型的状语从句。</p><h2 id="二、时间状语从句">二、时间状语从句</h2><p>在英文中，一提到时间，就绕不开时态，而这又恰恰是令许多人头疼的知识点。如果你对时态不是很熟悉，这部分的内容可以先简单过一遍。等后面我们讨论完了时态，再回过头来看，或许就能豁然开朗了。</p><h3 id="1-1、when-while-as（当…的时候）">1.1、when / while / as（当…的时候）</h3><p>when引导的时间状语从句多用一般态，可接短暂动词，也可接延续动词。while引导的时间状语从句多用进行态，强调动作的进行，只能接延续动词。as则是一个万能词，可接一般态，也可接进行态。</p><ul><li><p>when he began to play a tune, we had our first glimpse of the snake.</p><p>当他开始吹奏一支曲子时，我们才第一次看到那条蛇。</p></li><li><p>I looked down and nearly fell of the ladder when I saw a policeman.</p><p>当我看清是一个警察时，差一点儿从梯子上掉下去。</p></li><li><p>While he was eating, I asked him to lend me twenty pounds.</p><p>当他吃饭时，我提出向他借20英镑。</p></li><li><p>While the battered car was moving away, Roy stopped his bus and telephoned the police.</p><p>当那辆被撞坏的车开走后，罗伊停下来，给警察打了电话。</p></li><li><p>As she walked away, I followed her out of the fair.</p><p>当她走开时，我也跟着她出了集市。</p></li><li><p>As the thieves were trying to get away in their car, Roy drove his bus into the back of it.</p><p>当那两个小偷企图乘车逃跑时，罗伊驾驶他的公共汽车撞在了那辆车的后尾上。</p></li></ul><h4 id="1-1-1、when">1.1.1、when</h4><p>when有时候也有“就在此时”的意思，用以说明前一个分句的时间。即当它表达主句发生的时间的时候，when引导的从句必须放在主句后面。</p><ul><li><p>I had nearly reached the town, when the young man suddenly said, very slowly, ‘Do you speak English?’</p><p>就要到达那个镇时，那个青年突然开了口，慢慢地说道：“你会讲英语吗？”</p></li><li><p>I was almost there when a sarcastic voice below said, ‘I don’t thing the windows need cleaning at this time of the night.’</p><p>我快爬到窗口时，下面一个人用讽刺的口吻说：“我看不必在夜里这个时候擦窗子吧。”</p></li></ul><p>如果时间状语从句表示将来，一般将来时要改为一般现在时。</p><ul><li><p>I will be a teacher when I grow up.（虽然“长大”发生在将来，但因为是时间状语从句，所以用一般现在时）</p><p>我长大的时候，要做一个老师。</p></li></ul><p>whenever是when的强调形式，表“无论何时”、“每当”</p><ul><li><p>Whenever you have an aim, you must sacrifice something of freedom to attain it.</p><p>When you have an aim, you must sacrifice something of freedom to attain it.</p><p>每当有目标，你必须牺牲一定的自由去达成目标。</p></li><li><p>Forgive others whenever you can.</p><p>Forgive others when you can.</p><p>得饶人处且饶人</p></li></ul><h4 id="1-1-2、while">1.1.2、while</h4><p>while既可以作副词连词，也可以作并列连词。</p><ul><li>表示“当…时”，while视为副词连词，引导状语从句，此时两个句子的时态通常不同。<ul><li>While two detectives were keeping guard at the door, two others opened the parcel.</li><li>A robot-arm will grab the telescope and hold it while the astronauts make the necessary repairs.</li></ul></li><li>表示“而…”，while视为并列连词，连接两个分句，此时两个句子时态相同。<ul><li>When the plane arrived, some of the detectives were waiting inside the main building while others were waiting on the airfield.</li></ul></li></ul><h3 id="1-2、before-after（在…之前-在…之后）">1.2、before / after（在…之前/在…之后）</h3><p>before和after通常接短暂动词，但也可以接延续动词。</p><ul><li><p>After I had left a small village in the south of France, I drove on to the next town.</p><p>在离开法国南部的一个小村庄后，我继续驶往下一个城镇。</p></li><li><p>After he has retired, he will devote himself to gardening.</p><p>他退休后，将致力于园艺。</p></li><li><p>Before he retired, Frank was the head of a very large business company, but as a boy he used to work into a small shop.</p><p>在退休前，弗兰克是一家非常大的商业公司的经理，但他小时候却在一家小铺里做工。</p></li></ul><p>当before用以说明主句的时间很长时，翻译为”才“；而用以说明主句的时间很短时，翻译为”就“。这时，before引导的从句必须放在主句后面。</p><ul><li><p>Nearly a week passed before the girl was able to explain what had happened to her.</p><p>几乎过了一个星期，那姑娘才能讲述自己的遭遇。</p></li><li><p>Only three days passed before the girl was able to explain what had happened to her.</p><p>仅仅过了三天，那个女孩就能讲述自己的遭遇。</p></li></ul><h3 id="1-3、until-till-（直到…）">1.3、until / till （直到…）</h3><p>until和till引导的从句只能接短暂动词。当主句表达肯定的意思时，用延续动词；当主句表达否定的意思时，用短暂动词。</p><ul><li><p>He waited until the volcano became quiet and he was able to return two days later.</p><p>他等到火山平静下来，两天以后又返回去。</p></li><li><p>The young man did not wake up until the bed had struck the ground.（no … until … 翻译为“直到…才…”）</p><p>那个年轻人直到床撞到地上才醒了过来。</p></li></ul><h3 id="1-4、as-soon-as-the-moment-（一…就…）">1.4、as soon as / the moment （一…就…）</h3><p>as soon as和the moment只能接短暂动词。</p><ul><li><p>As soon as he had got into the car, I said good morning to him in French and he replied in the same language.</p><p>他一上车，我就用法语向他问早上好，他也同样用法语回答我。</p></li><li><p>As soon as this was done, they cooked a meal over an open fire.</p><p>这件事刚刚做完，他们就在篝火上烧起了饭。</p></li><li><p>The moment you leave this tent, you will get a big surprise.</p><p>您一走出这个帐篷，就会大吃一惊。</p></li></ul><h3 id="1-5、no-sooner-…-than-…-hardly-…-when-…-scarcely-…-before-…-（刚…就…）">1.5、no sooner … than … / hardly … when … / scarcely … before … （刚…就…）</h3><p>no sooner … than … 表示主句动作已完成，hardly … when … 和scarcely … before … 表示主句动作差点完成。</p><p>通常情况下，在这个类句型中，主句用过去完成时，从句用一般过去时且能接短暂动词。</p><ul><li><p>He had no sooner returned than he bought a house and went to live there.</p><p>他刚一回到英国便买下了一幢房子住了进去。</p></li><li><p>He had hardly had time to settle down when he sold the house and left the country.</p><p>他还没等安顿下来就卖掉了房子，离开了这个国家。</p></li><li><p>I had scarcely fallen asleep before the noise from neighbor work me up.</p><p>我刚一睡着，邻居发出的噪音就把我吵醒了。</p></li></ul><h3 id="1-6、since-ever-since（自从…）">1.6、since / ever since（自从…）</h3><p>since和ever since可以接短暂动词，也可以接延续动词。</p><ul><li><p>We haven’t seen each other since we graduated.</p><p>他刚在城里买下一所新房子，但自从搬进去后，就和汽车及车主们发生了摩擦。</p></li><li><p>He has just bought a new house in the city, but ever since he moved in, he has had trouble with cars and their owners.</p><p>自从毕业后我们彼此就没有见过面。</p></li></ul><p>注：since后通常接一般态，而不能接完成态，最常用的是一般过去时。而且其后的动词通常是短暂性动词。</p><h3 id="1-7、造句练习">1.7、造句练习</h3><p>注：鼠标选中空白处有惊喜哦</p><ul><li><p>当我走进这座大楼的时候，看见一位拿着公文包的女士（while）。</p><p><font color="#ffffff"> I saw a lady with a briefcase while I was walking into the building. </font></p></li><li><p>当你长大，你就会知道父母有多伟大。</p><p><font color="#ffffff"> When you grow up, you will know how great your parents are. </font></p></li><li><p>每当你发现你和多数人站在同一边时，就是改革的时候了。</p><p><font color="#ffffff"> Whenever you find that you are on the side of the majority, it is the time to reform. </font></p></li><li><p>玛丽打开礼物后，便开始写感谢函（thank-you notes）了。</p><p><font color="#ffffff"> After she opened her gifts, Mary started writing thank-you notes. </font></p></li><li><p>雨一停，天空中就出现了一道彩虹。</p><p><font color="#ffffff"> As soon as the rain stooped, a rainbow appeared in the sky. </font></p></li><li><p>比赛才刚刚开始，两个队就打了起来。（no sooner … than）</p><p><font color="#ffffff"> The game had no snooer started than the two teams began to fight. </font></p></li><li><p>Lulu刚用她的新电脑，电脑就坏了。（hardly … when）</p><p><font color="#ffffff"> Lulu had hardly used her new computer when it broke. </font></p></li><li><p>我们会待在海边直到天黑。</p><p><font color="#ffffff"> We are going to stay at the beach until it gets dark. </font></p></li><li><p>已经过了三个月，大卫才提到他生病了。</p><p><font color="#ffffff"> It had been three months before David mentioned he was sick. </font></p></li><li><p>我在电影院门口等Lisa，不久以后她就到了。</p><p><font color="#ffffff"> We waited for Lisa in front of the cinema and it was not long before she arrived. </font></p></li></ul><h2 id="三、地点状语从句">三、地点状语从句</h2><p>地点状语从句的连词是where。它引导的地点状语从句，不仅可以表示地点，还可以表示抽象意义“在…形式之下”。常用来表示主句动作发生的地点，即在…地点/形式下，发生了什么事。</p><ul><li><p>Where there is a will, there is a way.</p><p>有志者，事竟成。</p></li><li><p>Where there is smoke, there is fire.</p><p>无风不起浪。</p></li><li><p>A driver should slow down where there are schools.</p><p>在有学校的地方，司机应缓行。</p></li><li><p>Where the cost of government is high, resources for development are correspondingly low.</p><p>凡是政府管理费用高的地方，用于发展的资金就会相应地减少。</p></li><li><p>Where others ran away in fear, the soldier bravely fought against the enemy.</p><p>在其他人惊慌逃跑的情况下，这名士兵英勇地抗击敌军。</p></li></ul><p>造句练习（注：鼠标选中空白处有惊喜哦）：</p><ul><li><p>有生命就有希望。</p><p><font color="#ffffff"> Where there is life, there is hope. </font></p></li><li><p>在我成长的地方，人们在马路上都是靠右行驶。</p><p><font color="#ffffff"> Where I grew up, people drive on the right side of the road. </font></p></li><li><p>医生建议我住在空气更新鲜的地方。</p><p><font color="#ffffff"> The doctor advised me to live where the air is fresher. </font></p></li><li><p>在你有足够信心的前提下，你将会成功。</p><p><font color="#ffffff"> Where you have enough confidence, you will succeed. </font></p></li><li><p>无论你去哪里，无论你做什么，我将一直在这儿等你。</p><p><font color="#ffffff"> Wherever you go, Whatever you do, I will be right here waiting for you. </font></p></li></ul><h2 id="四、原因状语从句">四、原因状语从句</h2><p>原因状语从句，就是中文里的“因为…”。</p><p>原因状语从句的连词有很多。比如，because、as、since、for和in that都可以引导原因状语从句。其中，because语气最强（强调从句），只有它能回答why的提问，也只有它能被强调词（only、just、perhaps）修饰。for和in that语气最弱（强调主句），而且只能放在主句后面，for常常用来表示推断的理由。而在汉译英时，“由于”翻译为as，“既然”翻译为since。</p><ul><li><p>Teenagers are damaging their health because they play computer games too much.</p><p>因为青少年们玩电脑游戏太多，他们的健康正在受损。</p></li><li><p>As a great many people will be visiting the country, the government will be building new hotels, an immense stadium, and a new Olympic-standard swimming pool.</p><p>由于将有大批的人到我们国家来，所以政府准备建造一些新的饭店、一个大型体育场和一个新的奥运会标准游泳池。</p></li><li><p>I will seek to balance career and family since both are important to me.</p><p>由于事业和家庭对我都很重要，我要努力在两者之间取得平衡。</p></li><li><p>He had had a long and uncomfortable trip, for he had been confined to the wooden box for over ten hours.</p><p>他经历了一次漫长而难受额旅程，因为他在那个木箱里闷了10个多个小时。</p></li><li><p>He didn’t attend the negotiation in that he was ill.</p><p>他因为生病，没有参加谈判。</p></li></ul><p>造句练习（注：鼠标选中空白处有惊喜哦）：</p><ul><li><p>我们将取消音乐会，因为音乐家出了意外，现在人在医院里。</p><p><font color="#ffffff"> We will cancel the concert because the musician had an accident and is in the hospital. </font></p></li><li><p>由于下周一是法定假日，所有的政府机关都将休息。</p><p><font color="#ffffff"> As next Monday is a national holiday, all government offices will be closed. </font></p></li><li><p>既然你是英语专业的，我猜想你能帮助我学习这个句子。</p><p><font color="#ffffff"> Since you are an English major, I guess you can help me study this sentence. </font></p></li><li><p>这个问题的答案我很久都理解不透（elude me）, 也许是因为问题太简单了。</p><p><font color="#ffffff"> The answer to this question eluded me for a long time, perhaps because it was so simple. </font></p></li><li><p>昨晚下雨了，因为今天早上地面是湿的。</p><p><font color="#ffffff"> It ranied last night, for the ground is wet this morning. </font></p></li></ul><p>补充：because和because of的区别是，because of是介词短语，后面只能接名词，不能接句子。类似的介词短语还有due to，in view of，thanks to，owing to等。</p><ul><li><p>Because of this, he has not been able to get his own car into his garage even once.</p><p>为此，他甚至一次也没能把自己的车开进车库。</p></li><li><p>Owing to the heavy rain, there have been many mudslides in the hill lately.</p><p>因为大雨，最近山区发生了多起泥石流。</p></li><li><p>Thanks to great public transportation, few people in the city need to own cars.</p><p>因为有很好的公交系统，这个城市很少有人需要自己买车。</p></li></ul><h2 id="五、目的状语从句">五、目的状语从句</h2><p>目的状语从句，一般翻译为“以便于…”。</p><p>常用连词有so that、in order that和that。在目的状语从句中，常用含有情态动词。</p><ul><li><p>This time he was barking so that someone would let him out!</p><p>这次他叫着让人把他放出去。</p></li><li><p>This time, he managed to climb into the mouth of Kituro so that he could take photographs and measure temperatures.</p><p>这次他设法爬进了基图罗火山口，以便能拍摄照片和测试温度。</p></li><li><p>They has taken special precautions so that no one should recognize them.</p><p>他们做了特别的预防措施以防别人认出他们。</p></li><li><p>I am saving money in order that I can buy a house.</p><p>我正在攒钱，以便我能买一所房子。</p></li></ul><p>造句练习：</p><ul><li><p>这位电影明星伪装自己，以便在人群中不被认出来。</p><p><font color="#ffffff"> The moive star disguised himself so that he wouldn’t be recognized in the crowd. </font></p></li><li><p>我们应该早起以便能看到日出。</p><p><font color="#ffffff"> We should wake up early in the morning in order that we can see the sun rise. </font></p></li></ul><h2 id="六、方式状语从句">六、方式状语从句</h2><p>方式状语从句表示动作的方式，在汉语中就是“就像…一样”、“以…样的方式”的意思。引导词有as、as if、as though、the way。</p><ul><li><p>When in Rome, do as the Romans do.</p><p>入乡随俗。</p></li><li><p>He acted as if he had never lived in England before.</p><p>他的举动就好像他从未在英国生活过一样。</p></li><li><p>To achieve great things we must live as though we were never going to die.</p><p>做大事就要有永生的气概。</p></li><li><p>You should do it the way you were taught.</p><p>按照教你的那样去做。</p></li></ul><p>翻译练习（注：鼠标选中空白处有惊喜哦）：</p><ul><li><p>你应该像规划假期一样规划你的退休生活。</p><p><font color="#ffffff"> You should plan your retirement as you plan your vacation. </font></p></li><li><p>请照我这样，读这个单词。</p><p><font color="#ffffff"> Please pronounce the word the way I do. </font></p></li></ul><p>补充：在美式英语中，可用like来代替as if、as though，但是在书面语中很少用</p><ul><li><p>He studies English very hard, like he did Chinese some years ago.</p><p>He studies English very hard, as if he did Chinese some years ago.</p><p>He studies English very hard, as though did Chinese some years ago.</p><p>他非常用功地学英语，就像多年前学中文一样。</p></li></ul><h2 id="七、结果状语从句">七、结果状语从句</h2><p>结果状语从句，就是中文里的“如此…以至于…”。</p><p>常用的连词有：so … that …，such … that …，so that。</p><p>在so … that …句型中，so后面要接形容词或副词，或相当于形容词的分词。此外，还可以用enough取代so，但是enough要后置。</p><ul><li><p>Mrs. Sterling got so angry that she ran after them.</p><p>斯特林夫人非常气愤，向着他们追了过去。</p></li><li><p>My friend, Hugh, has always been fat, but things got so bad recently that he decided to go on a diet.</p><p>我的朋友休一直很胖，但是近来情况变得越发糟糕，以致他决定节食。</p></li><li><p>He did the work so badly that I had to do it all over again myself.</p><p>他干的太差劲了，我只好亲自重做。</p></li><li><p>She is old enough that she can get married.</p><p>She is so old that she can get married.</p><p>她已达到可结婚的年龄。</p></li></ul><p>在such … that … 句型中，such后面要接名词。</p><ul><li><p>The men got such a fright that they dropped the bag and ran away.</p><p>这两个人吓了一跳，扔下提包逃跑了。</p></li></ul><p>造句练习（注：鼠标选中空白处有惊喜哦）：</p><ul><li><p>湖面上的雾太浓，所以我们不能看到对岸。</p><p><font color="#ffffff"> The fog on the lake was very thick, so we couldn’t see the other side. </font></p></li><li><p>玛丽很贴心，以至于大家都很喜欢她。</p><p><font color="#ffffff"> Mary is so sweet that everyone loves her. </font></p></li><li><p>他们是很糟糕的厨师以至于没人去他们的餐厅。</p><p><font color="#ffffff"> They are such terrible cooks that no one came to their restaurant. </font></p></li></ul><p>补充：so是一个特殊的连词。</p><p>当它作连词时，是so that …的省略形式，引导的是结果状语从句。</p><ul><li><p>My brother has never been abroad before, so he is finding this trip every exciting.</p><p>我弟弟以前从未出过国，因此，他觉得这次旅行非常激动人心。</p></li><li><p>To make matters worse, the room is rather small, so I have temporarily put my books on the floor.</p><p>更糟糕的是，房间非常小，所以我暂时把书放在了地板上。</p></li></ul><p>当它作副词时，其引导的句子可以前面的句子分开。</p><ul><li><p>The children were at school, my husband was at work and the house was quiet. So I decided to make some meat pies.</p><p>孩子们在上学，我丈夫在上班，家里很清静。于是我决定做写肉馅饼。</p></li></ul><h2 id="八、让步状语从句">八、让步状语从句</h2><p>让步状语从句，就是中文里边的“虽然…但是…”。</p><p>引导让步状语从句的副词连词有：though、although、even though、even if。其中，though、although、even tough是对事实的让步，翻译为“虽然，尽管”；even if是对假设的让步，翻译为“即使，哪怕是”。</p><p>和中文不同的是，主句前绝不可在加but，但可用yet / still。</p><ul><li><p>Though she hesitated for a moment, she finally went in and asked to see a dress that was in the window.</p><p>她虽然犹豫了片刻，但终于还是走进了商店，要求把陈列在橱窗里的一件衣服拿给她看。</p></li><li><p>Although the bed was smashed to pieces, the man was miraculously unhurt.</p><p>尽管床摔成了碎片，但年轻人却奇迹地没有受伤。</p></li><li><p>Even though it was still summer, it rained continually and it was often bitterly cold.</p><p>即使那时仍为夏季，但雨总是下个不停，而且常常冷的厉害。</p></li><li><p>The villagers have told him that they will not accept the pub even if he gives it away.</p><p>村里的人已经告诉他，即使他把小酒店白送人，他们也不要。</p></li></ul><p>while / whereas也可以引导让步状语从句，相当于though或although</p><ul><li><p>While winning is not everything, trying to win is everything.</p><p>尽管获胜并不重要，但是为了获胜而努力却很重要。</p></li><li><p>Whereas you cannot turn back the clock, you can take control of your life.</p><p>虽然你不能使时钟倒转，但却可以掌控自己的生活。</p></li></ul><p>no matter wh-（when、where、who、which、what、how）或者whenever、wherever、whoever、whichever、whatever、however也可以引导让步状语从句</p><ul><li><p>No matter where you live, you would find it difficult not to laugh at, say, Charlie Chaplin’s early films.（No matter where = wherever）</p><p>比如说，不管你生活在哪里，你看查理·卓别林的早期电影很难不发笑。</p></li><li><p>No matter who he is, he must obey the law.（No matter who = whoever）</p><p>无论他是谁，都必须遵守法律。</p></li><li><p>No matter which people criticize you, don’t let them take your focus off your dream.（No matter which = whichever）</p><p>无论什么人批评你，都不要让他们破坏你的梦想。</p></li><li><p>No matter what you do, do with your might.（No matter what = whatever）</p><p>无论你做什么，要尽力。</p></li><li><p>No matter how busy you are, he always insists on coming with you.（No matter how = however）</p><p>不管你多忙，他总是坚持要跟你去。</p></li><li><p>The business would be a success, whoever owned it.</p><p>不论什么人经营，这生意都会成功。</p></li><li><p>Whatever may happen, you must keep calm.</p><p>不论什么事发生，你必须保持冷静。</p></li></ul><p>whether也可以引导让步状语从句，表示“无论…”。一般和or或or not一起使用。</p><ul><li><p>Whether we realize it or not, each of us has the strong desire to success.</p><p>不管我们是否意识到，我们都有成功的愿望。</p></li><li><p>Whether we win or lose, we should respect the election result.</p><p>无论是输还是赢，我们应该尊重选举结果。</p></li><li><p>Whether or not he will stay, I really don’t care.</p><p>他要走还是要留，我真的不关心。</p></li></ul><p>造句练习（注：鼠标选中空白处有惊喜哦）：</p><ul><li><p>虽然他是我兄弟，但我们长得不像。</p><p><font color="#ffffff"> Though he is my brother, we don’t look alike. </font></p></li><li><p>尽管我父亲已经到了退休年龄，却打算继续工作。</p><p><font color="#ffffff"> My father plans to carry on working even though he is old enough to retire. </font></p></li><li><p>尽全力去奋斗，不管是否喜欢。</p><p><font color="#ffffff"> Try you best to fight, whether you enjoy it or not. </font></p></li><li><p>无论是你做还是他做，这个工作今天都得做完。</p><p><font color="#ffffff"> Whether you or he do it, the work mush be finished today. </font></p></li></ul><h2 id="九、小结">九、小结</h2><p>最后，小结一下今天的内容，我们还是直接看图：</p><p><img src="/img/image-20221106145425527.png" alt="image-20221106145425527"></p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>名词性从句</title>
    <link href="/2022/07/10/%E5%90%8D%E8%AF%8D%E6%80%A7%E4%BB%8E%E5%8F%A5/"/>
    <url>/2022/07/10/%E5%90%8D%E8%AF%8D%E6%80%A7%E4%BB%8E%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>在前面我们提到，英文中的复杂句主要分为两大类，并列句和复合句。其中，复合句主要有三种类型，名词性从句、状语从句和定语从句。今天我们来看看最简单复合句，名词性从句。</p><h2 id="一、什么是名词性从句">一、什么是名词性从句</h2><p>所谓从句，就是一个句子，在另一个句子里做句子成分。</p><p>名词性从句，就是一个句子，在另一个句子里当名词使用。它相当于一个名词，名词能做什么，它就能做什么。</p><p>在一个句子中，名词一般是作主语、宾语、表语和同位语。相应的就会有主语从句、宾语从句、表语从句和同位语从句。比如，“他不爱读书让我很生气”。就是一个主语从句。这里的“他不爱读书”不仅是主语，而且还是一个完整的句子。</p><p>从句需要有引导词。比如，“他不爱读书让我很生气”。绝对不能翻译为“He doesn’t like to study makes me angry.”，必须加上引导词&quot;That he doesn’t like to study makes me angry.&quot;。</p><p>名词性从句的引导词可以被划分为以下3类：</p><ul><li>that引导的陈述句</li><li>whether/if引导的一般疑问句</li><li>疑问词引导的特殊疑问句</li></ul><h2 id="二、that从句">二、that从句</h2><p>任何一个陈述句，前面加上引导词that，就构成了that从句。当that从句在句子中作宾语/表语时，that可以省略。</p><ul><li><p>That everyone may receive a moderate education is an object of vital importance.（主语从句）</p><p>每个人能够接受适当的教育是一个至关重要的目标。</p></li><li><p>Many people pretend that they understand modern art.（宾语从句）</p><p>Many people pretend they understand modern art.</p><p>很多人装成很懂现代艺术的样子。</p></li><li><p>The most surprising thing about it, however, is that it can land anywhere: on snow, water, or even on a ploughed field.（表语从句）</p><p>The most surprising thing about it, however, is it can land anywhere: one snow, water, or even on a ploughed field.</p><p>然而，最令人惊奇的是它能够在任何地方降落：雪地、水面甚至刚耕过的田里。</p></li><li><p>No one could count for the fact that one of the boxes was extremely heavy.（同位语从句）</p><p>其中有只箱子特别中，可谁也弄不清是怎么回事。</p></li></ul><p>that从句作主语时，为了使主干更紧凑，通常可用it作形式主语，而将真正的主语后置。</p><ul><li><p>It was obvious that he was very embarrassed.</p><p>That he was very embarrassed was obvious.</p><p>显然他感到很尴尬。</p></li><li><p>It is a curious coincidence that Mr. Page will have been teaching for a total of forty years.</p><p>That Mr. Page will have been teaching for a total of forty years is a curious coincidence.</p><p>佩奇先生执教总共满40年，这真是奇妙的巧合。</p></li></ul><p>需要注意的是，consider、deem、think、find和believe这五个动词是宾补动词，构成第四大句型，表示“认为…是…”。在宾补句型中，如果宾语是一个从句，则不能采用宾语补语的常见造句规则。</p><p>比如，“我认为健康是非常重要的”，这里的“健康”是一个名词，因此可以直接翻译为“I think health very important”。</p><p>而“我认为我们每天说英语是重要的”，这里的“我们每天说英语”是一个从句，此时不能翻译为“I think that we should speak English important”，而应该翻译为“I think it important that we should speak English”。</p><ul><li><p>I think it necessary that you do it at once.</p><p>我认为你必须立刻做那件事。</p></li><li><p>We find it necessary that we practice spoken English every day.</p><p>我们发现每天练习英语口语很有必要。</p></li></ul><h2 id="三、whether-if从句">三、whether/if从句</h2><p>whether/if从句用于引导一般疑问句。所谓一般疑问句，就是答案为“是”或者“不是”的问句。比如，Will he come tomorrow？就是一个一般疑问句。</p><p>任何一个一般疑问句，前面加上引导词whether或if，就构成了whether/if从句。比如，“我不知道他明天会来吗？”这句话不能翻译为：I don’t know will he come tomorrow。正确的翻译应该是：I don’t know if he will come tomorrow.</p><p>需要注意的是，主语与be动词或助动词的位置要还原成陈述句的样子。如果助动词为do，does，did，在还原成陈述句后，需要将do，does，did去掉，后面的动词根据人称和时态进行变化。</p><ul><li><p>Whether they would support us was a problem.（主语从句，Would they support us？）</p><p>他们是否会支持我们还是一个问题。</p></li><li><p>He asked if Mr Gilber’s operation had been successful and the doctor told him that it had been.（宾语从句，Is Mr Gilber’s operation successful？ / Has Mr Gilber’s operation been successful？）</p><p>他问吉尔伯特先生的手术是否成功，医生告诉他手术很成功。</p></li><li><p>On the way home, he asked Jenny if she (had) enjoyed the speech.（宾语从句，直接宾语，Do you enjoy the speech？）</p><p>在回家的路上，他问珍妮是否喜欢他的祝词。</p></li></ul><p>还一点需要注意的是，在介词后或or not结构中，通常用whether。</p><ul><li><p>My sister is only seven, but she always tells me whether my pictures are good or not.</p><p>我的妹妹只有7岁，但她总能说出我的画是好还是坏。</p></li><li><p>I worry about whether I hurt his feeling.</p><p>我担心是否伤害了他的感情。</p></li></ul><h2 id="四、疑问词从句">四、疑问词从句</h2><p>疑问词从句的构成方法与whether从句一样，只是将whether换成疑问词（when、where、what、how和why等）而已。此外，语序的变化规则和whether从句也是相同的。比如，“我不知道他什么时候来”，应该翻译为：I don’t know when he will come.</p><ul><li><p>He asked when Mr Gilbert would be allowed to go home and the doctor told him that he would have to stay in hospital for another two weeks.（宾语从句，）</p><p>他问吉尔伯特先生什么时候可以回家，医生说他在医院还必须再住上两个星期。</p></li><li><p>The doctors have not yet decided how the woman died.</p><p>医生至今还未确定这位妇女的死因。</p></li><li><p>I have no idea what has happened to him.</p><p>我不知道他发生了什么事？</p></li></ul><h2 id="五、小结">五、小结</h2><p>最后，小结一下今天的内容吧，我们还是直接看图：</p><p><img src="/img/image-20221105151053378.png" alt="image-20221105151053378"></p><h2 id="六、造句练习">六、造句练习</h2><p>注：鼠标选中空白处有惊喜哦</p><ul><li><p>谁将负责这项工程还没有（被）决定。（be in charge of）</p><p><font color="#ffffff"> Who will be in charge of the project hasn’t been decided yet. </font></p></li><li><p>他要来参加这个会议（已经）使得我们每个人激动了。</p><p><font color="#ffffff"> It makes every one of us very excited That he will come to the conference. </font></p></li><li><p>它告诉我们他们会帮助我们完成整个工作的。</p><p><font color="#ffffff"> He told me that they would help us finish the whole work. </font></p></li><li><p>我不知道您是否能小声点。</p><p><font color="#ffffff"> I wonder whether/if you would mind making less noise. </font></p></li><li><p>我认为每天多喝水是有必要的。</p><p><font color="#ffffff"> I think it necessary that we (should) take/drink plenty of water every day. </font></p></li><li><p>我不知道他们什么时候回来定居。</p><p><font color="#ffffff"> I have no idea when they will be back and settle down. </font></p></li><li><p>我（已经）发现所有的票都（已经）卖光了。</p><p><font color="#ffffff"> I have found that all the tickets had been sold out. </font></p></li><li><p>问题是这部电视剧是否值得一看。</p><p><font color="#ffffff"> The question is whether the TV play is worth watching. </font></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并列句 = 简单句 + 并列连词 + 简单句</title>
    <link href="/2022/07/10/%E5%B9%B6%E5%88%97%E5%8F%A5%20=%20%E7%AE%80%E5%8D%95%E5%8F%A5%20+%20%E5%B9%B6%E5%88%97%E8%BF%9E%E8%AF%8D%20+%20%E7%AE%80%E5%8D%95%E5%8F%A5/"/>
    <url>/2022/07/10/%E5%B9%B6%E5%88%97%E5%8F%A5%20=%20%E7%AE%80%E5%8D%95%E5%8F%A5%20+%20%E5%B9%B6%E5%88%97%E8%BF%9E%E8%AF%8D%20+%20%E7%AE%80%E5%8D%95%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们学习了英文中简单句的造句方法，也就是5大基本句型。今天，我们来看看英语中最简单的复杂句，并列句。</p><h2 id="一、简单句-vs-复杂句">一、简单句 vs 复杂句</h2><p>首先，我们要知道的是，句子短不等于简单句，句子长不等于复杂句。</p><h3 id="1-1、简单句">1.1、简单句</h3><p>所谓简单句，就是只有一个主干的句子。</p><p>比如，“寒冷的早上，我看到了各种红的蓝的黄的幻觉”，这句话看起来很复杂，但它其实是一个简单句，因为它的谓语动词只有一个。这句子只有一个主干，我产生了幻觉。寒冷的、早上是状语，而红的、蓝的、黄的是定语。</p><p>再比如，“我在吃饭的时候小明给我打了个电话”。这个句子看起来很简单，但它其实是一个复杂句。因为句子的主干不只一个，一个是我在吃饭，另一个是小明在给我打电话。</p><h3 id="1-2、复杂句">1.2、复杂句</h3><p>在英语中，常见的复杂句主要有两种，并列句和复合句。</p><p>所谓的并列句，就是由并列连词连接两个，或两个以上简单句而成的句子。</p><p>所谓的复合句，就是除了主句外，还包含一个或一个以上从句的句子。连接主句和从句的词主要用三种：</p><ul><li>引导词，连接名词性从句</li><li>副词连词，连接状语从句</li><li>关系词，连接定语从句</li></ul><p>需要注意的是，汉语可以用逗号分隔两个完整的句子，但英语绝对不可以。</p><p>在英语中，只要出现两个完成的句子，它们之间就绝对不能出现逗号，而是必须有连词连接，或者把其中一个句子，化简为分词短语或不定式短语。</p><p>简单来说，在汉语中，可以一逗到底，但在英语中却不行。比如，在汉语中，我们可以说，我今天吃了一碗面（逗号），然后我看到了小红（逗号），小红对我说今天天气好好啊（句号）。如果把这句话翻译成英语，就是三个句子，不能只用逗号。我们不能说“I eat noodles today, I saw Xiao hong.”，我们只能讲&quot;I eat noodles today and then I saw Xiao Hong.&quot;。</p><h2 id="二、并列连词">二、并列连词</h2><p>在并列句中，一定会出现并列连词。而最基本的并列连词，就是一些比较简单的单一连接词。比如，and（和），or（否则，或者），but（但是）等。它们可以连接任何对等的句子，或连句子中任何对等的成分。</p><h3 id="2-1、连接整个句子">2.1、连接整个句子</h3><p>就是把两个完整的句子连接在一起。比如，</p><ul><li><p>I had just lost £50 and I felt very upset.</p><p>我刚刚丢了50英镑，感到非常烦恼。</p></li><li><p>The police had a difficult time, but they were most amused.</p><p>警察虽然吃了苦头，但他们还是感到很有趣。</p></li></ul><p>注：一般情况下，and不加逗号，but则要在它前面的句子后加逗号。</p><p>在用or连接句子时，通常用于祈使句（表达命令）后，一般翻译为“否则”。比如，</p><ul><li><p>Obey your boss or you will be fired.</p><p>服从你的上司，否则你会被解雇。</p></li><li><p>Don’t cheat at exams or others will despise you.</p><p>考试不要作弊，否则别人会瞧不起你。</p></li><li><p>Give me liberty or give me death.</p><p>不自由，毋宁死。</p></li></ul><h3 id="2-2、连接句子中的对等成分">2.2、连接句子中的对等成分</h3><h4 id="2-2-1、连接主语">2.2.1、连接主语</h4><ul><li><p>A young man and a young woman were sitting behind me.</p><p>一个青年男子和一个青年女子坐在我的身后。</p></li></ul><h4 id="2-2-2、连接谓语">2.2.2、连接谓语</h4><p>相当于是连接两个句子，只是省略了第二个句子的主语。比如，</p><ul><li><p>I visited museums and (I) sat in public gardens.</p><p>我参观了博物馆，还去了公园。</p></li><li><p>I entered the hotel manager’s office and (I) sat down.</p><p>我走进饭店经理的办公室，坐了下来。</p></li></ul><p>在连接谓语时，如果助动词相同，可省略助动词。比如，</p><ul><li><p>After taking off, we were flying low over the city and (were) slowly gaining height, when the plane suddenly turned round and flew back to the airport.</p><p>起飞之后，我们在城市上空低地地飞行，然后慢慢爬高。这时飞机突然调转头来，飞回了机场。</p></li></ul><p>其实，谓语动词相同时，也可以省略。比如，</p><ul><li><p>Mary is very happy but John (is) very miserable.</p><p>玛丽很幸福，但是约翰很悲惨。</p></li><li><p>Experience is the father of wisdom, and memory (is) the mother.</p><p>经验乃智慧之父，记忆为智慧之母。</p></li><li><p>Reading makes a full man; conference (makes) a ready man; and writing (makes) an exact man.</p><p>读书使人渊博，交谈使人机敏，写作使人严谨。</p></li></ul><h4 id="2-2-3、连接宾语">2.2.3、连接宾语</h4><ul><li><p>I looked at the man and the woman angrily.</p><p>我回过头怒视着那一男一女。</p></li><li><p>He asked me for a meal and a glass of beer.（连接介词for的两个宾语）</p><p>他问我要一顿饭和一杯啤酒。</p></li></ul><h4 id="2-2-4、连接表语">2.2.4、连接表语</h4><ul><li><p>The railway station was big, black and dark.</p><p>火车站很大，又黑又暗。</p></li><li><p>The explanation was simple but very unusual.</p><p>解释很简单，却异乎寻常。</p></li></ul><h4 id="2-2-5、连接宾补">2.2.5、连接宾补</h4><ul><li><p>He saw tow thieves rush out of a shop and run towards a waiting car.</p><p>他看到有两个小偷从一家商店里冲出来，奔向等在那里的一辆汽车。</p></li></ul><h4 id="2-2-6、连接定语">2.2.6、连接定语</h4><ul><li><p>Pupils of the school, old and new, will be sending him a present to mark the occasion.</p><p>为了纪念这个日子，学校的学生——无论老同学还是新同学——将送他一件礼物。</p></li></ul><h4 id="2-2-7、连接状语">2.2.7、连接状语</h4><ul><li><p>We shall all remember Mr. Page for his patience and understanding and for the kindly encouragement.</p><p>我们不会忘记佩奇先生对我们既有耐心又充满理解，还有亲切鼓励。</p></li></ul><h3 id="2-3、注意事项">2.3、注意事项</h3><p>需要注意的是，当or连接两个句子时，通常翻译为“否则”；而当or连接对等成分的时候，则翻译为“或者”。比如，</p><ul><li><p>Don’t cheat on exam, or you’ll be despised.（连接句子）</p><p>考试不要作弊，否则你会被瞧不起。</p></li><li><p>They will go to the zoo or play volleyball.（连接谓语）</p><p>他们要去动物园或打排球。</p></li><li><p>I want to have talk with Mr. Jones or Mr. Smith.（连接宾语）</p><p>我想和琼斯先生或者史密斯先生谈谈。</p></li></ul><p>And也可以表示 “然后、但是、那么，则”的意思。比如，</p><ul><li><p>I will set my goal and work toward it.</p><p>我要确定目标，然后为此努力。</p></li><li><p>Idleness is sweet, and its consequences are cruel.</p><p>懒惰是甜蜜的，但其结果是残酷的。</p></li><li><p>Cease to struggle and you cease to live.</p><p>停止奋斗，则终止了生命。</p></li></ul><h2 id="三、衍生连词">三、衍生连词</h2><p>虽然最基本的并列连词只有and、or和but这三个，但由它们可以衍生出很多连接词。比如：</p><ul><li>and，可变化为both… and…（…和…都）</li><li>or，可变化为either… or…（要么… 要么…）；neither… nor…（既不是… 也不是…）</li><li>but，可变化为not… but…（不是…而是…）；not only… but also…（不仅… 而且…）</li></ul><p>此外，as well as和rather than也可视为并列连词。下面我们来看一些具体的例句。</p><h3 id="3-1、both…-and…（…和…都）">3.1、both… and…（…和…都）</h3><ul><li><p>To go gar, you need both a dream and a positive attitude.</p><p>要成功，你需要梦想和积极的态度。</p></li></ul><h3 id="3-2、either…-or…（要么…-要么…）">3.2、either… or…（要么… 要么…）</h3><ul><li><p>In answer to these questions I either nodded or made strange noises.</p><p>在回答这些问题时，我要么点头，要么发出奇怪的声音。</p></li><li><p>Either Bob or Jim or Sam will be the new vice president of the company.</p><p>不是鲍勃就是吉姆或是山姆会成为这家公司的新副总裁。</p></li></ul><h3 id="3-3、neither…-nor…（既不是…-也不是…）">3.3、neither… nor…（既不是… 也不是…）</h3><ul><li><p>He answered me, but he spoke neither slowly nor clearly.</p><p>他回答了我，但他讲得既不慢也不清楚。</p></li><li><p>We are worried about Mary. She neither eats nor drinks nor talks.</p><p>我们替玛丽担心。她不吃不喝也不说话。</p></li></ul><p>在该句型中，也可用其它否定词代替neither</p><ul><li><p>The story is neither interesting nor instructive.</p><p>The story is not interesting nor instructive.</p><p>这个故事没有味道，也没有教育意义。</p></li><li><p>I have neither spoken nor written to her.</p><p>I have never spoken nor written to her.</p><p>我跟她从来没说过话，也没写过信。</p></li></ul><h3 id="3-3、not…-but…（不是…而是…）">3.3、not… but…（不是…而是…）</h3><ul><li><p>I went to the concert not with my brother but with my friend.</p><p>我不是和我哥哥去音乐会，而是和我朋友去的。</p></li><li><p>We choose to go to the moon in this decade and do the other thins, not because they are easy, but because they are hard.</p><p>我们选择10年内登月以及做另外一些事情，不是因为它们容易，而是因为它们困难。</p></li><li><p>“Listen, my dear, we must hold on to hope,” my father calm but insistently replied. “Not because hope is real, but because we have to live up to nobility”.</p><p>“听着，亲爱的，我们必须抱有希望，”我爸爸平静但坚定地回答。“这并不是因为希望真的存在 ，而是因为我们要做高贵的人。”</p></li></ul><h3 id="3-4、not-only…-but-also…（不仅…-而且…）">3.4、not only… but also…（不仅… 而且…）</h3><ul><li><p>He answered all the questions not only quickly but (also) accurately.</p><p>他回答所有问题时不仅快，而且准确。</p></li><li><p>The Big Ben is not only of immense size, but is extremely accurate as well.</p><p>此钟不仅外形巨大，而且走时也非常准确。</p><p>注：后句中的动词is没有省略，是因为前后的动词并不完全一致。be of是一个常见的动词搭配，其后要加名词，等同于be动词后加形容词。其实，在这里我们也可以说The Big Ben is not only immense, but also extremely accurate.</p></li></ul><p>在英国英语中，常用not only … but … as well，而在美国英语中，常用not only … but also …（also可省略）</p><ul><li><p>I not only spoke English very carefully, but very clearly as well.（英）</p><p>I not only spoke English very carefully, but (also) very clearly.（美）</p><p>我的英语讲得不但非常认真，而且咬字也非常清楚。</p></li></ul><h3 id="3-7、…-as-well-as-…（既是…又是…）">3.7、… as well as …（既是…又是…）</h3><ul><li><p>Nursing is vocation as well as profession.</p><p>护理工作既是职业又是救死扶伤的责任。</p></li><li><p>He shared in my sorrows as well as in my joys.</p><p>他分担我的快乐也分享我的悲伤。</p></li></ul><h3 id="3-8、…-rather-than-…（是…-而不是…）">3.8、… rather than …（是… 而不是…）</h3><ul><li><p>There are political rather than social matters.</p><p>这是政治问题而不是社会问题。</p></li></ul><h2 id="四、小结">四、小结</h2><p>最后，小结一下今天的内容，一图胜千言，我们直接看思维导图：</p><p><img src="/img/image-20221030191412063.png" alt="image-20221030191412063"></p><h2 id="五、造句练习">五、造句练习</h2><p>注：鼠标选中空白处有惊喜哦</p><ul><li><p>中国和印度的人口都超过了10亿。</p><p><font color="#ffffff"> Both China and India have a population of over one billion. </font></p></li><li><p>我们应该要么把电脑送修要么买台新的。</p><p><font color="#ffffff"> We should either get the computer fixed or buy a new one. </font></p></li><li><p>冰箱里既没有牛奶也没有蔬菜。</p><p><font color="#ffffff"> Neither milk nor vegetables is in the refrigerator. </font></p></li><li><p>无论下雪、下雨或者高温天气都不能阻止这些邮递员完成他们的投递工作。</p><p><font color="#ffffff"> Neither snow nor rain nor hot weather prevents these postmen from completing their deliveries. </font></p></li><li><p>不是公司董事长而是我将出席明天早上的上午会议。</p><p><font color="#ffffff"> Not the company’s president but I am going to the business meeting tomorrow morning. </font></p></li><li><p>我们都喜欢张小姐，不是因为她是我们老师，而是因为她使美女。</p><p><font color="#ffffff"> We all like Miss Zhang not because she is our teather but because she is very beautiful. </font></p></li><li><p>恶心和呕吐都是食物中毒的症状。</p><p><font color="#ffffff"> Both mausea and vomiting are signs of food poisoning. </font></p></li><li><p>他不但英语说得非常好，而且还会说法语。</p><p><font color="#ffffff"> He can ont only speak English very well but also French. </font></p></li><li><p>这名女子听到这个消息的时候是高兴而不是悲伤。</p><p><font color="#ffffff"> The woman was happy rather than sad when she heard the news. </font></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英文基础语法概念和简单句造句法则</title>
    <link href="/2022/06/19/%E8%8B%B1%E6%96%87%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%A6%82%E5%BF%B5%E5%92%8C%E7%AE%80%E5%8D%95%E5%8F%A5%E9%80%A0%E5%8F%A5%E6%B3%95%E5%88%99/"/>
    <url>/2022/06/19/%E8%8B%B1%E6%96%87%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%A6%82%E5%BF%B5%E5%92%8C%E7%AE%80%E5%8D%95%E5%8F%A5%E9%80%A0%E5%8F%A5%E6%B3%95%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>想要快速提升英文读写能力，应对各种类型的英语考试，学会如何用英文造句，可以说是最高效的方法。这篇文章讲解的是，英文中最基础的语法概念，以及简单句的造句法则。</p><h2 id="一、词性">一、词性</h2><p>词性，是指一个单词的分类。在英语中，所有的单词，基本都可以被分为两类：虚词和实词。</p><p>虚词，是指没有具体含义的词。一般有两类，介词（in、at、on等）和连词（and、but、or等）。</p><p>实词，是指有实际意义的词。主要有四大类，名词，动词，形容词和副词。</p><ul><li>名词，用来表达一件东西的名称的词。比如，花、草、太阳、月亮等等。</li><li>动词，表示运动的词。比如，打、骂、唱、跳等。</li><li>形容词，专门用来修饰名词的词。比如，白、富、美、高、富、帅。</li><li>副词，在句子中起辅助作用的词，一般用来表示行为或状态，专门用来修饰名词以外的所有的词。比如大声地唱歌。</li></ul><h2 id="二、句子成分">二、句子成分</h2><p>句子成分，是指单词组成句子后，在句中起到什么样的作用。最基本的句子成分，主谓宾。</p><ul><li><p>主语，是一个句子的主人，即主体部分。比如，&quot;我打他&quot;中“我”。</p></li><li><p>宾语，是一个句子的客人，即客体部分。也被称为受体，接受主体的动作。比如，&quot;我打他&quot;中“他”。</p></li><li><p>谓语，是用来表示主语动作的词。比如，&quot;我打他&quot;中“打”。</p></li></ul><p>注：句子成分和词性是不同的。比如，名词可以做主语和宾语，但是做主语和宾语的不一定是一个名词，也可能是短语或者短句。</p><h2 id="三、5大基本句型">三、5大基本句型</h2><p>在英文中，动词只有5种类型，对应的就产生了5种句型。它们分别是：</p><ul><li>系动词，主语 + 系动词 + 表语</li><li>不及物动词，主语 + 谓语</li><li>及物动词，主语 + 谓语 + 宾语</li><li>不完全及物动词，主语 + 谓语 + 宾语 + 宾语补语</li><li>授予动词，主语 + 谓语 + 间接宾语 + 直接宾语</li></ul><p>接下来，我们重点理解这5种基本句型。</p><h3 id="3-1、系动词：主系表">3.1、系动词：主系表</h3><h4 id="3-1-1、what">3.1.1、what</h4><p>系动词，是一种特殊的动词，属于动词的一种。用英文讲，就是linking verb，即联系动词。比如，汉语里的“是”、“为”，英语里的am、is、are。在句子中，系动词一般做谓语，没有实际意思。比如，你是猪，其中的“是”并没有实际意思，只是起到了一个连接的作用。</p><p>表语，是指在联系动词之后的、补充说明主语性质的部分。</p><h4 id="3-1-2、how">3.1.2、how</h4><p>判断一个句子是否为主系表结构，最简单的方法是，看句子中的谓语，能否翻译成“是”或者“为”。比如：</p><ul><li>I am a good person.</li><li>I become a good person.</li></ul><p>这里，am和become，分别可翻译成“是”和“为”，因此是主系表结构。当然，这个方法并不具备普适性。总的来说，英语中的系动词一共分为4大类：</p><ul><li>be动词</li><li>状态保持动词</li><li>状态转变动词</li><li>感官动词</li></ul><h4 id="3-1-3、who">3.1.3、who</h4><h5 id="3-1-3-1-、be动词">3.1.3.1 、be动词</h5><p>be动词，就是am、is、are这3个词，以及它们对应的过去、将来时态。在be动词之后，有3大类表语，它们分别是：</p><ul><li>名词</li><li>形容词</li><li>地点副词</li></ul><p>当名词作表语时，这类句子和汉语可以完全对应，be动词翻译为“是”。比如：</p><ul><li><p>Tim is an engineer.</p><p>蒂姆是个工程师。</p></li><li><p>The price is £2,000.</p><p>价格是2000英镑。</p></li></ul><p>当形容词作表语时，这类句子和汉语略有不同，be动词一般不翻译出来，直接被省略。比如：</p><ul><li><p>The play was very interesting.</p><p>戏很有意思。</p></li><li><p>The milk is in the refrigerator.（注：这里是介词短语充当形容词）</p><p>牛奶在冰箱里。</p></li></ul><p>当副词作表语时，这种类型的句子，一定只能是地点副词，别的副词不行。比如：</p><ul><li><p>Your sister is here these days.</p><p>这些天你姐姐在这儿。</p></li><li><p>My bedroom is downstairs.</p><p>我的卧室在楼下。</p></li></ul><h5 id="3-1-3-2、状态保持动词">3.1.3.2、状态保持动词</h5><p>这类动词只有3个，它们分别是keep、remain和stay，这3个词后面只能加形容词做表语，可以和be无缝切换。比如：</p><ul><li><p>You should keep quiet.</p><p>You should be quiet.</p><p>你应该保持安静。</p></li><li><p>No one can remain youthful forever.</p><p>No one can be youthful forever.</p><p>没人能永葆青春。</p></li><li><p>The weather stayed fine for a week.</p><p>The weather was fine for a week.</p><p>这个星期天气一直很好。</p></li></ul><h5 id="3-1-3-3、状态转变动词">3.1.3.3、状态转变动词</h5><p>这类动词只有6个，它们分别是become、get、grow、turn、come和go，它们基本上都可以理解成“为”，就是“变成”、“变为”和“变得”。</p><p>become是一个万能词，既可以表示“变成”，这时后面只能接名词，同时也可以表示“变得”，此时后面一般接形容词。比如：</p><ul><li><p>He became a teacher.</p><p>他成为了一名教师。</p></li><li><p>He became very nervous.</p><p>他变得很紧张。</p></li></ul><p>get表示“变得怎样”，后面只能接形容词。比如：</p><ul><li><p>He got very angry.</p><p>他非常生气。</p></li></ul><p>grow可以表示为“慢慢变”，因为它的本意是“生长”，我们都是慢慢长大的。比如：</p><ul><li><p>The weather grew cold in the night.</p><p>晚上天气慢慢变冷。</p></li></ul><p>turn可以表示为“快速变”，因为它的本意是“转身”，当然是一下子转过去。比如：</p><ul><li><p>His face turned pale.</p><p>他的脸色变得苍白。</p></li></ul><p>come可以表示为“变好”，因为它的本意是“来”，我们希望什么东西来，当然是好的东西啊。比如：</p><ul><li><p>Thing will come right.</p><p>事情会变好。</p></li></ul><p>go可以表示为“变坏”。因为它的本意是“走”，我们希望什么东西走，当然是坏的东西啊。比如：</p><ul><li><p>The meat always goes bad in summer.</p><p>肉在夏天经常会坏掉。</p></li></ul><h5 id="3-1-3-4、感官动词">3.1.3.4、感官动词</h5><p>这类动词只有5个，它们分别是look、sound、smell、taste和fell。在翻译这5个动词时，一律翻译为“…起来”，即“看起来、听起来、闻起来，尝起来，感觉起来（或刚到）”，其后只能接形容词（或相当于形容词的分词）作表语。例如：</p><ul><li><p>He looked very angry.</p><p>他看上去非常气愤。</p></li><li><p>They were all hungry and the food smelled good.</p><p>他们全都饿了，饭菜散发出阵阵香味。</p></li><li><p>I felt very nervous when I went into his office.</p><p>当我走进他的办公室时，我感到非常紧张。</p></li></ul><p>需要注意的是，感官动词后，决不能直接加名词作表语。如果要加名词，就必须采用“感官动词 + 介词like + 名词”的结构，此时翻译为“像…”。例如：</p><ul><li><p>The sun looks like an orange globe.</p><p>太阳看上去像只橙色的球体。</p></li></ul><h4 id="3-1-4、造句练习">3.1.4、造句练习</h4><p>注：鼠标选中空白处有惊喜哦</p><ul><li><p>每件事都很有序（in good order）。</p><p><font color="#ffffff"> Everything is in good order.</font></p></li><li><p>我的房子就在这里。</p><p><font color="#ffffff"> My house is here.</font></p></li><li><p>这辆轿车看起来很棒。</p><p><font color="#ffffff"> This car looks very good.</font></p></li><li><p>鳄鱼肉尝起来就像鸡肉。</p><p><font color="#ffffff"> Alligator meet tastes like chicken.</font></p></li><li><p>地震期间你应该保持冷静。</p><p><font color="#ffffff"> You should keep calm during an earthquake. </font></p></li><li><p>麦克去年成为一名职业篮球运动员。</p><p><font color="#ffffff"> Mike became a professional basketball player last year. </font></p></li><li><p>天气变得寒冷而多风（cold and windy）。</p><p><font color="#ffffff"> The weather has turned cold and windy. </font></p></li></ul><h3 id="3-2、不及物动词：主谓">3.2、不及物动词：主谓</h3><h4 id="3-2-1、what">3.2.1、what</h4><p>不及动词，intransitive verb，简称vi。就是本身意就很完全，不需要作用对象，不加宾语就能构成完整句子的动词。比如，游泳、出生、笑、做梦等。</p><p>这类动词很好理解，汉语怎么说，英文就怎么说。比如，I dance，我跳舞，中英完全对照，也很完整。</p><h4 id="3-2-2、how">3.2.2、how</h4><p>判断这类动词的方法很简单，在动词前面加上“被”字，看是否正常。如果正常，就是及物动词，否则就是不及物动词。比如，被打、被处罚、被喜欢等都正常，而如果说，被跳舞、被做梦、被游泳等，就很不通顺了。</p><p>这类句型，通常会有带有一个或多个状语，来进一步说明动作发生的时间，地点，方式等。比如，</p><ul><li>Detectives were waiting at the airport all morning.</li></ul><p>其中，Detectives是主语，were waiting是谓语，at the airport是地点状语，all morning是时间状语。</p><p>注：很多动词，本身即可以作不及物动词，也可以作及物动词，除了上述的判断方法外，得在具体语境中判断。</p><h4 id="3-2-3、造句练习">3.2.3、造句练习</h4><p>注：鼠标选中空白处有惊喜哦</p><ul><li><p>鸟儿快乐地唱着歌。</p><p><font color="#ffffff"> The birds sing happily. </font></p></li><li><p>这场雨下午会停。</p><p><font color="#ffffff"> The rain will stop in the afternoon. </font></p></li><li><p>孩子们正在公园里玩耍。</p><p><font color="#ffffff"> The children are playing in the park. </font></p></li><li><p>我的老师昨天在医院去世了（pass away）。</p><p><font color="#ffffff"> My teacher passed away in the hospital yesterday. </font></p></li></ul><h3 id="3-3、及物动词：主谓宾">3.3、及物动词：主谓宾</h3><h4 id="3-3-1、what">3.3.1、what</h4><p>及物动词，transitive verb，简称vt，就是加了宾语后，意思很完全的动词。有主动和被动两种语态。有些短语相当于及物动词，称为及物动词短语。</p><ul><li><p>Yesterday, a pigeon carried the first message from Pinhurst to Silbury.</p><p>昨天，一只鸽子把第一封信从平赫特带到锡尔伯里。</p></li><li><p>The bird covered the distance in three minutes.</p><p>这只鸟只用了3分钟就飞完了全程。</p></li><li><p>The bride and the groom cut the wedding cake together.</p><p>新郎和新娘一起切下结婚蛋糕。</p></li><li><p>I had an amusing experience last year.</p><p>去年我有过一次有趣的经历。</p></li><li><p>This wonderful plane can carry seven passengers.</p><p>这架奇妙的飞机可以载7名乘客。</p></li></ul><h4 id="3-3-2、造句练习">3.3.2、造句练习</h4><p>注：鼠标选中空白处有惊喜哦</p><ul><li><p>老师在教室的墙上贴了一些照片。</p><p><font color="#ffffff"> The teacher put up some pictures on the wall in the classroom. </font></p></li><li><p>在公共场合你应该尊敬老人。</p><p><font color="#ffffff"> You should respect the old in public places. </font></p></li><li><p>他一周前开始节食。</p><p><font color="#ffffff"> He began his diet a week ago. </font></p></li><li><p>他于1935年9月创造了一项新的世界纪录。</p><p><font color="#ffffff"> He set up a new world record in September 1935. </font></p></li><li><p>只有极少数人能实现它们的梦想。</p><p><font color="#ffffff"> only very few people can realize their dreams. </font></p></li></ul><h3 id="3-4、不完全及物动词：主谓宾补">3.4、不完全及物动词：主谓宾补</h3><h4 id="3-4-1、what">3.4.1、what</h4><p>不完全及物动词，incomplete transitive verb，简称i.vt。这种动词加了宾语后，意思仍然不完全，需要加上补语才能使句子完整。</p><p>补语，是对宾语特征或宾语动作的补充说明。</p><h4 id="3-4-2、how">3.4.2、how</h4><p>判断这类动词的方法很简单，将动词带入到汉语句子中，看句子的意思是否完整。</p><p>比如，“她使我爱上生活”，这里的“使”就是不完全及物动词，如果只说“她使我”意思是不完整的，得加上补语“爱上生活”，才是完整的句子。</p><h4 id="3-4-2、who">3.4.2、who</h4><p>最常用的不完全及物动词，是使役动词，主要有4个，它们分别是make、have、let和get，通常翻译成“使…做…”。其中，make / have / let + 宾语 + 动词原形（补语），get + 宾语 + 动词不定式（补语）。</p><ul><li><p>I made him wash the car</p><p>我叫他洗车。</p></li><li><p>I got him to wash the car</p><p>我叫他洗车。</p></li></ul><h4 id="3-4-3、造句练习">3.4.3、造句练习</h4><p>注：鼠标选中空白处有惊喜哦</p><ul><li><p>炎热的天气使我感到昏昏欲睡（feel lethargic）</p><p><font color="#ffffff"> The hot weather made me feel lethargic. </font></p></li></ul><h3 id="3-5、授予动词：主谓间直">3.5、授予动词：主谓间直</h3><h4 id="3-5-1、what">3.5.1、what</h4><p>授予动词，dative verb，简称d.v，是及物动词的一种，但需要连接两个宾语，第一个为间接宾语（indirect object），表示授予的对象，第二个为直接宾语（direct object），表示授予的东西。</p><p>比如，我给了他一本书。这里就有两个宾语“他”和“书”。动作“给”需要两个步骤，先拿书，再给他。所以，“书”是直接宾语，“他”是间接宾语。</p><p>注：直接宾语和间接宾语，都是谓语动词的作用对象，这是与第四大句型的区别。在第四大句型中，补语是说明宾语的性质，或者是宾语发出的动作。</p><h4 id="3-5-2、who">3.5.2、who</h4><p>最常用的授予动词有7个，它们分别是give、send、tell、teach、pay、show和offer。</p><ul><li><p>Richard Mattes gave the testers six different kinds of things.</p><p>Richard Mattes给了这些测试者6种不同类型的东西。</p></li><li><p>I send him a book in reward for his help.</p><p>我送给他一本书来答谢他的帮助。</p></li><li><p>The scientist told us many stories about birds.</p><p>博物学家给我们讲述了许多有关鸟儿的故事。</p></li><li><p>A friendly waiter taught me a few words of Italian. Then he lent me a book.</p><p>一位好客的服务员教了我几句意大利语，之后还借给我一本书。</p></li><li><p>Yesterday I paid him a visit.</p><p>昨天我去看望了他。</p></li><li><p>Then he showed me the contents of the parcel.</p><p>接着他给我看了包里的东西。</p></li><li><p>He offered me a lot of money.</p><p>他给了我很多钱。</p></li></ul><h4 id="3-5-3、造句练习">3.5.3、造句练习</h4><p>注：鼠标选中空白处有惊喜哦</p><ul><li><p>情人节他送给女友一束花。</p><p><font color="#ffffff"> He gave a bunch of flowers to his girlfriend on Valentine’s Day. </font></p></li><li><p>请寄给我一张收到此款的收据。</p><p><font color="#ffffff"> Please send me a receipt for the money. </font></p></li><li><p>他告诉我几个关于英语老师的神奇故事。</p><p><font color="#ffffff"> He told me some magical stories about our English teacher. </font></p></li></ul><h2 id="四、7大英语句子成分简述">四、7大英语句子成分简述</h2><p>在英语中，有7大句子成分，它们分别是主语、谓语、宾语、定语、状语、补语和表语。此外，还有一个同位语的概念。其中，主语、谓语、宾语、补语和表语，在前面的内容中，已经讲解过了，这里简单回顾一下，后面重点讲解定语、补语和同位语。</p><ul><li>主语，句子的主人。<strong>我</strong>吃饭了</li><li>谓语，表达主语的动作或状态。我<strong>吃</strong>饭</li><li>宾语，句子的客人，主语动作的受体。我打<strong>他</strong></li><li>补语，在不完全及物动词之后，补充说明宾语。我妈命令我<strong>下班早点回家</strong></li><li>表语，在系动词之后，表达主语的具体情况。他是<strong>人渣</strong></li></ul><h3 id="4-1、定语">4.1、定语</h3><h4 id="4-1-1、what">4.1.1、what</h4><p>定语，是限定、界定名词的部分。比如，一个高个子的、留着长头发的、穿着红色衣服的、喜欢学习英语的学生。</p><h4 id="4-1-2、who">4.1.2、who</h4><blockquote><p>什么语法成分能够作定语？</p></blockquote><p>形容词以及相当于形容词性质的语法成分（比如，介词短语或者形容词从句）</p><p>一般来说，一个短语，如果是“…的”，它就是形容词性质的。比如说，穿着红色衣服的，喜欢学习英语的。</p><h4 id="4-1-3、where">4.1.3、where</h4><p>英语中95%的定语都遵循“前小后大”法则。即：</p><ul><li><p>1个单词组成的定语（限定词、形容词、名词以及名词所有格），放在所修饰名词的前面。</p></li><li><p>2个以上单词组成的定语（of属格、不定式短语、分词短语、形容词短语、介词短语等），放在所修饰名词的后面。</p></li></ul><p>例句：</p><ul><li><p>They were expecting a valuable parcel of diamonds from South Africa.</p><p>他们正期待从南非来的一个装着钻石的贵重包裹。</p></li><li><p>Mrs. Rumbold was a large unsmiling lady in a tight black dress.</p><p>兰伯尔德夫人是一位身材高大、表情严肃的女人，穿一件紧身的黑衣服。</p></li><li><p>First of all, he wrote out a long list of all the foods.</p><p>首先，他开列了一张长长的列了所有食物的目录。</p></li></ul><h4 id="4-1-4、造句练习">4.1.4、造句练习</h4><p>注：鼠标选中空白处有惊喜哦</p><ul><li><p>我喜欢课桌上那本英语书。</p><p><font color="#ffffff"> I like the English book on table. </font></p></li><li><p>他们正在研究一个关于贸易标准(trading standard)的复杂问题。</p><p><font color="#ffffff"> They are studying a complicated problem about trading statndard. </font></p></li><li><p>我将告诉你们昨天老师给我讲的那个非常有趣的关于月亮的中国古代故事。</p><p><font color="#ffffff"> I will tell you a very interesting old Chinese story about moon that my teacher told me yesterday. </font></p></li></ul><h3 id="4-2、状语">4.2、状语</h3><h4 id="4-2-1、what">4.2.1、what</h4><p>状语，是描述一个动作细节特征的部分。</p><p>在汉语中，常常对应着“…地”。比如，唱歌。我们可以说，大声地唱歌、欢乐地唱歌、投入地唱歌等等。如果是表达时间、地点、方式的状语，则可以不带“地”。比如，在教室里唱歌、在上个星期的晚会上唱歌、用古典的方式唱歌。</p><p>在英语中，动词是verb，副词是adverb，状语是adverbial。ad这个前缀，表示加强的意思。所以，不管是副词adverb，还是状语adverbial，都是用来加强动词verb的。</p><p>除了修饰动词外，状语也可以修饰除了名词之外的任何词（如形容词、介词、连词，还可以修饰副词本身）。</p><h4 id="4-2-2、who">4.2.2、who</h4><blockquote><p>什么语法成分能够作状语？</p></blockquote><p>副词以及相当于副词的语法成分（比如，介词短语和状语从句）。</p><p>副词在句子中处于副手位置，即辅助地位。通常用于修饰动词的这几个要素，时间（when）、地点（where）、方式（how）、程度（How much）。比如，表达时间的副词now、just now，表达地点的介词短语in the house。</p><blockquote><p>如何判断介词短语是定语还是状语？</p></blockquote><p>看介词短语是形容词性质还是副词性质</p><h4 id="4-2-3、where">4.2.3、where</h4><p>小状语（单独的副词）放在其所修饰的词语之前。修饰动词时，放在动词之前。修饰其它成分（形容词、介词、连词、副词）时，放在其它成分之前。比如：</p><ul><li><p>We are <strong>now</strong> living in a beautiful new house in the country.</p><p>我们现在住在乡间的一栋漂亮的新住宅里。</p></li><li><p>Letters will cost a little more, but they will <strong>certainly</strong> travel faster.</p><p>这样会稍微多花点钱，但肯定是快得多了。</p><p>注，如有需要，小状语可以放在句中任何位置</p></li></ul><p>大状语（2个以上单词构成的状语，如介词短语，不定式短语，状语从句）放在整个句子的两头。放在开头时，一般要加上逗号。比如：</p><ul><li><p>On Wednesday evening, we went to the Town Hall.</p><p>星期三的晚上，我们去了市政厅。</p></li><li><p>I was having dinner at a restaurant when Tony Steele came in.</p><p>我正在一家饭馆吃饭，托尼·斯蒂尔走了进来。</p></li></ul><p>句中同时出现几个时间状语或者几个地点状语时，按从小到大顺序。</p><ul><li><p>We landed in America at 8 o’clock on June 15th, 2012.</p><p>2012年6月15日上午8点我们在美国着陆。</p></li><li><p>We live at number 35, South Renmin Road, Chengdu.</p><p>我们住在成都市人民南路35号。</p></li></ul><p>句子后面有多种类型的状语时，顺序是方式——地点——时间。比如：</p><ul><li><p>He put his milk bottles carefully on the doorstep every morning.</p><p>他每天早上小心地把牛奶瓶放在门口台阶上。</p></li></ul><h3 id="4-3、同位语">4.3、同位语</h3><h4 id="4-3-1、what">4.3.1、what</h4><p>同位语，是指句子中指代同一事物的两个词、短语或从句，它们是同位关系。比如：</p><ul><li>My sister, Helen Wilson, will travel with me.</li></ul><p>句中的My sister和Helen Wilson指的是同一个人，它们是同位关系，后一成分通常叫做前一成分的同位语。</p><p>注：英语中的同位语，不是单独的句子成分，而是和名词成分相并列的关系，相当于是对该名词的进一步解释说明。名词或任何相当于名词的成分，均可作同位语。</p><h4 id="4-3-2、造句练习">4.3.2、造句练习</h4><p>注：鼠标选中空白处有惊喜哦</p><ul><li><p>我的英语老师Brent Peter先生是加拿大人。</p><p><font color="#ffffff"> My English teacher, Mr. Brent peter, is Canaian. </font></p></li><li><p>昨天我遇到了我弟弟的朋友汤姆。</p><p><font color="#ffffff"> Yesterday I met Tom, afriend of my brother’s. </font></p></li><li><p>我们中国人民是勤劳勇敢的。</p><p><font color="#ffffff"> We Chinese people are brave and hardworkind. </font></p></li></ul><h2 id="五、小结">五、小结</h2><p>最后，小结一下今天的内容，一图胜千言，我们直接看思维导图：</p><p><img src="/img/image-20221120143004759.png" alt="image-20221120143004759"></p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何配置家财险和车险</title>
    <link href="/2022/05/02/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%AE%B6%E8%B4%A2%E9%99%A9%E5%92%8C%E8%BD%A6%E9%99%A9/"/>
    <url>/2022/05/02/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%AE%B6%E8%B4%A2%E9%99%A9%E5%92%8C%E8%BD%A6%E9%99%A9/</url>
    
    <content type="html"><![CDATA[<p>和生命不一样，财产是可以精确计算的，所以所有的财产险，理赔时都会遵循一个原则，叫做“损失补偿原则”。什么意思呢？就是当风险发生时，损失了多少，保险公司就赔多少。举个例子，给房子投保，保额设成3000万，后来失火损失了300万，保险公司只会赔300万而不是3000万。</p><p>所以，在配置家财险和车险时，首先要评估下想要投保的财产价值，根据价值来确定保额。</p><h2 id="一、家财险">一、家财险</h2><p>和生命不一样，财产是可以精确计算的，所以所有的财产险，理赔时都会遵循一个原则，叫做“损失补偿原则”。什么意思呢？就是当风险发生时，损失了多少，保险公司就赔多少。举个例子，给房子投保，保额设成3000万，后来失火损失了300万，保险公司只会赔300万而不是3000万。</p><p>比如在买家财险时，可以加总下房子本身的价值、室内装修的花费和室内物品的价值等，计算出来的结果就是要购买的保额。</p><p>假如所有财产加起来只有300万，但保险顾问推荐了一款1000万保额的家财险，此时不要觉得保额越高收益就越大。因为真的出现风险，保险公司只会赔偿300万，定了那么高的保额，只是多交了保费。</p><p>确定保额后，就可以选择具体产品了。普通家财险一般就包含，对房屋、室内、物品和责任的保障。</p><p>除此之外，也可以添加一些附加险，比如居家责任险、保姆专门险等，可以根据自己的需求灵活地进行组合。不过，不同公司的产品可能有不同的除外责任，在选择具体的保险产品时，尤其要注意下这一点。</p><h2 id="二、车险">二、车险</h2><p>那车险具体怎么购买呢？</p><p>首先，交强险是国家强制购买的，必须要买，建议再配上3种主险，车损险、第三者责任险跟车上人员责任险，这几种基本就包括了开车常见的风险，既保障了我们的车或人，也保障了因我们的责任造成的他人或车的损失。</p><p>不过，这些车险有一个问题需要注意，它们都设有免赔额，也就是说有一部分损失得由自己承担，保险公司不负责赔偿。比如，在投保时合同里写了每次事故免赔额是1000元，那么事故发生了，损失在1000元以下的，保险公司是不赔的；如果超过1000元，比方说损失了2500，保险公司只赔超过1000的部分，也就是1500元。</p><p>所以，如果用车比较多的话，不妨在附加险里配置一个“不计免赔险”，多交一点保费，但一旦发生问题，保险公司就会全数赔偿。</p><p>当然，车险还有很多附加险，可以根据自己的开车情况来选择，如果生活在一个雨水较多的城市，就应添加一个涉水险；如果不经常开车，可以选择按天收费的。这个完全可以根据自己的需求来配置，比较灵活。</p><h2 id="三、小结">三、小结</h2><h3 id="3-1、家财险">3.1、家财险</h3><p><img src="/img/image-20220502092246158.png" alt="image-20220502092246158"></p><h3 id="3-2、车险">3.2、车险</h3><p><img src="/img/image-20220502092313553.png" alt="image-20220502092313553"></p><h2 id="四、参考">四、参考</h2><p><a href="https://www.dedao.cn/course/detail?id=Ox1El850jp9VaZas6xJZg6MbrdvRBo">给忙碌者的个人保险课</a></p>]]></content>
    
    
    <categories>
      
      <category>理财投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>保险</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何配置重疾险和寿险</title>
    <link href="/2022/05/01/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E9%87%8D%E7%96%BE%E9%99%A9%E5%92%8C%E5%AF%BF%E9%99%A9/"/>
    <url>/2022/05/01/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E9%87%8D%E7%96%BE%E9%99%A9%E5%92%8C%E5%AF%BF%E9%99%A9/</url>
    
    <content type="html"><![CDATA[<p>todo</p><h2 id="一、重疾险">一、重疾险</h2><p>在配置重疾险时，首先要关注的是保额。</p><p>重疾险主要解决的是生病后失去收入来源，那在设置保额的时候，就要考虑生病期间的生活费用。</p><p>一般来说，在中国治愈重大疾病需要5年，5年后如果没有出现复发情况就叫临床治愈，所以，建议可以把保额设置成5年生活必需支出的费用总和，保证生活质量不下降。</p><p>另外，还可以关注下，保险公司做的升级形式的重疾险。</p><p>比如分组多次赔付，就是把原本重疾险保障的疾病范围进行分类，如果一个人分别得了不同组别的疾病，就可以多次赔偿。</p><blockquote><p>为什么会有这个升级呢？</p></blockquote><p>因为现在重大疾病都呈现出“三高一低”的发展趋势，就是高发病率、高医疗费、高治愈率和低龄化，也就是说现在人们一生可能不止得一场重大疾病，如果小强得了癌症，他买的重疾险就赔付了，那他再得其他病，保险公司就不会再赔了。针对这种情况，很多保险公司就开发了分组多次赔付的重疾险。</p><p>再比如有种升级方式是覆盖轻症、中症，就是过去还挺重大的疾病，因为医疗技术的发展，这些病变成了轻症、中症。但它们的发病率也挺高，费用也不小，所以，保险公司就开展了延伸服务，在保额之外还能进行赔付。</p><p>比如小强得了轻微脑中风后遗症，这属于轻症，根据合同约定，可以额外赔付30%，过了一段时间，小强的脑中风没治好，发展成了中度，保险公司会给他再额外赔偿50%，为什么这两次都说是额外呢？因为如果后来小强还是发展成了重度，保险公司还会再赔100%的保额。也就是说，三次总共赔付了180%，前两次都算额外赔付。</p><p>还有一种升级方式是转年金责任，比如有一些慢性病不构成重疾，但又需要长期费用的支出，那可以将重疾险转为年金行为，让保险公司按月或者按年支付费用，作为长期治疗费用。</p><h2 id="二、寿险">二、寿险</h2><p>配置寿险时，需要注意哪些呢？</p><p>第一点也还是保额，我们经常说，生命无价，那选择多大的保额合适呢？建议是，有多大责任，就买多大保额。也就是说，要把家里的贷款负债、基本生活成本、子女教育、赡养父母花销等支出都考虑进去，根据需要承担的责任来设置保额。</p><p>而且，因为生命无价，寿险的保额是可以叠加的。可以在两家保险公司分别购买寿险，一旦风险发生，两家公司都会赔偿。</p><p>寿险除了选择保额，还要选择保障时间。如果是普通家庭，建议选择定期寿险，一般保到60~70岁，这种保险保费比较便宜，是普通家庭都可以承受的支出，同时保额也相对较高。</p><h2 id="三、豁免条款">三、豁免条款</h2><p>配置重疾险和寿险时还有一些小技巧，比如有家庭的话，可以夫妻互相给对方买保险，然后在保单里加一个保费豁免条款。</p><blockquote><p>什么是保费豁免呢？</p></blockquote><p>就是如果投保人或被保险人发生一些特定情况，比如死亡、重大疾病等，投保人可以不用再续缴保费，但保险合同仍然有效。</p><p>比如，小强和他妻子互相给对方投保。假如有一天小强意外死亡，妻子给他买的那张保单就可以获得理赔了，而他给妻子买的那张保单，因为小强已经身故了，就没人交保费了，保单就会失效，但如果他当时增加了豁免条款，那这份保单就不需要再交保费了，但保单会继续有效。</p><p>这个技巧也可以用在给孩子买保险上，比如给孩子买份50万的重疾险，可以夫妻双方各投一半，分别买25万，然后加上保费豁免条款，如果任意一方发生风险时，一半的保费就不用再交，但保单依然有效。</p><h2 id="四、小结">四、小结</h2><h3 id="4-1、重疾险">4.1、重疾险</h3><p><img src="/img/image-20220501170708757.png" alt="image-20220501170708757"></p><h3 id="4-2、寿险">4.2、寿险</h3><p><img src="/img/image-20220501170735400.png" alt="image-20220501170735400"></p><h2 id="五、参考">五、参考</h2><p><a href="https://www.dedao.cn/course/detail?id=Ox1El850jp9VaZas6xJZg6MbrdvRBo">给忙碌者的个人保险课</a></p>]]></content>
    
    
    <categories>
      
      <category>理财投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>保险</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何配置意外险和医疗险</title>
    <link href="/2022/05/01/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E6%84%8F%E5%A4%96%E9%99%A9%E5%92%8C%E5%8C%BB%E7%96%97%E9%99%A9/"/>
    <url>/2022/05/01/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E6%84%8F%E5%A4%96%E9%99%A9%E5%92%8C%E5%8C%BB%E7%96%97%E9%99%A9/</url>
    
    <content type="html"><![CDATA[<h2 id="一、意外险">一、意外险</h2><p>在选择意外险时，要考虑两个方面，保障范围和是不是有附加意外医疗的责任。</p><p>关于保障范围，市面上对意外险有很多细分的险种，比如航空意外险、车驾意外险、电梯意外险等等。建议选择综合意外险，这类保险通常在海陆空各方面都会有保障，包含了意外伤害保障、意外伤害医疗保障、意外伤害生活津贴等等各个部分，综合意外险不仅保障范围比较全，保费也比较便宜。</p><p>需要注意的是，在考虑保障范围时，要专门留心一下是不是包含伤残责任。</p><p>因为意外发生后，往往伤残的概率要比致死率高，一旦造成伤残，不仅治疗费用更高，还会因为没法工作而失去收入来源，所以一定要选择包含伤残责任的意外险。而且，在合同条款里不同保险公司对伤残鉴定的标准也不完全一致，所以要仔细阅读条款。</p><p>第二个方面就是是否有附加伤害医疗责任。</p><p>比如王坚强因为意外摔倒导致小腿骨折，但骨折程度没有达到理赔标准，如果意外险里包含了意外伤害医疗责任就可以靠它来报销。这部分保额理论上是越高越好，但保额太高，就可能会出现“故意意外”，所以保险公司卖意外险的保额一般不会超过1000万。</p><h2 id="二、医疗险">二、医疗险</h2><p>在选择医疗险，要关注哪些核心要素呢？</p><p>首先是保额，报销型医疗险，保额不需要太高，我们最常听到的百万医疗险就是100万的保额，这对大部分人来说已经足够。</p><p>其次要看是否可以覆盖自费药，如果不能报销社保范围外用药，保额再高也没啥太大作用。</p><p>接下来就看医院范围是否广泛，比如有些医疗险会要求去二级及以上的公立医院住院才给报销，报销范围广的话，我们就可以放心去一些治疗实力比较强的医院就诊。</p><p>最后就看免赔额，保险公司为了降低自己的理赔额度，会在产品上会加一个免赔额，损失超过这个数才给赔，但它会在保费上给我们优惠。比如有两款类似的产品，一个不设免赔额保费可能要在四五千，一个设1万的免赔额保费可能才四五百，所以，如果经济状况不稳定，可以选择保费低、有免赔额的保险产品。但这里需要注意的是，风险要可控，尽量选择免赔额在能够承受的损失范围内，否则我们买保险就失去了意义。</p><h2 id="三、小结">三、小结</h2><h3 id="3-1、意外险">3.1、意外险</h3><p><img src="/img/image-20220501121011018.png" alt="image-20220501121011018"></p><h3 id="3-2、医疗险">3.2、医疗险</h3><p><img src="/img/image-20220501121704255.png" alt="image-20220501121704255"></p><h2 id="四、参考">四、参考</h2><p><a href="https://www.dedao.cn/course/detail?id=Ox1El850jp9VaZas6xJZg6MbrdvRBo">给忙碌者的个人保险课</a></p>]]></content>
    
    
    <categories>
      
      <category>理财投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>保险</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>买房：如何买到合适的房子</title>
    <link href="/2022/04/23/%E4%B9%B0%E6%88%BF%EF%BC%9A%E5%A6%82%E4%BD%95%E4%B9%B0%E5%88%B0%E5%90%88%E9%80%82%E7%9A%84%E6%88%BF%E5%AD%90/"/>
    <url>/2022/04/23/%E4%B9%B0%E6%88%BF%EF%BC%9A%E5%A6%82%E4%BD%95%E4%B9%B0%E5%88%B0%E5%90%88%E9%80%82%E7%9A%84%E6%88%BF%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p>对很多人来说，房子不只是住的地方，还意味着一种“安家”的仪式感、安全感。如果有了买房的想法，不要拖，只要把日常生活保障好了，家人健康保障好了，应该尽快把买房提上日程。</p><p>当然，买房是一件大事，不但要一口气投入很多的资金，后面还有贷款，房子的价值还可能会变动，它会直接影响我们未来几十年的财务安排。</p><p>那么，怎么才能避免踩坑、聪明买房？怎么才能在预算范围之内，挑到最适合自己的房子？下面，我们就来讨论一下这些问题。</p><h2 id="一、明确买房标准">一、明确买房标准</h2><p>如果想买房，第一步是去找中介看房吗？</p><p>不是，第一步是要想明白：我们买这个房是为了什么？是要自己住，还是拿来投资？</p><h3 id="1-1、房子的两种功能">1.1、房子的两种功能</h3><p>房子两种有功能，“自住”和“投资”。建议，两个功能里只选一个，至少是着重关注其中一个，因为这直接决定了我们的选房标准。</p><p>如果是买来自己住，那只需要考虑住得是不是舒服，能不能满足使用需求，房价涨不涨并不重要。而如果是为了投资，挑选的逻辑就完全不一样了，最重要的标准就是：它在未来能不能更值钱。</p><h3 id="1-2、用好房产工具">1.2、用好房产工具</h3><p>把房产这个工具用好了，我们的财务压力也能减轻。</p><p>比如，我们想买一套房，打算5-10年后，孩子大了再换一个大一点的。那么，这套房的投资目的就要放在前面，选一个尽量好出手的房源。</p><p>等到孩子上学了，要买第二套房，那这一次换房可能就要住上好多年，住得舒服、生活方便就是首要考虑的事情了。</p><h3 id="1-3、小结">1.3、小结</h3><p>建议的选房标准是，自己住，舒服最重要，要投资，增值最重要。夸张一点说，全国甚至全世界的房子都是我们的投资选择。</p><blockquote><p>可能有人会问，怎么能知道什么房子会涨价呢？</p></blockquote><p>很多人以为，买房一定是个稳赚不赔的生意，所以在投资房产的时候，勒紧裤腰带也要买，甚至闭眼买。这就太不理智了。一套房长期涨不涨，最重要的是看它所在的城市，甚至所在的地段有没有人口净流入。</p><p>一个城市如果能吸引很多人口，特别是年轻人流入，人多了，资源就会相对稀缺，房产作为资源的一种，当然是物以稀为贵。像前几年的深圳，这几年的成都，都属于这种情况。</p><h2 id="二、向外看政策，向内盘现金">二、向外看政策，向内盘现金</h2><p>有了明确的买房标准，下一步就是挑选合适的房子了。</p><h3 id="2-1、看政策">2.1、看政策</h3><p>很多人在挑房时，会陷入各种细节的讨论：地段怎么样，环境好不好，两室一厅还是三室一厅。其实这些都是小问题，首先要了解的是政策，不然看好了房才发现买不了，费时又费力。</p><p>看政策，先要看在想买房的城市有没有购房资格。如果是北京、上海这样的大城市，对户籍、社保都有哪些要求？结婚和单身的人，购房资格上有什么不一样？如果现在没资格，是不是过几年可以有资格？购房资格这事，直接决定了我们有没有资格动手。</p><p>绝大多数人都是贷款买房的，如果购房资格有了，再去看一看这个城市首付大概占多大比例。拿北京来说，第二套房的首付比例要比第一套高，公寓的首付比例要比普通住宅高，等等。</p><h3 id="2-2、盘现金">2.2、盘现金</h3><p>政策搞清楚了，我们再来想钱的事情。先盘一盘手里的现金，这直接决定了所能买的房子的价格上限。比如，小明在一个二线城市工作，想要买一套房子自己住。他研究了行情和政策，明确了这么几件事：</p><ul><li><p>首先，购房资格已经有了。</p></li><li><p>其次，他看中的区域附近，首付三成就可以上车。</p></li><li><p>接下来，小明盘点了一下能调动的现金，发现差不多有70万。</p></li></ul><p>这个时候，他是不是就能用70万当首付，除以30%，去买230多万的房子呢？</p><p>还得再谨慎一点，因为他买的时候不仅要付首付，还要交税、物业费等各种费用，算下来他能掏的首付就只有60万了。所以小李能买的房子上限，其实是200万。超过这个上限，就不建议小李去看了。</p><h3 id="2-3、小结">2.3、小结</h3><p>想明白为什么要买，了解了政策，盘好了预算，再去选具体的房子。这样选出来的房子，不一定十全十美，但至少不会踩坑。</p><blockquote><p>可能有人要问，在大城市工作想买房，但既没有购房资格，也凑不齐首付，是不是努力攒几年钱再买呢？</p></blockquote><p>不建议这么去做，因为在一线城市，房屋供需旺盛，收入不一定能赶上房价的增长速度。有这样一个思路，可供参考：如果暂时负担不起你目标城市的房子，可以考虑选择一个房价可以接受，同时房价增长速度又超过所在城市的地方。等到条件成熟，再在所在城市购入，完成置换。</p><h2 id="三、做好还贷计划">三、做好还贷计划</h2><p>房子选好了，准备正式上车，马上要面对的就是贷款的问题。用多少公积金、多少商业贷款，每个人情况都不一样，但要特别提醒的是，一定要认真做好还贷计划。</p><p>在这里，有几个建议可供参考。</p><h3 id="3-1、还款周期">3.1、还款周期</h3><p>还贷计划要解决的第一个问题就是还多久，换句话说就是每个月还多少。</p><p>有人一想到每个月要还大几千，其中还有一大笔钱是利息，心里就非常抵触，于是一开始就想办法缩短还款的时间，本来要还30年，现在20年就想还完。但说实话，这不是很有必要。</p><p>我们要知道的是，在所有提供贷款的机构中，银行利息是最低的，房贷是一种普通人可以利用的良性杠杆。建议是，可以在一开始，适当让交费期长一些。为什么呢？</p><ul><li>还款的周期越长，每个月交费压力就越小。考虑到通胀因素，越往后还贷压力就越小。</li><li>以后收入增加了，还可以把还款周期缩短，比如把30年改成20年，但要是一开始定短了，要把20年变成30年，银行就不同意。</li></ul><h3 id="3-2、还款金额">3.2、还款金额</h3><p>第二个问题是每个月还多少比较好呢？</p><p>我们知道，健康的负债状态，就是稳定正向现金流，减掉刚性支出和必要的储蓄，剩下的钱还可以覆盖每个月要还的本息。</p><p>具体到房贷上，一般占每月收入的40%到60%是比较合理的。每个月发了工资，大约一半还房贷，还有一半除了刚性支出和储蓄，没准还能看看电影、偶尔约个饭、逛逛街，生活质量还是不错的。</p><h3 id="3-3、还款方式">3.3、还款方式</h3><p>第三个问题是，选择什么样的贷款方式？</p><p>最常见的选择，就是“等额本金”和“等额本息”。这两种方式最直接的差别就是，等额本金前面还得多、后面还得少，是先难后易，而等额本息每个月还的数额都一样。</p><p>选哪种呢？一个依据是，未来的收入是会乐观地增加，还是可能减少。</p><p>如果是处在事业上升期的家庭，建议等额本息，平滑地去还贷。如果一开始挣得少、还得多，可能直接影响生活质量。如果选择每月还一样的数额，随着收入不断增加，压力其实是递减的。</p><p>当然，如果预计未来收入可能减少，比如贷款还没还完就面临退休的家庭，那么等额本金先多后少的方式就是更合适的</p><h3 id="3-4、提前还贷">3.4、提前还贷</h3><p>最后一个问题是，要不要提前还贷？</p><p>比如买房第5年后，收入提高了，打算把30年的周期缩短到20年，可不可以呢？当然可以，但不一定划算。</p><p>现在大部分贷款，不管等额本金还是等额本息，都是前期主要还利息，后期主要还本金。着急去还本金，并不能减少多少利息，还损失了这笔钱的流动性和投资收益。</p><p>网上很容易查到一种工具“提前还贷计算器”，可以用它来计算一下，看看这笔钱到底是提前还了划算，还是留在手里做理财划算，然后再做决定。</p><h2 id="四、总结">四、总结</h2><ul><li><p>买房前，要先考虑好是自住还是投资，自住要舒服，投资要看投资价值。</p></li><li><p>挑房时，要做好两方面工作：对外看政策，对内盘现金。</p></li><li><p>购买时，要认真对待还贷计划，考虑好还款周期、每月还多少、选择哪种还款方式、要不要提前还贷，总之要保证有一个健康的负债水平。</p></li></ul><h2 id="五、参考">五、参考</h2><p><a href="https://www.dedao.cn/course/detail?id=z1DWOMARavZVxoMs0LKP2mlx7bjydL">李璞·家庭财富管理</a></p>]]></content>
    
    
    <categories>
      
      <category>理财投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>家庭理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>健康：如何应对疾病风险</title>
    <link href="/2022/04/23/%E5%81%A5%E5%BA%B7%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E7%96%BE%E7%97%85%E9%A3%8E%E9%99%A9/"/>
    <url>/2022/04/23/%E5%81%A5%E5%BA%B7%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E7%96%BE%E7%97%85%E9%A3%8E%E9%99%A9/</url>
    
    <content type="html"><![CDATA[<p>我们常说，身体是革命的本钱。健康是1，其余的都是1后面的0，没有健康的身体，我们的人生就是一个0。佛语云：人生无常。即使平时我们在怎么注重健康，也无法保证不会发生疾病风险。这里，我们要知道的是，疾病本身不确定，但可用到的工具很确定，那就是保险。</p><blockquote><p>保险本质上是一种杠杠，能帮助我们未雨绸缪，用小钱撬动大钱，一旦疾病出现，我们就能有一个专款专用的账户来应对这个风险，而不用急着去四处筹钱。</p></blockquote><h2 id="一、我们有哪些健康风险">一、我们有哪些健康风险</h2><p>目前，我们可以买的保险产品有很多，在进行实际配置前，先要对疾病有一定的了解，这样才能做到有的放矢。否则，就很有可能出现，花了大价钱，买了一堆保险，以为自己是有保障，然而在疾病发生时，才发现自己是在“裸泳”。</p><p>总的来说，生活中的疾病大概可以分成三类：</p><ul><li>第一类是日常小病，跑趟医院开点药就能好；</li><li>第二类是中症，可能做了个手术，几个月才能痊愈；</li><li>第三类是重症，也就是癌症、心肌梗塞这些“大病”，这些往往会对我们的生活造成很大的影响。</li></ul><h2 id="二、如何应对健康风险">二、如何应对健康风险</h2><p>对不同程度的疾病有一定的了解后，接下来，我们来看看具体如何应对它们。</p><p>生活中，各种头疼脑热是最常见的小病。对于日常小病，医保基本能覆盖。医保是国家的福利政策，重要性不言而喻，这个一定要上。</p><p>除了医保之外，还有一种各地政府联合保险公司的普惠型医疗险，比如北京的京惠保、天津的津惠保、上海的沪惠保等等。这类保险的保障额度比医保更高，还覆盖了很多不在医保范围内的药物。因为有福利性质，价格很便宜，一年保费一两百块钱，性价比很高，可以用来作为医保的有效补充，是应对部分日常小病和部分中症的好工具。</p><p>随着年龄增长，出现中症甚至重疾的几率会变高，这类风险往往是，医保报完还得自费几万几十万，这对于普通家庭来说，是一个不小的压力。另外，患病不可避免地会影响工作，这样收入也会受到影响，生活质量会出现下降。想要防范这部分风险，就要引入商业医疗险和重疾险了。</p><p>总结一下，在配置健康保险时，可以按照小病-中症-重疾的顺序。医保和普惠型保险应对小病没问题，商业医疗险主要应对中症和重症的医疗费用，重疾险是规避因为重大疾病而造成的收入损失风险。这样，我们配置健康保险的顺序就很明白了：医保&gt;普惠型保险&gt;医疗险&gt;重疾险。</p><h2 id="三、普通家庭怎么安排">三、普通家庭怎么安排</h2><blockquote><p>社保和普惠性保险，价格低，都配上没问题。但医疗险和重疾险，保费少的每年几百块，多的成千上万，此时该怎么安排呢？</p></blockquote><p>要是资金充足的话，当然是给家里每个人都买上，服务水平越高、保额越高越好。但对于普通家庭来说，预算往往是有限的，我们可以参考以下几个建议。</p><h3 id="3-1、控预算">3.1、控预算</h3><p>首先，总预算要控制好，不要为了买保险影响正常生活。</p><p>预算建议是，用在保障型保险（包括意外险、医疗险、重疾险、寿险）的总保费不要超过家庭年收入的15%。比如家庭每年收入大概是30万，那全家人加到一起，买保障型保险的钱不要超过4.5万。</p><h3 id="3-2、设优先">3.2、设优先</h3><p>总预算定好之后，第二个问题就是，谁先买，谁后买？</p><p>建议是，医保、普惠型保险这些基础保障，要保证家里所有人都有。剩下的资金，可以做一个成员配置优先级：先大人后小孩，先主力后其他。</p><p>先说先大人后小孩。很多父母，因为非常爱自己的孩子，从孩子出生开始就给他买各种保险产品，自己却在“裸奔”，这种行为非常不可取。父母病了，钱花没了，谁来照顾孩子呢？所以大人一定是优先保障。记住，大人是孩子最大的保险。</p><p>大人之间的策略是，先主力后其他，也就是先给家庭中经济贡献最大的那个主力成员投保。因为一旦TA出现意外，对整个家庭的经济影响是非常大的。按照前面说的产品优先级，把TA的保险补充完整之后，如果还有资金，再给其他成员依次配置。</p><h3 id="3-3、选险种">3.3、选险种</h3><p>第三个问题是，市面上的商业健康险产品那么多，具体该怎么选择呢？</p><p>商业健康险产品归纳起来就两类：医疗险和重疾险。建议优先配置医疗险，然后配置重疾险。至于为什么要这样配置，下面我们来分析一下。</p><p>医疗险，保的是医疗费。可以把它理解成医保以外的报销。我们去医院看病，需要先提前垫付自费的部分，然后拿着发票去找保险公司报销。花多少，保险公司就赔付多少。只要保额能覆盖医疗费，压力就不会太大。</p><p>医疗险有个特点，一般是一年一买，如果我们前一年赔付得多，保险公司就会判断我们下一年患病几率可能很大，会选择增加保费或者拒保。所以医疗险买着买着，到了五六十岁，可能就买不上了。</p><p>进入老年之后，万一罹患重疾，能起作用的就是年轻时候买的重疾险。</p><p>跟医疗险相比，重疾险不用一年一年地续保，根据不同的产品，可以保一辈子，也可以只保到六七十岁。一旦真的发生重大疾病，保险公司会按照合同规定的保额，一次性把钱赔付给我们。</p><p>比如买的保险保额50万，但治病只要30万，那保险公司也会一次性赔50万，剩下的钱怎么花都可以。所以，重疾险除了能用来治病，还能减小疾病对家庭收入的影响。</p><p>了解了这两个险种的特点，我们就知道为什么，医疗险在前，重疾险在后了。</p><p>医疗险是弥补医保不能覆盖的医疗费用，保障的是当下。而重疾险是保障不会因为重疾而拖垮整个家庭财务，保障的是将来。从紧迫性上看，当然是先管好当下，再去考虑将来。</p><h3 id="3-4、配保额">3.4、配保额</h3><p>第四个问题，选好了保险产品，保额多与少该如何配置呢？</p><p>先看医疗险，普通人可以选择百万医疗，保费大概是几百块一年，保额每年都有上百万，对大部分人来说就已经足够了。</p><p>买重疾险的时候，因为投入比较多，所以很多产品会附带其他的服务。建议是，优先考虑保额充足，再去考虑别的服务。</p><p>比如我们有5000元的预算买重疾险，这笔钱可以买一款消费型+终身50万保额的产品，或者一款储蓄型+终身30万保额的产品。什么意思呢？消费型是说，如果风险没有发生，交的保费不退。储蓄型则是，如果风险没有发生，交的保费最终会按一定利率连本带利返还。</p><p>这时候该怎么选？是不是对能退保费的有点心动？想一想，咱们购买重疾险的目的是什么？就是万一疾病发生的时候，能有一大笔钱来救急，所以保额才是最重要的。所以优先建议，选那个保额50万的。</p><p>至于重疾险具体选择多少保额合适，我们可以参考以下两条思路：</p><ul><li><p>一是把保额设置为5年家庭生活必须支出的总和。这是因为在中国治愈重大疾病的周期一般是5年，这笔保额可以保证，在患病者不工作的情况下生活质量不下降。</p></li><li><p>二是根据自己的责任设置保额。也就是把五年内，家里的负债、生活成本、子女教育、赡养父母等等需要投入的钱加到一起，让重疾险保额帮我们一次性解决问题。</p></li></ul><p>保额越高，服务水平越高，保障的人越多，保费也就越高。可以根据自己的需求量力而行。如果资金有限，实现不了想要的目标，那建议退而求其次，先设置一个次级的保障，等以后收入增加了再加保。</p><h2 id="四、总结">四、总结</h2><ul><li>疾病本身不确定，但可用到的工具很确定，那就是保险。</li><li>防范疾病风险的思路是，日常小病 - 中症 - 重症，依次匹配社保 - 普惠型保险 - 医疗险、重疾险。</li><li>在确定预算之后，可以根据家庭成员优先级和产品优先级来进行配置，至于保额则可以根据自身需求量力而行。</li></ul><h2 id="五、参考">五、参考</h2><p><a href="https://www.dedao.cn/course/detail?id=z1DWOMARavZVxoMs0LKP2mlx7bjydL">李璞·家庭财富管理</a></p>]]></content>
    
    
    <categories>
      
      <category>理财投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>家庭理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资产配置：怎么把鸡蛋放到对的篮子里</title>
    <link href="/2022/04/17/%E8%B5%84%E4%BA%A7%E9%85%8D%E7%BD%AE%EF%BC%9A%E6%80%8E%E4%B9%88%E6%8A%8A%E9%B8%A1%E8%9B%8B%E6%94%BE%E5%88%B0%E5%AF%B9%E7%9A%84%E7%AF%AE%E5%AD%90%E9%87%8C/"/>
    <url>/2022/04/17/%E8%B5%84%E4%BA%A7%E9%85%8D%E7%BD%AE%EF%BC%9A%E6%80%8E%E4%B9%88%E6%8A%8A%E9%B8%A1%E8%9B%8B%E6%94%BE%E5%88%B0%E5%AF%B9%E7%9A%84%E7%AF%AE%E5%AD%90%E9%87%8C/</url>
    
    <content type="html"><![CDATA[<p>我们都知道，不要把鸡蛋放在同一篮子里，但只有这句话是不够的，我们还要将鸡蛋放进对的篮子里。要达到这个目标，可以分三步走。首先，知道自己有多个鸡蛋，然后，知道篮子和篮子不一样的，最后，把鸡蛋放进去。</p><h2 id="一、确定年度结余">一、确定年度结余</h2><p>在放鸡蛋之前，我们首先要搞清楚自己有多少个鸡蛋，也就是确定我们的家庭年度结余。</p><p>所谓年度结余，就是一年总收入减掉总开销，剩下来的钱才是可以去投资的。想要知道自己每年能剩下多少钱，可以用一个古老而智慧的方法，记账。</p><p>记账，不仅能知道花了多少钱，还能知道钱花到哪里去了。这样在&quot;节流&quot;时，就能知道可以从哪里省钱。此外，我们提到过，要有一个备用金账户，里面放3到6个月的支出。在不同的人生阶段，每个月的支出也会变化，通过记账就能一直知道自己花了多少钱，就可以随时调整这个备用金账户了。</p><p>在记账时，我们可以把每月支出分成三类：固定消费、日常消费和个性化消费：</p><ul><li>固定消费，就是必须花出去，数额基本固定的钱。比如，房贷、房租、水电煤气、物业费、车位费等。</li><li>日常消费，就是一定要花，但花多少不太固定的钱。比如，伙食费、交通费、日用品消费，服装费等。</li><li>个性化消费，就是并非一定要花，而且数额也不固定的钱。通常是一些娱乐、享受支出，比如看电影、朋友聚会买单、旅游度假等。</li></ul><p>对于这些消费，我们可以一笔一笔地记，用记账APP打标签归类。不过还有更方便的方法，用三张银行卡分别对应三类消费，也可以用支付宝、微信、信用卡来分别支付三类消费。这样，三类消费就一目了然了，只要在不同账户里调取账单，就能知道哪类消费花得多花的少了。</p><h2 id="二、三大类资产配置">二、三大类资产配置</h2><p>知道了自己有多少个鸡蛋，接下来就是选篮子了。</p><p>一说到篮子，我们马上会想到存款、保险、房产、车位、基金、股票······其实这些都属于具体工具，是下一步才要考虑的，我们首先要考虑的是，篮子的分类，即资产的划分：防守型资产、稳定型资产、进攻型资产。</p><h3 id="2-1、防守型资产">2.1、防守型资产</h3><p>防守型资产，主要用来应对日常开支和风险事件。这部分钱就像房子的地基一样，一定不能出问题，而且要随取随用。也就是说这类资产要具备安全性和流动性。</p><blockquote><p>那满足安全性、流动性的工具有哪些呢？</p></blockquote><p>包括现金、活期存款，还有一类，货币基金，它风险要远远小于其他基金，灵活性也很好，所以也属于保守型。另外，保险和信用卡也可以归属到防守型资产。因为它们安全性都很高，而且在保障突发事件的时候效果会很好。比如健康保险，如果家里有老人孩子经常跑医院的，它能给你减少医疗费用的负担。寿险，保障的是人的生命，特别适合给家里的“经济顶梁柱”买上。信用卡，平时多备几张不消费的信用卡，哪一天急用现金了，它能帮我们周转。</p><h3 id="2-2、稳定型资产">2.2、稳定型资产</h3><p>稳定型资产，主要用来追求一定的收益，并且还要具备一定的安全性，属于“先保值，再增值”的类型。比如，非自住房产、车位、国债、定期存款、理财型保险都属于这一类。</p><p>稳定型资产一般有固定期限，不像防守型资产那么灵活，但它也有一个好处，就是可以根据未来的事儿提前规划。比如，你打算三年后买辆车，就可以拿原准备买车的钱，买一个三年期的国债，或者存三年的定期存款，到时候拿出来，车也买了，还有收益。</p><h3 id="2-3、进攻型资产">2.3、进攻型资产</h3><p>进攻型资产，主要用来追求高收益。我们最熟悉的就是股票、基金了，收益高，风险也大，在上车之前，一定要谨慎评估家里的风险承受能力。还有外汇期货、艺术品、大宗商品期货什么的，也属于进攻型资产，但普通家庭就不建议选择这些了。</p><h3 id="2-4、小结">2.4、小结</h3><p>具体每一类资产都对应哪些工具，通过下表我们可以随时查阅：</p><p><img src="/img/image-20220417103231125.png" alt="image-20220417103231125"></p><p>总的来说，手里有钱可以用，又有一些钱在稳定增值，还有余钱去追求更多的财富，这才是科学的“不把鸡蛋放到同一个篮子里”。</p><h2 id="三、具体资产配置">三、具体资产配置</h2><blockquote><p>三个篮子选好了，具体往里面放多少鸡蛋呢？</p></blockquote><p>建议的思路是，年度结余越少，越应该注重稳定，在结余多一些的时候，可以适当增加进攻型资产的比例。具体比例，可以参考下表：</p><p><img src="/img/image-20220417103957093.png" alt="image-20220417103957093"></p><p>比如，对于年度结余20万人民币以下的家庭，建议三成的防守型资产和七成的稳定型资产，完全没有必要去配置进攻型资产。为什么？因为在专业从业者看来，年度结余20万以下的家庭，抗风险的能力是比较弱的。万一进攻型资产亏损了，家人又突发疾病，就会难以应对。</p><p>如果家庭年度结余多一些，在20万到50万之间，抗风险能力明显变强了，就可以适度增加一些进攻型资产。建议是，这一类家庭防守型、稳定型、进攻型的比例可以设定为2:7:1。</p><p>要是年度结余比这更多，进攻型资产的比例可以继续增加。</p><p>需要注意的是，使是年度结余达到了1000万的家庭，三类资产里最高的还是稳定型资产，要占到一半。</p><blockquote><p>Q：这个策略是否适用于单身人士？</p></blockquote><p>关键在于，自己能承受多大程度的风险。上面的策略，是按家庭的风险承受能力设计的，追求的是稳健，单身人士，当然可以用。</p><h2 id="四、总结">四、总结</h2><ul><li>新家庭财富管理的当务之急，是做好资产配置，把鸡蛋放到对的篮子里。</li><li>放对鸡蛋的正确步骤应该是：首先，通过记账了解家庭的年度结余；然后，盘点可以选择的防守型资产、稳定型资产和进攻型资产类型；最后，设置好不同的资产比例。</li><li>单身人士是否适合这个方案，关键在于对风险的承受程度。</li></ul><h2 id="五、参考">五、参考</h2><p><a href="https://www.dedao.cn/course/detail?id=z1DWOMARavZVxoMs0LKP2mlx7bjydL">李璞·家庭财富管理</a></p>]]></content>
    
    
    <categories>
      
      <category>理财投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>家庭理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理财工具：买对理财的关键是什么</title>
    <link href="/2022/04/17/%E7%90%86%E8%B4%A2%E5%B7%A5%E5%85%B7%EF%BC%9A%E4%B9%B0%E5%AF%B9%E7%90%86%E8%B4%A2%E7%9A%84%E5%85%B3%E9%94%AE%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2022/04/17/%E7%90%86%E8%B4%A2%E5%B7%A5%E5%85%B7%EF%BC%9A%E4%B9%B0%E5%AF%B9%E7%90%86%E8%B4%A2%E7%9A%84%E5%85%B3%E9%94%AE%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>一说到理财，我们往往想的是，买哪款理财产品收益最好。追求收益是人之常情，但在家庭财富管理上，用这个心态去买理财，多半要出问题。买对理财的关键，不在于买哪款产品、有多高收益，而在于合理分配自己的收入，为未来可能发生的不同事件，准备好一个又一个的专款专用账户。</p><h2 id="一、为事件买理财">一、为事件买理财</h2><p>在家里遇到各种事的时候，如果有一笔及时的钱去覆盖，那我们买理财的水平就超过了大多数人。如何达到这个目的呢？</p><p>首先需要明确的是：买什么产品不重要，为什么事买才重要。</p><blockquote><p>思考：每月工资到账以后，你是如何安排这笔钱的？</p></blockquote><p>很多人的答案，自然是先扣掉一笔钱用于日常消费，剩余的钱用来投资理财。比如存在银行，或者跟着身边懂理财的朋友买一两款理财产品，赚点收益。可仔细想想，有没有感觉这笔钱花得糊里糊涂的？表面看上去，是在财务管理，但现实可能是，等真的遇到事了，才会去查各个账户里都有多少钱，再决定要不要忍痛割肉，把钱取出来。</p><p>问题出在哪呢？顺序错了。正确的理财思路，不是先拿花钱买一堆产品，而是一开始就根据未来要发生的事件，选择对应的工具。</p><p>我们知道，所有的理财工具，归根结底都由三个特点来界定：安全性、收益性、流动性。这三个特点组成了一个“不可能三角”，三者最多只能得其二。比如基金、股票，收益很高，流动性也不错，但是风险较大。银行活期存款，流动性好，很安全，但收益低。理财型保险，长期收益不错，也安全，但流动性就差了。不管是什么理财产品，都可以在这个坐标里找到自己的位置。</p><p><img src="/img/image-20220417161548051.png" alt="image-20220417161548051"></p><p>在为事件买理财产品时，有一个三步法，可供我们参考：</p><ul><li><p>首先，确定事情发生的时间点。</p></li><li><p>然后，确定事件能承受的风险。</p></li><li><p>最后，确定自己能够投入的本金。</p></li></ul><p>走完这三步，该选什么理财工具，就比较清楚了。</p><h3 id="1-1、确定事件时间点">1.1、确定事件时间点</h3><p>先来看第一步，确定事件的时间点。就是看这个事大概会在未来什么时候发生，投在这件事上的钱有多长时间不用。这个时间点，对应的就是工具的流动性。我们来看一个例子：</p><ul><li>明年年假，你想去海南旅游一趟，时间只有一年，那么挑选的工具流动性就要好，比如活期存款、货币型基金、1年以内的理财，以及灵活的股票、基金等。</li><li>5年后，你想买房，那就可以选择中短期的理财产品，比如5年期的存款、国债。</li><li>20年后，孩子到了上大学的年龄，你想送孩子出国留学。30年后，你到了退休的年龄，养老要排上日程。二三十年后才发生的事情，就对流动性要求没那么高，你的选择有房产、长期国债、保险等等。</li></ul><p>这一步走完，可以选择的工具范围就变小了。</p><h3 id="1-2、确实事件风险系数">1.2、确实事件风险系数</h3><p>再进入第二步，确定事件的风险系数，这对应着工具的安全性。</p><p>不同人对风险的容忍程度不一样，我们可能见过一些判断风险偏好的测试题。不过，家庭财富管理就不能完全按个人偏好是激进还是保守来了，而是要按照事件本身来规划。</p><p>怎么看一个事件能不能承受风险呢？有三条标准。</p><ul><li>刚性事件比柔性事件对风险的容忍度更低。这个很好理解，比如王光明的儿子王小明三年后要上学了，孩子的教育经费不能接受风险。同样是三年后，一家人打算出门旅游，这笔钱能承受的风险就比教育经费要高得多。</li><li>近期的事件比还有很长时间发生的事件对风险的容忍度要低。比如老王五年后就要养老，王光明是三十年后才要养老，王光明的养老理财能承受的风险就比老王高。</li><li>每个人对事件重要性的衡量标准也不同。就拿五年后换辆好车来说，有人觉得不重要，亏了就推迟换车计划，但对于爱车一族来说，换辆好车就是最必要的事情，绝对要买，能承受的风险就更小。</li></ul><p>对照这三个标准，可以选择的工具范围就进一步缩小了。</p><p>###　1.3、确定可以投入的本金</p><p>接下来就是第三步，看我们为了这件事，可以投入多少本金。</p><p>这对应的是理财工具的门槛，比如多少钱起投，能选择的工具，要和可投资余额相匹配。</p><p>那怎么确定自己的可投资余额呢？很简单，收入扣除各项消费和负债，这部分就属于灵活资金，可以放进理财工具里。如果这样算下来没有资金了，那咱还是先好好上班赚钱，等可投资余额多了再投资吧。</p><h2 id="二、案例练习">二、案例练习</h2><p>走完上面的三步，基本就能确定为这个事件要选择什么样的工具了。下面，我们来通过一个具体的例子练习一下。</p><p>王光明计划3年后和女朋友结婚，结婚钱已经有了，小两口自己准备度蜜月的钱。他们商量，每月拿5000元来为这件事投资，如果投资成功，蜜月就出国旅游，投资失败，就不去旅游了。</p><p>咱们按照三步法来走。</p><ul><li>第一步，事件发生在什么时候？3年后，说明可以选择的工具是中短期的产品，流动性不必那么高。</li><li>第二步，蜜月旅行能承受多大风险？小两口觉得可以承受风险，那安全性就没那么重要，收益性更重要。</li><li>第三步，可投资余额是每月5000块。</li></ul><p>综合下来，适合蜜月旅游的理财工具，应该是3年之后可赎回，收益要高。那么，收益低的银行存款、国债、货币基金就不合适了，流动性差的保险、3年期以上的理财产品也不适合。需要大笔资金投入的工具也不行，比如房产。</p><p>盘算之后，小两口能选的工具就只有：股票、基金、3年期以下的高收益理财产品。它们收益高，到了时间也能保证赎回，虽然风险大，但事件本身是能承担风险的。</p><h2 id="三、笔坑指南">三、笔坑指南</h2><p>搞懂了这个三步规划法就会发现，我们身边常见的财务管理困境，几乎都是这三步有一步、甚至有几步没走对。常见的坑有这几种，请一定注意避免：</p><ul><li><p>第一种，周期错配，就是不使用这笔钱的周期和你选择的工具不一致。比如我需要一笔钱来应对日常紧急事件，但一发工资就买了一年期理财，遇到事取不出来。反过来也成立，如果你的养老明明30年后才会发生，你却把钱放在了银行活期存款，这就浪费了这笔钱的增值空间。</p></li><li><p>第二种，风险错配，就是这件事情能承受的风险和你选择的工具风险不匹配。像王光明度蜜月这个案例，原本可以承受股票的风险，要是把钱存了银行，就不合理了。这只是损失了收益，要是拿不能承担风险的事件去匹配高风险工具，后果会更严重。比如小张胆子特别大，愿意追求高收益。他想为自己和妻子的健康事件做好规划，于是拿所有的本金去投资了一款理财产品，据说几个月收益就有30%多，结果产品暴雷，本金亏进去了。这时候，如果他或者妻子健康出了状况，根本拿不出钱来治疗。</p></li><li><p>第三个坑，是本金错配。比如明明没有足够的资金，也要借钱或者拿信用卡套现去投资，或者去买自己没有资格买的产品。</p></li></ul><p>如果按照前面说的“三步法”去规划理财，这三个问题基本不会发生。当然，我们可以用这个方法回过头检查一下，自己现在的配置是否合理。</p><h2 id="四、总结">四、总结</h2><ul><li>在家庭理财中，配置理财工具时，第一位要考虑的不是选择什么产品，而是为了什么事件买。</li><li>理财工具的“三步规划法”是，考虑事件发生的时间点、事件的风险系数、可投资金额。</li><li>在规划完成后，要按上面的三步进行对照检查，看看有没有错配问题。</li></ul><h2 id="五、参考">五、参考</h2><p><a href="https://www.dedao.cn/course/detail?id=z1DWOMARavZVxoMs0LKP2mlx7bjydL">李璞·家庭财富管理</a></p>]]></content>
    
    
    <categories>
      
      <category>理财投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>家庭理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>负债工具：如何用好财富杠杆</title>
    <link href="/2022/04/17/%E8%B4%9F%E5%80%BA%E5%B7%A5%E5%85%B7%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E5%A5%BD%E8%B4%A2%E5%AF%8C%E6%9D%A0%E6%9D%86/"/>
    <url>/2022/04/17/%E8%B4%9F%E5%80%BA%E5%B7%A5%E5%85%B7%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E5%A5%BD%E8%B4%A2%E5%AF%8C%E6%9D%A0%E6%9D%86/</url>
    
    <content type="html"><![CDATA[<p>阿基米德说，“给我一个支点，我就能撬起整个地球”。从这句话我们可以看出，用好杠杆就能发挥出巨大的力量。负债，其实就是一种“财务杠杆”，它能帮我们把一笔未来才会出现的钱撬到现在，马上就能用，提供的是流动性。如果能用好这个工具，它不但不会成为我们的负担，还能帮助我们解决很多问题。</p><h2 id="一、负债工具有哪些">一、负债工具有哪些</h2><p>下表就是我们日常可用的负债工具：</p><p><img src="/img/image-20220417142054530.png" alt="image-20220417142054530"></p><p>咱们平时经常接触的房贷、车贷、花呗、借呗、信用卡，还有企业主用到的经营贷款，都属于负债工具，但它们的利率、使用周期和还款方式差异很大。</p><p>像信用卡、借呗这样的信用贷款，还有花呗、京东白条这样的消费贷款，都属于短期工具，利率相对比较高。而房贷、车贷，还有经营贷款，周期长，利率就比较低，但有些需要有抵押物，所以它们各自的应用场景很不一样。</p><p>想要用好这些负债工具，有两个核心问题一定要考虑：为什么事负债，以及负多少债。</p><h2 id="二、值得负债的事">二、值得负债的事</h2><p>我们先来看第一个问题：</p><blockquote><p>为什么事负债？</p></blockquote><p>聪明负债的关键是，把借来的钱花在刀刃上。适当的在刚性支出上负债就是很合适的。刚性支出就是一定要花的钱，比如日常开支、看病、买房、子女教育以及各种突发事件。</p><p>很多人觉得，只有拿不出钱的时候才会用到负债工具，其实在日常开支上也可以用。注意，这个日常开支说的是最基本的衣食住行，不包括奢侈享受。日常开支是相对稳定的，可以用信用卡或者花呗来付，再把原来那笔现金买一笔短期的理财，到时候再取出来还。这样，每个月都可以多一笔收益。</p><p>负债工具还有更大的用处，救急。家里突然有人生病，医保报完、保险赔付完了还需要一笔，或者是别的突发急用，现金不够怎么办呢？可以申请几张信用卡备着，平常就别用来消费了，一旦有事发生，不用急着把理财里的钱拿出来，也能度过难关。</p><p>至于买房、孩子上大学这些大事，负债工具有多重要就不用多说了。买房我们会用上房贷，孩子如果出国读书，需要一大笔学费，助学贷款都可以发挥作用。在这种大事面前，负债工具能用就一定要用。</p><blockquote><p>说完值得负债的事情，那哪些事情不值得负债呢？</p></blockquote><p>就是那些可花可不花的钱，尤其是享受型的消费。比如，新款iPhone定价8000多，很多年轻人一时拿不出现金，就想借个消费贷，现在很多平台都推出了“分期免息”，平摊下来每个月只要几百块，又没有利息，这么便宜，所以赶紧买。但我们要知道的是，买的没有卖的精，我们来算两笔账：</p><ul><li>很多平台说的“免息”并不是真的没有利息，而是换了种方式，叫“分期服务费”。以京东白条为例，分期服务费率在0.5%-1.2%之间，每期的服务费=消费本金*分期服务费率。假如我借了8000块买手机，分了12期，服务费率1%，每个月就要交80块服务费，一年下来，960元就不知不觉花出去了。</li><li>第二笔账是，即使免了服务费，我们也损失这笔钱的机会成本。很多人买新款手机，并不是旧手机不能用了，而是为了追赶潮流，买到以后新鲜感也持续不了多久。但假如省下这笔钱去理财，这一年可能还能赚几百块钱。</li></ul><p>除了享受型消费不值得负债外，借钱理财的方法就更加不可取。理由很简单，我们很难靠这个赚钱。如果一个人拿信用卡套现去炒股，信用卡的套现利率是日息万分之五，假设一年期的套现利率是18%，他炒股的收益一定要达到18%以上才能赚钱。如果达不到，哪怕只差1%，那也是亏了，相当于炒了半天，连还信用卡都不够，而年收益要达到18%以上，对很多人炒股达到这个收益非常难。</p><p>总结一下适合负债的场景：刚性支出比较适合，享受消费不太适合，负债投资很不可取。</p><h2 id="三、在偿还能力范围内负债">三、在偿还能力范围内负债</h2><p>接着我们来看第二问题：</p><blockquote><p>负多少债？即怎样判断自己的负债水平是否合理？</p></blockquote><p>负债的钱占到每月百分之多少才算合理，并没有一个让所有人都可以参考的比例，因为人和人情况不一样。比如，一个刚毕业的年轻人，假设每个月收入4000块，负债1000块，负债占收入的25%，这个比例好像也不是很高，但他扣掉房租和生活费，剩下的现金就很少了，很可能就还不上。但同样用收入的25%来负债，对于一个企业主来说，可能就没什么问题。</p><p>合理负债的关键是，在自己的偿还能力范围内负债。我们可以通过一个方法来判断自己的负债水平是否合理：先用每个月的稳定正向现金流（基本就是我们的收入），减去本月的必要支出和储蓄，看看剩下的钱有多少。剩下的这笔钱，才是我们可以用来还债的。</p><p>比如，一个家庭每个月收入是1万块，扣掉固定支出和储蓄，还剩5000块，这个家庭每个月要还房贷3000块，信用卡1000块，加起来4000块，剩下的5000块完全能覆盖，这就非常好。如果每个月要还的钱超过了5000，收入又没有增加，那就得减少支出了，万一哪个月还不上，信用就会受到影响。</p><blockquote><p>为什么要减掉日常支出和储蓄呢？</p></blockquote><p>如果没有算上储蓄，全拿去还债了，家里就会存不下钱。如果没有算上日常开支就更严重了，正常生活都会受影响。很多人都只看到自己的工资够不够，就贷了一大笔款，等到真的要还的时候，每个月都是捉襟见肘，非常狼狈。</p><p>总的来说，如果每个月要还的本息加起来，可以被剩下的钱覆盖，那就没问题。如果覆盖不了，就需要调整。</p><h2 id="四、健康的负债状态">四、健康的负债状态</h2><p>健康的负债状态，就是稳定正向现金流，减掉刚性支出，再减掉必要的储蓄，剩下的钱还可以覆盖每个月要还的本息。</p><p>如果收入只能覆盖利息，覆盖不了本，就很容易进入亚健康状态。比如，现在有很多商家为了劝我们消费，喜欢打“0首付”的广告，最典型的就是买车，消费者每个月先还利息就行了，等到三五年以后再还本金。</p><p>一辆9万的车，每个月只要交1000块钱利息就能开走，2年以后再把剩余9万本金还上。有些人觉得很好啊，我每个月还一点点钱，就能开上车了。但是，如果把本金算上，再平摊到每个月，这辆9万的车，每个月实际要还的是4500多元。如果每个月可以用5000块来负债，差不多可以满足，如果还债的预算只有4000，其实是不够的。</p><p>所以，再看到这样的广告，不能只看到每个月的利息，一定要算一下，本金加上利息平摊到每个月要还多少，每个月还利息的时候，要把还本金的钱存下来，这样到时候才有钱可还。</p><p>亚健康状态不是不能有，但是有风险，要提前规划、提高警惕。还有比亚健康更危险的，就是庞氏状态，不停地借新的钱还旧的钱，就像滚雪球一样，越欠越多。而且这个状况是不可逆的，因为已经没有了还款能力。</p><h2 id="五、小结">五、小结</h2><ul><li>负债是一种中性工具，它是一个帮我们把一笔未来的钱撬到现在的“财务杠杆”。</li><li>要在合理的事情上负债。刚性支出比较适合，享受消费不太适合，负债投资就更加不可取了。</li><li>健康的负债状态是，稳定正向现金流，减掉刚性支出，再减掉必要的储蓄，剩下的钱还可以覆盖每个月要还的本息。</li></ul><h2 id="六、参考">六、参考</h2><p><a href="https://www.dedao.cn/course/detail?id=z1DWOMARavZVxoMs0LKP2mlx7bjydL">李璞·家庭财富管理</a></p>]]></content>
    
    
    <categories>
      
      <category>理财投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>家庭理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>怎么给人生大事排序</title>
    <link href="/2022/04/10/%E6%80%8E%E4%B9%88%E7%BB%99%E4%BA%BA%E7%94%9F%E5%A4%A7%E4%BA%8B%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/04/10/%E6%80%8E%E4%B9%88%E7%BB%99%E4%BA%BA%E7%94%9F%E5%A4%A7%E4%BA%8B%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>我们知道目标事件可以分为刚性的和柔性的，需要着重规划的是刚性事件。可是一家人的刚性事件会有很多，还房贷、买车、给爸妈养老……我们得分出先后，一件一件解决。接下来，我们就来讨论目标事件的优先级问题。</p><h2 id="一、人生时间轴">一、人生时间轴</h2><p>法律对我们要承担的财务责任有基本的限定：</p><ul><li>作为子女，对父母有赡养的义务；</li><li>作为丈夫或者妻子，对另一半有相互照顾的义务；</li><li>作为父母，对未成年子女有抚养、教育的义务。</li></ul><p>如果将这些财务责任具体到一个人身上，他的人生时间轴大概会是这样的：</p><p><img src="/img/1766194249805594656" alt="img"></p><ul><li>23岁，大学毕业，参加工作实现了经济独立，要承担起自己的财务责任了。</li><li>两年后，有了女朋友，27岁时，考虑结婚，就迎来了人生中第一件财务上的大事：结婚买房。</li><li>夫妇俩过了几年二人世界。在30岁这年，夫妻俩迎来了他们的第一个孩子。两年后，第二个孩子也出生了。要照顾好两个孩子的衣食住行，还要为孩子将来的教育做好打算。</li><li>这几年，收入不断上涨，解决家庭的正常开支似乎不成问题，但是父母一天天老了，父母的看病、养老问题，也需要自己和妻子在经济上伸把手了。</li><li>时间继续往前走。50岁左右的时候，两个孩子要上大学了。这是孩子人生中的关键一步，如果孩子有意愿出国留学，孩子的教育金，也是需要解决的一大问题。</li><li>等两个孩子大学毕业、经济独立，夫妻俩对孩子的财务责任就基本完成了。接下来，就是考虑为父母养老，以及规划自己和伴侣的退休生活。</li></ul><p>总结一下，我们一生里必须面对的大事包括：结婚、买房、子女教育、父母的养老和医疗，还有自己的养老。</p><h2 id="二、先保证日常开支">二、先保证日常开支</h2><blockquote><p>人生大事这么多，先解决哪个呢？</p></blockquote><p>答案是，先保证自己的日常开支不受影响，再根据自己的人生阶段去安排即将发生的大事。</p><p>首先是日常开支。日常开支看似都是小钱，但每天都在发生，而且会伴随我们一生。所以，一定要有一个账户，永远在里面准备好三到六个月的日常开支，保证可以随时取。这笔钱能让我们在遇到意外的时候基本生活不受影响。</p><p>关于这笔钱，有两点一定要记住：</p><ul><li><p>第一，这笔钱轻易不能动。不管是要投资，还是要来一次奢侈的消费，都不可以轻易花这个账户里的钱。如果这笔钱都没攒够，就先别想投资的事情了。</p></li><li><p>第二，这笔钱的多少不是固定的。在不同阶段，我们的日常开支是不一样的，这个账户里的钱也要跟着变化。我们需要先了解自己的支出情况，再去规划这个备用金的账户。</p></li></ul><h2 id="三、人生大事排序">三、人生大事排序</h2><p>日常开支有了保证，我们就能放心安排后面的大事了。不同阶段的人即将面对的大事肯定不一样。对于人生大事，建议的排序是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">医疗费用 &gt; 买房 &gt; 父母和自己养老金 &gt; 孩子的大学教育金<br></code></pre></td></tr></table></figure><ul><li>首先，医疗费用在首位，有两个原因：第一，健康是第一位的，身体是革命的本钱。有了健康，才有其他的一切。第二个原因是，疾病在任何时候都有可能发生，所以我们不能拿家庭成员的健康冒险。况且现在的医疗费用也不低，更应该提前准备。</li><li>接下来可以考虑买房这件事了。买房是个大事，关系着成家和养老，不仅要考虑钱，还要考虑在哪买、怎么买等等</li><li>房子的问题解决了，接下来，我们会选择为父母和自己准备养老金。</li></ul><blockquote><p>可能有人会问：为什么不优先准备孩子的大学教育金呢？</p></blockquote><p>一是因为养老是生存问题，教育是发展问题。生存问题，天然就比发展问题要紧迫。</p><p>二是教育比养老更容易调动外部资金。假设孩子考上大学但家里钱不够，年轻人可以申请助学贷款，这种贷款是福利性质的，一般利率非常低。年轻人的事业前景更好，所以更容易找到杠杆、调动外部资源。而养老想要调动外部资金，不尽早准备是很难的。</p><blockquote><p>可能有人会问：我有社保，还需要储备养老金来解决生存问题吗？</p></blockquote><p>社保当然很重要，是我们的退休生活最基础的保障，但如果希望自己的退休生活更有品质，那只依靠社保大概率是不能满足的，需要我们额外做些准备。</p><h2 id="四、规划的边界在哪里">四、规划的边界在哪里</h2><p>我们可能觉得奇怪，为什么上面的事件中没有“给孩子买房”或者“为孩子准备结婚的钱”这类事件呢？</p><p>要不要给孩子买房或者准备婚嫁的钱，这个问题没有对错，只是观念不同。在传统观念里，孩子在买房的时候问父母要钱很正常，父母也觉得自己有义务帮孩子减轻负担。但是在今天看来，这件事并不存在于“人生必须”的时间线上。</p><p>这么说，当然是出于现代的观念了。孩子在成年且有独立生活能力之后，父母对孩子就没有必须要完成的财务责任了。孩子会有自己的人生事件线，应该自己负担日常生活支出、配置房产等等。</p><p>父母和孩子两条线虽然是并行的，但也应该分清楚。很多父母把自己和孩子的两条线合在一起，把孩子成年后要花钱的事情也归在自己的账户里，孩子要结婚、要买房、要旅游，父母都出钱，这样的“账户混同”会带来问题。</p><p>每个人都应该先对自己的那条事件线负责任。如果父母已经完成了自己那条线上的事情，还有额外的精力和资金，再来考虑帮助孩子完成他的责任。</p><h2 id="五、总结">五、总结</h2><ul><li>普通人一生里必须面对的大事包括：结婚、买房、子女教育、父母的养老和医疗，还有自己的养老。</li><li>安排大事之前，需要预留3-6个月的日常开支作为备用金。</li><li>在大事安排上，建议的顺序是医疗费用 &gt; 买房 &gt; 父母和自己养老金 &gt; 孩子的大学教育金</li><li>每个人都应该先对自己的那条事件线负责任。如果父母已经完成了自己那条线，再来考虑帮助孩子完成他的责任。</li></ul><h2 id="六、参考">六、参考</h2><p><a href="https://www.dedao.cn/course/detail?id=z1DWOMARavZVxoMs0LKP2mlx7bjydL">李璞·家庭财富管理</a></p>]]></content>
    
    
    <categories>
      
      <category>理财投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>家庭理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好的家庭财富管理是怎样的</title>
    <link href="/2022/04/10/%E5%A5%BD%E7%9A%84%E5%AE%B6%E5%BA%AD%E8%B4%A2%E5%AF%8C%E7%AE%A1%E7%90%86%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/"/>
    <url>/2022/04/10/%E5%A5%BD%E7%9A%84%E5%AE%B6%E5%BA%AD%E8%B4%A2%E5%AF%8C%E7%AE%A1%E7%90%86%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>家庭财富管理，不是赚到更多的钱，而是提前做出规划，把家里大大小小的目标事件解决好。换句话说，不管是看病、买房这样的大事，还是买菜、吃饭这样的小事，当事情发生时，如果我们能拿出所需的资金，把事情安排好、解决掉，不让它成为家庭的阻碍，那就算是把家庭财富管理好了。</p><p>家庭财富管理，需要我们转变一下思路——从关注财务转换到关注事务。</p><h2 id="一、目标事件">一、目标事件</h2><p>目标事件，就是所有需要我们花钱的事情。一家人过日子，目标事件真的太多了：</p><ul><li>首先，一日三餐、住房、医疗，这是最基本的。</li><li>除此之外，我们还会追求点生活的品质，比如经常看看电影、看看演出，日常喝个奶茶、吃点零食。</li><li>赶上节假日，给自己和家人买点儿礼物，偶尔亲友小聚也必不可少。</li><li>此外，有人想送孩子出国读书，家里有老人要赡养，也都要花钱。</li></ul><p>乍一看，目标事件好像很多。但其实，需要花钱的事，大概可以分为两类：</p><ul><li>刚性事件：就是那些一定要面对的事情，这笔钱无论如何必须得花。比如，一日三餐、房租、房贷等。</li><li>柔性事件：就是那些不完成也没什么大问题的事情。比如，买名牌包、旅游等。</li></ul><p>有了目标事件，接着就是实现这些目标了，我们可以借助一些财富管理工具实现这些目标。</p><h2 id="二、财富管理工具">二、财富管理工具</h2><p>财富管理工具，除了基金、股票、保险等理财工具外，还包括信用卡、贷款等负债工具。</p><p>此时我们可能会有这样的疑问：负债工具是让我欠债，借的钱，不仅要还，还得付利息，得不偿失，怎么就是工具了呢？</p><p>其实，我们可以换个角度想：在需要用钱的时候，银行把钱借给我们，这不就是在帮我们吗？既然是帮我们，那当然是工具啊。在这里，我们需要知道的是：工具本身没有好坏。总有人说信用卡、花呗让人超前消费、“毁掉了年轻人”，但这不是工具的问题，而是没有合理使用工具的问题。</p><p>此外，我们还需要知道的是，所有的理财工具，不管被包装成什么样子，都符合“不可能三角理论”，即安全性、收益性和流动性，三者最多只能得其二。比如，银行存款很安全，流动性也很高，但收益比较低。股票收益可能很高，流动性也不错，但是不安全、风险比较大。</p><h2 id="三、如何制定策略">三、如何制定策略</h2><p>具体选择什么工具、比例怎么安排，不同人、不同家庭差别很大。在为目标事件制定策略前，我们可以先思考几个问题：</p><ul><li><p>我有多少本金？看看自己能拿出多少本金，来为目标事件进行规划。</p></li><li><p>我的投资周期有多久？也就是说，我有多长时间去做规划？周期不同，可以选择的工具和能够获得的收益也不相同。</p><p>比如，一个人有10万块，想用来规划2年以后的出国旅行，那他就要知道，2年的周期，又要安全，比较合适的就是银行存款，收益不会太高。但如果这笔钱是准备20年后的养老，那就可以以20年为周期来选产品，比如养老保险、20年期的国债，就会获得比较高的收益。</p></li><li><p>我能承受多大的风险？在自己可以承受的风险范围内选择工具，盲目追求高收益而忽视风险，很有可能血本无归。</p></li></ul><p>接下来我们看一个例子，假设有三个人，他们都想给家里买辆车，希望3年内攒够5万块来交首付：</p><ul><li>第一个人很保守、不能承受风险，也没有存款，于是选择每月往银行里存1500元，不到3年就能攒够5万。</li><li>第二个人本身有5万本金，而且很大胆，于是选择拿这5万块去炒股。如果3年后5万变成10万，他就买一辆更豪华的车，如果5万都赔了，就干脆放弃买车计划，继续坐公交。</li><li>第三个人风格居中，于是他选择用这5万本金买了3年期的银行理财，3年后拿回本金和收益。</li></ul><p>这三个人的目标和投资周期都一样，但因为本金和风险偏好不同，选择的策略就不一样，选择的工具自然也不一样了。</p><h2 id="四、总结">四、总结</h2><ul><li>家庭财富管理，不是赚更多的钱，而是“为事做准备”</li><li>所有的目标事件可以分为刚性事件和柔性事件，需要着重规划的是刚性事件</li><li>财富管理工具包括理财工具和负债工具，所有理财工具都符合流动性、安全性、收益性的“不可能三角”</li><li>选择具体工具时至少需要考虑这几个问题：我有多少本金？我的投资周期有多久？我能承受多大风险？</li></ul><h2 id="五、参考">五、参考</h2><p><a href="https://www.dedao.cn/course/detail?id=z1DWOMARavZVxoMs0LKP2mlx7bjydL">李璞·家庭财富管理</a></p>]]></content>
    
    
    <categories>
      
      <category>理财投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>家庭理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理财，先别急着赚钱</title>
    <link href="/2022/04/10/%E7%90%86%E8%B4%A2%EF%BC%8C%E5%85%88%E5%88%AB%E6%80%A5%E7%9D%80%E8%B5%9A%E9%92%B1/"/>
    <url>/2022/04/10/%E7%90%86%E8%B4%A2%EF%BC%8C%E5%85%88%E5%88%AB%E6%80%A5%E7%9D%80%E8%B5%9A%E9%92%B1/</url>
    
    <content type="html"><![CDATA[<p>在进行理财投资时，很多人一心想着怎么赚钱，以及怎么赚到大钱。抱着这种想法投资，最后的结果往往是亏得血本无归，甚至基本生活都受到影响。对于大多数人来说，首先应该了解的是：怎么规避风险，不吃大亏，保护好自己的辛苦钱。</p><h2 id="一、别小看工资">一、别小看工资</h2><p>工资是理财的源头。对于理财来说，最重要的就是有稳定的劳动收入。</p><p>如果没有收入，理财的本金从哪里来？如果收入还没有一定的积累，就投入到理财中，那就是在用“要紧的钱”冒险，这属于给自己挖坑。</p><p>投资应该是一件锦上添花的事情，如果现在的收入不稳定，或者可投资的钱很少，就应该把主要精力放在工作上。</p><h2 id="二、别混淆资质">二、别混淆资质</h2><p>虽然现在的市场上有很多理财工具，但是并非什么理财产品都能买。</p><p>国家对不同的投资者可以买的产品是有限制的。如果买的产品不在自己的安全投资范围内，很有可能吃大亏。而且，如果买了自己原本不能买的产品，一旦出现问题，法律也不会为我们提供保障，因为这属于违规操作。</p><p>国家把投资者划分为三类：</p><ul><li>专业投资者：主要是指有一定金融资质的金融机构，比如银行、证券公司、期货公司等，它们可以投资外汇产品、大宗商品等等。</li><li>合格投资者：是指资产达到一定规模的投资者。比如，家庭金融净资产不低于300万元，或者近3年本人平均收入不低于40万元。</li><li>普通投资者：也就是我们常说的散户，绝大多数人都属于这一类。普通投资者可以选择的投资工具，就是我们熟悉的那些，银行储蓄、银行理财、股票、保险、基金、房产等。除了这几类，其他的很有可能是骗局。</li></ul><h2 id="三、别指望暴富">三、别指望暴富</h2><p>理财产品千千万，在做选择时，如果按照一定的标准去买，不一定暴富，但一定不会暴雷。这几个标准是：</p><ul><li>合规的渠道</li><li>合法的产品</li><li>合理的收益</li></ul><p>判断渠道是否合规、产品是否合法的方式很简单，就是去相关网站查询。机构开展金融业务或售卖产品，都要先取得监管部门的允许，相关的信息都会在网上进行公布，这些信息我们可以通过一些网站来查询：</p><ul><li>中国证券监督管理委员会：<a href="http://www.csrc.gov.cn/pub/newsite/">http://www.csrc.gov.cn/pub/newsite/</a></li><li>中国银行保险监督管理委员会：<a href="http://www.cbirc.gov.cn/cn/view/pages/index/index.html">http://www.cbirc.gov.cn/cn/view/pages/index/index.html</a></li><li>中国理财网：<a href="https://www.chinawealth.com.cn/zzlc/index.shtml">https://www.chinawealth.com.cn/zzlc/index.shtml</a></li></ul><p><img src="/img/image-20220410161747436.png" alt="image-20220410161747436"></p><p>而收益是否合理，则是一个比较大的话题，下一节我们详谈。</p><h2 id="四、如何判断收益是否合理">四、如何判断收益是否合理</h2><p>有五个指标可以帮助我们判断投资产品的收益是否合理。它们分别是：</p><h3 id="4-1、一年期国债收益率">4.1、一年期国债收益率</h3><p>第一个是一年期国债的收益率。国债就是我们把钱借给国家，到期后还本付息。我们一般会认为国家的信用等级是最高的，所以可以说国债利率就是无风险利率。</p><p>如果一个项目的收益率跟一年期国债差不多，那就可以认为这个项目风险很小。</p><p>国债的收益率是不断变化的，比如2021年7月1号的一年期国债收益率是2.42%，这个数据我们可以通过国家财政部的网站查询：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//yi</span>eld.chinabond.com.cn<span class="hljs-regexp">/cbweb-czb-web/</span>czb/moreInfo?locale=cn_ZH<br></code></pre></td></tr></table></figure><h3 id="4-2、银保监会允许的最高预定利率">4.2、银保监会允许的最高预定利率</h3><p>第二个指标是银保监会允许保险公司发行普通型养老年金和长期年金产品的最高预定利率，2019年是3.5%，我们可以把它理解为“准无风险收益率”。</p><p>为什么说它是“准无风险”呢？因为在所有机构投资者中，保险公司的投资渠道最广、投资限制最严，它们托管的多是医药费和养老金，需要保证长期安全。所以，如果一个投资项目的收益率在3.5%以下，基本是安全区间。</p><h3 id="4-3、一年期贷款基础利率">4.3、一年期贷款基础利率</h3><p>第三个指标是贷款市场一年期报价利率（LPR），2021年12月发布的是3.8%。银行贷款利率是所有机构贷款中利率最低的。如果一个项目的收益率在3.8以内，说明它能以较低的利率借到钱，那它的资质应该不会差。</p><h3 id="4-4、GDP增速">4.4、GDP增速</h3><p>第四个指标是GDP增速。如果一个产品的收益率超过了国家平均增长水平，我们就要提高警惕了。每年2-4月，统计局会发布过去一年的全国年度统计公报，2019年GDP较上一年增长了6.1%，这个指标每年都会波动，我们可以在国家统计局网站查询GDP增速。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># 统计数据 - 年度统计公报</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.stats.gov.cn/</span><br></code></pre></td></tr></table></figure><h3 id="4-5、高利贷标准红线">4.5、高利贷标准红线</h3><p>第五个指标是高利贷标准红线，一般为4倍的LPR，在这个利率以上的产品，连法律都不保护我们的权益，所以别碰它，因为风险太大了。</p><h3 id="4-6、小结">4.6、小结</h3><p>一般来说，收益越高，风险也就越大。当我们看到一款产品的收益后，就可以用这五个指标来判断它的风险。</p><p><img src="/img/1766113821174271204" alt="img"></p><h2 id="五、总结">五、总结</h2><ul><li>理财时最重要的，不是依靠理财暴富，而是保护劳动所得，不要暴雷。</li><li>工资提供的本金是所有理财的基础。</li><li>在理财之前，先弄清楚自己的投资资质，然后在适合的范围中选择产品</li><li>购买之前，先判断渠道是否合规、产品是否合法，再判断是否合理。</li></ul><h2 id="六、参考">六、参考</h2><p><a href="https://www.dedao.cn/course/detail?id=z1DWOMARavZVxoMs0LKP2mlx7bjydL">李璞·家庭财富管理</a></p>]]></content>
    
    
    <categories>
      
      <category>理财投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>家庭理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Region合并</title>
    <link href="/2022/04/08/Region%E5%90%88%E5%B9%B6/"/>
    <url>/2022/04/08/Region%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="一、What">一、What</h2><p>在线合并Region是HBase非常重要的功能之一。相比Region分裂，在线合并Region的使用场景比较有限，最典型的一个应用场景是，在某些业务中本来接收写入的Region在之后的很长时间都不再接收任何写入，而且Region上的数据因为TTL过期被删除。这种场景下的Region实际上没有任何存在的意义，被称为空闲Region。一旦集群中空闲Region很多，就会导致集群管理运维成本增加。此时，可以使用在线合并功能将这些Region与相邻的Region合并，减少集群中空闲Region的个数。</p><h2 id="二、How">二、How</h2><p>从原理上看，Region合并的主要流程如下：</p><p>1）客户端发送merge请求给Master。</p><p>2）Master将待合并的所有Region都move到同一个RegionServer上。</p><p>3）Master发送merge请求给该RegionServer。</p><p>4）RegionServer启动一个本地事务执行merge操作。</p><p>5）merge操作将待合并的两个Region下线，并将两个Region的文件进行合并。</p><p>6）将这两个Region从hbase:meta中删除，并将新生成的Region添加到hbase:meta中。</p><p>7）将新生成的Region上线。</p><p>HBase使用merge_region命令执行Region合并，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hbase&gt; merge_region <span class="hljs-string">&#x27;ENCODED_REGIONNAME&#x27;</span>, <span class="hljs-string">&#x27;ENCODED_REGIONNAME&#x27;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hbase&gt; merge_region <span class="hljs-string">&#x27;ENCODED_REGIONNAME&#x27;</span>, <span class="hljs-string">&#x27;ENCODED_REGIONNAME&#x27;</span>, <span class="hljs-literal">true</span></span><br></code></pre></td></tr></table></figure><p>merge_region是一个异步操作，命令执行之后会立刻返回，用户需要一段时间之后手动检测合并是否成功。默认情况下merge_region命令只能合并相邻的两个Region，非相邻的Region无法执行合并操作。同时，HBase也提供了一个可选参数true，使用此参数可以强制让不相邻的Region进行合并，因为该参数风险较大，不建议在生产环境使用。</p><h2 id="三、参考">三、参考</h2><p>[HBase原理与实践](<a href="https://book.douban.com/subject/34819650/">HBase原理与实践 (豆瓣)</a>)</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Region分裂</title>
    <link href="/2022/04/07/Region%E5%88%86%E8%A3%82/"/>
    <url>/2022/04/07/Region%E5%88%86%E8%A3%82/</url>
    
    <content type="html"><![CDATA[<p>Region分裂是HBase的核心功能之一，它是HBase实现分布式可扩展性的基础。在HBase中，Region分裂有多种触发策略可以配置，一旦触发分裂，HBase就会寻找分裂点，然后执行真正的分裂操作。</p><h2 id="一、What">一、What</h2><p>HBase支持好几种分裂触发策略。每种触发策略都有其各自的适用场景，我们可以根据业务在表级别选择不同的分裂触发策略。以下是几种常用的分裂触发策略：</p><p><img src="G:%5CMy%5Csource%5Cimg%5C2022-04-07-17-15-34-image.png" alt=""></p><ul><li><p>ConstantSizeRegionSplitPolicy：0.94版本之前默认分裂策略——当某个Region中最大的Store的大小超过阈值（hbase.hregion.max.filesize）后触发分裂。相比于其他策略，该策略最简单，但是在生产环境这种分裂策略却有很大弊端——对于大表和小表没有明显的区分。如果阈值设置较大对大表比较友好，但是小表有可能不会触发分裂，极端情况下可能就只有1个Region，这对业务来说并不是什么好事。如果阈值设置较小则对小表友好，但一个大表就会在整个集群中产生大量的Region，这对于集群的管理、资源使用来说都不是一件好事。</p></li><li><p>IncreasingToUpperBoundRegionSplitPolicy：0.94版本~2.0版本默认分裂策略。该策略总体来看和ConstantSizeRegionSplitPolicy思路相同，某个Region中最大Store大小超过设置阈值就会触发分裂。但是这个阈值并不是一个固定的值，而是在一定条件下不断调整，调整后的阈值大小和Region所属表在当前RegionServer上的Region个数有关系，调整后的阈值等于（#regions） * （#regions） * （#regions） * flush size * 2，当然阈值并不会无限增大，最大值为用户设置的MaxRegionFileSize。该策略很好地弥补了ConstantSizeRegionSplitPolicy的短板，能够自适应大表和小表，而且在集群规模较大的场景下，对很多大表来说表现很优秀。然而，这种策略并不完美，比如在大集群场景下，很多小表就会产生大量小Region，分散在整个集群中。</p></li><li><p>SteppingSplitPolicy：2.0版本的默认分裂策略。这种分裂策略的分裂阈值也发生了变化，相比IncreasingToUpperBoundRegionSplitPolicy简单了一些，分裂阈值大小和待分裂Region所属表在当前RegionServer上的Region个数有关，如果Region个数等于1，分裂阈值为flush size * 2，否则为MaxRegionFileSize。这种分裂策略对于大集群中的大表、小表会比IncreasingToUpperBoundRegionSplitPolicy更加友好，小表不会再产生大量的小Region。</p></li></ul><p>此外，还有一些其他分裂策略。比如，使用DisableSplitPolicy策略可以禁止Region分裂；而KeyPrefixRegionSplitPolicy和DelimitedKeyPrefixRegionSplitPolicy依然依据默认的分裂策略，但对于分裂点有自己的规定，比如KeyPrefixRegionSplitPolicy要求必须让相同的PrefixKey处于同一个Region中。</p><p>在实际的选择中，使用默认的分裂策略即可，当然我们也可以根据需要在CF级别设置Region分裂策略，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">create &#x27;table&#x27;, &#123;NAME =&gt; &#x27;cf&#x27;, SPLIT_POLICY =&gt; &#x27;org.apache.hadoop.hbase.regionserver.ConstantSizeRegionSplitPolicy&#x27;&#125;<br></code></pre></td></tr></table></figure><h2 id="二、How">二、How</h2><h3 id="2-1、寻找分裂点">2.1、寻找分裂点</h3><p>在满足Region分裂条件后就会触发Region分裂，而触发分裂后的第一步就是：寻找分裂点。所有的分裂策略，不论是ConstantSizeRegionSplitPolicy、IncreasingToUpperBoundRegionSplitPolicy还是SteppingSplitPolicy，对于分裂点的定义都是一致的。当然，我们手动执行分裂时指定分裂点的情况除外。</p><p>HBase对于分裂点的定义是：Region中最大Store中的最大文件中最中心的一个Block的首个rowkey。另外，HBase还规定，如果定位到的rowkey是整个文件的首个rowkey或者最后一个rowkey，则认为没有分裂点。</p><blockquote><p>此时，我们可能会问什么情况下会出现没有分裂点的场景？</p></blockquote><p>最典型的场景就是在待分裂的region中只有一个block，此时执行split就无法分裂。比如，新建一张测试表，然后往表中插入几条数据并执行flush，最后在执行split，就会发现数据表并没有真正执行分裂。原因就在于测试表中只有一个Block，此时如果查看debug日志会有如下内容：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">2017-08-19 11:26:17,404 <span class="hljs-built_in">INFO</span> [PriorityRpcServer.<span class="hljs-attribute">handler</span>=1,queue=1,port=60020] regionserver.RSRpcServices: Splitting split,,1503112775843.6adfcc49ba04f307d6c6a604572d1bb2.<br>2017-08-19 11:26:17,499 <span class="hljs-built_in">DEBUG</span> [PriorityRpcServer.<span class="hljs-attribute">handler</span>=1,queue=1,port=60020] regionserver.StoreFile: cannot split because midkey is the same as first <span class="hljs-keyword">or</span> last row<br>2017-08-19 11:26:17,499 <span class="hljs-built_in">DEBUG</span> [PriorityRpcServer.<span class="hljs-attribute">handler</span>=1,queue=1,port=60020] regionserver.CompactSplitThread: Region split,,1503112775843.6adfcc49ba04f307d6c6a604572d1bb2. <span class="hljs-keyword">not</span> splittable because <span class="hljs-attribute">midkey</span>=<span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h3 id="2-2、执行分裂">2.2、执行分裂</h3><p>HBase将整个分裂过程包装成了一个事务，目的是保证分裂过程的原子性。这个事务的整个过程分为三个阶段：prepare、execute和rollback。我们可以通过如下伪代码来理解这个过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!st.prepare()) <span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br>    st.execute(<span class="hljs-built_in">this</span>.server, <span class="hljs-built_in">this</span>.server, user);<br>    status = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        st.rollback(<span class="hljs-built_in">this</span>.server, <span class="hljs-built_in">this</span>.server);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException re) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Failed rollback of failed split parent.getRegionNameAsSring() -- aborting server&quot;</span>;<br>        LOG.info(msg, re);<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="2-2-1、prepare阶段">2.2.1、prepare阶段</h4><p>在内存中初始化两个子region，具体会生成两个HRegionInfo对象，包括tableName、regionName、startKey和endKey等。同时还会生成一个transaction journal对象，用来记录分裂的进展。</p><h4 id="2-2-2、execute阶段">2.2.2、execute阶段</h4><p>分裂的核心操作，如下所示：</p><p><img src="G:%5CMy%5Csource%5Cimg%5C2022-04-08-10-02-45-72a84cee8ea60db68c52b405fb08519f.jpg" alt=""></p><p>这个阶段的步骤如下：</p><ul><li><p>1）RegionServer将ZooKeeper节点/region-in-transition中该Region的状态更改为SPLITING。</p></li><li><p>2）Master通过watch节点/region-in-transition检测到Region状态改变，并修改内存中Region的状态。此时，在Master页面RIT模块可以看到Region执行split的状态信息。</p></li><li><p>3）在父存储目录下新建临时文件夹.split，保存split后的daughter region信息。</p></li><li><p>4）关闭父Region。父Region关闭数据写入并触发flush操作，将写入Region的数据全部持久化到磁盘。此后短时间内客户端落在父Region上的请求都会抛出异常NotServingRegionException。</p></li><li><p>5）在.split文件夹下新建两个文件夹，称为daughter A、daughter B，并在文件夹中生成reference文件，分别指向父Region中对应文件。这个步骤是所有步骤中最核心的一个环节，会生成如下reference文件日志</p></li></ul><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">2017</span><span class="hljs-number">-08</span><span class="hljs-number">-12</span> <span class="hljs-number">11</span>:<span class="hljs-number">53</span>:<span class="hljs-number">38</span><span class="hljs-punctuation">,</span><span class="hljs-number">158</span> DEBUG [StoreOpener<span class="hljs-number">-0155388346</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span><span class="hljs-keyword">c</span><span class="hljs-number">919</span>d<span class="hljs-number">3</span>f<span class="hljs-number">05</span>d<span class="hljs-number">7188e885</span>e<span class="hljs-number">0</span><span class="hljs-number">-1</span>] regionserver.StoreFileInfo: reference &#x27;hdfs:// hdfscluster/hbase-rsgroup/data/<span class="hljs-keyword">default</span>/music/<span class="hljs-number">0155388346</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span><span class="hljs-keyword">c</span><span class="hljs-number">919</span>d<span class="hljs-number">3</span>f<span class="hljs-number">05</span>d<span class="hljs-number">7188e885</span>e<span class="hljs-number">0</span>/cf/d<span class="hljs-number">24415</span><span class="hljs-keyword">c</span><span class="hljs-number">4</span>fb<span class="hljs-number">44427</span>b<span class="hljs-number">8</span>f<span class="hljs-number">698143e5</span><span class="hljs-keyword">c</span><span class="hljs-number">4</span>d<span class="hljs-number">9</span>dc.<span class="hljs-number">00</span>bb<span class="hljs-number">6239169411e4</span>d<span class="hljs-number">0</span>ecb<span class="hljs-number">6</span>ddfdbacf<span class="hljs-number">66</span>&#x27; <span class="hljs-keyword">to</span> region<span class="hljs-operator">=</span><span class="hljs-number">00</span>bb<span class="hljs-number">6239169411e4</span>d<span class="hljs-number">0</span>ecb<span class="hljs-number">6</span>ddfdbacf<span class="hljs-number">66</span> hfile<span class="hljs-operator">=</span>d<span class="hljs-number">24415</span><span class="hljs-keyword">c</span><span class="hljs-number">4</span>fb<span class="hljs-number">44427</span>b<span class="hljs-number">8</span>f<span class="hljs-number">698143e5</span><span class="hljs-keyword">c</span><span class="hljs-number">4</span>d<span class="hljs-number">9</span>dc。<br></code></pre></td></tr></table></figure><p>其中，reference文件名为d24415c4fb44427b8f698143e5c4d9dc.00bb6239169411e4d0ecb6ddfdbacf66，格式比较特殊，该文件名具体含义如下：根据日志可以看到，分裂的父Region是00bb6239169411e4d0ecb6ddfdbacf66，对应的HFile文件是d24415c4fb44427b8f698143e5c4d9dc，可见通过reference文件名就可以知道referene文件指向哪个父Region中的哪个HFile文件，如下所示：</p><p><img src="G:%5CMy%5Csource%5Cimg%5C2022-04-08-09-23-42-2b1c890056f256388500354035040222.jpg" alt=""></p><p>除此之外，reference文件的文件内容也非常重要。reference文件是一个引用文件（并非Linux链接文件），文件内容并不是用户数据，而是由两部分构成：其一是分裂点splitkey，其二是一个boolean类型的变量（true或者false），true表示该reference文件引用的是父文件的上半部分（top），false表示引用的是下半部分（bottom）。用户可以使用hadoop命令查看reference文件的具体内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hadoop dfs -cat /hbase-rsgroup/data/default/music/0155388346c3c919d3f05d7188e885e0/cf/d24415c4fb44427b8f698143e5c4d9dc.00bb6239169411e4d0ecb6ddfdbacf66<br></code></pre></td></tr></table></figure><ul><li><p>6）父Region分裂为两个子Region后，将daughter A、daughter B拷贝到HBase根目录下，形成两个新的Region。</p></li><li><p>7）父Region通知修改hbase:meta表后下线，不再提供服务。下线后父Region在meta表中的信息并不会马上删除，而是将split列、offline列标注为true，并记录两个子Region，如下：</p></li></ul><p><img src="G:%5CMy%5Csource%5Cimg%5C2022-04-08-10-01-26-2972674a92db3bbd4a87dd4c4fe5b058.jpg" alt=""></p><ul><li>8）开启daughter A、daughter B两个子Region。通知修改hbase:meta表，正式对外提供服务，如下：</li></ul><p><img src="G:%5CMy%5Csource%5Cimg%5C2022-04-08-10-02-22-8f5a42021031860a911e363911e84cf2.jpg" alt=""></p><h4 id="2-2-3、rollback阶段">2.2.3、rollback阶段</h4><p>如果execute阶段出现异常，则执行rollback操作。为了实现回滚，整个分裂过程分为很多子阶段，回滚程序会根据当前进展到哪个子阶段清理对应的垃圾数据。代码中使用JournalEntryType来表示各个子阶段，如下：</p><table><thead><tr><th>Jounal Entey Type</th><th>拆分进度</th><th>回滚（清理垃圾数据）</th></tr></thead><tbody><tr><td>STARTED</td><td>拆分逻辑被触发</td><td>NONE</td></tr><tr><td>PREPARED</td><td>执行拆分前的准备工作</td><td>NONE</td></tr><tr><td>SET_SPLITING_IN_ZK</td><td>Zookeeper中创建出拆分节点</td><td>删除Zookeeper中的拆分节点</td></tr><tr><td>CREATE_SPLIT_DIR</td><td>拆分目录.split被生成</td><td>清理父Region下的拆分目录</td></tr><tr><td>CLOSED_PARENT_REGION</td><td>父Region被关闭</td><td>重新对父Region执行初始化操作</td></tr><tr><td>OFFLINE_PARENT</td><td>父Region被下线，不再提供上线服务</td><td>重新将父Region上线</td></tr><tr><td>STARTED_REGION_A_CREATED</td><td>第一个子Region被成功创建</td><td>清理第一个子Region的存储目录</td></tr><tr><td>STARTED_REGION_B_CREATED</td><td>第二个子Region被成功创建</td><td>清理第二个子Region的存储目录</td></tr><tr><td>OPENED_REGION_A</td><td>第一个子Region被开启</td><td>关闭第一个子Region</td></tr><tr><td>OPENED_REGION_B</td><td>第二个子Region被开启</td><td>关闭第二个子Region</td></tr></tbody></table><h2 id="三、How-Good">三、How Good</h2><h3 id="3-1-、原子性保证">3.1 、原子性保证</h3><p>Region分裂是一个比较复杂的过程，涉及父Region中HFile文件分裂、两个子Region生成、系统meta元数据更改等很多子步骤，因此必须保证整个分裂过程的原子性，即要么分裂成功，要么分裂失败，在任何情况下不能出现分裂完成一半的情况。</p><p>为了实现原子性，HBase使用状态机的方式保存分裂过程中每个子步骤状态，这样一旦出现异常，系统可以根据当前所处的状态决定是否回滚，以及如何回滚。遗憾的是，目前实现中这些中间状态都只存储在内存中，一旦在分裂过程中出现RegionServer宕机的情况，有可能会出现分裂处于中间状态的情况，也就是RIT状态。这种情况下需要使用HBCK工具具体查看并分析解决方案。</p><p>在2.0版本之后，HBase将实现新的分布式事务框架Procedure V2（HBASE-12459），新框架使用类似HLog的日志文件存储这种单机事务（DDL操作、split操作、move操作等）的中间状态，因此可以保证即使在事务执行过程中参与者发生了宕机，依然可以使用对应日志文件为协调者，对事务进行回滚操作或者重试提交，从而大大减少甚至杜绝RIT现象。这也是HBase 2.0在可用性方面最值得期待的一个亮点功能。</p><p>在执行split的过程中一旦发生RegionServer宕机等异常可能会导致region-in-transition。通常情况下建议使用HBCK查看报错信息，然后再根据HBCK提供的一些工具进行修复，HBCK提供了部分命令对处于split状态的rit region进行修复，主要的命令如下：</p><ul><li><p>-fixSplitParents  Try to force offline split parents to be online.</p></li><li><p>-removeParents    Try to offline and sideline lingering parents an<br>d keep daughter regions.</p></li><li><p>-fixReferenceFiles  Try to offline lingering reference store files</p></li></ul><h3 id="3-2、对其他模块的影响">3.2、对其他模块的影响</h3><p>Region分裂过程因为没有涉及数据的移动，所以分裂成本本身并不是很高，可以很快完成。分裂后子Region的文件实际没有任何用户数据，文件中存储的仅是一些元数据信息——分裂点rowkey等。此时我们可能会有一些疑问：</p><blockquote><p>通过reference文件如何查找数据呢？</p><p>子Region的数据实际在什么时候完成真正迁移？</p><p>数据迁移完成之后父Region什么时候会被删掉？</p></blockquote><h4 id="3-2-1、通过reference文件查找数据">3.2.1、通过reference文件查找数据</h4><p>通过reference文件查找数据的整个流程如下：</p><p><img src="G:%5CMy%5Csource%5Cimg%5C2022-04-08-15-38-23-a6bc692664fe1c9fe438bb06fc5c2e20.jpg" alt=""></p><ul><li><p>根据reference文件名（父Region名 + HFile文件名）定位到真实数据所在文件路径。</p></li><li><p>根据reference文件内容中记录的两个重要字段确定实际扫描范围。top字段表示扫描范围是HFile的上半部分还是下半部分。如果top为true，表示扫描的是上半部分，结合splitkey字段可以明确扫描范围为[firstkey，splitkey)；如果top为false，表示扫描的是下半部分，结合splitkey字段可以明确扫描范围为[splitkey，endkey)。</p></li></ul><h4 id="3-2-2、父Region的数据迁移到子Region目录的时间">3.2.2、父Region的数据迁移到子Region目录的时间</h4><p>迁移发生在子Region执行Major Compaction时。根据Compaction原理，从一系列小文件中依次由小到大读出所有数据并写入一个大文件，完成之后再将所有小文件删掉，因此Compaction本身就是一次数据迁移。分裂后的数据迁移完全可以借助Compaction实现，子Region执行Major Compaction后会将父目录中属于该子Region的所有数据读出来，并写入子Region目录数据文件中。</p><h4 id="3-3-3、父Region被删除的时间">3.3.3、父Region被删除的时间</h4><p>Master会启动一个线程定期遍历检查所有处于splittig状态的父Region，确定父Region是否可以被清理。检查过程分为两步：</p><p>1）检测线程首先会在meta表中读出所有split列为true的Region，并加载出其分裂后生成的两个子Region（meta表中splitA列和splitB列）。</p><p>2）检查两个子Region是否还存在引用文件，如果都不存在引用文件就可以认为该父Region对应的文件可以被删除。</p><h2 id="四、参考">四、参考</h2><p>[HBase原理与实践](<a href="https://book.douban.com/subject/34819650/">HBase原理与实践 (豆瓣)</a>)</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Region迁移</title>
    <link href="/2022/04/07/Region%E8%BF%81%E7%A7%BB/"/>
    <url>/2022/04/07/Region%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<p>在一个分布式系统中，分片迁移是最基础的核心功能。集群的负载均衡、故障恢复等功能都是建立在分片迁移基础之上的。负载均衡，可以简单理解为集群中所有节点上的分片个数保持相同，即分片在集群中不断迁移。</p><h2 id="一、What">一、What</h2><p>在HBase系统中，一个Region就是一个数据分片，所以分片迁移就是Region迁移。HBase的Region迁移是一个非常轻量级的操作。之所以说它轻量，是因为HBase的数据存储在HDFS上，不需要独立管理。HBase在迁移Region时不需要迁移实际数据，只要将读写服务迁移即可。在实际执行分片迁移时主要有两个步骤：</p><ul><li><p>第一步，根据负载均衡策略执行分片迁移计划；</p></li><li><p>第二步，根据迁移计划执行分片的实际迁移。</p></li></ul><p>HBase的Region迁移虽然是一个轻量级操作，但实现逻辑比较复杂。其复杂性主要表现在以下两个方面：</p><ul><li><p>其一，迁移过程中涉及多种状态的转变；</p></li><li><p>其二，迁移过程中涉及多个组件（Master、ZooKeeper以及RegionServer）的协调；</p></li></ul><h2 id="二、How">二、How</h2><p>Region迁移操作分为两个阶段：unassign阶段和assign阶段。从总体上来看，整个unassign/assign操作是一个比较复杂的过程，会涉及Master、RegionServer和ZooKeeper三个组件，它们的主要职责如下：</p><ul><li><p>Master负责维护Region在整个操作过程中的状态变化，起到枢纽的作用。</p></li><li><p>RegionServer负责执行具体的unassign/assign操作，实际上就是关闭Region或者打开Region操作。</p></li><li><p>ZooKeeper负责存储操作过程中的事件。ZooKeeper上有一个路径为/hbase/region-in-transition的节点，一旦Region发生unssign操作，就会在这个节点下生成一个子节点（内容是“事件”经过序列化的字符串），并且Master会在这个子节点上监听，一旦发生任何事件，Master会即时更新Region的状态。</p></li></ul><h3 id="2-1、unassign阶段">2.1、unassign阶段</h3><p><img src="G:%5CMy%5Csource%5Cimg%5C2022-04-07-16-53-43-01.png" alt=""></p><p>unassign表示Region从源RegionServer下线，整个过程如下：</p><ul><li><p>Master生成M_ZK_REGION_CLOSING事件并更新到ZooKeeper，同时将本地内存中该Region的状态改为PENDING_CLOSE。</p></li><li><p>Master通过RPC发送close命令给拥有该Region的RegionServer，令其关闭该Region。</p></li><li><p>RegionServer接收到Master发送过来的命令后，生成一个RS_ZK_REGION_CLOSING事件并更新到ZooKeeper。</p></li><li><p>Master监听到ZooKeeper节点变动后，更新内存中Region的状态为CLOSING。</p></li><li><p>RegionServer执行Region关闭操作。如果该Region正在执行flush或者Compaction，就等待操作完成；否则将该Region下的所有MemStore强制flush，然后关闭Region相关的服务。</p></li><li><p>关闭完成后，生成RS_ZK_REGION_CLOSE事件并更新到ZooKeeper。Master监听到ZooKeeper节点变动后，更新该Region的状态为CLOSED。</p></li></ul><h3 id="2-2、assign阶段">2.2、assign阶段</h3><p><img src="G:%5CMy%5Csource%5Cimg%5C2022-04-07-16-52-12-02.png" alt=""></p><p>assign表示Region在目标RegionServer上线，整个过程如下：</p><ul><li><p>Master生成M_ZK_REGION_OPENING事件并更新到ZooKeeper，同时将本地内存中该Region的状态改为PENDING_OPEN。</p></li><li><p>Master通过RPC发送open命令给拥有该Region的RegionServer，令其打开该Region。</p></li><li><p>RegionServer接收到Master发送过来的命令后，生成一个RS_ZK_REGION_OPENING事件并更新到ZooKeeper。</p></li><li><p>Master监听到ZooKeeper节点变动后，更新内存中Region的状态为OPENING。</p></li><li><p>RegionServer执行Region打开操作，初始化相应的服务。</p></li><li><p>打开完成后，生成RS_ZK_REGION_OPENED事件并更新到ZooKeeper。Master监听到ZooKeeper节点变动后，更新该Region的状态为OPEN。</p></li></ul><h2 id="三、How-Good">三、How Good</h2><p>在Region迁移的过程中，会伴随Region状态的不断改变。此时，我们可能会有疑问：</p><blockquote><p>为什需要设置这些状态？</p><p>这些状态是如何管理的？</p></blockquote><p>首先，我们需要知道的是，无论是unnassign操作还是assign操作，都是由多个子操作组成的，同时还会涉及多个组件的协调合作，只有通过记录Region状态才能知道当前unassign或者assign的进度，在发生异常后才能根据具体的状态继续执行。</p><p>其次，我们需要知道的是，Region的这些状态会存储在三个区域：meta表、Master内存以及ZooKeeper的region-in-transition节点，并且它们的作用各不相同：</p><ul><li><p>meta表存储Region所在的RegionServer（不存储迁移过程中的中间状态）。如果Region从RS1成功迁移到RS2，那么meta表中就持久化存有Region与RS2的对应关系，而如果迁移中间出现异常，那么meta表就持久化存有Region与RS1的对应关系。</p></li><li><p>Master内存存储整个集群所有的Region信息。根据这些信息可以得出Region当前以什么状态位于哪个RegionServer上。Master存储的Region状态变更都是由RegionServer通过ZooKeeper通知给Master的，所以Master上的Region状态变更总是滞后于实际的Region状态。需要注意的是，我们在HBase Master WebUI上看到的Region状态都来自于Master内存信息。</p></li><li><p>ZooKeeper中存储临时性的状态转变信息。作为Master和RegionServer之间反馈Region状态的中介。如果Master（或RegionServer）在某个阶段发生异常，ZooKeeper上存储的状态可以在新Master（或RegionServer）启动之后作为依据继续进行迁移操作。</p></li></ul><p>最后，我们需要知道的是，只有上述三个存储区域内的状态保持一致时，对应的Region才处于正常的工作状态。但在很多异常情况下，Region状态在三个地方并不能保持一致，这就会出现region-in-transition（RIT）现象。</p><p>举个例子，RegionServer已经将Region成功打开，但是在远程更新hbase:meta元数据时出现异常（网络异常、RegionServer宕机、hbase:meta异常等）。此时，Master维护的Region状态为OPENING，ZooKeeper维护的Region状态为RS_ZK_REGION_OPENING，hbase:meta存储的Region所在RS为null。但是，Region已经在新的RegionServer上打开了，此时在Web UI上就会看到Region处于RIT状态。</p><p>了解了RIT的由来，我们就会知道Region在迁移过程中必然会出现暂时的RIT状态，这种场景并不需要任何人工干预。</p><h2 id="四、参考">四、参考</h2><p>[HBase原理与实践](<a href="https://book.douban.com/subject/34819650/">HBase原理与实践 (豆瓣)</a>)</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HBase手动移动Region</title>
    <link href="/2022/04/06/HBase%E6%89%8B%E5%8A%A8%E7%A7%BB%E5%8A%A8Region/"/>
    <url>/2022/04/06/HBase%E6%89%8B%E5%8A%A8%E7%A7%BB%E5%8A%A8Region/</url>
    
    <content type="html"><![CDATA[<p>当HBase的某个表的region集中在某台RegionServer上时，会出现热点问题，此时为了负载均衡就需要移动均分到其他RS上</p><h2 id="一、缘起">一、缘起</h2><p>最近捣鼓性能测试，创建了200W用户数据。然而，在测试登录接口的性能时，发现请求全落在了同一台RegionServer上，出现了热点问题。最初，想通过HBase的负载均衡策略自动解决这个问题，于是执行了balancer操作，结果热点问题依然存在。最后，在RS UI页面上发现用户数据连续分布在一台RS上，于是想使用手动的方式将region移动到其他几个节点上，实现负载均衡。</p><h2 id="二、流程">二、流程</h2><p>手动移动region的过程其实很简单，只需一个move命令即可，其使用方式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">hbase(main):011:0* help &#x27;move&#x27;<br>Move a region.  Optionally specify target regionserver else we choose one<br>at random.  NOTE: You pass the encoded region name, not the region name so<br>this command is a little different to the others.  The encoded region name<br>is the hash suffix on region names: e.g. if the region name were<br>TestTable,0094429456,1289497600452.527db22f95c8a9e0116f0cc13c680396. then<br>the encoded region name portion is 527db22f95c8a9e0116f0cc13c680396<br>A server name is its host, port plus startcode. For example:<br>host187.example.com,60020,1289493121758<br>Examples:<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  hbase&gt; </span><span class="language-bash">move <span class="hljs-string">&#x27;ENCODED_REGIONNAME&#x27;</span></span><br><span class="hljs-meta prompt_">  hbase&gt; </span><span class="language-bash">move <span class="hljs-string">&#x27;ENCODED_REGIONNAME&#x27;</span>, <span class="hljs-string">&#x27;SERVER_NAME&#x27;</span></span><br></code></pre></td></tr></table></figure><p>其中，ENCODED_REGIONNAME和SERVER_NAME可以在HBase的UI上获取</p><h2 id="三、参考">三、参考</h2><p><a href="https://blog.csdn.net/qingzhenli/article/details/72963439">Hbase region移动_自由盼盼的博客-CSDN博客_hbase 移动region</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HBase的负载均衡策略</title>
    <link href="/2022/04/06/HBase%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/"/>
    <url>/2022/04/06/HBase%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p>负载均衡是分布式系统的必备功能，多个节点组成的分布式系统必须通过负载均衡机制保证各个节点之间负载的均衡性，一旦出现负载非常集中的情况，就很有可能导致对应的部分节点响应变慢，进而拖慢甚至拖垮整个集群。<br>在实际生产线环境中，负载均衡机制最重要的一个应用场景是系统扩容。分布式系统通过增加节点实现扩展性，但如果说扩容就是增加节点其实并不准确。扩容操作一般分为两个步骤：首先，需要增加节点并让系统感知到节点加入；其次，需要将系统中已有节点负载迁移到新加入节点上。而负载迁移在具体实现上需要借助于负载均衡机制。</p><p>负载均衡从字面上来看就是通过一定策略使得整个系统的负载在所有节点上都表现均衡。那首先需要明确系统负载的是什么，应该通过哪些元素来刻画。负载明确之后进一步检查集群的负载现状，如果已经均衡就不必做任何处理，如果不均衡就要制订负载迁移计划。迁移计划制订之后需要根据计划进行具体负载的迁移。</p><h2 id="一、负载均衡策略">一、负载均衡策略</h2><p>HBase官方目前支持两种负载均衡策略：SimpleLoadBalancer策略和StochasticLoadBalancer策略。</p><h3 id="1-1、SimpleLoadBalancer策略">1.1、SimpleLoadBalancer策略</h3><p>这种策略能够保证每个RegionServer的Region个数基本相等，假设集群中一共有n个RegionServer，m个Region，那么集群的平均负载就是average=m/n，这种策略能够保证所有RegionServer上的Region个数都在［floor（average），ceil（average）］之间。</p><p>因此，SimpleLoadBalancer策略中负载就是Region个数，集群负载迁移计划就是Region从个数较多的RegionServer上迁移到个数较少的RegionServer上。</p><p>这种策略简单易懂，但是，考虑的因素太过单一，对于RegionServer上的读写QPS、数据量大小等因素都没有实际考虑，这样就可能出现一种情况：虽然集群中每个RegionServer的Region个数都基本相同，但因为某台RegionServer上的Region全部都是热点数据，导致90%的读写请求还是落在了这台RegionServer上，这样显而易见没有达到负载均衡的目的。</p><h3 id="1-2、StochasticLoadBalancer策略">1.2、StochasticLoadBalancer策略</h3><p>StochasticLoadBalancer策略相比SimpleLoadBalancer策略更复杂，它对于负载的定义不再是Region个数这么简单，而是由个种独立负载加权计算的复合值，这些独立负载包括：</p><ul><li><p>Region个数（RegionCountSkewCostFunction）</p></li><li><p>Region负载</p></li><li><p>读请求数（ReadRequestCostFunction）</p></li><li><p>写请求数（WriteRequestCostFunction）</p></li><li><p>StoreFile大小（StoreFileCostFunction）</p></li><li><p>MemStore大小（MemStoreSizeCostFunction）</p></li><li><p>数据本地率（LocalityCostFunction）</p></li><li><p>移动代价（MoveCostFunction）</p></li></ul><p>这些独立负载经过加权计算会得到一个代价值，系统使用这个代价值来评估当前Region分布是否均衡，越均衡代价值越低。HBase通过不断随机挑选迭代来找到一组Region迁移计划，使得代价值最小。</p><h2 id="二、负载均衡策略的配置">二、负载均衡策略的配置</h2><p>目前HBase默认的负载均衡策略是StochasticLoadBalancer。我们可以通过配置选择具体的负载均衡策略，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.master.loadbalancer.class<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>org.apache.hadoop.hbase.master.balancer.SimpleLoadBalancer<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="三、负载均衡相关的命令">三、负载均衡相关的命令</h2><p>HBase提供了几个与负载均衡相关的Shell命令，它们分别是：</p><ul><li><p>balancer_enabled：查询负载均衡功能是否开启</p></li><li><p>balance_switch：开启或关闭负载均衡功能</p></li><li><p>balancer：执行负载均衡</p></li></ul><h2 id="四、参考">四、参考</h2><p>[HBase原理与实践](<a href="https://book.douban.com/subject/34819650/">HBase原理与实践 (豆瓣)</a>)</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HBase的目录结构</title>
    <link href="/2022/04/06/HBase%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <url>/2022/04/06/HBase%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="一、HBase目录结构">一、HBase目录结构</h2><h3 id="1-1、On-ZooKeeper">1.1、On ZooKeeper</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;ls /hbase&quot;</span> | zookeeper-client | <span class="hljs-built_in">tail</span> -2 | <span class="hljs-built_in">head</span> -1 | awk -F <span class="hljs-string">&#x27;[][]&#x27;</span> <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>); <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span></span><br>meta-region-server,<br>rs,<br>splitWAL,<br>backup-masters,<br>table-lock,<br>flush-table-proc,<br>master-maintenance,<br>online-snapshot,<br>master,<br>switch,<br>running,<br>draining,<br>namespace,<br>hbaseid,<br>table<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>meta-region-server：包含meta region</li><li>rs</li><li>splitWAL</li><li>backup-masters</li><li>table-lock</li><li>flush-table-proc</li><li>master-maintenance</li><li>online-snapshot</li><li>master</li><li>switch</li><li>running</li><li>draining</li><li>namespace</li><li>hbaseid</li><li>table</li></ul><h3 id="1-2、On-HDFS">1.2、On HDFS</h3><h4 id="1-2-1、根级目录-文件">1.2.1、根级目录/文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo -u hdfs hadoop fs -<span class="hljs-built_in">ls</span> /hbase</span><br>Found 14 items<br>drwxr-xr-x   - hdfs  supergroup          0 2019-11-12 03:31 /hbase/.hbase-snapshot<br>drwxr-xr-x   - hbase supergroup          0 2019-11-12 03:16 /hbase/.tmp<br>drwxr-xr-x   - hbase supergroup          0 2019-11-12 04:30 /hbase/MasterProcWALs<br>drwxr-xr-x   - hbase supergroup          0 2019-11-12 03:16 /hbase/WALs<br>drwxr-xr-x   - hbase supergroup          0 2019-11-12 03:31 /hbase/archive<br>drwxr-xr-x   - hbase supergroup          0 2019-11-12 03:13 /hbase/corrupt<br>drwxr-xr-x   - hbase supergroup          0 2019-11-12 03:17 /hbase/data<br>-rw-r--r--   3 hbase supergroup         42 2019-11-12 03:13 /hbase/hbase.id<br>-rw-r--r--   3 hbase supergroup          7 2019-11-12 03:13 /hbase/hbase.version<br>drwxr-xr-x   - hbase supergroup          0 2019-11-12 04:30 /hbase/oldWALs<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>/hbase/.hbase-snapshot - 存储Snapshot的相关信息</li><li>/hbase/.tmp - 临时目录。比如，写一个hbase.id文件，先在这里写成功后，再rename到/hbase/hbase.id</li><li>/hbase/MasterProcWALs - 保存master执行过程中程序的状态，用于中断恢复执行使用</li><li>/hbase/WALs - 记录每台regionserver上的WAL日志文件</li><li>/hbase/archive - 归档目录。进行snapshot或者升级时会使用该目录，compaction删除hfile时也会把旧的hfile归档到这里。该目录由 HMaster 上的一个定时任务定期去清理。</li><li>/hbase/corrupt - splitlog的corrupt目录，以及corrupt hfile的目录</li><li>/hbase/data - HBase的表数据目录。从0.98版本开始支持 namespace 的概念模型，系统会预置两个 namespace 即: hbase 和 default</li><li>/hbase/hbase.id - 集群的唯一ID文件。在集群启动时初始化生成</li><li>/hbase/hbase.version - 版本文件（hbase软件版本、代码静态版本），现在都是8</li><li>/hbase/oldWALs - 历史WAL日志。已经确认持久化了的WAL日志文件会被移到这里，完成了splitlog的旧日志，也会被放到这里。</li></ul><h4 id="1-2-2、子目录-文件">1.2.2、子目录/文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># /hbase/WALs</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">对于每个regionServer节点,WALs日志目录下都包含一个对应的子目录</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">用于记录每台RegionServer上的WAL日志文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">regionServer目录的名字是有时间的。下一次启动时，RS目录就会使用新的目录结构存放wal，这个旧的RS目录会被splitlog拆分回放</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo -u hdfs hadoop fs -<span class="hljs-built_in">ls</span> /hbase/WALs</span><br>Found 4 items<br>drwxr-xr-x   - hbase supergroup          0 2019-11-12 05:16 /hbase/WALs/node2,16020,1573528597339<br>drwxr-xr-x   - hbase supergroup          0 2019-11-12 05:16 /hbase/WALs/node3,16020,1573528597152<br>drwxr-xr-x   - hbase supergroup          0 2019-11-12 05:16 /hbase/WALs/node4,16020,1573528597150<br>drwxr-xr-x   - hbase supergroup          0 2019-11-12 05:16 /hbase/WALs/node5,16020,1573528597109<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">每个子目录下会有多个HLog文件（因为日志滚动）</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo -u hdfs hadoop fs -<span class="hljs-built_in">ls</span> /hbase/WALs/node2,16020,1573528597339</span><br>Found 1 items<br>-rw-r--r--   3 hbase supergroup          0 2019-11-12 05:16 /hbase/WALs/node2,16020,1573528597339/node2%2C16020%2C1573528597339.node2%2C16020%2C1573528597339.regiongroup-0.1573535804334<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># /hbase/oldWALs</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">具体的oldWALs文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo -u hdfs hadoop fs -<span class="hljs-built_in">ls</span> /hbase/oldWALs</span><br>Found 220 items<br>-rw-r--r--   3 hbase supergroup         91 2019-11-12 06:16 /hbase/oldWALs/node2%2C16020%2C1573528597339.node2%2C16020%2C1573528597339.regiongroup-0.1573535804334<br>-rw-r--r--   3 hbase supergroup         91 2019-11-12 06:16 /hbase/oldWALs/node3%2C16020%2C1573528597152.node3%2C16020%2C1573528597152.regiongroup-0.1573535804199<br>-rw-r--r--   3 hbase supergroup         91 2019-11-12 06:16 /hbase/oldWALs/node4%2C16020%2C1573528597150.meta.1573535805180.meta<br>-rw-r--r--   3 hbase supergroup         91 2019-11-12 06:16 /hbase/oldWALs/node4%2C16020%2C1573528597150.node4%2C16020%2C1573528597150.regiongroup-0.1573535804696<br>-rw-r--r--   3 hbase supergroup         91 2019-11-12 06:16 /hbase/oldWALs/node5%2C16020%2C1573528597109.node5%2C16020%2C1573528597109.regiongroup-0.1573535804408<br>-rw-r--r--   3 hbase supergroup   33602916 2019-11-12 03:34 /hbase/oldWALs/pv2-00000000000000000001.log<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># /hbase/archive/</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">表的归档和快照具体目录形如:</span><br>/hbase/archive/data/default/表名/region名/列族名/fd2221d8d1ae4e579c21882f0ec4c5a5<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># /hbase/data/</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">default存放所有用户的数据表</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hbase存放HBase的系统表</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo -u hdfs hadoop fs -<span class="hljs-built_in">ls</span> /hbase/data</span><br>Found 2 items<br>drwxr-xr-x   - hbase supergroup          0 2019-11-12 03:17 /hbase/data/default<br>drwxr-xr-x   - hbase supergroup          0 2019-11-12 03:16 /hbase/data/hbase<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># /hbase/data/hbase</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">meta是元数据表，记录region相关信息</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">namespace存储了HBase中的所有namespace信息，包括预置的hbase 和 default</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo -u hdfs hadoop fs -<span class="hljs-built_in">ls</span> /hbase/data/hbase</span><br>Found 2 items<br>drwxr-xr-x   - hbase supergroup          0 2019-11-12 03:13 /hbase/data/hbase/meta<br>drwxr-xr-x   - hbase supergroup          0 2019-11-12 03:16 /hbase/data/hbase/namespace<br></code></pre></td></tr></table></figure><h4 id="1-2-3、表目录">1.2.3、表目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">/hbase/data/default/TestTable/.tabledesc/<br>/hbase/data/default/TestTable/.tabledesc/.tableinfo.0000000001<br>/hbase/data/default/TestTable/.tabledesc/.tmp<br>/hbase/data/default/TestTable/fc06f27a6c5bc2ff57ea38018b4dd399/<br></code></pre></td></tr></table></figure><p>它们的作用分别是：</p><ul><li>存放表的元数据信息文件</li><li>表具体的元数据信息文件</li><li>存放中间数据的临时目录，当.tableinfo被更新时该目录就会被用到</li><li>表中的region目录 ，  由表名+Start Key+时间戳产生的hashcode</li></ul><h4 id="1-2-4、region目录">1.2.4、region目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">/hbase/data/default/TestTable/fc06f27a6c5bc2ff57ea38018b4dd399/列族名/<br>/hbase/data/default/TestTable/fc06f27a6c5bc2ff57ea38018b4dd399/列族名/2e58b3e274ba4d889408b05e526d4b7b<br>/hbase/data/default/TestTable/fc06f27a6c5bc2ff57ea38018b4dd399/recovered.edits/340.seqid<br>/hbase/data/default/TestTable/fc06f27a6c5bc2ff57ea38018b4dd399/.regioninfo<br>/hbase/data/default/TestTable/fc06f27a6c5bc2ff57ea38018b4dd399/.tmp<br>/hbase/data/default/TestTable/fc06f27a6c5bc2ff57ea38018b4dd399/.splits<br>/hbase/data/default/TestTable/fc06f27a6c5bc2ff57ea38018b4dd399/.merges<br></code></pre></td></tr></table></figure><p>它们的作用分别是：</p><ul><li>存储该列族所有的数据文件</li><li>该列族实际的数据文件（HFile）</li><li>当splitlog发生时，一个RS的wal会按照region级别split WALs写到对应目录下的的recovered.edits目录上，使得此region再次被open的时候，回放这些recovered.edits 日志。</li><li>regioninfo文件。 包含了region的HRegionInfo的序列化信息，与tableinfo类似。hbase hbck 工具可以用它来生成丢失的表条目元数据</li><li>compaction时的临时目录</li><li>split时的临时目录，如果region上一次的split没有完成就被中断了，这个region再open时会自动清理这个目录，一般不需要人工干预。</li><li>merges时的临时目录，和split一样，如果没有正常完成就被中断了，那么在下次被open的时候自动清理。一般也不需要人工干预。</li></ul><h2 id="二、HBase涉及的主要文件">二、HBase涉及的主要文件</h2><ul><li>hfile -  数据文件</li><li>hfilelink - hbase snapshot会用到, migration upgrade 也会使用到。</li><li>reference -  用来指定half hfile，一个region有reference时，这个region不能split。split/merge会创建这个。进行compaction后生成新的hfile后，会把这个reference删除。hfile的reference文件名格式一般是 hfile.parentEncRegion。如：/hbase/data/default/table/region-one/family/hfilename。其region-two有reference hfile文件名格式为：/hbase/data/default/table/region-two/family/hfile.region-one 通常无效引用就是 region-one的hfile不存在了，那么这个引用就会失效。他的修复方法一般是把reference无效的引用移除。</li><li>.regioninfo - 保存着 endkey/offline标志/regionid/regionName/split标志/startkey/tablename等信息</li><li>tableinfo  保存着 tableName/table属性信息/table级别config信息/family信息。其中family信息保存着 famliyName/famiy属性/famliy级别config信息等。</li></ul><h2 id="三、参考">三、参考</h2><p><a href="https://segmentfault.com/a/1190000014708618">https://segmentfault.com/a/1190000014708618</a></p><p><a href="https://lihuimintu.github.io/2019/06/19/HBase-File-ZK-Structure/#%E5%9C%A8-hdfs-%E8%B7%AF%E5%BE%84">https://lihuimintu.github.io/2019/06/19/HBase-File-ZK-Structure/#在-hdfs-路径</a>](<a href="https://lihuimintu.github.io/2019/06/19/HBase-File-ZK-Structure/#%E5%9C%A8-hdfs-%E8%B7%AF%E5%BE%84">https://lihuimintu.github.io/2019/06/19/HBase-File-ZK-Structure/#在-hdfs-路径</a>)</p><p><a href="https://blog.bcmeng.com/post/hbase-hdfs.html">https://blog.bcmeng.com/post/hbase-hdfs.html</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安慰</title>
    <link href="/2022/02/26/%E5%A6%82%E4%BD%95%E5%AE%89%E6%85%B0/"/>
    <url>/2022/02/26/%E5%A6%82%E4%BD%95%E5%AE%89%E6%85%B0/</url>
    
    <content type="html"><![CDATA[<p>在生活和工作中，难免会遇到一些不开心的事情，而当我们身边的人遭遇挫折时，应该怎样得体地表达自己的善意呢？</p><h2 id="同情心-≠-同理心">同情心 ≠ 同理心</h2><p>首先，我们需要知道的是，安慰，需要我们调用同理心，而不是同情心。</p><p>同情心，其实是一种居高临下的心态——你出事了，而我没事。比如，当一个人遭逢变故时，同情心会促使我们对他说“太可伶了”、“节哀顺变”、“会好起来的”······这些并不是安慰、而是围观。</p><p>同理心，就是能准确地传达“我理解你”、“我和你感同身受”、“我接纳你此刻所有情绪”等信息。比如，一个爱跳舞的孩子，罹患股癌，需要截肢。此时最恰当的安慰方式是，给她一个拥抱，并告诉她：“好孩子，我知道你一定很伤心。没关系，你痛痛快快地哭吧，哭够了再说。”</p><p>沟通不是表达能力问题，而是心理建设问题。这一点在安慰场景中尤为突出。安慰的前提是能感受他人之感受，在实际行动过程中，安慰可以被分为两个关键动作：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">安慰 </span>=<span class="hljs-string"> 轻度介入 + 提供支持</span><br></code></pre></td></tr></table></figure><h2 id="轻度介入">轻度介入</h2><p>安慰，是一种相对被动的沟通，需要节制并且温和地传递力量。</p><p>很多时候，我们会觉得安慰人很难、很尴尬，其实是因为我们把握不好自己与沟通对象之间那种微妙的边界感。这就是为什么在安慰这个场景中，轻度介入是最安全的。</p><p>轻度介入，能保证我们在不冒犯别人的前提下，可以根据需要层层加码。反过来，如果我们一上来就用力过猛的话，则有可能把双方的沟通搞僵。因此，每次满怀善意地发起安慰前，我们自己都要先评估一下：双方的关系有那么近吗？他出事了，轮得着我来安慰吗？</p><p>“轻度介入”的轻度，究竟是多轻呢？我们可以参考一个标准：只要对方没有表露出他的需求，就不要主动提供安慰。比如，上级被领导骂了，心情很糟糕，跟你发牢骚——“我写材料这么多年了，伺候的领导好几任，从来没人说我写得不好，怎么就他各种不满意”。此时，我们只需要说一句话“领导，您看需要我做什么，您随时安排。”</p><p>轻度介入的安慰，只需要向对方表达两层意思：“我会陪着你”、“我愿意为你分担”。在安慰一些不是很熟悉的人时，我们可能会担心”对方得寸进尺，提一个我们没法答应的需要“。在这种情况下，我们只需要在提问时，把自己能接受的选项放进去即可。比如，”我在某某方面有点便利，你看我能不能为你做点什么？“</p><h2 id="提供支持">提供支持</h2><p>轻度介入之后，为了进一步推进关系，我们还要做一个关键动作：提供支持，让对方感受到”行胜与言“的力量。</p><p>我们可以将支持分为三种：资源支持、情绪支持和经验支持。</p><p>资源支持，就是为对方提供一些我们所能给予资源。比如，下属家里有事儿，公司规定只能请假5天，我们动用一点小权力，多给他放两天假。</p><p>情绪支持，就是为对方提供一个释放负面情绪的出口。比如，同事家里遭遇了一个重大的变故，回老家处理完，上班时情绪还是很低落。此时，我们可以对他说“最近你不在公司，想知道公司发生了什么大事儿 吗？”</p><p>经验支持，就是把自己的同类经验摊开来，供对方参考。比如，同事被老板臭骂了一顿。此时，我们可以对他说“上次我也被老板训了，当时情绪比较激动，丧了好几天。现在回头看，其实挺傻的。大家都是为了把事做得更 好。”</p><h2 id="上个台阶">上个台阶</h2><blockquote><p>当我们自己成为被安慰的对象时，怎么接收别人的安慰？</p></blockquote><p>要把对方的善意稳稳接住，有以下三个原则：</p><ul><li>自己能扛的，自己扛住</li><li>对于别人的安慰表示感谢。</li><li>对于那些不得体的安慰，赶紧用一个封闭式的句式，“谢谢，谢谢你的关心”，画上句号。</li></ul><h2 id="小结">小结</h2><p>结合上述两个关键动作，我们可以得到安慰的“格式化”表述：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">（刚听说）你遇到这个情况，我也不知道该帮你做点什么。我有这样这样几个便利，只要你需要，随时找我。别跟我客气，我随时都在。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>表达沟通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安慰</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求助</title>
    <link href="/2022/02/26/%E5%A6%82%E4%BD%95%E6%B1%82%E5%8A%A9/"/>
    <url>/2022/02/26/%E5%A6%82%E4%BD%95%E6%B1%82%E5%8A%A9/</url>
    
    <content type="html"><![CDATA[<p>在真实的世界中，无论工作还是生活，从来不是一场闭卷考试，没有必要通过“单打独斗”来证明自己的实力。很多沟通高手在本身能力很强的情况下，也会策略性地“示弱”，向别人请求帮助，并且把这种求助的过程作为一个重要的沟通方法来使用。这个做法常常会产生神奇的效果。发起一次求助，必须满足两个先决条件：：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">求助 </span>=<span class="hljs-string"> 别人帮得了 + 自己值得帮</span><br></code></pre></td></tr></table></figure><h2 id="别人帮得了">别人帮得了</h2><p>判断“对方是不是帮得了这个忙”，是我们发起求助的第一步。求助被拒，很多时候是因为我们强人所难。那怎么判断对方是不是帮得了呢？</p><h3 id="方法一：在时间和精力上可启动">方法一：在时间和精力上可启动</h3><p>我们发起求助时，必须要明确自己的责任主体定位，尽可能减轻对方的负担。首先要让对方觉得这件事是轻量级的，是可以轻松启动的。如果我们求助的事项需要对方付出他承受范围以外的时间和精力，他自然会觉得帮不了我们，也不想帮我们。</p><p>假设，领导给小杨布置了制作50页演讲PPT的任务，用于第二天的会议。</p><p>小杨领到任务后，扭头就去找同事小王帮忙：“小王，江湖救急，你是咱们组最擅长做PPT的，能不能帮我把这个活给做了？”因为小杨的求助，单纯是在“派活”，在“甩锅”，小王当然会拒绝。求助，是别人对你的责任伸出援手，而不是别人替你把活儿扛走。突然向对方求助一个大文件的制作，而且转天就要——这种工作量，即使对方不在乎你甩锅，也不愿意帮你，因为需要投入的时间和精力太多了。</p><p>事实上，小杨可以这样发起求助：“王老师，我要负责制作咱们组明天会议的PPT，想请您帮忙指导一下。”紧接着说具体的求助事项：“领导把这个任务交给我了，上次大会的时候，您做的PPT领导们都特别喜欢，客户也觉得我们的PPT做得非常酷炫，您看这事儿我没法求别人，只能觍着脸来求您了。”到这里需要注意，不是请小王替自己完成，而是请求他的指导：“您那几个特别酷炫的效果是用什么软件做的？您教教我，教会我以后，我就不用再麻烦您了。”如果只是教几个技巧，小王投入的精力和时间都比较少，况且这个任务还关系到小组表现，通常他是会愿意帮忙的。</p><h3 id="方法二：在职责边界内可启动">方法二：在职责边界内可启动</h3><p>求助是一个将对方拉入我们自己协作网络的过程。每个人在协作网络中都有自己的职责边界。不是说我们只要态度友善一点，对方就愿意“越界”协助。所以，在求助之前，我们要想好协作网络上有哪些人和节点，这件事是在谁的职责边界内可以启动的。在每个节点找到那个对应的人求助，他就能帮到我们。</p><p>销售部的小杨有个客户做活动，要提前调拨一批宣传物料。如果按照原定计划走流程，需要半个月的时间。小杨就想找另一个部门的小王帮忙，请他先调一批物料出来。这批物料是其他客户预订的，并不着急用，可以应急。请问，小杨应该怎么沟通，才能让小王觉得这个忙是帮得了的呢？</p><p>从小王的角度看，无论小杨找到自己说了什么，这个忙都帮不了，因为自己并没有权限调动这些货物。再从小杨的角度看，我们就可以得到关于求助的一条金律：求助事项必须是在对方职责范围内可以启动的。</p><p>小杨选择了错误的协作路径，找没有权力拍板的小王帮忙，自然没法拿到应急物料。正确路径应该是先跟小王打个招呼，了解到这批物料确实可以用，而且小王原则上也不反对。有了这个默契之后，再向自己的直属领导求助，推动自己的领导去找小王的直属领导协调。两位领导取得共识之后，把指令下达给小王，小王就能帮他这个忙了。</p><h3 id="方法三：在关系程度内可启动">方法三：在关系程度内可启动</h3><blockquote><p>来看下一个场景：某天你突然接到一个人的微信：“听说你认识那谁谁谁，我有个业务想找他，能不能帮我介绍一下？”你一看，发现你俩已经整整三年没说过话了，对方张嘴就让你帮他介绍一个重要关系，你心里大概率想的是：“不帮，我欠你的吗？”</p><p>这样的求助通常启动不了，因为双方关系的温度没到。我们向这样的“冷关系”求助时，就要做好“大概率会被拒绝”的心理准备。如果反过来，我们在上述场景中是发起求助的那个人，我们该怎么做呢？</p></blockquote><p>如果这个业务对我们来说很重要，而且你又确切地知道对方能帮到你，你要做的不是舌灿莲花地说服对方，而是想办法让双方的关系重新升温。比如，先恢复轻量级的互动，不定期地问候一声，或是送对方一本最近在看的好书。</p><p>如果我们要对方帮忙的是件大事儿，那么预留给关系升温的时间应该尽可能长一些。在明确感受到双方关系已经热热乎乎的时候，再开口问他：“有个事儿不知道合适不合适，我想跟您这儿问个线索。”</p><blockquote><p>此时我们可能会问：“为了得到对方的帮助，心机这么深，万一对方回过神来，觉得我在套路他，这可怎么办？”</p></blockquote><p>首先，交浅言深是沟通的大忌，千万不要今天刚给人家寄本书，明天就问人家借钱，这确实会让对方觉得自己被套路了。要明确双方关系已经熟络到你可以开口求助的程度，再去那么做。</p><p>其次，就算对方意识到，我们是为了求助而跟他搞关系，其实也无伤大雅。只要我们行为得体，对方并不会反感。稍微年长些的人都明白一个道理：有人肯“利用”我，那是我的福气；天天有人求我帮忙，那恰恰证明了我的“江湖地位”。只要对方不是死缠烂打，让人极度反感，我不会对他的求助有什么意见，甚至我还有成人之美的冲动，愿意帮助他完成这件事。</p><blockquote><p>说到关系的激活和维护，在求助中有一个场景值得我们再思考一下，就是通过中间人去联系我们原本不认识的人。</p></blockquote><p>这种情况在现实生活中也很常见。在发起这类求助时，我们需要注意几个事项：</p><ul><li>第一，不要同时找好几个中间人。最终的求助对象如果同时收到好多人的传话，会有被逼迫感。况且，中间人们意识到彼此的存在以后，也会迁怒于我们：“竟然还去找了别人，是觉得交给我不放心吗？”</li><li>第二，要给中间人足够的信息量：要求助什么事，原因是什么，已经准备好了什么，等等。这些关键信息，中间人都要提前知道。否则要来回沟通不说，还有可能闹笑话。</li><li>第三，别让中间人承担太多责任。人家牵个线，只负责帮我们和对方认识，但不负责成交。要是把太多责任安放在中间人身上，就会把他吓跑。</li></ul><h2 id="自己值得帮">自己值得帮</h2><p>除了别人帮得了，证明我们自己值得被帮也是一件非常重要的事。那么，有什么方法可以证明我们自己值得帮呢？</p><h3 id="方法一：先干为敬">方法一：先干为敬</h3><p>证明自己值得帮，首先要证明自己在这件事上已经付出了极大的努力。在这个意义上，它可以被叫作“先干为敬法”，在发起求助时可以用下述结构来表达：</p><ul><li>第一，说明目标。“我遇到了什么什么问题，想占用您几分钟时间，请教一下。”这说明我们珍惜对方的时间成本。</li><li>第二，展现努力。“这个问题是什么，我们之前已经做了什么，但是我们还没有搞定。”这会让对方觉得我们确实是搞不定了才发起求助的，而不是偷懒想找人甩锅。</li><li>第三，提出诉求。“我们做了这些努力，都没有搞定，能不能麻烦您做某件事？”</li></ul><h3 id="方法二：真诚领情">方法二：真诚领情</h3><p>在获得帮助、对方向我们释放善意时，我们要真诚地领情。</p><p>人情债的特点是利息高，有很多讲究。比如，我们都知道致谢要及时，但怎样算及时呢？一笔算一笔吗？当然不是。对方帮了我们一个忙，我们立马表示要回礼，就会让对方觉得我们把这份善意变成了交易，从而觉得和我们来往很没劲。我们所谓的及时致谢，其实是趁这件事还热乎着去做，而不是发起“一手交钱一手交货”的行动。</p><blockquote><p>那么，怎样向帮助我们的人表示感谢才是合适的呢？</p></blockquote><p>表示感谢最好当面沟通，可以结合对方的贡献程度不断升级。比如，从口头致谢到送一个小礼物，甚至到给对方发“表扬信”，让感谢的场景别具仪式感。举个例子。你的同事帮你解决了一个问题。他平时跟你关系挺不错的，算是给你个人帮个忙。但你在致谢时，不能把它完全当作你们俩的私事，而应该升级感谢的场景，比如在你们的共同上级面前表达对这位同事的正面评价和认同——这就是沟通高手发“感谢信”的方式，不是红纸黑字意义上的感谢信，而是在一个更大、更具仪式感的场景中向对方表示感谢。</p><p>不要把美好的互助关系变成低水平的工作交换。比如这样的回复：“小王，谢谢你这次给我做PPT，下次你做PPT的时候我也帮你。”这非但没有升级表扬的场景，还试图用以物易物的方式予以反馈，对方心里肯定不舒服。事实上，向对方反馈时也可以留出一个开放的可选项，像这样说：“特别感谢你，有什么用得着我的地方，你可千万别跟我客气。”未来他可能找你，也可能不找你，但有这句话，对方至少知道你领情了，而且你也把掌控感给了他。</p><p>当求助对象很厉害，这辈子可能也还不了人情。如果想维系住这段重要的关系，可以用每隔半年跟对方汇报我们的进步的方式，来表达感谢。比如，对方半年前可能帮了你一个忙，他自己都已经忘了，但是半年后你跟他说：“王总，您上次帮我，对我帮助特别大。最近我在我们公司升职了，您要有时间的话，我想请您吃个饭。”对方答不答应吃饭不重要，重要的是他一定很欣慰——在他自己已经把这件事忘记的情况下，你一直记着这份人情。而且，这会让他觉得，“这是在我的帮助下成长起来的年轻人，他的命运因为我的帮助发生了改变”。未来他也会更加关注你的成长，如果你再有什么困难需要找他帮忙，他答应的可能性也就更高了。</p><h2 id="被拒绝了怎么办">被拒绝了怎么办</h2><p>哪怕前期我们做了很多努力，还是要做好被对方拒绝的准备。建议在求助之前就想好，对方拒绝之后要如何回应。</p><p>先说一个反面案例，就是求人不成，反过来讽刺别人。小王拒绝帮小杨做PPT，小杨就说：“您现在职位也高了，特别忙，我就不该来麻烦您。”简单一句话，两个人在职场上可能就结仇了。所以，不管你以怎样的方式被拒绝了，都不要给对方负面的反馈。</p><p>小杨其实可以这么说：“完全理解，完全理解。这样，没关系，我再想想办法。”这句话听起来就很客气。当然，紧接着可以再说一句：“不过，麻烦您也帮我想着点，万一有办法或者有什么好的建议，您随时跟我说说。”对方可能想着，也可能不想着，但是万一想着呢？他觉得帮不了你，但是回家跟老婆一商量，他老婆说不定能帮你解决问题。这样双方未来的互动就有了更多可能性。</p><h2 id="上个台阶">上个台阶</h2><p>在这里想强调的是，为自己配备“救生员”的重要性。它字面意义上指的是那些在危急关头现身，向我们提供帮助的人。我建议，每个人都应该找到自己的“救生员”，而且只向他们发起一类求助，就是借助他们丰富的工作、生活经验，指点我们往后的几步棋该怎么走，或者告诉我们向谁求助最高效。</p><p>适合做“救生员”的人通常满足以下两个条件。</p><ul><li>第一，我们和对方的工作、生活有一定的交集，这样“救生员”才能理解我们的处境。当我们真的碰到难处时，他也可以帮我们分析出现问题的实质性原因。</li><li>第二，在双方有交集的前提下，不能有直接的利害关系。比如，现任的直接上级，或者公司里关系很近的同事就不合适。这些人可能都是直接求助的对象，但是因为我们的利益密切关联在一起，他可能没法成为我们的“救生员”。</li></ul><p>满足这两点的，就是你的备选“救生员”。导师、学长，都可能成为“救生员”。还有一种人特别合适——前领导。离开了上一家单位，但跟前领导关系不错，很尊重他，他水平也很高，那他就适合当我们的“救生员”。一方面是因为他很了解我们，另一方面是因为他的地位和经验要比我们高上一截，眼界更宽。这种“救生员”会特别有价值。</p>]]></content>
    
    
    <categories>
      
      <category>表达沟通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>表达沟通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>破冰</title>
    <link href="/2022/02/26/%E5%A6%82%E4%BD%95%E7%A0%B4%E5%86%B0/"/>
    <url>/2022/02/26/%E5%A6%82%E4%BD%95%E7%A0%B4%E5%86%B0/</url>
    
    <content type="html"><![CDATA[<p>破冰不是一次性动作，而是一个动态过程。它的本质应该是“双向奔赴”，让两个人在沟通过程中互相一点点靠近。拼命表现自我，只能引起对方的注意，却没法让对方卸下防御，没准还会让对方反感地后退一步。</p><p>好的破冰方法，可以概括为以下三个动作：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">破冰 </span>=<span class="hljs-string"> 双线卡位 + 展现关切 + 营造掌控</span><br></code></pre></td></tr></table></figure><h2 id="动作一：双线卡位">动作一：双线卡位</h2><p>破冰的第一步，自我介绍，目的不是塞多少信息进去，而是要在对方的世界里稳稳地“卡”住一个位置，让对方把我们放在他的记忆地图里。就是要用一条经线和一条纬线为对方建立准确的坐标。</p><p>在和人初次见面时，可以先给沟通对象一根“经线”，即交代“我是谁”，“我是干什么的（从事的工作）”。比如，“我是张三，目前就职于一家服务大家终身学习需求的创业公司。”</p><p>在搭上经线后，别忘了假设那条用于“卡位”的纬线。这里的纬线，是指双方的共同关系。比如，同乡、同校（或公司）、同好（共同的爱好）、同伴（共同的朋友）。</p><h2 id="动作二：展现关切">动作二：展现关切</h2><p>通过经线和纬线在对方的人际网络里卡住一个位置后，我们可以沿着纬线继续像对方展现：我们不仅有共同联系，我还非常关心你。比如，和客户见面，在完成“卡位”后就可以跟上一句：“贵公司上次办的那个发布会特别成功。您演讲提到的那个什么什么观点，让我很受启发。”</p><h2 id="动作三：营造掌控">动作三：营造掌控</h2><p>营造掌控，就是把自己的一部分交给对方，营造掌控感。</p><p>最轻的一种方式，是把自己的联系方式交给对方。比如，与对方告别后，给他发一条微信：我是张三，139×××，请惠存。</p><p>稍微重一点的方式，是把自己能够马上落实的一个行动交给对方。比如，在刚才的交流中，你们提到了某部电影、某本书。离开之后你就可以把链接发给他，附上这么一句话：“刚才我们说到的那部片子/那本书，我感觉特别好。这是链接，您看完之后，咱们可以继续交流。”</p><p>再重一些的方式，是把自己的一个“小秘密”交给对方。举个例子，我和另外一家公司的一名女性高管初次见面，相谈甚欢，聊到个人形象方面的问题时，她向我打听北京哪里有靠谱的发型师。如果希望把她发展成私人朋友，我就会把我发型师的微信名片推给她。这样，我们除了是工作合作伙伴，还共享着私人生活的“小秘密”，再次见面也很容易找到朋友的感觉。</p><h2 id="上个台阶">上个台阶</h2><p>按照记忆曲线的原理，即使我们完成了破冰的所有动作，对方还是有可能快速忘记我们。对此，可以在破冰的第二天和对方再进行一次轻量级互动。</p><p>可以给对方发个微信，对前一天的交流做出反馈。比如，他推荐了一本书，在与他见面之后买了这本书，就可以给他拍张照片，写上：“书到了，读起来。”说到这儿就行了，对方这下肯定记住我们了。</p><p>还有更轻的方式：对方刚好发了一条朋友圈，写个评论，也能让对方对我们的印象更深一点。</p>]]></content>
    
    
    <categories>
      
      <category>表达沟通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>表达沟通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>赞美</title>
    <link href="/2022/02/26/%E5%A6%82%E4%BD%95%E8%B5%9E%E7%BE%8E/"/>
    <url>/2022/02/26/%E5%A6%82%E4%BD%95%E8%B5%9E%E7%BE%8E/</url>
    
    <content type="html"><![CDATA[<p>很多人把赞美等同于夸人，就觉得赞美是一件很简单的事。其实，赞美远没有我们想象中得那么简单。没有水平的夸人不仅不会加分，没夸到点子上，甚至可能会得罪人。</p><h2 id="用行动表达赞美">用行动表达赞美</h2><p>用行动，而不是用语言来表达赞美。这不仅降低了对我们语言能力的要求，还更加安全、有效。</p><p>注重礼仪。我们通过一些约定俗成的仪态规范向别人表示尊重。比如，在对方说话时，不应该环抱手臂，更应该四仰八叉的坐着，而应该不断地用身体语言表达出赞美，像是不断点头、身体前倾，口头配合着说：“嗯嗯，是这么回事。”</p><p>控制“摸机率”，就是在沟通时要尽最大可能少碰手机。在别人说话识我们频繁看手机，其实就是在告诉对方，你说得特别没意思，无聊到我想看会儿手机。而反过来则表示对方很重要，我们很尊重对方，沉浸在与对方的交流中，完全忘了看手机。</p><p>提高‘举机率“。这个方法很适用于演讲场场合。在听对方演讲时，适时举起手机拍摄对方的投影内容。通过这个行动，对方就能感知到我们的赞美。</p><p>认真做笔记。在对方发言时，认真做笔记是一个比身体语言更明确、更强烈的赞美信号。</p><h2 id="让对方被看见">让对方被看见</h2><blockquote><p>“每个人毕生都在追求的是被看见”。</p></blockquote><p>赞美的本质就是告诉对方，“我看见你了，我看见你的好了，我看见你跟别人不一样了”。只有当我们的赞美能体现出这层意思，那我们的赞美才能有效地。</p><p>如果将赞美拆解成公式的话，它应该由以下这些动作组成：</p><blockquote><p>赞美 = 打追光 + 轻轻地 + 深深地 + 常常地</p></blockquote><h3 id="动作一：打追光">动作一：打追光</h3><p>打追光，就是把“赞美的光束”打在人身上，让他被看见。但不同的光线所呈现的效果不同，如何才能准确地将适合的光线打到不同的人身上呢？这里有两个技巧。</p><p>发现差异。观察差异、发现对方跟别人不一样的地方；把追光打在那个位置，然后赞美他。更重要的是，这个差异，不是对方与我们之间的差异，也不是对方与泛泛的普通人之间的差异，而必须是对方跟他所在群体之间的差异。比如，亦舒夸林青霞“美而不自知”，这就是在赞美她和其他顶级大美女之间的差异。</p><p>照亮行为，而不是照亮禀赋。行为是每个人自己后天的努力，而且是在观察之后才会发现的，更符合“被看见”的需求。但需要注意的是，在观察和照亮行为时，一定符合对方的人设。比如，读书时，一些学霸明明前一天晚上熬夜刷题，但并不希望别人知道。这时就不要跟他说：“你好刻苦，我昨天在你们楼下看到你的房间一直亮着灯。”</p><h3 id="动作二：轻轻地">动作二：轻轻地</h3><p>轻轻地，是指赞美的表达一定要简洁，不给人造成负担。比如，在职场向同事表达赞美，最佳时机就是在擦肩而过的瞬间带上一句：“张老师，您昨天的发言我收获特别大。”此时，对方只用回一句：“谢谢，有用就好。“到这里，赞美和接受赞美就迅速完成了闭环。</p><p>如果希望赞美能给人留下深刻印象，还可以使用一些”破冰“时的技巧。比如，事后用邮件或者微信来表达赞美。或者在参加完对方的活动后，发个朋友圈夸一夸。</p><h3 id="动作三：深深地">动作三：深深地</h3><p>深深地，并不是说赞美的言辞要多深邃，而是要表达对方对于我们的影响之深——我由衷地赞美你，因为你的优秀深深地影响了我。比如，在职场中可以这样赞美领导：“上次您跟我谈话时指出的那几个问题，最近两个月我挨个解决了一遍，结果在工作产生了······的效果。”</p><p>“深深地赞美”其实可以做到非常简洁。比如，一个人是这样赞美罗胖的：“罗老师，有一次60秒语音，您可能自己都忘了，但是对我影响很大。听您讲完，我就把家里的沙发和电视机都搬走了。现在我的客厅就是一个书房，我和孩子一人一个书桌，我们的幸福感很高。”</p><h3 id="动作四：常常地">动作四：常常地</h3><p>常常地，就是要经常表达赞美。</p><p>我们要有意识的要求自己：作为职业‘灯光师“，追光灯一旦打开，就别停下来。无论场合是大还是小，是一对一还是一对多，我们在哪里，正反馈就在哪里。比如，朋友请我们吃饭，结果饭菜一般，服务也乏善可陈。即使这样，我们也能给一个正反馈：”今天有机会跟你一起吃法，真是好。我真是感觉到那句话，吃什么完全不重要，重要的是跟谁吃。“</p><h2 id="如何回应赞美">如何回应赞美</h2><blockquote><p>在收到别人的赞美时，怎样可以更好的回应对方?</p></blockquote><p>大大方方的回应：”谢谢，你真好。“在此基础上，更高明地接受赞美的方式，其实是保留一个开放性的结尾，让对方可以无限继续下去。</p><p>比如，领导表扬我们：”材料处理得不错。“我们可以回复说：”谢谢领导，我还有很多做得不到位的地方，您要有时间的话，再给我指导指导。“或者“我最近就想攻破材料这关，您给我说说，咱们单位我还应该跟谁请教请教？”除了回应领导的赞美，表达自己想要进一步努力的态度，还保留了开放性结尾，让沟通可以顺利推进下去。</p>]]></content>
    
    
    <categories>
      
      <category>表达沟通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>赞美</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>道歉</title>
    <link href="/2022/02/26/%E5%A6%82%E4%BD%95%E9%81%93%E6%AD%89/"/>
    <url>/2022/02/26/%E5%A6%82%E4%BD%95%E9%81%93%E6%AD%89/</url>
    
    <content type="html"><![CDATA[<p>道歉的终极奥义不是承认“我错了”，而是承认“你是对的”。重要的不是为过去的行为道歉，而是要向对方承诺一个面向未来的增量。</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">道歉 </span>=<span class="hljs-string"> 关闭过去 + 承诺未来</span><br></code></pre></td></tr></table></figure><h2 id="动作一：关闭过去">动作一：关闭过去</h2><p>关闭过去，意味着要想修复双方的关系，得把眼前的问题“翻篇”。这个动作主要遵循四个原则：</p><ul><li>道歉越早，代价越小。当意识到自己可能出错了的时候，立即去道歉。</li><li>把道歉和弥补损失分开。道歉处理的是感受上的损失，赔偿处理的则是事实意义上的损失。</li><li>诚恳的态度比做任何事都要重要。为了让对方感受到我们的诚意，一定要当面致歉。</li><li>接纳对方的情绪。引导对方释放情绪。</li></ul><h2 id="动作二：承诺未来">动作二：承诺未来</h2><p>关闭过去之后，道歉的下一个动作，就是承诺未来。让双方关系在没有破裂的前提下，还能往前走一步。具体来说，有以下三种方法。</p><h3 id="方法一：带着方案来">方法一：带着方案来</h3><p>既然对方因为我们的原因蒙受了损失，那就需要在道歉时说明，接下来我们准备怎么办，我们的新方案是什么。</p><p>我们先来看一个反面例子。一个丈夫忘了和妻子的结婚纪念日。其实忘了不可怕，可怕的是，他在认错时说：“你怎么才能不生气？”或者：“到底要我怎么做，你倒是说呀？”这显然是在给气头上的另一半火上浇油。对方会想：“这婚是我一个人结的是吧？你就不能谈谈自己的想法吗？”而当他带着一个新方案，比如“我们一起去一个你一直想去的海岛玩”去道歉时，给对方非常直观的感受是，他弥补的心情非常迫切，连补救措施都想好了。这个态度显然要比“你说怎么样就怎么样”好得多。</p><p>同理，职场沟通中，你在安抚完对方的情绪后可以这么说：“王总，今天机会难得，我不是单纯地来道歉的，我跟您说我有事儿，我是真有事儿。这次我们团队接受教训了，反省了很多，未来我们准备做这么几件事，您听听。”只要你在新方案里提出了具体行动，对方的兴趣就会被唤起，他的注意力就会被吸引至未来，而不是停留在你犯的错误中。</p><p>我们可能会说：“我也不知道他到底想要什么，也不知道能弥补他什么。”这个时候其实还有一个办法，就是“上个请教”。</p><h3 id="方法二：上个请教">方法二：上个请教</h3><p>上个请教，就是在不知道怎么办的时候，请对方来指导我们应该怎么做，然后基于对方的反馈，承诺一个面向未来的“增量”。</p><p>可以直接用请教的方式询问对方：“王总，您看之前确实是我们做得不周到，给您造成了损失。仅仅弥补损失肯定是不够的，您看，能不能请您给我们指条路？让我们心里稍微过得去。对我们来说也是个学习，我们也追求个进步。”</p><p>也可以在沟通快结束时“上个请教”，留下开放性结尾。比如，像这样说：“您看这事真是我做得不对，刚才我说的那几点，回去之后肯定都是要落实、要整改的。但说句不该说的话，这幸亏是发生在您身上，要是发生在一个不讲理的人身上，那我可怎么办？所以，我想请您从您的角度再给我提提建议，看以后怎么做才能避免类似错误。”</p><h3 id="方法三：上个小礼物">方法三：上个小礼物</h3><p>送小礼物不是为了给对方增加负担，而是为了让对方看到我们道歉的诚意、我们想要改变的决心。</p><p>向内部同事道歉时确实可以随便一点、幽默一点。比如，如果我们道歉的对象是一个关系比较熟的同事，那就可以在道歉时给他带杯茶，对他说：“真不好意思，让你着急上火。今天不请你喝咖啡了，我给你买了一杯清火的茶，请你消消气。”这样不仅表现了道歉的诚意，也用一两句幽默的话，缓和了双方之间尴尬的气氛。</p><p>道歉的对象是外部客户的话，我们就要结合平日里对客户的观察，出手相对重一点、认真一点。向外部客户道歉时，相对安全的做法是送书。送书首先要送好书、新书，其次要在品类上挑个好兆头，比如书名有非常积极的意涵，或者书的定位很高大上。如果想不到好书，也可以送一个“万能礼物”——演出票或者电影票。把两张票装在一个精致的小信封里送给对方，在递信封时跟上一句话：“您看，我让您生了这么长时间的气，怎么补偿也补偿不回来。我给您买了两张喜剧电影的票，周末您带着家人去开心一下。这部片子，能让您把因为我的错误失去的那两个小时的快乐给追回来。”</p><h2 id="不原谅怎么办">不原谅怎么办</h2><p>关闭过去、承诺未来以后，道歉按说应该结束了，但我们不得不承认一个现实：无论我们的道歉多么诚意满满，对方可能还是无法原谅。我们需要意识到的一点是，道歉不仅仅是为了对方，也是为了让我们自己安心。所以，不管对方是否接受道歉，我们都要把道歉对应的动作做完，这是我们对自己的一个交代。</p><h3 id="方法一：小事打个时间隔断">方法一：小事打个时间隔断</h3><p>打个时间隔断，就是字面意义上的把时间段稍微拉开一点，再做一次沟通。</p><p>随着时间推移，人会逐渐淡忘坏消息，也会逐渐消化坏情绪。所以，可以等对方情绪平稳一些之后，再把我们前文介绍的道歉流程走一遍，通过实际行动告诉他：“我很在乎你的意见，我并没有忘记道歉这件事。”</p><p>时间隔断以一周为宜。拖得太久不但显得我们没有诚意，而且可能在对方已经彻底翻篇的情况下，让他重新想起那种不愉快的情绪。更关键的是，这有可能影响双方的核心利益——要是我们拖了一个季度才跟领导反省错误，肯定会影响领导考核时对我们的评价。</p><h3 id="方法二：大事第一时间请求支援">方法二：大事第一时间请求支援</h3><p>当我们把外部客户得罪了，肯定不能拖上一周那么久，必须立刻处理。道歉后，如果对方坚持不原谅，我们也不能怕“暴露”。如果有我们承担不了的责任，应该第一时间向上级请求支援。</p><p>跟上级请求支援时，正确的做法应该是先向上级道歉——小杨把公司重要的客户得罪了，自然给上级制造了很大的麻烦，所以要先用前文介绍的流程向上级说明情况。比如这样说：“花姐，王总那边，我会给他解释。我已经写好了一段文字，您看能不能用您的方式，从您的角度，帮我给他打个电话解释解释？”</p><p>准备好行动方案以后再去请求支援，领导的接受程度肯定更高。除此之外，还可以先买个小礼物，跟领导打声招呼：“花姐，明天我去跟王总当面道歉，我给他买了一份小礼物，能不能以您的名义送给他？”借用上级的力量增强道歉力度，又没有实际给他添麻烦——这是领导乐于助力的。</p><h2 id="上个台阶">上个台阶</h2><p>如果我们成为接受道歉的人，当对方郑重其事地来道歉时，可以参考以下三条建议：</p><ul><li>坦然接受对方的道歉。在对方道歉时认真倾听，表示肯定，告诉他相关情况你已经了解。如果你准备原谅他的话，可以再说一句：“没关系，这次的事就这样了，我接受你的道歉。”无须做过多解释。</li><li>要阻止对方把问题升级。有的时候，对方的道歉里可能藏有些小阴谋——“为了表示诚意，我让我们董事长亲自来给你道歉”，或者“我们要搞一个道歉大会，想请你们公司所有人都来听一听我们的诚意”。这可不是在表达诚意，而是在把问题升级。所以，一定要阻止对方，比如像这样回复：“好的，你们的决心我已经看到了。但是，在什么层面产生的问题，咱们就在什么层面解决。你看这样好不好？效率最高。”冷静地把局面控制住。</li><li>道歉如果涉及外部关系，该秉公处理的就秉公处理。比如，你在公司里负责业务工作，如果你的一个供应商惹了大祸，可不是他向你个人道歉就可以解决的，因为还牵涉到公司层面的赔偿问题。所以，要把道歉和赔偿区别开来，告诉供应商：“道歉我收到了，但赔偿的问题不归我管，我会把这个工作移交给我们的法务同事，由这些专业的同事来跟你们对接。”这样做，一方面是防止对方认为你没有接受他的道歉，还在利用赔偿打击报复；另一方面是防止你自身的情绪和对方需要赔偿的事实搅在一起，将事态复杂化。</li></ul>]]></content>
    
    
    <categories>
      
      <category>表达沟通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>道歉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闲谈</title>
    <link href="/2022/02/19/%E5%A6%82%E4%BD%95%E9%97%B2%E8%B0%88/"/>
    <url>/2022/02/19/%E5%A6%82%E4%BD%95%E9%97%B2%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<p>闲谈是一个很高频的沟通场景。那么该如何让闲谈变得有价值，而不仅仅是聊闲天呢？</p><h2 id="涟漪式沟通">涟漪式沟通</h2><p>闲谈，是一种涟漪式的沟通——它没什么特定边界，就好比往湖面仍了个石子，用一个话题带动另一个话题，像水波纹那样一环环扩展开来。</p><p>闲谈，是闲下来时的交谈，而不是聊闲天。闲谈，并不是没有目标的沟通。闲谈的最高任务只有一个：优化双方关系。比如关系的建立、深化、修复，等等。我们可以通过闲谈，让自己和沟通对象之间的关系变得更好。</p><p>闲谈，由两个动作组成：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">闲谈 </span>=<span class="hljs-string"> 传递尊重 + 传递价值</span><br></code></pre></td></tr></table></figure><h2 id="传递尊重">传递尊重</h2><h3 id="方法一：上个请教">方法一：上个请教</h3><blockquote><p>等电梯时遇到公司的业务大拿，想和他交个朋友，应该怎样开启一个闲谈？</p></blockquote><p>在这样的场景中，最稳妥的方法是“上个请教”。可以这样说：”王老师，最近我有个客户要来北京，我们得招待一下。我也没见过什么世面，有没有好餐厅适合招待客户的，您给我推荐一下？“这就特别符合闲谈的特点：一方面，双方都没那么强的目的性，一个随口问，一个随口说；另一方面，它能起到促进关系的作用。</p><p>一个真正能促进双方关系的请教，其实有不少讲究。比如，请教的问题必须在对方擅长的领域，这样对方才会有自信心和控制感。因此，请教时要结合对方的特点，请教一个特定的、明确的、有场景性的问题。比如，如果沟通对象身上有明显的健身痕迹，就可以请教他平日里锻炼的方式。他如果真锻炼，肯定非常乐于分享。而如果他不锻炼，就变相夸了他身材好，他也会很开心。</p><blockquote><p>请教是一种万能的沟通方法。它不仅可以传递尊重，还能让我们切实地有所收获。苏格拉底曾说过：“问题是接生婆，它能帮助新思想诞生。”</p></blockquote><h3 id="方法二：多给一点">方法二：多给一点</h3><p>上个请教的方法，可以让我们打开对方的话匣子。这时候，如果想在沟通过程中保持开放性的交互，就得学会说话时“多给一点”。</p><p>在向对方请教时，不能抛出封闭式问题。比如：“王老师，我想请客户吃饭，您觉得我请他去全聚德好吗？”这样的问题，对方只能回答“好”或者“不好”。做完这个选择题，沟通就此结束。</p><p>在向对方请教时，要为对方提供更多的信息抓手。比如：“王老师，我想请客户吃饭，而且想招待得隆重点，您看我去哪家餐厅合适啊？”这不仅是一个开放性问题，而且因为有“想招待得隆重点”这个信息，对方的回答可以非常有针对性。</p><p>假如在闲谈中，我们是回答问题的那一方，也要注意“多给一点”。比如，对方问，请客户吃饭一般在哪儿。我们可以先说：“我一般都在某某地方”。然后继续问对方：“你客户大概多大年纪啊？”这时对方可能会接过话茬说：“我的客户特年轻，是个二十多岁的富二代。有什么讲究吗？”那我们可以继续回答：“如果是年轻人，我们公司附近就有一家意大利餐厅，格调挺高，菜品也不错。你带他去那儿吧。”</p><h3 id="方法三：深度破冰">方法三：深度破冰</h3><blockquote><p>在很多社交场合中，由于时间过长，“上个请教”、“多给一点”的方法根本撑不住。比如，一顿饭要吃两个小时，此时该怎么办？</p></blockquote><p>这时，可以用深度破冰，让双方半生不熟的关系在这两个小时内升温。在深度破冰环节所准备的自我介绍，除了说明“我是谁”、“我和你有什么关系”，还要想想与这个闲谈场景、这些人有特殊关系的事件或者故事。它将成为我们投入湖水中的第一粒小石子，可以引发涟漪效应。</p><p>有一次，我和博世（Bosch）中国的高管交流。这类社交场合，我们在正式见面前肯定要准备和对方相关的谈资。比如，有的人会说：“我买过博世的产品，你们的电器品质很好。”对方听罢当然很高兴，但这还不够。因为，深度破冰需要一个能够展现你和对方特殊关系的故事。我在见了博世的高管后说了这么一句话：“你们肯定不知道，我跟博世有一个特殊交情。”对方表现得非常好奇：“有什么特殊交情，我们怎么不知道？”紧接着，我讲了这样一个故事：</p><blockquote><p>我先生追求我的时候，送我的第一个礼物就是博世的酒柜。关键是，你们公司的产品，品质也太过硬了，这个酒柜非常沉！我那时候住在一个没有电梯的四楼，找了三个搬运工，才给扛到家里。<br>你说，哪有刚开始追一个女孩，给人送酒柜的？我先生后来才告诉我，主要是因为博世酒柜特别结实耐用。这东西送进家里，就甭想出来了。这相当于在我家里安了个信号灯，时刻提醒他的存在。现在我们结婚七八年了，这个酒柜还在我家客厅里。你说，我和你们的交情是不是很特殊？</p></blockquote><p>这其实是一个有趣的用户故事，对方听到博世的产品在我的生命中曾扮演过一个这么重要的角色后，肯定会非常欣慰。而且，对方除了我的基本信息，还知道了一些无伤大雅的隐私。比如，我结婚了，我老公是个多么有“心机”的人，他送我的第一个礼物，等等。这其实就是一次升级版的、适用于深度破冰的自我介绍。当然，这个故事中有不少可以用来发散的线索，对方抓取线索后，就可以接过话茬来说，博世的电器做得到底有多结实，或者他自己的家庭情况等。只要你在深度破冰时开了个好头，这种涟漪式的谈话就可以无限发散下去。</p><p>我们在社交场合的谈资，其实是可以通过“强准备”完成的。想象一下，在我们的大脑里有好多装了各式谈资的抽屉：</p><ul><li>遇到养宠物的人，可以把装有猫猫狗狗谈资的抽屉拉开来取素材；</li><li>遇到有健身习惯的人，可以把装有健身餐或者器材谈资的抽屉拉开来取素材。</li><li>甚至可以专门腾出一个抽屉，用来装和某个特定的人（比如你的重要合作伙伴，或者你的顶头上司）相关的谈资。</li></ul><p>闲谈之所以要“强准备”，是因为我们可以运用这些谈资和对方积极互动。对方可能会意识到我们平时就很关注他，感觉自己受到了重视，那我们就在这个过程中传递了对他的尊重。</p><h3 id="方法四：管理人设">方法四：管理人设</h3><p>在有了多个谈资抽屉后，我们就可以轻易地开启闲谈了。这里需要注意的是，谈资不仅要和对方的经历相关，还要符合我们本身的“人设”。</p><p>这里的管理人设，不是给自己帖标签，而是管理我们不应该谈的东西。比如，一个全职妈妈可以花很长时间聊孩子，这没任何问题。但如果你希望大家认为你是一名职业女性，那你跟别人交流时，诸如育儿的话题就不宜谈得过多。</p><p>在闲谈场景中，最令人反感的不是不说话或者把天聊死的人，而是夸夸其谈的人(know-it-all)。凡事都要掺和两句，其他人就没发言机会了。这不符合在闲谈时传递尊重的原则。</p><p>我们应该有意识地将那些不应该谈的话题剔除出去，甚至可以坦率地承认，有些话题我们完全不懂，把它们交由在场的其他人解释。比如，在一些高端活动上，当大家开始讨论红酒时，如果我们不懂，就可以坦率地承认：“我一无所知，你们给我点杯冰啤酒就行。”</p><p>要尽可能避免在闲谈中聊到彼此的三观问题，这是一条“强边界”。观点类的问题特别容易引起争论。比如，有人跟你聊，在互联网上学习非常不好。对方的某个观点很容易引发你的不满情绪。这时候，你为了捍卫自己的观点，就会跟对方争个脸红脖子粗。</p><h2 id="传递价值">传递价值</h2><p>在闲谈时，除了传递尊重，我们还要传递价值。这里的价值，并非是实实在在的经济价值，只要让对方觉得我们说的对他用，感受良好，有收获感，就可以了。传递价值的闲谈会让我们赢得别人的尊重，这样我们的关系也会更长远。</p><p>在一对一的闲谈场景中，我们可以直接向对方传递出自己的价值。比如，小李热衷于看电影，那他可以在闲谈时给大家推荐个片单；小王特别懂吃，他就能帮大家推荐餐厅。我们身上的一些特质，其实可以在闲谈中帮助我们传递价值。</p><p>在一对多的闲谈场景中，直接传递价值的方法就不适用了，最好用的方法是上个请教。比如，我们可以这样问问大家：”我特别爱看电影，但是最近一直挺忙的，大家说说最近都看过什么好电影？“这个问题虽然简单，但是可以”激起涟漪“，让每个人都有话可说。当轮到我们的时候，就可以展现自己的价值了：“我想了一下，给大家推荐部老电影吧，是什么什么，但是很好看……”诸如此类的话题还有很多，比如，在饭桌上实在没话说，就可以聊：“某某某年，你在哪里，在做什么？”这同样是一个“万能话题”，任何人都能说上两句。至于某某年具体是哪一年，其实有些讲究。它得是大家有共同记忆的一个时间节点。</p><p>我们可以在平时多积累一些这样的话题。当我们积累和发起这类问题时，一定要想清楚自己的价值在什么地方。即，当这个话题，在人群中转了一圈，重新回到我们自己身上时，我们能传递出什么样的价值。</p>]]></content>
    
    
    <categories>
      
      <category>表达沟通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>表达沟通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>倾听</title>
    <link href="/2022/02/19/%E5%A6%82%E4%BD%95%E5%80%BE%E5%90%AC/"/>
    <url>/2022/02/19/%E5%A6%82%E4%BD%95%E5%80%BE%E5%90%AC/</url>
    
    <content type="html"><![CDATA[<p>那些公认的沟通高手，往往有一个共性：沟通不靠说，人狠话不多。因为他们知道，口若悬河只会把人推开。把嘴巴闭上，把耳朵支起来，才是让他人愿意和我们沟通的头号秘诀。</p><p>倾听是沟通的起点。如果我们无法听懂对方表达的意思，甚至听不全对方提供的信息，绝对不可能展开有效的沟通。</p><h2 id="结构化倾听">结构化倾听</h2><p>结构化倾听，是指在接收到对方传达的信息后，要习惯性地在头脑里画三个框，分别放三件东西：沟通对象的情绪、事实和期待。</p><h3 id="第一个框：情绪">第一个框：情绪</h3><p>情绪是我们内心感受的外在表现。</p><p>高兴、悲伤、恐惧、焦虑、愤怒······都是情绪。但人们通常不会直接表示“我很生气，我很焦虑”，而是把情绪隐藏在话语里面。比如，“领导总是让我加班”，这句话就是情绪。“总是”一词，表达的只是一种主观感受，而不是事实。因此，我们在倾听时要把对方语言里隐藏的情绪识别出来，分清何为事实，何为情绪。</p><p>一旦出现“总是、老是、每次、经常、永远”等类似的词，我们就可以立即告诉自己，对方是在宣泄情绪。这样的词通常被称作“情绪路标词”。只要出现“情绪路标词”我们就要意识到，对方没有在陈述事实，而是在发泄情绪。这时候我们要做的，不是跟他辩论事实真相，而是安抚他的情绪。只有把恶劣的情绪先将下来，双方才有沟通的基础。</p><h3 id="第二个框：事实">第二个框：事实</h3><p>事实是那些不受主观判断影响，可考证、可追溯的内容。比如，“你不会说话”这是事实吗？不是，这是一个评论。“昨天开会时，你说小张是一个猪”这才是一个事实。</p><p>从对方给出的一堆信息中判断哪些是事实，是最考验侦探能力的，这需要我们调用自己的经验和对时间本身的了解。我们可以借用新闻记者核查事实的方法，在对方的描述中考证以下几个要素：</p><ul><li>时间（when）</li><li>地点（where）</li><li>人物（who）</li><li>事件（what）</li></ul><p>如果能用这4个W还原实际场景，那么对方所言大概率就是事实。相反，如果这些要素语焉不详，而仅仅从诸如“我觉得”、“我判断”、“我认为”的主观推论出发，那我们听到的陈述很可能不是事实。</p><h3 id="第三个框：期待">第三个框：期待</h3><p>期待就是对方内心真正想要得到的东西，即对方的需求。</p><p>在识别出对方的情绪和事实后，我们需要结合二者来判断对方的期待。比如，我们作为一个客服，接到一个用户的电话投诉，说收到的商品有破损，很生气。此时，我们该怎么反馈？</p><p>我们先看错误的处理方式，跟客户道歉说“您别生气，您别着急”。这是在否定对方的情绪，只会让对方更加生气。</p><p>正确的处理方式是，在头脑里画为出三个框，分别放入事实、情绪和期待：</p><ul><li>事实：对方收到了一件破损的商品。</li><li>情绪：他很生气，也很着急。</li><li>期待：赶紧换货，最好还能补偿损失。</li></ul><p>所以，不要跟他在情绪上纠缠。首先承认他不应该有这样的遭遇，然后承认错误、道歉，紧接着跟上一句：“我马上给您补发新的商品，并且同步发您一个小礼品，希望能弥补一点点您的损失。”</p><p>在发现对方真实的期待后，我们就可以做出正确的反应。</p><h2 id="反向叙述">反向叙述</h2><p>所谓反向叙述，是按照自己理解的逻辑，重新描述一遍前面结构化倾听获得的信息，请对方做个确认。反向叙述包含三个步骤：</p><ul><li>第一步：响应情绪</li><li>第二步：确认事实</li><li>第三步：明确行动</li></ul><h3 id="第一步：响应情绪">第一步：响应情绪</h3><p>响应情绪，就是点破并接纳对方的情绪。即，对对方的情绪给予正面的回应。</p><p>比如，当对方生气、着急时，千万不要说“你别生气，你别着急”。因为这是在否定对方的情绪，这样只会让对方更生气。正确的做法应该是点破：“我知道，这个时候你肯定特着急”。就这么一句，不要纠缠，立马进入第二步。</p><h3 id="第二步：确认事实">第二步：确认事实</h3><p>确认事实，就是进行信息挖掘，把听到的事实用自己的话描述一遍。</p><p>比如，“您刚才说的这几点，我的理解是······，不知道我的理解对吗？”如果正确，对方就会给予肯定的确认，如果不对，对方就会补充更多的信息。当拿到经过确认的信息后，就可以进入第三步了。</p><p>注：如果对方表达的信息，我们压根儿就没听懂。此时，不要逃避，可以借由一系列提问的技巧去追问，比如：“您能跟我再展开讲讲吗？”甚至，再诚恳一点，直接说：“不好意思啊，这里我没听太明白，您能再跟我说说吗？”</p><h3 id="第三步：明确行动">第三步：明确行动</h3><p>明确行动，就是结合情绪和事实，推导出的对方的期待，并给出可行动的步骤。即，按照前面的所有信息，把对方的期待翻译成接下来可实施的行动，让对方清晰地感受到，你确实听懂了他的意思，并按照他的期待规划出了行动。</p><blockquote><p>沟通场景：我们作为人力资源部的员工，领导问：”绩效方案做这么久了，怎么还没弄好？“事实是，周一领的任务，已经做了80%，说好下周一交方案。</p></blockquote><p>第一步，先响应对方的情绪。“不好意思，是我一直没汇报进度，让您着急了”——点破对方“着急”引发的情绪。说完这句，不要恋战，立马进入第二步。</p><p>第二步，确认事实。“领导，我已经完成80%，有些小细节还没有完善进去。先跟您确认下，这份绩效方案重点考虑哪些地方呢？”</p><p>此时，领导回答：“最近业务运营调整要配合绩效方案，没有绩效就没法开展调整。”这下我们就听明白了。领导要拿到我们的工作结果以后，才能开展他自己的工作。那他的期待是什么？他不是觉得我们超时了，而是想让我们提前交但没明说。这时就得赶紧明确一下接下来的行动。</p><p>第三步，明确行动。“好的，我以最快速度把主干部分做出来，一些次要问题之后再完善。再针对最近的情况微调一下，做一份最适合现在营业情况的绩效方案。明天下午四点，我们可以讨论一下方案吗？”</p>]]></content>
    
    
    <categories>
      
      <category>表达沟通</category>
      
    </categories>
    
    
    <tags>
      
      <tag>表达沟通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL全局分析工具：mysqlreport</title>
    <link href="/2022/01/10/MySQL%E5%85%A8%E5%B1%80%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%9Amysqlreport/"/>
    <url>/2022/01/10/MySQL%E5%85%A8%E5%B1%80%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%9Amysqlreport/</url>
    
    <content type="html"><![CDATA[<p>mysqlreport可以将MySQL中一些重要的状态变量变成为一个易读的报告。通过这份报告，我们就能快速地查看MySQL服务器的各种性能指标，而不用根据<code>show status</code>的值进行大量、繁琐的计算。</p><h2 id="一、安装">一、安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">MySQL 8.0</span><br>sudo apt-get install libdbi-perl libdbd-mysql-perl -y<br><br>cd /tmp &amp;&amp; git clone https://github.com/daniel-nichter/hackmysql.com.git<br>sudo cp ./hackmysql.com/mysqlreport/mysqlreport /usr/bin/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">MySQL 5.7</span><br>sudo apt-get install libdbi-perl libdbd-mysql-perl -y<br><br>sudo apt-get install mysql-client-5.7 -y<br></code></pre></td></tr></table></figure><h2 id="二、使用">二、使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">mysqlreport --user root --password 123456 --host 127.0.0.1 --port 3306 --no-mycnf --flush-status --outfile myreport-$(<span class="hljs-built_in">date</span> +%Y%m%dT%H%M%S)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">mysqlreport --<span class="hljs-built_in">help</span></span><br>mysqlreport v3.5 Apr 16 2008<br>mysqlreport makes an easy-to-read report of important MySQL status values.<br><br>Command line options (abbreviations work):<br>   --user USER       Connect to MySQL as USER<br>   --password PASS   Use PASS or prompt for MySQL user&#x27;s password<br>   --host ADDRESS    Connect to MySQL at ADDRESS<br>   --port PORT       Connect to MySQL at PORT<br>   --socket SOCKET   Connect to MySQL at SOCKET<br>   --no-mycnf        Don&#x27;t read ~/.my.cnf<br>   --infile FILE     Read status values from FILE instead of MySQL<br>   --outfile FILE    Write report to FILE<br>   --email ADDRESS   Email report to ADDRESS (doesn&#x27;t work on Windows)<br>   --flush-status    Issue FLUSH STATUS; after getting current values<br>   --relative X      Generate relative reports. If X is an integer,<br>                     reports are live from the MySQL server X seconds apart.<br>                     If X is a list of infiles (file1 file2 etc.),<br>                     reports are generated from the infiles in the order<br>                     that they are given.<br>   --report-count N  Collect N number of live relative reports (default 1)<br>   --detach          Fork and detach from terminal (run in background)<br>   --help            Prints this<br>   --debug           Print debugging information<br><br>Visit http://hackmysql.com/mysqlreport for more information.<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p>–infile表示用文件中读取show status值，而不是从MySQL中获取。</p></li><li><p>–outfile表示将报告输出到屏幕后，再输出的文件中。</p></li><li><p>–email表示将报告输出到屏幕后，再通过电子邮件发送到指定地址。此选项要求sendmail位于/usr/sbin/，因此在Windows上不起作用。</p></li><li><p>–flush-status表示在生成报告后执行“flush status”语句。</p></li><li><p>–relative用于设置报告的生成间隔。mysqlreport通常生成的报告显示了MySQL服务器在整个正常运行时间内的值。–relative选项使mysqlreport生成与以前的报告相关的报告。如果–relative选项为X指定了一个整数值，那么mysqlreport将从MySQL服务器生成相隔X秒的相对报告。报告数由–report count选项控制。默认值为1个相对报告。例如，给定选项–relative 60，mysqlreport将生成2个报告：第一个报告将立即生成；这是开始报告或基线报告。第二个报告将在60秒后生成。第二个报告的值将相对于开始报告。例如，假设在开始的报告中总共有10.00个问题。然后假设在60秒的时间间隔内，MySQL服务器又回答了1k个问题。第二份报告将显示总共1.00k个问题，而不是11.00k个问题。如果给–relative选项指定了一个内嵌列表（类似于–infile选项所使用的列表），那么mysqlreport将仅从给定的内嵌中按给定内嵌的顺序生成相关报告。给定列表中的内嵌名称应使用空格分隔；例如：file1 file2等。在命令行中按正确的时间顺序指定内嵌很重要：先指定旧的内嵌。第一个内嵌应具有系统变量值（来自“显示变量”或“手动包含”）。内嵌可以有一组或多组MySQL SHOW STATUS值。但是请注意，“mysqladmin-r-inextended”的输出将不起作用，因为带有-r选项的mysqladmin已经将SHOW STATUS值相对化。 因为mysqlreport首先将报告写入临时文件，所以当–relative与整数（而不是与infies一起使用）一起使用时，mysqlreport将说明它正在写入哪个临时文件。这样，人们就可以在撰写相关报告时观察其进展情况。</p></li><li><p>–report-count表示生成多少个报告。此选项仅适用于–relative，当为–relative指定一个整数值时。mysqlreport实际上生成N+1个报告：第一个报告是开始报告或基线报告。然后，生成N个相关报告。</p></li><li><p>–detach表示后台运行。此选项将导致mysqlreport分叉，从终端分离，并在后台继续运行。分叉之后，mysqlreport将说明它正在写入哪个临时文件。此选项还需要选项–outfile或–email。如果既没有给出–outfile也没有给出–email，那么报告就会被删除，因为因为mysqlreport从终端分离，报告无法打印到终端。此选项与option–relative一起使用，这样mysqlreport就可以长时间收集相关报告，而不必使用控制终端（即用户登录）。例如，可以通过运行mysqlreport在一个小时内捕获一个相对报告，并将整个报告通过电子邮件发送给自己</p></li></ul><h2 id="三、输出解读">三、输出解读</h2><h3 id="3-1、key-索引报表">3.1、key - 索引报表</h3><p>该部分显示了MyISAM引擎的shared key buffer的使用情况，如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">__ Key <span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span>_<br>Buffer used     3.00k of  16.00M  %Used:   0.02<br>  Current       2.92M            %Usage:  18.26<br>Write hit       0.00%<br>Read hit       50.00%<br></code></pre></td></tr></table></figure><p>可以看到，当前的key_buffer_size为16M。在过去的一段时间中，MySQ单次使用的Key Buffer最大为3k，占总大小的0.02%，当该比值大于等于80%时，可以考虑调大key_buffer_size。需要注意的是，该值永远不可能大于95%，因为mysql内部的数据结构也会占用shared key buffer，但mysqlreport无法统计到它们。此外，还可以看到，当前总共使用了2.92M的Key Buffer，占总大小的18.26%。</p><p>Write hit和Read hit，分别指索引的写命中率和读命中率。对于索引的写命中率，在写操作（update、insert等）多的场景下命中率可能接近0%，在读操作（select等）多的场景下命中率可能高于90%，而当命中率小于0%时，表示MySQL经常将索引写入磁盘中。对于索引的读命中率，当命中率低于99%时，表示Key Buffer过小，大量索引需要从磁盘读取。</p><h3 id="3-2、questions-操作报表">3.2、questions - 操作报表</h3><p>该部分显示了MySQL Server正在忙些什么以及有多忙，其中包括MySQL的各种操作和MySQL协议通信。如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">__ Questions ___________________________________________________________<br>Total          98.06k   47.46/s<br>  DMS          81.23k   39.32/s  %Total:  82.84<br>  QC Hits      16.58k    8.02/s           16.91<br>  COM_QUIT        200    0.10/s            0.20<br>  Com_            131    0.06/s            0.13<br>  -Unknown         82    0.04/s            0.08<br>Slow 5 s            0    0.00/s            0.00  %DMS:   0.00  Log:  ON<br>DMS            81.23k   39.32/s           82.84<br>  SELECT       64.44k   31.19/s           65.72         79.33<br>  INSERT       16.75k    8.11/s           17.08         20.61<br>  UPDATE           41    0.02/s            0.04          0.05<br>  REPLACE           0    0.00/s            0.00          0.00<br>  DELETE            0    0.00/s            0.00          0.00<br>Com_              131    0.06/s            0.13<br>  change_db       119    0.06/s            0.12<br>  show_fields       9    0.00/s            0.01<br>  show_status       2    0.00/s            0.00<br></code></pre></td></tr></table></figure><p>在Total部分是MySQL对所有操作的总计，以及这些操作自MySQL Server启动以来的速率。这些总计数据包含如下内容：</p><ul><li>DMS，即数据操作语句。主要包括了select、insert、replcate、update、delete等操作。在一个长时间运行的系统中，该部分应该是占比最高的。</li><li>QC Hits，即查询缓存命中率，是指MySQL从查询缓存中检索结果而不是执行实际的查询获取结果的次数</li><li>COM_QUIT，是一些可忽略的、不重要的操作。</li><li>Com_，是MySQL处理的各种命令，通常与协议相关。理想情况下，该值应该很低，过高则说明MySQL一直在空转。</li><li>Unknown，是一些未知的操作。通常，该值应该很低。</li></ul><p>在Slow部分显示了MySQL执行的慢查询数量。如上，执行时间超过5s秒的操作将被视为慢查询，当前总计到了0条慢查询。<code>%DMS</code>表示数据操作语句在慢查询中的比重。<code>LOG</code>表示是否将慢查询记录到日志中。</p><p>在DMS部分则显示了数据操作语句详细分布情况。</p><p>在Com_部分则显示了MySQL处理的各种命令的分布情况。</p><h3 id="3-3、select-and-sort-查询和排序报表">3.3、select and sort - 查询和排序报表</h3><p>该部分显示了各种类型的select语句的详细分布情况，如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">__</span> SELECT and Sort _____________________________________________________<br><span class="hljs-attribute">Scan</span>               <span class="hljs-number">38</span>    <span class="hljs-number">0</span>.<span class="hljs-number">02</span>/s %SELECT:   <span class="hljs-number">0</span>.<span class="hljs-number">06</span><br><span class="hljs-attribute">Range</span>              <span class="hljs-number">14</span>    <span class="hljs-number">0</span>.<span class="hljs-number">01</span>/s            <span class="hljs-number">0</span>.<span class="hljs-number">02</span><br><span class="hljs-attribute">Full</span> join           <span class="hljs-number">3</span>    <span class="hljs-number">0</span>.<span class="hljs-number">00</span>/s            <span class="hljs-number">0</span>.<span class="hljs-number">00</span><br><span class="hljs-attribute">Range</span> check         <span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">00</span>/s            <span class="hljs-number">0</span>.<span class="hljs-number">00</span><br><span class="hljs-attribute">Full</span> rng join       <span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">00</span>/s            <span class="hljs-number">0</span>.<span class="hljs-number">00</span><br><span class="hljs-attribute">Sort</span> scan          <span class="hljs-number">14</span>    <span class="hljs-number">0</span>.<span class="hljs-number">01</span>/s<br><span class="hljs-attribute">Sort</span> range         <span class="hljs-number">26</span>    <span class="hljs-number">0</span>.<span class="hljs-number">01</span>/s<br><span class="hljs-attribute">Sort</span> mrg pass       <span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">00</span>/s<br></code></pre></td></tr></table></figure><p>其中，Scan表示全表扫描，Range表示范围查询，Full join表示联合全表扫描。正常情况下，应该有很多的Range范围查询，而如果Scan和Full join过多，则说明SQL写得有问题。</p><h3 id="3-4、query-cache-查询缓存报表">3.4、query cache - 查询缓存报表</h3><p>该部分显示了查询缓存的使用情况，如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">__</span> Query Cache _________________________________________________________<br><span class="hljs-attribute">Memory</span> usage   <span class="hljs-number">17</span>.<span class="hljs-number">81</span>M of  <span class="hljs-number">32</span>.<span class="hljs-number">00</span>M  %Used:  <span class="hljs-number">55</span>.<span class="hljs-number">66</span><br><span class="hljs-attribute">Block</span> Fragmnt  <span class="hljs-number">13</span>.<span class="hljs-number">05</span>%<br><span class="hljs-attribute">Hits</span>           <span class="hljs-number">16</span>.<span class="hljs-number">58</span>k    <span class="hljs-number">8</span>.<span class="hljs-number">02</span>/s<br><span class="hljs-attribute">Inserts</span>        <span class="hljs-number">48</span>.<span class="hljs-number">50</span>k   <span class="hljs-number">23</span>.<span class="hljs-number">48</span>/s<br><span class="hljs-attribute">Prunes</span>         <span class="hljs-number">33</span>.<span class="hljs-number">46</span>k   <span class="hljs-number">16</span>.<span class="hljs-number">20</span>/s<br><span class="hljs-attribute">Insrt</span>:Prune    <span class="hljs-number">1</span>.<span class="hljs-number">45</span>:<span class="hljs-number">1</span>    <span class="hljs-number">7</span>.<span class="hljs-number">28</span>/s<br><span class="hljs-attribute">Hit</span>:Insert     <span class="hljs-number">0</span>.<span class="hljs-number">34</span>:<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>在Memory usage部分显示了查询缓存的内存使用情况。当查询缓存占用了大量的内存时，会体现在Prunes部分。</p><p>在Block Fragmnt部分显示了查询缓存所使用内存的碎片情况。该值是可用缓存块与总块的百分比。值越大，说明碎片越多。10%到20%是平均水平。如上示例，碎片率是13.05%，这个可以接受的，但可以尝试调整query_cache_min_res_unit参数，看看碎片率是否会下降。</p><p>在Hits、Inserts、Prunes部分显示了对查询缓存的操作情况。其中，Hits表示命中查询缓存的次数、Inserts表示在查询缓存中插入新数据的次数，Prunes表示删减查询缓存中数据的次数。</p><p>在Insert:Prunes部分显示了查询缓存的波动性。Insert大于Prunes，说明查询缓存稳定；Insert小于Prunes，说明查询缓存易失。查询缓存稳定表示缓存经常被使用，查询缓存易失表示缓存大小过小（此时增大缓存大小即可）或MySQL试图缓存所有的东西（此时可以调整查询缓存的使用类型调整为2，默认为1）。</p><p>在Hit:Insert部分显示了查询缓存的有效性。在理想的情况下，MySQL应该在查询缓存中插入一堆稳定的查询，然后直接从查询缓存中获取结果。因此，如果查询缓存的有效性高，那么Hit应该大于Insert。当Insert大于或等于Hit时，表示查询缓存不稳定。</p><h3 id="3-5、Table-Locks-表锁报表">3.5、Table Locks - 表锁报表</h3><p>该部分显示了MySQL锁的使用情况，如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">__ Table Locks <span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span>_<br>Waited          1.01k    0.49/s  %Total:   1.24<br>Immediate      80.04k   38.74/s<br></code></pre></td></tr></table></figure><p>在Waited部分显示了MySQL必须等待才能获得表锁的数量。该值应该尽可能低，等待表锁的百分比不应超过10%，较高的百分比意味着表或查询索引不佳或者查询速度较慢。</p><p>在Immediate部分显示了MySQL立即获得表锁的数量。</p><h3 id="3-6、tables-表报表">3.6、tables - 表报表</h3><p>在该部分显示了表的使用情况，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">__ Tables ______________________________________________________________<br>Open              107 of 1024    %Cache:  10.45<br>Opened            118    0.06/s<br></code></pre></td></tr></table></figure><p>在Open部分显示了当前打开的表数、可打开的表总数、表缓存的使用率。而在Opened部分则显示了MySQL自启动以来打开的表总数和打开速率。</p><p>在这里我们需要知道两件事：首先，表缓存使用率。如果接近100%，那么可以考虑调大table_cache。其次，打开表的速率。它可以用于确定table_cache是否太低。一般来说，这个值应该小于1/s。但是，对于一个繁忙且运行良好的MySQL服务器来说，每秒打开7个表，并以100%的表缓存使用率运行，也是没有问题的。</p><h3 id="3-7、Connections-连接报表">3.7、Connections - 连接报表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">__ Connections <span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span>_<br>Max used           77 of  600      %Max:  12.83<br>Total             202    0.10/s<br></code></pre></td></tr></table></figure><p>在Max used部分显示了当前并发连接数、允许的最大并发连接数、当前并发连接数与允许的最大并发连接数的比率。而在Total部分则显示了MySQL自启动以来建立连接的总数和建立连接的速率。</p><p>如果连接使用率接近100%（第一行，第三列），则可能需要调大max_connections系统变量。但我们需要知道的是，对于优化良好的服务器来说，即使在非常繁忙的场景下，采用默认值（100）也是适用的。一个到MySQL的连接应该只持续几秒钟，所以即使100个连接也可以用很长时间。如果最大连接数非常高或者随时间缓慢增加，则问题可能出在其他地方，比如查询速度慢、索引不良或甚至DNS解析速度慢等。因此，在调大max_connections之前，先定位出100个连接不够使用的根本原因，并验证这是一个合理的需求而不是其它问题，然后再进行调整。</p><p>关于每秒连接数，这个值可能相当高。事实上，如果该值很高，并且一切运行良好，这也是正常的。通常，超过10个连接/秒是可能的，但大多数服务器的连接/秒都低于5。</p><h3 id="3-8、Created-Temp-临时表报表">3.8、Created Temp - 临时表报表</h3><p>该部分显示了MySQL临时表的创建情况，如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">__ Created Temp <span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><br>Disk table         10    0.00/s<br>Table              26    0.01/s    Size:  4.00M<br>File                3    0.00/s<br></code></pre></td></tr></table></figure><p>MySQL可以在硬盘、RAM和临时文件中创建临时表，分别对应于如上的三行数据。这些值都是相对的，没有一个明确的标准。由于硬盘上的临时表是最慢的（由第一行disk table表示），所以该值应该是三个中最小的一个。只有当MySQL不能在内存（大小由tmp_table_size设置）中创建临时表时，才会在硬盘上创建临时表。tmp_table_size的值由第二行第三列的size指示。理想情况下，应该是在RAM或临时文件中创建临时表。</p><h3 id="3-9、Threads-线程报表">3.9、Threads - 线程报表</h3><p>该部分显示了与MySQL线程相关的信息，如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">__ Threads <span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span>_<br>Running            55 of   77<br>Cache               0              %Hit:    0.5<br>Created           201    0.10/s<br>Slow                0    0.00/s<br><br>__ Aborted <span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span>_<br>Clients             0    0.00/s<br>Connects            8    0.00/s<br><br>__ Bytes <span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">___</span><br><span class="hljs-strong">Sent           38.46M  18.62k/s</span><br><span class="hljs-strong">Received        7.98M   3.86k/s</span><br></code></pre></td></tr></table></figure><p>这里需要特别注意的是，Cache和%Hit。每个到MySQL的连接都是由单独的线程处理的。在启动时，MySQL会创建一些线程，并将这些线程保存在线程缓存中，这样就不必不断地杀死和创建线程。虽然重建线程的成本并不高，但频繁地线程抖动也不好。当并发连接数超过线程缓存（由系统变量thread_cache_size设置）时，MySQL就会开始线程抖动，即疯狂地创建线程以满足新连接的需求。当发生这种情况时，线程缓存命中率会下降。因此，如果MySQL服务器有线程抖动（即线程缓存命中率很低），可以考虑调大线程缓存大小。</p><blockquote><p>如果你有一个繁忙的服务器，并且有很多快速连接，请将你的线程缓存设置得足够高，以便SHOW STATUS中的Threads_created值停止增加。您的 CPU 会感谢您。…线程缓存确实不是我们最糟糕的问题。但在我们修复了所有较大的问题之后，情况变得更糟。</p></blockquote><p>在这个例子中，线程缓存的命中率非常低，只有0.5%，这意味着几乎每一个新连接都会导致MySQL创建一个新线程。很容易看出原因：Cache行的第一列表示线程缓存中剩余零个线程。因此，应该调大线程缓存大小。此外，需要注意的是，这里的Created行与前面的connections total行之间的相关性，即201个线程创建和202个总连接数之间的相关性。因此，这里的线程缓存命中率几乎为0。</p><h3 id="3-10、InnoDB-Buffer-Pool-InnoDB缓存池报表">3.10、InnoDB Buffer Pool - InnoDB缓存池报表</h3><p>我们知道，InnoDB引擎会将索引数据和表数据都缓存到Buffer Pool中，而在其内部实现上，InnoDB Buffer Pool则是由包含不同类型数据的16KB页组成。因此，该部分显示了InnoDB Buffer Pool中页的使用情况，如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">__</span> InnoDB Buffer Pool __________________________________________________<br><span class="hljs-attribute">Usage</span>           <span class="hljs-number">3</span>.<span class="hljs-number">95</span>M of   <span class="hljs-number">7</span>.<span class="hljs-number">00</span>M  %Used:  <span class="hljs-number">56</span>.<span class="hljs-number">47</span><br><span class="hljs-attribute">Read</span> hit       <span class="hljs-number">99</span>.<span class="hljs-number">99</span>%<br><span class="hljs-attribute">Pages</span><br>  <span class="hljs-attribute">Free</span>            <span class="hljs-number">195</span>            %Total:  <span class="hljs-number">43</span>.<span class="hljs-number">53</span><br>  <span class="hljs-attribute">Data</span>            <span class="hljs-number">249</span>                     <span class="hljs-number">55</span>.<span class="hljs-number">58</span> %Drty:   <span class="hljs-number">0</span>.<span class="hljs-number">00</span><br>  <span class="hljs-attribute">Misc</span>              <span class="hljs-number">4</span>                      <span class="hljs-number">0</span>.<span class="hljs-number">89</span><br>  <span class="hljs-attribute">Latched</span>           <span class="hljs-number">0</span>                      <span class="hljs-number">0</span>.<span class="hljs-number">00</span><br><span class="hljs-attribute">Reads</span>         <span class="hljs-number">574</span>.<span class="hljs-number">56</span>k     <span class="hljs-number">0</span>.<span class="hljs-number">6</span>/s<br>  <span class="hljs-attribute">From</span> file       <span class="hljs-number">176</span>     <span class="hljs-number">0</span>.<span class="hljs-number">0</span>/s            <span class="hljs-number">0</span>.<span class="hljs-number">03</span><br>  <span class="hljs-attribute">Ahead</span> Rnd         <span class="hljs-number">4</span>     <span class="hljs-number">0</span>.<span class="hljs-number">0</span>/s<br>  <span class="hljs-attribute">Ahead</span> Sql         <span class="hljs-number">2</span>     <span class="hljs-number">0</span>.<span class="hljs-number">0</span>/s<br><span class="hljs-attribute">Writes</span>        <span class="hljs-number">160</span>.<span class="hljs-number">82</span>k     <span class="hljs-number">0</span>.<span class="hljs-number">2</span>/s<br><span class="hljs-attribute">Flushes</span>         <span class="hljs-number">1</span>.<span class="hljs-number">04</span>k     <span class="hljs-number">0</span>.<span class="hljs-number">0</span>/s<br><span class="hljs-attribute">Wait</span> Free           <span class="hljs-number">0</span>       <span class="hljs-number">0</span>/s<br></code></pre></td></tr></table></figure><p>我们可以看到，配置的InnoDB Buffer Pool大小为7M，当前使用了3.95M，占总大小的56.47%。</p><p>Read hit是指读操作（读索引/读数据）命中缓存的比率。该值应该非常接近100%，在多数情况下，该值大于99.98%。</p><p>在Pages部分显示了Buffer Pool的详细使用情况。每一行对应不同类型的缓存页，它们分别是：</p><ul><li>Free，空闲页。是指剩余可用的缓存页。如上，剩余195个缓存页，占Buffer Pool总大小的43.43%。</li><li>Data，数据页。是指缓存索引和数据所使用的页。如上，缓存索引和数据使用了249个缓存页，占Buffer Pool总大小的55.58%，其中包含0%的脏页（已修改但尚未刷新到磁盘的数据页）。</li><li>Misc，杂页。是指因分配了管理任务（如行锁、自适应哈希索引等）而繁忙的数据页。如上，有4个繁忙的页，占Buffer Pool总大小的0.89%。</li><li>Latched，锁页。是指当前正在进行读取或写入操作的页，或者是由于一些原因无法刷新或删除的页。</li></ul><p>在Reads部分显示了InnoDB Buffer Pool的读取活动。它们的含义如下：</p><ul><li>第一行，是缓冲池的读取情况。在繁忙的服务器上，这个值应该很高，因为InnoDB会从位于RAM的缓冲池中读取大部分页面。该值可用于衡量InnoDB缓冲池的写吞吐量。由于InnoDB所需的几乎所有内容都可以保存在缓冲池中，并可以从中检索数据，因此缓冲池的读取速度应该是很快的。如上，当前InnoDB缓冲池的读取速率为0.6k/s，但它超过200k/s也是有可能的。</li><li>第二行，是指因InnoDB缓冲池无法满足，而从磁盘读取的次数。</li><li>第三行，是InnoDB发起的随机预读数。当查询随机顺序扫描一个表的部分内容时，就会发生这种情况。</li><li>第四行，是InnoDB发起的顺序预读数。当查询执行顺序全表扫描时，就会发生这种情况。该值应该尽可能小。</li></ul><p>在Writes部分显示了InnoDB Buffer Pool的写入活动。可以看作是InnoDB缓冲池的写吞吐量。该行列出了写缓冲池的次数和速率。在执行了大量的update或insert操作的服务器上，该值可能会很高。</p><p>在Flushes部分显示了Buffer Pool页面刷新的请求数。</p><p>在Wait Free部分显示了使用Buffer Pool时的等待情况。通常，对InnoDB缓冲池的写操作是在后台进行的。但在读取或创建一个页面，而又没有可用的干净页时，需要等待页面先刷新。如果缓冲池大小设置正确，则该值应该很小。</p><h3 id="3-11、InnoDB-Lock-InnoDB锁报表">3.11、InnoDB Lock - InnoDB锁报表</h3><p>我们知道，MyISAM是表级锁，InnoDB是行级锁。该部分显示了InnoDB行锁的情况，如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">__ InnoDB Lock <span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span><span class="hljs-strong">____</span>_<br>Waits               0       0/s<br>Current             0<br>Time acquiring<br>  Total             0 ms<br>  Average           0 ms<br>  Max               0 ms<br></code></pre></td></tr></table></figure><p>在Waits部分显示了等待锁的次数。该部分最好为零。</p><p>在Current部分显示了当前正在等待行锁的数量。该部分最好为零。</p><p>在Time acquiring部分显示了在等待行锁时所花费的时间情况，它们的含义分别是：</p><ul><li>Total：等待行锁的总毫秒数</li><li>Average：等待行锁的平均毫秒数</li><li>Max：等待行锁的最大毫秒数</li></ul><p>根据经验，锁平均时间最好接近零。锁次数可以有，因为这个值是累加的，所以数据库启动时间长，用得多，锁次数就会增加。</p><h3 id="3-12、InnoDB-Data、Pages、Rows-InnoDB数据、页、行信息报表">3.12、InnoDB Data、Pages、Rows - InnoDB数据、页、行信息报表</h3><p>该部分显示了用于衡量InnoDB引擎吞吐量的一些常用指标，如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">__</span> InnoDB Data, Pages, Rows ____________________________________________<br> <span class="hljs-attribute">Data</span><br>   <span class="hljs-attribute">Reads</span>           <span class="hljs-number">225</span>     <span class="hljs-number">0</span>.<span class="hljs-number">0</span>/s<br>   <span class="hljs-attribute">Writes</span>          <span class="hljs-number">799</span>     <span class="hljs-number">0</span>.<span class="hljs-number">0</span>/s<br>   <span class="hljs-attribute">fsync</span>           <span class="hljs-number">541</span>     <span class="hljs-number">0</span>.<span class="hljs-number">0</span>/s<br>   <span class="hljs-attribute">Pending</span><br>     <span class="hljs-attribute">Reads</span>           <span class="hljs-number">0</span><br>     <span class="hljs-attribute">Writes</span>          <span class="hljs-number">0</span><br>     <span class="hljs-attribute">fsync</span>           <span class="hljs-number">0</span><br><br> <span class="hljs-attribute">Pages</span><br>   <span class="hljs-attribute">Created</span>          <span class="hljs-number">23</span>     <span class="hljs-number">0</span>.<span class="hljs-number">0</span>/s<br>   <span class="hljs-attribute">Read</span>            <span class="hljs-number">226</span>     <span class="hljs-number">0</span>.<span class="hljs-number">0</span>/s<br>   <span class="hljs-attribute">Written</span>       <span class="hljs-number">1</span>.<span class="hljs-number">04</span>k     <span class="hljs-number">0</span>.<span class="hljs-number">0</span>/s<br><br> <span class="hljs-attribute">Rows</span><br>   <span class="hljs-attribute">Deleted</span>      <span class="hljs-number">25</span>.<span class="hljs-number">04</span>k     <span class="hljs-number">0</span>.<span class="hljs-number">0</span>/s<br>   <span class="hljs-attribute">Inserted</span>     <span class="hljs-number">25</span>.<span class="hljs-number">04</span>k     <span class="hljs-number">0</span>.<span class="hljs-number">0</span>/s<br>   <span class="hljs-attribute">Read</span>         <span class="hljs-number">81</span>.<span class="hljs-number">91</span>k     <span class="hljs-number">0</span>.<span class="hljs-number">1</span>/s<br>   <span class="hljs-attribute">Updated</span>           <span class="hljs-number">0</span>       <span class="hljs-number">0</span>/s<br></code></pre></td></tr></table></figure><p>在Data部分显示了四个与InnoDB数据相关的操作情况，它们分别是：</p><ul><li>Read，指InnoDB引擎执行的数据读取总次数。</li><li>Writes，指InnoDB引擎执行的数据写入总次数。</li><li>fsync，指InnoDB引擎将数据从RAM刷入磁盘的总次数。通常，该值低于读或写。</li><li>Pending，指当前被挂起的数据读取、写入和同步的总次数。这些值最好为零。</li></ul><p>在Pages部分显示了三个与InnoDB缓存页相关的操作情况，它们分别是：</p><ul><li>Created，是指在InnoDB缓存池中创建页的数量和速率；</li><li>Read，是指在InnoDB缓存池中读取页的数量和速率；</li><li>Written，是指在InnoDB缓存池中写入页的数量和速率；</li></ul><p>在Rows部分显示了四个与InnoDB表中行相关的操作情况，它们分别是：</p><ul><li>Deleted，是指从InnoDB表中删除的行数量和速率；</li><li>Inserted，是指在InnoDB表中插入的行数量和速率；</li><li>Read，是指从InnoDB表中读取的行数量和速率；</li><li>Updated，是指在InnoDB表中更新的行数量和速率；</li></ul><h2 id="四、参考">四、参考</h2><p><a href="https://github.com/daniel-nichter/hackmysql.com/tree/master/mysqlreport">https://github.com/daniel-nichter/hackmysql.com/tree/master/mysqlreport</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>mysqlreport</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何高效复盘</title>
    <link href="/2022/01/09/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%A4%8D%E7%9B%98/"/>
    <url>/2022/01/09/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%A4%8D%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<p>复盘，就是从即将结束的项目中，总结成功经验，吸取失败教训。</p><p>当我们开始做一件事情时，首先要有明确的目标，并要制定出相应的执行计划；然后在执行了一段时间后，停下来，对执行情况进行复盘；最后分析的得出：什么事情要继续做、什么事情要停止做、什么事情要开始做。</p><h2 id="一、Why">一、Why</h2><blockquote><p>你在某个会上，给负责产品的副总裁交代了一个任务：去德国考察。某天你问他进展如何，他说：“啊？我正忙着质量改进，还没有空想这件事，真要去考察啊？”交代的事情，没有下文，怎么办？</p></blockquote><p>我讲过一个“方法”：PDCA循环。PDCA循环，又称戴明循环。P-D-C-A这四个字母，分别代表：Plan（计划），Do（行动），Check（检查），Act（处理）。它的本质，就是给任何事情扣上闭环，有开始就必须有结束，避免石沉大海，做到：凡事有交代，件件有着落，事事有回音。你知道了PDCA循环。但是，你做到了吗？</p><blockquote><p>你把目标分解成任务，把任务分配给员工。任务结束后，你对结果不满意。你说打个分吧。满分1分，你只打了0.3分，单员工给自己打了0.9分。为什么会这样？为什么大家对同一件事情的认知，差别这么大呢？这是因为，大家对任务，和完成任务的标准认识不统一。怎么办？</p></blockquote><p>我讲过一个“方法”：SMART原则。SMART原则，是一套指定目标的原则。S-M-A-R-T这5个字母，代表Specific（具体的），Measurable（可衡量的），Attainable（可实现的），Relevant（相关的）和Time-Based（有时间限制的）。它的本质是，砍掉模棱两可，砍掉标准争议，砍掉不切实际，砍掉无关目标，砍掉无线拖延，让目标从“一千个人心中的一千个哈姆雷特”，变成同一个。你知道了SMART原则。但是，你做到了吗？</p><blockquote><p>你特别想自律，也特别想借助“他律”的方法，把最后期限作为第一生产力，一段一段地冲刺马拉松，但你和你的团队，总是与自己的懒惰握手言和。怎么办？</p></blockquote><p>我讲过一个“方法”：Scrum方法。Scrum方法，就是由三个角色（产品负责人，Scrum专家，团队成员）、四个仪式（冲刺计划会，每日站会，冲刺评审会，冲刺回顾会）和三个物件（产品积压，冲刺积压，燃尽图）组成的一套项目管理方法。它的本质，是把一次漫长的长跑，分割成一段段全力以赴的冲刺，通过流程提高效率。你知道了Scrum方法。但是，你做到了吗？</p><blockquote><p>这个世界上，有那么多管理方法取之不尽、用之不竭，PDCA循环，SMART原则，Scrum方法…但是，你是不是深受触动之后，到今天都没有行动呢？为什么会这样？为什么懂了那么多道理，却依然过不好这一生？为什么会了那么多方法，一路走来，一步一个跟头，却依然做不好一件事呢？到底如何做，才能成长得更快一点呢？</p></blockquote><p>答案是：不断复盘。只有不断复盘，才会不断进步。要想达成任务目标，都需要不断复盘。</p><h2 id="二、How">二、How</h2><p>那么，怎么复盘呢？我们来看一个故事。</p><blockquote><p>我一直有个目标，就是徒步“穹顶1维度”，抵达北极点。</p><p>什么是徒步“穹顶1维度”？就是先做直升机，降落到北纬89度北冰洋的浮冰上，然后在“流动”的浮冰上徒步整整一个维度，抵达北极点。</p><p>真有意思。可是，在浮冰上，怎么徒步呢？拿出GPS，打开卫星地图，规划一条能绕开浮冰裂缝，通往北极点的路线。然后，踩着流动的浮冰，出发。坚持走，坚持走。直到晚上，搭帐篷，休息。</p><p>有意思的部分来了。你猜，第二天醒来，你必须要做的一件事是什么？再次拿出GPS，打开卫星地图，看看自己在哪里。然后，重新规划一条能绕开浮冰裂缝，通往北极点的路线。再次出发。</p><p>为什么要重新规划？因为脚下是浮冰啊，它一直在“流动”。早上起来一看，糟糕，睡了一觉，因为昨夜大风，浮冰居然往回流动了50公里。</p></blockquote><p>创业，就是在浮冰上徒步。年初的目标，可以不变，但是路线，可能一直在变。这就需要“调整”。可是，怎么进行调整呢？答案是复盘。复盘，简单来说，就是根据上周的“浮冰”动向，做三件事：继续做（Continue doing）、停止做（Stop doing）、开始做（Start to do）。</p><ul><li><p>什么是“继续做”？上周，经过平常很少交流的几位员工的座位。问了问他们工作的情况，以及需要什么帮助。员工很受鼓舞。嗯，这件事以后要“继续做”。因为这既能帮助自己了解一线情况，也给员工鼓励。</p></li><li><p>什么是“停止做”？上周，月度经营分析会开了4个小时。几个观点来来回回，吵作一团。以后，不按照“六定思考帽”方法开讨论会，这件事要“停止做”。因为这既浪费大家的时间，也很难得出有效结论。</p></li><li><p>什么是“开始做”？上周，我发现几个员工很有潜力，但是没有被放在重要的岗位上锻炼。这是个严重的问题。要通知人力资源部，“开始做”高级潜力员工计划，用有挑战的工作和可以培养，留住优秀员工。</p></li></ul><p>这就是继续做，停止做，和开始做。这就是复盘。 一年有52周。 如果能坚持每周复盘，就会有52次拿出GPS和卫星地图，面朝目标，重新调整路线的机会。 每周逼近自己想要的未来。</p><h2 id="三、How-Good">三、How Good</h2><p>关于复盘，在进化岛社群中，我还分享过一个例子：</p><blockquote><p>我和儿子小米制定了一个每天8：00到学校的目标，以及6:55起床，7:50出门的规划。</p><p>第二天早上，我送他上学，出门的时间是7:48。我就跟他说：祝贺你啊，今天很好，本来我们是预计7:50出门的，你今天提前了2分钟，恭喜啊！恭喜你之后呢，咋们要做个复盘。</p><p>小米在学围棋，已经是围棋的业余一段了。所以我跟他说，复盘这个概念啊，其实就是来自于围棋。一盘棋下完后，你都要再看一遍：刚才我们的每一步棋，哪些其实还可以有更好的下法，这就是复盘。复盘是提升自己的非常重要的一个步骤。如果缺少复盘，我们能学到的东西就少多了。于是我们就来复盘看看，今天出门提前了2分钟，但究竟是在哪里提前的呢？</p><p>昨天我们经过计算，调整了计划，今天你也在行动上做出了改变：我们把起床时间改在了6:55，今天早上你果然在6:55，闹钟一响就起床了，特别棒！然后今天早上我们居然是7:48，提前了2分钟出门，所以要祝贺你！</p><p>但是只看结果还不够，我们还要对规划和执行做一个分析，看看各个环节哪个需要保持（继续做），哪个可以做得更好（开始做），以及哪个不再需要做（停止做），这就是复盘。最大的提前发生在哪里呢？在吃饭环节。昨天我们把吃饭的时间调整为20分钟，但今天早上实际只用了10分钟，也就是吃饭时间其实是大大减少了。</p><p>那为什么吃饭时间会减少了？因为今天早上吃的东西比较方便，才节省了时间。哦，原来这是一个例外情况。节省时间，并不是因为能力的提升，而是因为食物变化。它在执行层面是一个例外，是一个“奖赏”。所以我们应该把它放在一边，不需要调整规划，吃饭时间还是规划为20分钟。</p><p>既然今天花在吃饭上的时间减少了10分钟，那么理论上我们应该是在7:40就能出门的呀，为什么7:48才出门呢？那一定是有地方多了8分钟。我对小米说，你看，这就是复盘的好处。我们不能最后笼统地得出一个结论，说结果是好的，今天咋们做的不错。我们的分开来看，有哪些东西做得是比原来好，又有哪些东西做得不如从前。总得结果好像是略好一些，但其实分项来看，是有好有差的。这样我们才能得出结论说，什么东西继续做，什么东西要改一种方法做，以及什么东西不要做。</p><p>那什么地方多花了8分钟呢？噢！他说，是在吃饭之前。因为早饭还没有准备好，所以多等了8分钟，这样就把时间给花掉了。这样我们就又发现了一个非常重要的规划上的问题，就是等待的8分钟是无所事事的休息，还是安排别的事情。比如说，我们可以把后面收拾书包，或者上厕所等等，这些事情提前。如果这些事情提前做了的话，最后出门的时间就可以早于7:48了。所以呢， 最后我们得出结论，就是：</p><p>第一，吃饭的时间不需要调整（继续做）。</p><p>第二，从安排设计上来说，在早饭没有准备好的情况下，可以把收拾书包等等这些动作提前，统筹使用时间，总体效率会更高（开始做）。</p><p>这就是我们说的复盘。</p></blockquote><h2 id="四、最后的话">四、最后的话</h2><blockquote><p>苏格拉底说：未经审视的人生不值得过。</p></blockquote><p>当我们立下一个目标之后，可以每周六（或周五离开办公室前），给自己留30分钟，做个复盘。复盘，就是给自己一个检视自己的机会。每周检视一次，一年52次。</p><p>那怎么检视呢？可以用自己最自然、最喜欢的方式。格式不重要，检视很重要。但如果实在没有格式，就可以用我们在前面建议的：继续做（Continue doing）、停止做（Stop doing）、开始做（Start to do）。</p><p>检视完之后呢？计划。计划，不用长篇大论。只需要写下一周，觉得一定要做的事情。每周日（或周一早点到办公室），给自己留30分钟，列个计划。每走一段路，看看离目标是越来越近，还是渐行渐远？所有计划，都不会自动变为现实。只有行动可以改变结果。除了周计划，在每个季度结束的时候，还可以进行“季度复盘”。这就和上市公司的季报一样，慎重回顾，不断进步。</p><p>要想达成任何目标，都需要不断复盘。人最大的进步，来自于日常工作的复盘总结、计划、开放的心态。没有复盘，人就会在一个错误的地方，重复的犯错，没有经验积累。只有不断复盘，我们才能不断进步。</p><h2 id="五、参考">五、参考</h2><p><a href="https://mp.weixin.qq.com/s/bIQFgGYQ7ia3T6efEP95uQ">刘润</a></p>]]></content>
    
    
    <categories>
      
      <category>个人成长</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复盘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>愚人船问题</title>
    <link href="/2022/01/08/%E6%84%9A%E4%BA%BA%E8%88%B9%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/08/%E6%84%9A%E4%BA%BA%E8%88%B9%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>传说中有这么一艘船，它所有的操作系统都在船舱里，但这个船舱是密闭的，而且里面没有灯。把一个人扔进船舱里，里面一团漆黑，他只能一点点摸索，慢慢学这个操作系统是如何使用的。</p><p>与此同时，在甲板上还有一群人，他们不仅能看见外面的情况，而且会使用这个系统。于是，他们站在甲板上使劲地喊：前面就是瞧石，你不要往那边开，再开我们就触瞧了。</p><p>但在船舱里的这一位，他不仅在学这个操作系统，而且根本就听不见甲板上的人在说些什么，他只能胡乱地摸索着往前开。如果他足够的幸运，他就能避开礁石。如果他运气不好，可能整船的人都触礁了。</p></blockquote><p>我们的人生不就是一条愚人船吗？现在的我，就是那个站在甲板上的人。而十年前的我，就是那个在密闭船舱里的人。假如，现在我穿越回十年前，我一定会跟自己说：这个事不要干，愚蠢！那件事不要做，那是个陷阱。不要把心思都用在考试上，想办法换个专业，找找实习。然后跟家长说，不要买股票，一定要把所有的钱都投资房产，房地产会涨。在不久的将来会出现一个叫微信的东西，要多积累文章，好成为第一个微信大号。但这个场景永远都不会出现，我们就是那个活在愚人船里的人。</p><p>愚人船问题，看似好像无解，但在现实生活中，还真有人破解了这个问题。比如，著名投资人查理·芒格，作为一个职业投资人，他每天所面对的就是一大堆愚人船问题——识别出现在的哪些公司，在未来能够盈利。面对成千上万的机会，他所采用的投资心法是：坐等投资法。即平时多观察多思考，只投资好项目，然后长期持有。如果没有好项目，就坐等，一旦看准了机会就及时下手。</p><p>在查理·芒格坐等投资法的背后，有两份清单“靠谱清单”和“大坑清单”。他会把所有的潜在投资对象，用两个清单过一遍，符合靠谱清单的就投资，符合大坑清单的就扔掉。一旦遇到两个清单都通过的，那就把全部资本都投进去。</p><h2 id="靠谱清单">靠谱清单</h2><blockquote><p>如何制作自己的靠谱清单？</p></blockquote><p>跨学科思维，即多元思维模型。芒格认为，首先要学数学、定量分析法、决策树和排列组合；还要学点会计学，复式记账法。在剩下的所有学科里，他觉得最重要的是心理学，然后是生物学，再其次是微观经济学。</p><p>lollapalooza效应。它的意思是说，一些事情相互强化并极大地放大彼此效应的因素。就像物理学的临界质量，当达到一定程度的质量，就能引发核爆炸；达不到，就什么变化也没有。</p><p>终身学习。广泛阅读，不停的更新知识储备，丰富人生清单。</p><h2 id="大坑清单">大坑清单</h2><blockquote><p>如何制作自己的大坑清单？</p></blockquote><p>守住自己的能力圈。读传记、行业发展史，有意识的识别傻事，总结自己做过的傻事，其目的是识别自己的能力圈。逆向思考，即反过来想，寻找能力圈边界。</p><h2 id="附：《穷查理宝典》中列举的大坑清单">附：《穷查理宝典》中列举的大坑清单</h2><p>查理·芒格，在《穷查理宝典》一书中列出了人的25种误判清单（思维定势）。</p><ol><li>激励。它是个超级开关。永远不要低估激励的作用，其重要性怎么强调也不过分。只要能用激励，就不要用别的东西。富兰克林曾说过同样的道理——用利益而不是道德来说服人。</li><li>爱。人们渴望爱与被爱，因此对所爱者的缺点熟视无睹，听从其意志，偏爱其所爱，甚至不惜扭曲事实。</li><li>恨。恨与爱恰为镜像，人们为此无视所仇恨者的优点，乃至一切与之相关联的事物，同样不惜扭曲事实。</li><li>讨厌不确定性。人们不愿意陷入怀疑和不确定状态之中，总是想立即做出决定。这是演化而来的，不立即行动的那些猎物早就在进化中被猎食者吃干抹净。它与困惑和压力有关，困惑和压力越大，人们越想尽快摆脱怀疑。</li><li>一致性。人们讨厌前后不一，总想前后协调起来。这使得习惯至关重要，它是让人生保持一致性的快捷方式，后果是好习惯事半功倍，坏习惯事倍功半。</li><li>好奇。人类的好奇心远胜任何动物，这是一方面。另一方面，好细心害死猫。</li><li>公平。己所不欲，勿施于人。</li><li>嫉妒。圣经禁止人嫉妒有驴子的邻居，可是没用。巴菲特甚至说，推动世界的不是贪婪，而是嫉妒。</li><li>投桃报李，以牙还牙。没有它，人类不可能进化合作。但它也可以被利用来操纵人。给你小恩小惠，你油然而生感激，于是掉进陷阱。大脑本能地想投桃报李，但却不擅长计算数字。</li><li>近朱者赤。哪怕两样东西只是肤浅地联系在一起，也会对人的判断产生联带影响。但如果你得的是“波斯信使综合征”，后果很严重：带来坏消息的信使会被波斯国王杀掉，从此他再也听不到坏消息。</li><li>否认现实。如果现实太令人痛苦，人们会拒绝承认。</li><li>过度重视自己。人们总是认为自己拥有的东西更好，喜欢与自己相似的人。好处是安全，坏处是形成同类的小圈子，锁死在互相欣赏但逐渐衰败的螺旋里。伟大人物则相反，他们经常清扫房间，断舍离。</li><li>过度自信。这类人往往会高估自己对别人的判断。少想自己，多想概率，先别想自己能否做成一件事，去想这件事以前的成功率是多少。</li><li>厌恶损失。人们厌恶确定的损失，甚至不惜去冒巨大的风险来避免。</li><li>寻找认同。青少年受同伴影响远胜于家庭。成人也一样，在认同感的驱使下做出不可设想的事情，比如在集体中，普通人能对他人施以不可想象的暴力。</li><li>对标。记住别买附件。因为附件这门生意，就是建立在对标基础上的。我们做判断，总是长于找对标、作比较，也就是相对视角，非常不擅长于绝对视角。</li><li>压力。压力有二重性。套用保普洛夫对狗的研究：第一，压力会使用人崩溃；第二，压力若足够大，所有人都会崩溃；第三，最坚强的人一旦崩溃，恢复也最难；最有意思的是第四，恢复的唯一途径是重新施加巨大压力。</li><li>重视易得的东西。芒格提到一句歌词，“如果我爱的不再身边，我就爱身边的人”。</li><li>用进废退。只有练习才能精进，不过有些技能很不常用，要练到精处，只有随时练习。</li><li>毒品有害。</li><li>衰老。没有谁能在年老后还擅长学习新的复杂技能，迟滞岁月磨损的唯一办法是始终保持思考，怀抱欣喜之心学习。</li><li>服从权威。崇拜权力不是哪个民族的特性，这件事全人类共通。正因如此，把谁放在有权力的位置上这件事，要特别小心。</li><li>闲扯淡。人人都爱闲扯淡，这没什么办法，但你的尽量做到别让闲扯淡的人打扰做正事的人。</li><li>万事有理由。人们重视理由到什么地步？只要说了“因为”两个字，不管后面说什么，别人都会多让你一点。</li><li>这是个总开关，组合开关。如果把前面的单个开关组合起来，效果会更为强烈。比如，“厌恶损失”与“追求一致性”结合起来，使人不断在失败的事情上追加下注，直到全部输光。而“服从权威”、“追求一致性”，再加上“寻找认同”，则容易创造一些极端组织。</li></ol>]]></content>
    
    
    <categories>
      
      <category>个人成长</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>必知的金融知识</title>
    <link href="/2022/01/01/%E5%BF%85%E7%9F%A5%E7%9A%84%E9%87%91%E8%9E%8D%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/01/01/%E5%BF%85%E7%9F%A5%E7%9A%84%E9%87%91%E8%9E%8D%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>金融与我们的生活息息相关。一说到金融，就绕不开资产价格，而资产价格又绕不开楼市和股市。因此，懂一些必要的金融知识，不仅有助于我们理解当下的金融现象，而且还能辅助我们的个人投资决策。在庞大的金融知识体系中，有三个我们必须要理解的核心概念，它们分别是：</p><ul><li>货币发行。我们常说的“印钞”、“放水”对应的就是货币的扩张发行。</li><li>物价涨跌。我们常说的“通胀（物价上涨）”、“通缩（物价下跌）”，对应的则是物价的涨跌现象。</li><li>资产价格。我们常说的“财富缩水”、“稀释”、“洗劫”，对应的就是资产价格的运作规律。</li></ul><p>接下来，我们认识一下这三个概念。</p><h2 id="一、货币发行">一、货币发行</h2><p>现阶段，我国以间接金融为主体，调节货币供应量主要通过央行存款准备金率以及其他一些对银行的管理指标来进行。</p><h3 id="1-1、直接金融-vs-间接金融">1.1、直接金融 vs 间接金融</h3><p>与美国相比，我国的金融系统更加基础、更加初级。一个重要的特征是，以银行这种间接金融为主。</p><p>根据承担风险和收益的主体是否为个人，我们可以将金融分为直接金融和间接金融。</p><p>股票市场、债券市场这种资本市场就是典型的直接金融。我们买股票、买债券，收益和风险都是我们自己的，赚了没人来一份，亏了没人来管。</p><p>银行就是典型的间接金融。我们把钱存在银行，银行拿去放贷，它放贷亏了还是赚了，跟我们没半毛钱关系，只要它没有倒闭，它就会给我们保本保息。在这里，收益和风险都隔断在了银行手里，没有传导给我们。</p><h3 id="1-2、金融技术指标">1.2、金融技术指标</h3><p>我们常听到或看到的一些名词，比如，广义货币、狭义货币、M0、M1、M2等，并不是货币银行学的理论概念，而是日常实用性的金融技术指标。</p><ul><li><p>M0，就是社会上的现金纸币。由于电子支付的发展，该指标已经不具备衡量价值了。</p></li><li><p>M1，可用来衡量狭义货币，等于M0 + 银行各类活期存款，通常用于衡量社会当下的购买力。受支付宝、零钱通的影响，该指标的影响力也在下降。</p></li><li><p>M2，可用来衡量广义货币，等于M1 + 定期存款 + 货币基金 + 证券保证金。M2高速增长，意味着投资旺盛，说明远期购买力会增长。</p></li></ul><h3 id="1-3、存款准备金">1.3、存款准备金</h3><p>我们知道，当我们把钱存入银行时，银行会拿去放贷。而由于央行的各种限制，银行是不能随意放贷的。存款准备金率、存贷比、资本充足率、拨备覆盖率等都是央行用来限制银行发放贷款的主要指标。其中，存款准备金率是央行用来调节货币供应的主要手段。为了便于理解，我们来看这样一个场景：</p><blockquote><p>假设这个世界上只有我们手里的200块钱，我们将其中的100块钱存入银行，此时我们就有了100块钱的纸币现金 + 100块钱的存款。</p><p>现假设央行规定的存款准备金率为10%，这表示在我们存入银行的100块钱中，有10块钱要存在央行作为存款准备金，因此银行只能发放90块钱的贷款。</p><p>由于借款人一般不会直接拿着现金，还是会存入银行，因此借款人借的90块钱其实又成了银行新的存款。银行进一步放贷，因为10%的存储准备金率的限制，银行最多只能发放81块钱的贷款。这个过程不断反复进行，最终的结果是：</p><p>银行最多会放出去900块钱的贷款，而这些贷款同时也是借款人账户上的存款，这些存款加上我们最初的100块钱存款，全社会总计就有了1000块钱的存款，而央行则会拿到100块钱的存款准备金。</p></blockquote><p>在这个场景中，涉及了三个基本概念：</p><ul><li>基础货币。也叫高能货币，具有成倍信用派生的能力。数值上等于社会上的纸币现金 + 央行的存款准备金。在这个场景中，我们手里的200块钱就是基础货币。纸币现金，是还未进行信用派生的基础货币；存款准备金则是已经进行了信用派生的基础货币。</li><li>信用派生。可以简单的理解成放贷。我们存入银行的100块钱，通过银行系统的信用派生功能，最终会变成银行系统里的1000块存款。用前面的技术指标来看，这里的1000块钱都是M2。因此，M2的高速增长并不是政府印出来的，而是银行系统和借款人通过信用派生产生的。</li><li>货币乘数。是指信用派生的倍率。理论上限是央行存款准备金的倒数。在这个场景中，就是10%的倒数，即10倍。</li></ul><h3 id="1-4、我国的货币系统">1.4、我国的货币系统</h3><p>我国的货币系统可以总结成两点：</p><ul><li>第一，从过去以外汇占款为锚，过度到目前以公开市场工具为导向的基础货币投放体系，辅助以政策性银行作为补充。</li><li>第二，以银行信用派生为主体的广义货币投放体系。银行系统信用派生的核心是抵押物所带来的借款人信用，而抵押物的主体是基建、土地、房产、工业设施、原材料等实体资产。</li></ul><p>总的来说，我国的货币系统就是一个扎根于实体资产的信用系统。这是符合我国经济现实的——我国经济的根就是优质的基础设施和庞大的工业产能。</p><h4 id="1-4-1、广义货币增长史">1.4.1、广义货币增长史</h4><p>我国广义货币的派生历史可以分为四个阶段：</p><ul><li><p>第一阶段，改革开放一直到2008年之前，重头戏在2001年加入WTO之后。这一阶段，外汇是派生M2的主要来源——我们一穷二白，只生产不消费，生产了也都往国外卖，挣了不少外汇；再加上外国企业投资，带来不少外汇。</p></li><li><p>第二阶段，2009年前后的四万亿刺激计划。08年次贷危机后，外部需求熄火，内部又不能大搞消费，所以只能集中在投资上。这一阶段是央行唯一一次主观推动M2高速增长，央行降低银行的信贷管控，各大商业银行朝各地的基建项目和产业投资猛地发放贷款。</p></li><li><p>第三阶段，主要从2011年开始，是对四万亿的善后。</p></li><li><p>第四阶段，大致从2015年前后开始一直到最近，仍然是对四万亿的善后。</p></li></ul><p>总的来说，M2的高速增长是我国总资产规模增长的具体体现。</p><h4 id="1-4-2、基础货币投放方式">1.4.2、基础货币投放方式</h4><p>我国基础货币投放系统，主要分成三个部分：</p><ul><li>外汇。改革开放后，涌入了大量的外汇，而一笔外汇兑换成人民币后就形成了基础货币。</li><li>公开市场工具。从2013年开始，外汇在基础货币投放中的占比下降，央行的基础货币政策向独立化、现代化的方向过度，开始使用公开市场工具。比如，SLO（短期流动性调节工具）、SLF（常设借贷便利）、MLF（中期借贷便利）和PSL（抵押补充贷款）。这些工具本质都是商业银行把抵押物拿给央行，然后央行把相应的一笔钱给到商业银行。</li><li>政策性银行。主要有三大政策性银行，国家开发银行（国开行）、进出口银行（进出行）、农业发展银行（农发行）。它们都是国家出于社会效益的考量而设立的，不太考虑自身盈利。</li></ul><h4 id="1-4-3、我国货币系统的未来">1.4.3、我国货币系统的未来</h4><p>在当今发达国家中，存在着两个方向的发展模式：</p><ul><li>英美模式。英美已经走到了去工业化阶段，即普通工业严重衰败，高端工业有所保留。货币系统不再以实体资产作为信用来源，而是以虚拟资产作为估值主体。</li><li>德日模式。德日是唯二没有走去工业化的发达国家，它们的基建是发达国家中最好的。以银行这样的间接金融为主，是发达国家中发展最为稳定的。</li></ul><p>对于我国而言，我们没得挑，只有都搞，才能满足14亿人的就业和大国的能力需求。说白了，小国才做选择，大国只有我都要。</p><h2 id="二、物价涨跌">二、物价涨跌</h2><p>在美国，美联储用于核算物价、监控通胀的指标叫做The Core PCE Index，即核心PCE物价指数。PCE是Personal Consumption Expenditure（个人消费支出）的缩写。而在我国，衡量通胀的指标是CPI（Consumer Price Index，居民消费价格指数）。这也是国际上通用的指标。</p><p>与CPI相比，PCE一方面会考虑同类商品之间的替代性；另一方面会根据社会变化调整指数内部的权重。理论上，PCE是一个更先进的指标，但在实操上，PCE柔性太大，技术难度过高，因此，不适合我国当下的经济阶段。</p><p>我们知道，市场经济的核心是供给与需求。价值决定价格，供需影响价格。对于通胀与物价，我们只需要记住以下几个结论：</p><ul><li>通胀，不等于“恶性通胀”。对于成熟的经济体来说，经济主要靠消费拉动，消费持续增长，自然会带动温和通胀。</li><li>通胀，可建立在收入增长之上，也可建立在负债增长之上。负债是成熟经济体的主要消费方式之一，但对于负债运用不当，会产生巨大隐患，比如，08年的次贷危机。</li><li>放水，不一定会导致通胀。具体要看水怎么放，放给谁。比如，08年的四万亿计划，大量资金涌入房地产，导致房价大幅上涨。</li></ul><h2 id="三、资产价格">三、资产价格</h2><p>对于资产价格，我们需要记住以下观点：</p><blockquote><p>未来十年乃至二十年，中国股市会像过去十年的中国楼市一样，产生夸张的财富效应。区别在于股市的分化会比楼市大，不会全体普涨。</p><p>未来的增长主要集中在高技术、高水平、高门槛、高风险领域。这意味着，普通人能够直接参与的投资机会在变少、收益在变低、风险在变大，但资金成本却还没有降到很低，所以已经不适合普通人过度负债投资。说人话就是，晚了，“搏一搏，单车变摩托”的时代已经过去了。</p></blockquote><h3 id="3-1、房地产是否就此让位？">3.1、房地产是否就此让位？</h3><p>我们需要知道的是：中国过去15年的房地产发展和上涨历程是特定经济阶段下的特殊情况，而不是常态。</p><p>古往今来，天南地北，都存在的一个客观事实是：只要国家和平、社会稳定、经济能够正常发展，不管发展快慢，房地产的内在价值都是增加的。古代地主也好，现代房地产也罢，都能够被动分得经济发展的红利。</p><p>对于房地产的未来，我们只需记住以下几个结论：</p><ul><li>第一，房价不会实质性下跌。大范围、长周期来看，还是涨的。</li><li>第二，暴涨情况也不会再现。大范围、长周期来看，很难大幅跑赢整体经济增速。</li><li>第三，时间上会有周期性的兴衰，空间上则会有分布不均匀的情况。未来，核心大城市的高档房产和大多数城市的多数普通房产，两者的价格走势大概率会严重分化。</li></ul><h3 id="3-2、A股到底行不行？">3.2、A股到底行不行？</h3><h2 id="四、参考">四、参考</h2><p><a href="https://appe0mes6qx8480.h5.xiaoeknow.com/content_page/eyJhcHBfaWQiOiJhcHBlME1FczZxWDg0ODAiLCJzaGFyZV9mcm9tIjoidV81N2ViNGQwYTkzZDZkX0REaXR1SDM2IiwicHJvZHVjdF9pZCI6InBfNWYxMTFhZjFlNGIwZWUwYjg4NzMxNDUyIiwicmVzb3VyY2VfaWQiOiIiLCJ0eXBlIjozLCJyZXNvdXJjZV90eXBlIjo2LCJzaGFyZV9hZ2VudCI6ImFwcCIsImZlYXR1cmUiOiJmZV93eGIiLCJjb250ZW50X2FwcF9pZCI6IiIsInNvdXJjZSI6IiJ9?app_version=2.8.2">东西情报站</a></p>]]></content>
    
    
    <categories>
      
      <category>金融</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>原生家庭</title>
    <link href="/2021/12/25/%E5%8E%9F%E7%94%9F%E5%AE%B6%E5%BA%AD/"/>
    <url>/2021/12/25/%E5%8E%9F%E7%94%9F%E5%AE%B6%E5%BA%AD/</url>
    
    <content type="html"><![CDATA[<p>当一个孩子对自己的父母完全失去信任后，除了自己，他不会对任何人抱有期待。而当他对自身能力也完全失去信心后，生活中在小的挫折，也都有可能变成压倒他的最后一根稻草。</p><p>未经他人苦，莫劝人善良。如果有人告诉他，他有选择自私的权利，或许他不会做出这样的选择；如果有人告诉他，当一段关系不能带给他力量时，他可以选择远离，或许他不会做出这样的选择；如果有人告诉他，在面对原生家庭问题的路上，其实他并非孤军奋战，或许他不会做出这样的选择。</p><p>人生实苦，唯有自渡。假如在大学时没有逼着自己养成阅读的习惯，假如在大学时没有逼着自己养成跑步的习惯，假如在大学时没有逼着自己习得一技之长，或许在人生的某个时刻，我也会做出和他相同的选择。坚持阅读，让我对原生家庭有了更深刻地思考，也能更理性的看待原生家庭的问题；坚持跑步，让我变得自信、积极乐观，同时也有了释放焦虑和不安的出口；一技之长，让我实现经济独立，带给我远离原生家庭的勇气。</p><p>这世上只有一种英雄主义，那就是在看清生活的真相之后，依然热爱生活。以前总觉得自杀是一件很有“勇气”的事情，记得小时候和父母闹矛盾，一度怀疑自己是不是他们亲生的，甚至脑海中有过自杀的念头，只是当时没有行动的勇气。直到读到这么一句话：“她说，人生海海，敢死不叫勇气，活着才需要勇气。”这才对自杀这件事有了全新的认识。</p><p>我命由我不由天。运气是上天给予的，我们无权选择，更无力改变。但命却是我们可以通过努力来改变的。不好的原生家庭，只是我们前半生交到的一次霉运，但它并不会决定我们往后的人生。只不过，我们必须面对并承认这样一个事实，要想摆脱原生家庭带给我们的影响，过上幸福的人生，需要我们付出比常人更多的努力，仅此而已。</p><p>最后，如果你也被原生家庭问题困扰着，可以读读这几本书：《被讨厌的勇气》、《幸福的勇气》、《你当像鸟飞往你的山》和《回归故里》，读完这几本书，对于原生家庭问题你应该会有新的认识。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>碎碎念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>访问控制：基于角色的权限控制</title>
    <link href="/2021/03/14/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%9A%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <url>/2021/03/14/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%9A%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>todo</p><h2 id="一、RBAC是什么">一、RBAC是什么</h2><p>RBAC，是Role-Based Access Control的缩写，即基于角色的访问控制。在Kubernetes项目中，负责完成认证和授权工作的就是RBAC，它主要由三个最基本的内容组成：</p><ul><li>Subject：使用者，即可以是“人”，也可以是“机器”，还可以是我们在Kubernetes中定义的“用户”。</li><li>Role：角色，它就是一组权限规则，定义了一组可以对Kubernetes API对象进行操作的权限。</li><li>RoleBinding：角色绑定，它定义了“使用者”和“角色”的绑定关系。</li></ul><h2 id="二、如何使用RBAC">二、如何使用RBAC</h2><h3 id="2-1、定义Role">2.1、定义Role</h3><p>在Kubernetes项目中，Role就是一个API对象，它的定义如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">mynamespace</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-role</span><br><span class="hljs-attr">rules:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>  <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;pods&quot;</span>]<br>  <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>,<span class="hljs-string">&quot;list&quot;</span>]<br></code></pre></td></tr></table></figure><p>首先，我们在名为mynamespace的Namespace下，定义了一个名为my-role的Role对象。</p><p>然后，我们通过rules字段为my-role这个Role对象定义了权限规则。如上，这条规则的含义是：允许“使用者”，对mynamespace下面的Pod对象，进行get、watch和list操作。</p><h3 id="2-2、定义RoleBinding">2.2、定义RoleBinding</h3><p>在有了Role后，我们就可以将Role绑定到使用者上了，也即进行RoleBinding。在kubernetes项目中，RoleBinding也是一个API对象，它的定义如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">RoleBinding</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mynamespace</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-rolebinding</span><br><span class="hljs-attr">subjects:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">User</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-user</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-role</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br></code></pre></td></tr></table></figure><p>首先，我们通过subjects字段声明了“使用者”的信息，它的类型是User，它的名字是my-user。</p><p>然后，通过roleRef字段，我们直接引用了之前创建的Role对象。</p><p>这样，我们就完成了role和&quot;使用者&quot;的绑定关系，是不是很简单。</p><h2 id="三、理解Subject">三、理解Subject</h2><p>在上面的例子中，我们是不是会有这样的困惑：</p><blockquote><p>在Kubernets中，并没有User类型的API对象。而且，我们也没有创建过User，那这个User到底是从哪里来的呢？</p></blockquote><p>其实，Kubernetes中的“User”，就是“用户”，它只是授权系统中的一个逻辑概念。它需要通过外部认证服务（比如，Keystone）来提供。此外，我们还可以直接给API Server指定一个用户名、密码文件。这样，Kubernetes的授权系统，就可以从这个文件中找到对应的“用户”了。</p><p>在大多数时候，我们其实不会使用“用户”这个功能。在私有环境中，我们只要使用Kubernetes提供的内置“用户”，就足够了。而这个内置用户，就是ServiceAccount。</p><h3 id="3-1、实践ServiceAccount">3.1、实践ServiceAccount</h3><h4 id="3-1-1、定义ServiceAccount">3.1.1、定义ServiceAccount</h4><p>首先，我们定义一个ServiceAccount，它也是一个API对象，定义如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">mynamespace</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-sa</span><br></code></pre></td></tr></table></figure><p>可以看到，一个最简单的 ServiceAccount 对象只需要 Name 和 Namespace 这两个最基本的字段。</p><h4 id="3-1-2、定义Role">3.1.2、定义Role</h4><p>然后，我们直接使用上面定义的Role对象：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">mynamespace</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-role</span><br><span class="hljs-attr">rules:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>  <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;pods&quot;</span>]<br>  <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>,<span class="hljs-string">&quot;list&quot;</span>]<br></code></pre></td></tr></table></figure><h4 id="3-1-3、定义RoleBinding">3.1.3、定义RoleBinding</h4><p>接着，我们定义一个RoleBinding，将Role绑定到ServiceAccount，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">RoleBinding</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">mynamespace</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-rolebinding</span><br><span class="hljs-attr">subjects:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-sa</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">mynamespace</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-role</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br></code></pre></td></tr></table></figure><p>可以看到，在这个 RoleBinding 对象里，subjects 字段的类型（kind），不再是一个 User，而是一个名为 my-sa 的 ServiceAccount。</p><h4 id="3-1-4、创建对象">3.1.4、创建对象</h4><p>最后，我们用 kubectl 命令创建这三个对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f svc-account.yaml</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f role.yaml</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f role-binding.yaml</span><br></code></pre></td></tr></table></figure><h4 id="3-1-5、查看ServiceAccount">3.1.5、查看ServiceAccount</h4><p>当创建完成后，我们可以查看一下这个 ServiceAccount 的详细信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get sa -n mynamespace -o yaml</span><br>- apiVersion: v1<br>  kind: ServiceAccount<br>  metadata:<br>    creationTimestamp: 2018-09-08T12:59:17Z<br>    name: example-sa<br>    namespace: mynamespace<br>    resourceVersion: &quot;409327&quot;<br>    ...<br>  secrets:<br>  - name: example-sa-token-vmfg6<br></code></pre></td></tr></table></figure><p>可以看到，Kubernetes 会为这个 ServiceAccount 自动创建并分配一个 Secret 对象（上述 ServiceAcount 定义里最下面的 secrets 字段）。而这个 Secret对象，就是这个 ServiceAccount 对应的、用来跟 APIServer 进行交互的授权文件，我们一般称它为：Token。Token 文件的内容一般是证书或者密码，它以一个 Secret 对象的方式保存在 Etcd 当中。</p><h4 id="3-1-6、Pod使用ServiceAccount">3.1.6、Pod使用ServiceAccount</h4><blockquote><p>用户有了，也进行了授权，那如何使用这个用户呢？</p></blockquote><p>此时，Kubernetes中的主角Pod就该登场了，我们来看如下定义：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">mynamespace</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">sa-token-test</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.7.9</span><br>  <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">my-sa</span><br></code></pre></td></tr></table></figure><p>在这里，我们定义了 Pod 要使用的 ServiceAccount 的名字是：my-sa。这样，这个Pod就可以以my-sa这个内置用户的身份对APIServer进行一些操作了。</p><h4 id="3-1-7、ServerAccount的真面目">3.1.7、ServerAccount的真面目</h4><p>等这个 Pod 运行起来之后，我们就可以看到，该 ServiceAccount 的 token，也就是Secret 对象，被 Kubernetes 自动挂载到了容器的 /var/run/secrets/kubernetes.io/serviceaccount 目录下，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe pod sa-token-test -n mynamespace</span><br>Name:               sa-token-test<br>Namespace:          mynamespace<br>...<br>Containers:<br>  nginx:<br>    ...<br>    Mounts:<br>      /var/run/secrets/kubernetes.io/serviceaccount from example-sa-token-vmfg6 (ro)<br></code></pre></td></tr></table></figure><p>这时候，我们可以通过 kubectl exec 查看到这个目录里的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it sa-token-test -n mynamespace -- /bin/bash</span><br>root@sa-token-test:/# ls /var/run/secrets/kubernetes.io/serviceaccount<br>ca.crt namespace  token<br></code></pre></td></tr></table></figure><p>如上所示，容器里的应用，就可以使用这个 ca.crt 来访问 APIServer 了。更重要的是，此时它只能够做 GET、WATCH 和 LIST 操作。因为 my-sa 这个 ServiceAccount 的权限，已经被我们绑定的 Role 做了限制。</p><h3 id="3-2、默认ServiceAccount">3.2、默认ServiceAccount</h3><p>到这里，我们可能会有这样的疑问：</p><blockquote><p>我们平时定义Pod时并没有指定ServiceAccount，那是不是说Pod就不能对APIServer进行任何操作了呢？</p></blockquote><p>并不是。在Kubernetes中，如果一个Pod没有声明ServiceAccount，那么Kubernetes 就会自动在它的 Namespace 下创建一个名为 default 的默认 ServiceAccount，然后分配给这个 Pod。</p><p>在默认情况下，这个默认 ServiceAccount 并没有关联任何 Role。也就是说，此时它有访问 APIServer 的绝大多数权限。当然，这个访问所需要的 Token，还是默认 ServiceAccount 对应的 Secret 对象为它提供的，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe sa default</span><br>Name:                default<br>Namespace:           default<br>Labels:              &lt;none&gt;<br>Annotations:         &lt;none&gt;<br>Image pull secrets:  &lt;none&gt;<br>Mountable secrets:   default-token-s8rbq<br>Tokens:              default-token-s8rbq<br>Events:              &lt;none&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get secret</span><br>NAME                  TYPE                                  DATA      AGE<br>default-token-s8rbq   kubernetes.io/service-account-token   3         82d<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe secret default-token-s8rbq</span><br>Name:         default-token-s8rbq<br>Namespace:    default<br>Labels:       &lt;none&gt;<br>Annotations:  kubernetes.io/service-account.name=default<br>              kubernetes.io/service-account.uid=ffcb12b2-917f-11e8-abde-42010aa80002<br><br>Type:  kubernetes.io/service-account-token<br><br>Data<br>====<br>ca.crt:     1025 bytes<br>namespace:  7 bytes<br>token:      &lt;TOKEN数据&gt;<br></code></pre></td></tr></table></figure><p>可以看到，Kubernetes 会自动为默认 ServiceAccount 创建并绑定一个特殊的 Secret：<a href="http://xn--kubernetes-id4r549a128am11cpys.io/service-account-token%EF%BC%9B%E5%AE%83%E7%9A%84">它的类型是kubernetes.io/service-account-token；它的</a> Annotation 字段，<a href="http://xn--kubernetes-tm3px31hjw9a.io/service-account.name=default%EF%BC%8C%E5%8D%B3%E8%BF%99%E4%B8%AA">声明了kubernetes.io/service-account.name=default，即这个</a> Secret 会跟同一 Namespace 下名叫 default 的 ServiceAccount 进行绑定。</p><blockquote><p>注：在生产环境中，强烈建议为所有 Namespace 下的默认 ServiceAccount，绑定一个只读权限的 Role。</p></blockquote><h3 id="3-3、用户组">3.3、用户组</h3><p>除了“用户”（User）外，Kubernetes 还拥有“用户组”（Group）的概念，也就是一组“用户”的意思。如果我们为 Kubernetes 配置了外部认证服务的话，这个“用户组”的概念就会由外部认证服务提供。而对于 Kubernetes 的内置“用户”ServiceAccount 来说，这个“用户组”的概念也同样适用。</p><h4 id="3-3-1、ServiceAccount组">3.3.1、ServiceAccount组</h4><p>实际上，一个 ServiceAccount，在 Kubernetes 里对应的“用户”的名字是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">system:serviceaccount:<span class="hljs-tag">&lt;<span class="hljs-name">Namespace名字</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">ServiceAccount名字</span>&gt;</span><br></code></pre></td></tr></table></figure><p>而它对应的内置“用户组”的名字，就是：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">system:</span>serviceaccounts:&lt;<span class="hljs-keyword">Namespace</span>名字&gt;<br></code></pre></td></tr></table></figure><p>也就是说，ServiceAccount所属的Namespace就是它的组。</p><h4 id="3-3-2、ServiceAccount组的应用">3.3.2、ServiceAccount组的应用</h4><p>比如，现在我们可以在 RoleBinding 里定义如下的 subjects：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">subjects:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">Group</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">system:serviceaccounts:mynamespace</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br></code></pre></td></tr></table></figure><p>这就意味着这个 Role 的权限规则，作用于 mynamespace 里的所有 ServiceAccount。这就用到了“用户组”的概念。</p><h2 id="四、理解ClusterRole">四、理解ClusterRole</h2><h3 id="4-1、从rules字段说起">4.1、从rules字段说起</h3><p>我们先来看一下rules字段，它由如下五个字段构成：</p><ul><li>apiGroups（string array）：声明规则是为哪些API组下的资源定义的。如上，空（“”）表示核心API组。</li><li>resources（string array）：定义规则在哪些资源上生效。如上，Pods表示将规则应用的Pod对象上。</li><li>verbs（string array）：定义可以对资源进行哪些操作。如上，表示可以对资源进行get、watch和list等操作。</li><li>resourceNames（string array）：是一个可选字段。它是一个资源名称的白名单，即允许规则在哪些特定的资源上生效。</li><li>nonResourceURLs（string array）：定义了用户可访问的URL。它支持使用“*s”的形式，但只作用于整个url的最后一部分，因为nonResourceURL是没有namespace的，所以该形式，只适用于ClusterRole。一个规则可以在API资源（比如，Pod和Secret）上生效，也可以在非资源的URL（比如，/api）上生效，但不能同时在两者上生效。</li></ul><p>从这里可以看出，在kubernetes项目中，还存在一种ClusterRole对象，那么ClusterRole是用来干什么的呢？</p><h3 id="4-2、ClusterRole-ClusterRoleBinding">4.2、ClusterRole &amp; ClusterRoleBinding</h3><p>我们需要知道的是，Role 和 RoleBinding 对象都是 Namespaced 对象（Namespaced Object），即它们的权限规则仅在它们自己的 Namespace 内有效，roleRef 也只能引用当前 Namespace 里的 Role 对象。</p><blockquote><p>那么，对于非 Namespaced（Non-namespaced）对象（比如：Node），或者，某一个 Role 想要作用于所有的 Namespace 的时候，我们又该如何去做授权呢？</p></blockquote><p>这时候，我们就必须要使用 ClusterRole 和 ClusterRoleBinding 这两个组合了。这两个 API 对象的用法跟 Role 和 RoleBinding 完全一样。只不过，它们的定义里，没有了 Namespace 字段，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-clusterrole</span><br><span class="hljs-attr">rules:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>  <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;pods&quot;</span>]<br>  <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>]<br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-clusterrolebinding</span><br><span class="hljs-attr">subjects:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">User</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-user</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-clusterrole</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br></code></pre></td></tr></table></figure><p>通过如上ClusterRole 和 ClusterRoleBinding 的组合，名为 my-user 的用户，就拥有对所有 Namespace 里的 Pod 进行 GET、WATCH 和 LIST 操作的权限。</p><h3 id="4-3、系统保留的ClusterRole">4.3、系统保留的ClusterRole</h3><p>在 Kubernetes 中已经内置了很多个为系统保留的 ClusterRole，它们的名字都以 system: 开头。我们可以通过 <code>kubectl get clusterroles </code>查看到它们。</p><p>一般来说，这些系统 ClusterRole，是绑定给 Kubernetes 系统组件对应的 ServiceAccount 使用的。比如，其中一个名叫 system:kube-scheduler 的 ClusterRole，定义的权限规则是 kube-scheduler（Kubernetes 的调度器组件）运行所需的必要权限。我们可以通过如下指令查看这些权限的列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe clusterrole system:kube-scheduler</span><br>Name:         system:kube-scheduler<br>...<br>PolicyRule:<br>  Resources                    Non-Resource URLs Resource Names    Verbs<br>  ---------                    -----------------  --------------    -----<br>...<br>  services                     []                 []                [get list watch]<br>  replicasets.apps             []                 []                [get list watch]<br>  statefulsets.apps            []                 []                [get list watch]<br>  replicasets.extensions       []                 []                [get list watch]<br>  poddisruptionbudgets.policy  []                 []                [get list watch]<br>  pods/status                  []                 []                [patch update]<br></code></pre></td></tr></table></figure><p>这个 system:kube-scheduler 的 ClusterRole，就会被绑定给 kube-system Namesapce 下名叫 kube-scheduler 的 ServiceAccount，它正是 Kubernetes 调度器的 Pod 声明使用的 ServiceAccount。</p><p>除此之外，Kubernetes 还提供了四个预先定义好的 ClusterRole 来供用户直接使用：</p><ul><li>cluster-admin</li><li>addmin</li><li>edit</li><li>view</li></ul><p>通过它们的名字，我们应该能大致猜出它们都定义了哪些权限。比如，这个名叫 view 的 ClusterRole，就规定了使用者只有 Kubernetes API 的只读权限。</p><p>我们需要注意的是，上面这个 cluster-admin 角色，对应的是整个 Kubernetes 项目中的最高权限（verbs=*），如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe clusterrole cluster-admin</span><br>Name:         cluster-admin<br>Labels:       kubernetes.io/bootstrapping=rbac-defaults<br>Annotations:  rbac.authorization.kubernetes.io/autoupdate=true<br>PolicyRule:<br>  Resources  Non-Resource URLs Resource Names  Verbs<br>  ---------  -----------------  --------------  -----<br>  *.*        []                 []              [*]<br>             [*]                []              [*]<br></code></pre></td></tr></table></figure><p>所以，务必要谨慎而小心地使用 cluster-admin。</p><h3 id="4-4、权限设置">4.4、权限设置</h3><p>在 Role 或者 ClusterRole 里面，如果要赋予用户 my-user 所有权限，那我们就可以给它指定一个 verbs 字段的全集，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>, <span class="hljs-string">&quot;create&quot;</span>, <span class="hljs-string">&quot;update&quot;</span>, <span class="hljs-string">&quot;patch&quot;</span>, <span class="hljs-string">&quot;delete&quot;</span>]<br></code></pre></td></tr></table></figure><p>这些就是当前 Kubernetes（v1.11）里能够对 API 对象进行的所有操作了。</p><p>类似地，Role 对象的 rules 字段也可以进一步细化。比如，我们可以只针对某一个具体的对象进行权限设置，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">rules:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>  <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;configmaps&quot;</span>]<br>  <span class="hljs-attr">resourceNames:</span> [<span class="hljs-string">&quot;my-config&quot;</span>]<br>  <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>]<br></code></pre></td></tr></table></figure><p>这个例子就表示，这条规则的“被作用者”，只对名叫“my-config”的 ConfigMap 对象，有进行 GET 操作的权限。</p><h2 id="五、小结">五、小结</h2><p>在这篇文章中，我们主要讨论了Kubernetes项目中的RBAC机制，我们需要掌握如下几个概念：</p><ul><li>Subject：使用者，即认证用户，它可以是“用户”，也可以是“用户组”，在Kubernetes中通常使用的是ServiceAccount（Kubernetes系统的内置用户）。</li><li>Role：角色，即一组权限规则，它可以分为Role和ClusterRole，前者的作用范围是特定的Namespace，后者的作用范围是所有的Namespace。</li><li>Rolebinding：角色绑定，用于将“角色”与“使用”绑定，也即为用户分配权限。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何选择合适的开发模式</title>
    <link href="/2021/02/28/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/02/28/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>在确定选用哪种开发策略之前，我们需要回答出如下几个问题：</p><ul><li>Google和Facebook等互联网巨头都在用的主干开发（Trunk Based Development，简称TBD），我们能否直接采用。</li><li>大名鼎鼎的“Git Flow（A successful Git branching model）”，真的好用吗？我们能否直接套用？</li><li>GitHub的Github Flow和GitLab的GitLab Flow有什么区别，适合我们使用吗？</li><li>国内知名互联网公司，都在使用什么样的分支策略？</li></ul><p>而要回答出这几个问题，就需要我们对分支策略有一个比较全面的了解。</p><h3 id="一、主干开发模式">一、主干开发模式</h3><p>在主干开发模式中，存在着两种形态：</p><ul><li>主干开发，主干发布。直接在主干上集成，master分支可随时发布。</li><li>主干开发，发布发布。直接在主干上集成，除了一个用于发布的发布分支外，没有任何其他分支。必要时通过cherry pick的方式（选择部分变更集合并到其他分支），将部分变更合并到发布分支。</li></ul><p>在现实场景中，往往会进行并行开发，这样就会产生一个问题：同一个应用会有多个团队同时提交不同需求的代码，并且每个需求发布的时间点是不同的。使用主干开发模式，势必会将没有经过测试验证的代码发布到线上。此时，就需要在代码里预设很多功能开关。这些开关可以在运行期间隐藏、启用或禁用特定功能。而这必然会增加代码的复杂度。</p><p>所有，就了特性分支开发模式。</p><h3 id="二、特性分支开发模式">二、特性分支开发模式</h3><h4 id="2-1、Git-Flow">2.1、Git Flow</h4><p>Git Flow是因git的流行，而产生的开发模式。它的特点是：</p><ul><li>除了master分支之外，还会有一条常驻的develop开发分支；</li><li>所有的功能开发和缺陷修复都在develop分支上再建分支；</li><li>发布前会将develop分支合入到从master分支签出的release分支中，由releae分支来分布；</li><li>发布后会将release分支再合并回master和develop分支。</li></ul><p>由于Git Flow的流程过于繁琐，现在少有团队会选择这种开发模式。</p><p><img src="/img/image-20210228184330462.png" alt="image-20210228184330462"></p><h4 id="2-2、GitHub-Flow">2.2、GitHub Flow</h4><p>GitHub Flow是GitHub所使用的开发模式。它的特点是：</p><ul><li>只使用master和特性分支，并会借助GitHub的pull request功能；</li><li>master分支所包含的是已经或即将发布的稳定代码；</li><li>未审核、未提交的代码不能提交到master分支；</li><li>任何修改（修改代码、修复Bug、热修复、新功能开发）都在单独的分支进行；</li><li>新分支开发完成后，提交pull request，审查、测试通过后合并到master</li></ul><p><img src="/img/image-20210228184605413.png" alt="image-20210228184605413"></p><h4 id="2-3、GitLab-Flow">2.3、GitLab Flow</h4><p>GitLab Flow是GitLab在GitHub Flow的基础上做的改良，它额外衍生出了三个子类模型。</p><h5 id="2-3-1、带生产分支的GitLab-Flow">2.3.1、带生产分支的GitLab Flow</h5><p><img src="/img/image-20210228201558643.png" alt="image-20210228201558643"></p><p>说明：</p><ul><li>无法控制准确的发布时间，但又要求不停集成</li><li>需要创建一个production分支来放置发布的代码</li></ul><h5 id="2-3-2、带环境分支的GitLab-Flow">2.3.2、带环境分支的GitLab Flow</h5><p><img src="/img/image-20210228201709129.png" alt="image-20210228201709129"></p><p>说明：</p><ul><li>要求所有代码都在逐个环境中测试通过</li><li>需要为不同的环境建立不同的分支</li></ul><h5 id="2-3-3、带发布分支的GitLab-Flow">2.3.3、带发布分支的GitLab Flow</h5><p><img src="/img/image-20210228201829590.png" alt="image-20210228201829590"></p><p>说明：</p><ul><li>一般用于对外界发布软件的项目，同时需要维护多个发行版本</li><li>尽可能晚地从master拉取发布分支</li><li>Bug的修改应先合并到master，然后cherry pick到release分支</li></ul><h3 id="三、选出最合适的分支策略">三、选出最合适的分支策略</h3><p>上面提到的分支模型，都是 IT 研发领域比较流行的。虽然有些策略带上了代码平台的标识，如 GitHub Flow，但并不意味着该策略仅限于 GitHub 代码平台使用，我们完全可以在自己搭建的代码平台上使用这些策略。接下来，总体归纳一下什么情况下应该选择什么样的分支策略：</p><ul><li>主干开发。开发团队系统设计和开发能力强；有一套有效的特性切换机制，能保证上线后无需修改代码就能够修改系统行为。</li><li>Git Flow。不具备主干开发能力；有预定的发布周期；需要执行严格的发布流程。</li><li>GitHub Flow。不具备主干开发能力；随时集成随时发布：分支集成后经过代码评审和自动化测试，就可以立即发布的应用。</li><li>GitLab Flow（带生产分支）。不具备主干开发能力；无法控制准确的发布时间，但又要求不停集成。</li><li>GitLab Flow（带环境分支）。不具备主干开发能力；需要逐个通过各个测试环境验证。</li><li>GitLab Flow（带发布分支）。不具备主干开发能力；需要对外发布和维护不同版本。</li></ul><h3 id="四、小结">四、小结</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CMDB的前世今生？</title>
    <link href="/2021/01/24/CMDB%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <url>/2021/01/24/CMDB%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="一、CMDB的起源">一、CMDB的起源</h3><p>CMDB并不是一个新概念，它源于ITIL（Information Technology Infrastructure Library，信息技术基础架构库）。而ITIL这套理论体系在20世纪80年代末就已经成型，并在当时和后来的企业IT建设中作为服务管理的指导理论得到广泛推广和实施。</p><h3 id="二、传统思维下的CMDB">二、传统思维下的CMDB</h3><p>按照ITIL的定义：</p><blockquote><p>CMDB（Configuration Management DataBase），即配置管理数据库，是一个与所有IT系统组件相关的信息库，它包含IT基础架构配置项的详细信息。</p></blockquote><p>可以看到，这是一个很宽泛的概念，实际上并不具备可落地的指导意义。</p><p>从传统IT运维的角度来看，运维的核心对象是资源层面。因此，所谓的基础架构就是网络设备和硬件设备这个层面，并且各种关联和拓扑关系，基本上也是从服务器的视角去看。所以，在这个阶段更多是把CMDB建设成为一个以设备为中心的信息管理平台。</p><p>这种形态，在软件架构变化不大的情况下，比如，单体架构或分层架构，以服务器为中心去建设是没有问题的。因此，此时无论是设备数据，还是申请回收工作，都是很有限的，也就是整个IT基础设施的形态变化不大。</p><h3 id="三、互联网思维下的CMDB">三、互联网思维下的CMDB</h3><p>进入互联网时代后，CMDB也从理论概念的方法论阶段过渡到了具备具体技术方案的可实施阶段。但“此CMDB”已经非“彼CMDB”了，传统运维阶段，我们更多是以设备为核心进行管理，但是到了互联网技术阶段，这个核心就变成了应用这个对象。</p><p>此时的CMDB，虽然仍叫做配置管理数据库，但是这个配置管理的外延已经发生了很大的变化。之前所指的简单的硬件资源配置管理，只能算是狭义的理解。但从从广义上讲，当前的应用以及应用依赖的基础组件，都被纳入了这个配置管理的范畴。</p><p>所以在这个时期，我们提到的运维自动化，远不是自动化的服务器安装、部署交付或网络自动化配置这些单一的场景，而是出现了持续交付、DevOps、SRE等更适合这个时代的对运维职责的定义和新的方法论。</p><h3 id="四、小结">四、小结</h3><p>在本篇文章中，我们提到CMDB是在ITIL的指导理念下发展出来的，它经历了两个阶段的发展：</p><ul><li>在传统运维阶段，CMDB主要是指硬件资源配置管理；</li><li>在互联网技术阶段，CMDB不在是局限于硬件资源配置管理，而是上升到了应用以及基础组件的管理。</li></ul><h3 id="五、参考">五、参考</h3>]]></content>
    
    
    <categories>
      
      <category>Ops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维观</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从生命周期看应用的标准化？</title>
    <link href="/2021/01/24/%E4%BB%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9C%8B%E5%BA%94%E7%94%A8%E7%9A%84%E6%A0%87%E5%87%86%E5%8C%96/"/>
    <url>/2021/01/24/%E4%BB%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9C%8B%E5%BA%94%E7%94%A8%E7%9A%84%E6%A0%87%E5%87%86%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>谈到生命周期，我们首先就会联想到自己的生命周期，作为一个人类，我们都会经历从出生到死亡这么一个周期。在一个完整的生命周期中，我们又会经历不同的人生阶段，而在不同的人生阶段上，我们又会拥有不同的属性和关系，因而所要解决的人生课题也会不同。</p><p>类似的，作为运维的核心：应用，也会拥有其独特的生命周期。接下来，我们就来了解一下应用的“人生阶段”。</p><h3 id="一、应用的生命周期">一、应用的生命周期</h3><p>大体上，我们可以将应用的生命周期划分为五个阶段：</p><h4 id="1-1、创建阶段">1.1、创建阶段</h4><p>在这个阶段，最重要的工作，是确认应用的基础信息以及与基础组件的关系，要将这些信息固化下来。同时，另外一个很重要的工作，是要开启与应用相关的各类基础组件的生命周期。比如，应用需要用到的缓存、消息队列和DB等。</p><p>当然一个应用会使用到哪些基础组件，应该是在架构设计和编码阶段就确定下来的。而这里要做的事情，就是把这些信息通过应用关联起来，与应用的生命周期进行挂钩。</p><h4 id="1-2、研发阶段">1.2、研发阶段</h4><p>在这个阶段，主要是业务逻辑的实现和验证。对于业务逻辑层面的场景来说就是：</p><ul><li><p>代码开发。在这个过程就会涉及到代码的提交合并、编译打包以及不同环境下的部署发布。</p></li><li><p>质量保障。在这个过程中开发和测试会在不同的环境下进行各种类型的测试，比如，单元测试、集成测试以及系统测试等，而这也就是我们常说的持续集成。</p></li></ul><p>因此，在这个阶段，我们要做的最重要的一个事情就是：为研发团队打造完善的持续集成体系和工具链支持。</p><h4 id="1-3、上线阶段">1.3、上线阶段</h4><p>这是一个过渡阶段，从创建应用过渡到线上运行。在创建阶段，应用的基础信息和基础组件等信息都已经准备到位，之后，当应用开发完成后，我们会申请到应用运行的服务器资源，最后会将应用发布到线上运行。</p><h4 id="1-4、运行阶段">1.4、运行阶段</h4><p>这是应用生命周期中最重要、最核心的阶段。会涉及许多复杂的场景：</p><ul><li>从运维角度来看，应用在线上运行起来之后就已经变成了一个线上运行的进程。这个时候我们就需要获取到应用以及相关基础组件的各种运行指标。也就是说，我们要制定每个运维对象的SLI、SLO和SLA，同时要建设能够对这些指标进行监控和报警的监控体系。</li><li>从业务角度来看，应用是业务逻辑的执行载体，而业务需求会不断地变化和迭代，此时就会不断的迭代更新线上应用。因此，在这里我们要融合研发过程的持续集成体系，打造出一个完整的持续交付体系。</li><li>从运行阶段应用的关系来看，除了应用跟基础组件的关系外，应用跟应用、以及应用本身所包含的服务之间都会存在着调用关系，而且这些关系可能随时都在变化。此时我们就要对应用进行依赖管理和链路跟踪了。</li><li>从运行阶段应用的环境来看，应用会面临外部业务量的各种异常变化，以及应用自身所依赖的基础设施、基础组件和应用服务的各种异常状况。此时就出现了线上稳定性保障的场景。</li></ul><h4 id="1-5、销毁阶段">1.5、销毁阶段</h4><p>当应用的业务能力不在被需求时，应用也就可以下线销毁了。但是这里不仅仅是应用自身的销毁，围绕应用所产生出来的基础设施、基础组件以及关联关系都要一并清理，否则会给系统带来许多无源资源的浪费。</p><h3 id="二、小结">二、小结</h3><p>可以看到，应用作为一个完整的“个体”，会拥有自己独特的“人生阶段”，每个阶段上也会面临不同的“人生课题”：</p><ul><li>在创建阶段，主要是应用和基础组件的各种关联关系的梳理；</li><li>在研发阶段，主要是持续集成体系的建立；</li><li>在上线阶段，主要是基础设施资源的准备；</li><li>在运行阶段，主要是监控体系、持续交付体系、链路跟踪体系和稳定性保障等工作；</li><li>在销毁阶段，主要是应用及其关联资源的清理；</li></ul><h3 id="三、参考">三、参考</h3>]]></content>
    
    
    <categories>
      
      <category>Ops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维观</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对于基础组件我们要做什么？</title>
    <link href="/2021/01/24/%E5%AF%B9%E4%BA%8E%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E6%88%91%E4%BB%AC%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <url>/2021/01/24/%E5%AF%B9%E4%BA%8E%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E6%88%91%E4%BB%AC%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="一、从常见的分布式基础组件说起">一、从常见的分布式基础组件说起</h3><p>在微服务架构下，涉及到的主要基础架构组件包括：</p><ul><li>分布式服务化框架。比如，Dubbo、Spring Cloud；</li><li>分布式缓存及框架。比如，Redis、Memcached；</li><li>分布式消息中间件。比如，Kafka、RabbitMQ、ActiveMQ以及RocketMQ等；</li><li>数据库以及分布式数据库框架。比如，MySQL、MariaDB、TiDB等；</li><li>分布式文件系统以及存储框架。比如，HDFS、GlusterFS、Ceph等；</li><li>前端接入层。比如，LVS、Haproxy、Nginx等</li></ul><p>上面提到的这几类基础组件，基本上可以覆盖绝大多数的使用场景。此外，业界一些优秀的开源产品也可以满足我们绝大多数的业务需求。当然，一些公司为了满足业务上的个性化需求也会进行自研。</p><h3 id="二、为什么要统一基础组件">二、为什么要统一基础组件</h3><p>关于基础组件，业务可供我们选择的解决方案和产品非常多，但是选择多了就容易挑花眼，反而不知道该从何入手。按正常的思路，一般会先组织选型调研，然后进行方案验证和对比，最后确认统一的解决方案。</p><p>然而，在实际情况中，一些技术团队的不同开发人员，往往会根据个人喜好或开发需求，选择不同的开源产品。这样，随着使用场景的逐步深入和业务体量的增长，就会暴露出各种各样的问题：</p><ul><li>在开发层面，业务开发人员需要投入大量的时间、精力研究和适配各种开源产品，很难聚焦于业务需求的开发。</li><li>在运维层面，当我们考虑建设一个统一的效率和稳定性体系时，需求花大量时间去适配多种不同的组件。</li></ul><p>因此，在选择基础组件时，我们要做统一的规划和建设。原则上，每种基础组件只允许一种选型，这至少能满足90%甚至更多的使用场景。如果遇到特殊情况就做具体的分析和处理。</p><h3 id="三、基础组件服务化">三、基础组件服务化</h3><p>在我们统一了基础组件之后，下一步要做的就是服务化了。因为这些组件都只提供了简单的维护功能，并且许多维护工作都需要在命令行才能完成，这时我们就要考虑把这些组提供的维护API进行封装，以提供更加便捷的运维能力。</p><p>以Redis为例，我们需要提供的维护能力会有：</p><ul><li>创建、申请容量；</li><li>容量的扩容和缩容；</li><li>新增分片的服务发现以及访问路由配置；</li><li>运行指标监控；</li><li>准备切换能力等；</li></ul><p>以上这些操作，如果都依赖Redis提供的原生能力来实现，那基本是就是不可维护的。因此，我们必须对这些原生能力进行封装，结合具体的运维场景，将能力服务化，这样就可以大大提升使用方的便利性。</p><h3 id="四、小结">四、小结</h3><p>对于基础组件，我们要做的事情有两件：</p><ul><li>标准化。参与基础组件的选型，建立的统一的标准。</li><li>服务化。建立服务化平台，让开发人员借助平台的能力自助完成做基础组件的操作需求。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Ops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维观</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高效的Ops为什么要从标准化开始？</title>
    <link href="/2021/01/17/%E9%AB%98%E6%95%88%E7%9A%84Ops%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BB%8E%E6%A0%87%E5%87%86%E5%8C%96%E5%BC%80%E5%A7%8B%EF%BC%9F/"/>
    <url>/2021/01/17/%E9%AB%98%E6%95%88%E7%9A%84Ops%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BB%8E%E6%A0%87%E5%87%86%E5%8C%96%E5%BC%80%E5%A7%8B%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>todo</p><h3 id="一、从标准化开始谈起">一、从标准化开始谈起</h3><h4 id="1-1、什么是标准化">1.1、什么是标准化</h4><p>简单来说，标准化就是一个识别运维对象、建立对象模型的过程。</p><p>在有了统一的对象模型后，我们就能在统一的认识下开展有效的协作。进而就可以针对不同的运维对象，抽取出它们所对应的运维场景，最后就是这些运维场景的自动化实现了。</p><h4 id="1-2、为什么要标准化">1.2、为什么要标准化</h4><p>标准化的最终目的是为了自动化。在进行了标准化后，我们日常的运维工作就可以针对具体对象的具体场景进行展开。而如果运维操作脱离了具体对象的具体场景，那工作将变得混乱、没有章法，自动化也就无从谈起。</p><p>以扩容为例，要先确定到底是服务器的扩容，还是应用的扩容，还是其它对象的扩容。我们可以发现，对象不同，扩容这个场景所实施的动作是完全不一样的。如果把服务器的扩容套用到应用的扩容上，就必然会导致流程错乱。</p><h4 id="1-3、如何标准化">1.3、如何标准化</h4><p>在进行标准化工作时，我们可以遵循以下几个步骤：</p><ul><li>第一步，识别具体对象</li><li>第二步，识别对象属性</li><li>第三步，识别对象关系</li><li>第四步，识别对象场景</li></ul><p>接下来，我们按照这几个步骤，来看看如何对基础设施和应用进行标准化</p><h3 id="二、基础设施的标准化">二、基础设施的标准化</h3><p>基础设施层面的运维对象都是一个个物理存在的实体，应该很好识别：</p><ul><li><p>第一步，识别出具体对象。比如，会有服务器、存储、交换机、路由器、配件、机柜、IDC等。</p></li><li><p>第二步，识别出对象属性。比如，服务器会有SN序列号、IP地址、硬件配置（如CPU、内存、硬盘、网卡、PCIE、BIOS等）、操作系统、厂商、维保信息等；交换机会有带宽、厂商、型号等信息。</p></li><li><p>第三步，识别出对象关系。比如，虚拟机所在的宿主机、宿主机所在的机柜、机柜所在的IDC等简单的位置关系；更复杂一点就会有核心交换机、汇聚交换机、接入交换机以及机柜和服务器之间的拓扑关系。</p></li><li><p>第四步，识别出对象场景。比如，服务器的日常操作场景会有采购、入库、安装、配置、上线、下线、维修等等。另外，可能还会有针对这些基础设施之间拓扑关系的可视化查询场景，如交换机与服务器之间的级联关系、状态展示等。</p></li></ul><p>在这里，如果我们通过ER建模工具对前三步梳理出的信息进行数据建模，并将这些信息固化到DB中，一个资源层面的信息管理平台就基本成型了。</p><p>然而，信息固化并不是最终的目的，也没有价值，信息只有动态流转起来才有价值，因此，我们进行了第四步运维场景的识别。完成了这些准备工作后，就可以针对具体的运维场景进行自动化开发了。</p><h3 id="三、应用的标准化">三、应用的标准化</h3><p>应用层面的运维对象就是我们之前提到的运维核心：应用。对于这个对象的标准化，我们依然可以按照上面的逻辑来：</p><ul><li>第一步，识别出具体对象。比如，在微服务架构中，就是我们根据业务逻辑拆分出来的一个个业务应用。而在单体架构中，所有的业务逻辑都融合在一个应用中。</li><li>第二步，识别出对象属性。一个应用所具备的基本运维属性有：<ul><li>元数据属性，主要是一些简单直接地描述信息。比如，应用名、应用Owner、所属业务、是否为核心链路应用以及应用的功能说明等，这里的关键是应用名；</li><li>代码属性，主要是编程语言及版本（决定了后续的构建方式），GitLab地址等信息；</li><li>部署模式，主要涉及到一些基础软件包（如语言包Java、C++、Go等）和应用容器（如Tomcat、JBoss等）；</li><li>目录信息，主要是运行应用所需的一些目录。比如，应用包目录、日志目录、运维脚本目录、临时目录等；</li><li>运行脚本，如启停脚本、健康检查脚本；</li><li>运行时的参数配置，如运行端口，Java的JVM参数等</li></ul></li><li>第三步，识别出对象关系。主要是指应用与外部的关系，概括起来有三大类：<ul><li>应用与其它应用的关系。也就是应用的依赖关系，在微服务架构中，一个应用往往只能具备某些特定的功能，想要提供一个完整的业务逻辑就需要和外部的多个应用协作。</li><li>应用与基础设施的关系。运行应用需要有服务器资源来承载，访问应用需要ip、vip或dns等资源。</li><li>应用与基础组件的关系。一个动态应用在运行过程中，一定会依赖消息队列、缓存、DB和存储等基础组件。</li></ul></li><li>第四步，识别出对象场景。比如，持续交付，扩缩容，稳定性等。</li></ul><p>需要注意的是，应用是业务逻辑的抽象，因此应用会有业务和运维两个维度的属性。在运维工作中，更侧重于运维属性的识别，至于业务属性则往往由业务架构师识别。</p><h3 id="四、小结">四、小结</h3><p>在这篇文章中，我们从标准化开始谈起，进而讨论了如何对基础设施和应用进行标准化。到这里，你可能会说：还没有讨论如何对基础组件进行标准化啊。</p><p>我们知道，基础组件的生命周期是因为应用的依赖而开始的。基础组件，就是一个特殊的应用，因此，我们可以参考应用标准化的逻辑，来进行基础组件的标准化。</p>]]></content>
    
    
    <categories>
      
      <category>Ops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维观</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务时代，为什么要以“应用”为核心？</title>
    <link href="/2021/01/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BB%A5%E2%80%9C%E5%BA%94%E7%94%A8%E2%80%9D%E4%B8%BA%E6%A0%B8%E5%BF%83%EF%BC%9F/"/>
    <url>/2021/01/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BB%A5%E2%80%9C%E5%BA%94%E7%94%A8%E2%80%9D%E4%B8%BA%E6%A0%B8%E5%BF%83%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>todo</p><h3 id="一、应用的起源">一、应用的起源</h3><p>微服务架构一般都是从单体架构或分层架构演化过来的。软件架构微服务化的过程，就是一个根据业务模型不断进行细化的过程，在这个过程中切分出一个个具备不同职责的业务逻辑模块（即微服务模块），然后每个微服务模块都会提供相应业务逻辑的服务化接口。</p><p>简单来说，微服务化的核心就是一个字：拆。从一个单体工程，拆分出N个独立的模块。这些模块都可以独立部署和运行，并提供对应的业务能力。拆分后的模块数量与业务体量和复杂度相关，少则几个、十几个，多则几十、几百个，所以为了统一概念，我们通常称这些模块为应用。</p><p>为了确保每个应用的唯一性，我们会给每个应用定义一个唯一的标识符，比如app1、app2等，而这个唯一的标识符，就是我们常说的应用名。</p><h3 id="二、应用的模型">二、应用的模型</h3><p>需要知道的是，我们在上面定义出来的一个个应用，都是从业务角度入手进行细化拆分出来的一个个业务逻辑单元。这些应用虽然可以独立部署和运行，但是每个应用都只具备相对单一的业务功能。如果要完成整体的业务流程和目标，就需要和周边其它的微服务化应用交互。此外，它们还会依赖各种与业务无直接关系、相对独立的基础设施和组件，比如机器资源、域名、缓存、消息队列、DB等。</p><p>所以，在一个实际的运维场景中，除了应用这个实体之外，还会存在其他各类基础组件实体。应用在运行过程中，会不断地与它们产生和建立各种各样复杂的关联关系。而正是因为有了这种复杂的关联关系，才提高了我们的运维复杂度。也正因为如此，理清运维场景中的关联关系就变得尤为重要。</p><p>接下来，我们先来看一看可以从哪些角度来梳理这种关联关系。</p><h4 id="2-1、应用的业务模型">2.1、应用的业务模型</h4><p>应用的业务模型，就是每个应用对外提供的业务服务能力，通常会以API的方式暴露给外部。</p><p>该模型一般由业务架构师在进行业务需求分析和拆解时进行设计，更多的聚焦在业务逻辑上。</p><h4 id="2-2、应用的管理模型">2.2、应用的管理模型</h4><p>应用的管理模型，就是应用自身的各种属性，比如应用名、应用功能信息、责任人、Git地址、部署结构（代码路径、日志路径以及各类配置文件路径等）、启停方式、健康检测方式等等。其中，应用名是应用的唯一标识，我们一般用AppName来表示。</p><h4 id="2-3、应用的依赖模型">2.3、应用的依赖模型</h4><p>应用的依赖模型，就是应用运行时所需要的基础设施和基础组。其中：</p><ul><li><p>基础设施：主要是指应用运行所必需的资源载体，比如物理机、虚拟机或容器等。而如果应用会对外提供HTTP服务，就需要虚IP和DNS域名；</p></li><li><p>基础组件：主要是指我们常说的中间件体系，比如数据库、缓存、消息队列、文件存储等。</p></li></ul><p>在这里我们需要知道的是，这些基础设施和基础组件都是为了业务应用而存在的。正是因为业务应用的需要，才开启了它们各自的生命周期。如果脱离了这些业务应用，它们就失去了存在的意义。</p><h3 id="三、应用关系建模">三、应用关系建模</h3><p>在理解了应用的模型后，我们再去梳理应用的关联关系就会顺畅很多，这个梳理过程可以分为两步走：</p><ul><li>第一步，建立各个基础设施和基础组件的数据模型，同时识别出它们的唯一标识符。这一步与应用的管理模型梳理过程类似。以缓存为例，每当我们申请一个缓存空间时，通常会以NameSpace来表示唯一标识符，同时这个缓存空间会有容量大小和Partition分区等属性信息。</li><li>第二步，识别出基础设施和基础组件可以与应用名AppName建立关联关系的属性，或者在基础组件的数据模型中增加所属应用这样的字段。还是以缓存为例，当应用申请缓存空间时，可以直接将NameSpace字段的值设置为AppName，也可以在增加一个所属应用这样的字段，通过外键关联模式建立起应用于缓存空间的关联关系。</li></ul><p>经过这样两步的梳理，我们就可以建立出类似下图这样，以应用为核心的应用模型和关联关系模型了：</p><p><img src="/img/image-20210117120118502.png" alt="image-20210117120118502"></p>]]></content>
    
    
    <categories>
      
      <category>Ops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维观</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Terraform核心概念</title>
    <link href="/2021/01/05/Terraform%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <url>/2021/01/05/Terraform%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>todo</p><h2 id="一、Provider：基础设施管理驱动">一、Provider：基础设施管理驱动</h2><p>Provider是Terraform中一个非常重要的组件，它是一个用来管理基础设施的后端驱动，可以理解为Terraform的插件。每个云服务厂商会实现面向各家云服务的Provider，其中会包含资源元数据的定义，上层请求的处理和后端OpenAPI的调用以及响应处理。</p><p>Terraform调用不同的Provider完成不同类型资源的统一管理，目前大多数云平台均实现了各自的Provider。Provider无需手动安装，Terraform会在init阶段根据模板中的定义自动加载。</p><h2 id="二、Resource：资源的定义和管理">二、Resource：资源的定义和管理</h2><p>Resource是Terraform中的一个重要概念，它是Provider的重要组成部分。每个Resource是对特定基础设施特定资源的实现，它通过实现Create、Update、Read和Delete方法来管理特定资源的生命周期。</p><h3 id="2-1、定义资源">2.1、定义资源</h3><p>每个Resource都是通过关键字<code>resource</code>来定义的，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs HCL">resource &quot;huaweicloud_vpc&quot; &quot;main&quot; &#123;<br>  name = &quot;net1&quot;<br>  cidr = &quot;192.168.0.0/16&quot;<br>&#125;<br><br>resource &quot;huaweicloud_vpc_subnet&quot; &quot;main&quot; &#123;<br>  name              = &quot;zone1-1&quot;<br>  availability_zone = &quot;cn-east-2a&quot;<br>  vpc_id            = huaweicloud_vpc.main.id<br>  cidr              = &quot;192.168.1.0/24&quot;<br>  gateway_ip        = &quot;192.168.1.1&quot;<br>  dns_list          = [&quot;100.125.17.29&quot;,&quot;100.125.135.29&quot;]<br>&#125;<br></code></pre></td></tr></table></figure><p>对于一个Resource的定义来说，一般会包含如下几个部分：</p><ul><li>huaweicloud_vpc，是要操作的资源类型。它用于告诉Terraform将要操作的资源，其类型是VPC还是ECS等其他资源。需要注意的是，每个云厂商都有各自的资源类型实现。</li><li>main，是我们为这个资源起的名字。它用来标识所定义的资源，在同一个模板（即当前目录下所有以.tf结尾的文件）中，对同一资源类型的标识必须唯一。</li><li>{…}，大括号里的内容是资源的配置参数。它用来定义资源的属性，比如VPC的名字、网段等。</li></ul><p>在上述代码中，我们定义了名为net1、网段为192.168.0.0/16的VPC网络，并在这个网络下创建了一个名为zone1-1、网段为192.168.1.0/24的子网。</p><h3 id="2-2、创建资源">2.2、创建资源</h3><p>在完成资源的定义后，我们可以先通过<code>terraform plan</code>预览模板将要在云平台上创建的资源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">terraform plan</span><br>An execution plan has been generated and is shown below.<br>Resource actions are indicated with the following symbols:<br>  + create<br><br>Terraform will perform the following actions:<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">huaweicloud_vpc.main will be created</span><br>  + resource &quot;huaweicloud_vpc&quot; &quot;main&quot; &#123;<br>      + cidr                  = &quot;192.168.0.0/16&quot;<br>      + enterprise_project_id = (known after apply)<br>      + id                    = (known after apply)<br>      + name                  = &quot;net1&quot;<br>      + region                = (known after apply)<br>      + routes                = (known after apply)<br>      + shared                = (known after apply)<br>      + status                = (known after apply)<br>    &#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">huaweicloud_vpc_subnet.main will be created</span><br>  + resource &quot;huaweicloud_vpc_subnet&quot; &quot;main&quot; &#123;<br>      + availability_zone = &quot;cn-east-2a&quot;<br>      + cidr              = &quot;192.168.1.0/24&quot;<br>      + dhcp_enable       = true<br>      + dns_list          = [<br>          + &quot;100.125.17.29&quot;,<br>          + &quot;100.125.135.29&quot;,<br>        ]<br>      + gateway_ip        = &quot;192.168.1.1&quot;<br>      + id                = (known after apply)<br>      + name              = &quot;zone1-1&quot;<br>      + primary_dns       = (known after apply)<br>      + region            = (known after apply)<br>      + secondary_dns     = (known after apply)<br>      + subnet_id         = (known after apply)<br>      + vpc_id            = (known after apply)<br>    &#125;<br><br>Plan: 2 to add, 0 to change, 0 to destroy.<br><br>------------------------------------------------------------------------<br><br>Note: You didn&#x27;t specify an &quot;-out&quot; parameter to save this plan, so Terraform<br>can&#x27;t guarantee that exactly these actions will be performed if<br>&quot;terraform apply&quot; is subsequently run.<br></code></pre></td></tr></table></figure><p>可以看到，terraform将创建两个资源huaweicloud_vpc.main和huaweicloud_vpc_subnet.main，它们的某些属性为<code>known after apply</code>，这个意思是说该参数的值需要在执行terraform apply之后才能知道，通常像这样的字段如果没有显示的设置值，云平台将会自动生成。</p><p>在确认无误后，就可以执行terraform apply进行实际的创建操作了，输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">terraform apply</span><br>An execution plan has been generated and is shown below.<br>Resource actions are indicated with the following symbols:<br>  + create<br><br>Terraform will perform the following actions:<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">huaweicloud_vpc.main will be created</span><br>  + resource &quot;huaweicloud_vpc&quot; &quot;main&quot; &#123;<br>      + cidr                  = &quot;192.168.0.0/16&quot;<br>      + enterprise_project_id = (known after apply)<br>      + id                    = (known after apply)<br>      + name                  = &quot;net1&quot;<br>      + region                = (known after apply)<br>      + routes                = (known after apply)<br>      + shared                = (known after apply)<br>      + status                = (known after apply)<br>    &#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">huaweicloud_vpc_subnet.main will be created</span><br>  + resource &quot;huaweicloud_vpc_subnet&quot; &quot;main&quot; &#123;<br>      + availability_zone = &quot;cn-east-2a&quot;<br>      + cidr              = &quot;192.168.1.0/24&quot;<br>      + dhcp_enable       = true<br>      + dns_list          = [<br>          + &quot;100.125.17.29&quot;,<br>          + &quot;100.125.135.29&quot;,<br>        ]<br>      + gateway_ip        = &quot;192.168.1.1&quot;<br>      + id                = (known after apply)<br>      + name              = &quot;zone1-1&quot;<br>      + primary_dns       = (known after apply)<br>      + region            = (known after apply)<br>      + secondary_dns     = (known after apply)<br>      + subnet_id         = (known after apply)<br>      + vpc_id            = (known after apply)<br>    &#125;<br><br>Plan: 2 to add, 0 to change, 0 to destroy.<br><br>Do you want to perform these actions?<br>  Terraform will perform the actions described above.<br>  Only &#x27;yes&#x27; will be accepted to approve.<br><br>  Enter a value: yes<br><br>huaweicloud_vpc.main: Creating...<br>huaweicloud_vpc.main: Creation complete after 6s [id=867655c8-7641-4fbf-b8c4-34989e560d46]<br>huaweicloud_vpc_subnet.main: Creating...<br>huaweicloud_vpc_subnet.main: Creation complete after 8s [id=a35290c9-d9c5-4ee0-a24f-1fe65c88c0b8]<br><br>Apply complete! Resources: 2 added, 0 changed, 0 destroyed.<br></code></pre></td></tr></table></figure><p>为了安全起见，执行apply之后需要输入yes进行确认，当然我们可以在apply之后添加<code>-auto-approve</code>，这表示跳过确认环节直接创建。如果创建成功会输出资源的ID，此时，我们可以登录到Web控制台上查看验证这个创建操作；否则，会输出错误信息。</p><h3 id="2-3、变更资源">2.3、变更资源</h3><p>对于一个IaC工具来说，资源的变更非常简单，只需要修改模板中定义的属性值即可。在Terraform中对资源的变更有两种情况：</p><ul><li>原地变更（update in place），即在不改变资源生命周期的情况下，实现对资源属性的修改，如变更资源的名称、描述、便签等。</li><li>重建变更（destroy and then create replacemnt），资源的某些属性是不支持变更的，在这种情况下，如果修改资源属性，Terraform会先删除原有资源，然后按照最新的模板定义创建新的资源，从而间接实现资源的变更操作。对于不支持变更的属性，在各云厂商的provider文档中，会将该属性显示的声明为ForceNew。</li></ul><p>值得注意的是，在Terraform输出的信息中，会对增删改操作进行标识：</p><ul><li><code>+</code>，表示创建</li><li><code>~</code>，表示更新，左边的内容是旧值，右边的内容是新值</li><li><code>-</code>，表示释放</li></ul><p>接下来，我们分别演示这两种变更情况。</p><h4 id="2-3-1、原地变更">2.3.1、原地变更</h4><p>首先，我们来修改VPC的名字，将net1改为net，修改后的模板文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs HCL">resource &quot;huaweicloud_vpc&quot; &quot;main&quot; &#123;<br>  name = &quot;net&quot;<br>  cidr = &quot;192.168.0.0/16&quot;<br>&#125;<br><br>resource &quot;huaweicloud_vpc_subnet&quot; &quot;main&quot; &#123;<br>  name              = &quot;zone1-1&quot;<br>  availability_zone = &quot;cn-east-2a&quot;<br>  vpc_id            = huaweicloud_vpc.main.id<br>  cidr              = &quot;192.168.1.0/24&quot;<br>  gateway_ip        = &quot;192.168.1.1&quot;<br>  dns_list          = [&quot;100.125.17.29&quot;,&quot;100.125.135.29&quot;]<br>&#125;<br></code></pre></td></tr></table></figure><p>修改完成后，执行apply操作，其结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">terraform apply</span><br>huaweicloud_vpc.main: Refreshing state... [id=867655c8-7641-4fbf-b8c4-34989e560d46]<br>huaweicloud_vpc_subnet.main: Refreshing state... [id=a35290c9-d9c5-4ee0-a24f-1fe65c88c0b8]<br><br>An execution plan has been generated and is shown below.<br>Resource actions are indicated with the following symbols:<br>  ~ update in-place<br><br>Terraform will perform the following actions:<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">huaweicloud_vpc.main will be updated in-place</span><br>  ~ resource &quot;huaweicloud_vpc&quot; &quot;main&quot; &#123;<br>        id                    = &quot;867655c8-7641-4fbf-b8c4-34989e560d46&quot;<br>      ~ name                  = &quot;net1&quot; -&gt; &quot;net&quot;<br>        tags                  = &#123;&#125;<br>        # (6 unchanged attributes hidden)<br>    &#125;<br><br>Plan: 0 to add, 1 to change, 0 to destroy.<br><br>Do you want to perform these actions?<br>  Terraform will perform the actions described above.<br>  Only &#x27;yes&#x27; will be accepted to approve.<br><br>  Enter a value: yes<br><br>huaweicloud_vpc.main: Modifying... [id=867655c8-7641-4fbf-b8c4-34989e560d46]<br>huaweicloud_vpc.main: Modifications complete after 2s [id=867655c8-7641-4fbf-b8c4-34989e560d46]<br><br>Apply complete! Resources: 0 added, 1 changed, 0 destroyed.<br></code></pre></td></tr></table></figure><p>可以看到，terraform只进行了原地修改（updated in-place）操作，将ne1改为了net。</p><h4 id="2-3-2、重建变更">2.3.2、重建变更</h4><p>接着，我们来修改子网网段，将192.168.1.0/16改为192.168.2.0/16，修改后的模板文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs HCL">resource &quot;huaweicloud_vpc&quot; &quot;main&quot; &#123;<br>  name = &quot;net&quot;<br>  cidr = &quot;192.168.0.0/16&quot;<br>&#125;<br><br>resource &quot;huaweicloud_vpc_subnet&quot; &quot;main&quot; &#123;<br>  name              = &quot;zone1-1&quot;<br>  availability_zone = &quot;cn-east-2a&quot;<br>  vpc_id            = huaweicloud_vpc.main.id<br>  cidr              = &quot;192.168.2.0/24&quot;<br>  gateway_ip        = &quot;192.168.2.1&quot;<br>  dns_list          = [&quot;100.125.17.29&quot;,&quot;100.125.135.29&quot;]<br>&#125;<br></code></pre></td></tr></table></figure><p>修改完成后，执行apply操作，其结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">terraform apply</span><br>huaweicloud_vpc.main: Refreshing state... [id=867655c8-7641-4fbf-b8c4-34989e560d46]<br>huaweicloud_vpc_subnet.main: Refreshing state... [id=73b58ff0-0a3c-43db-927a-a4804e600a2d]<br><br>An execution plan has been generated and is shown below.<br>Resource actions are indicated with the following symbols:<br>-/+ destroy and then create replacement<br><br>Terraform will perform the following actions:<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">huaweicloud_vpc_subnet.main must be replaced</span><br>-/+ resource &quot;huaweicloud_vpc_subnet&quot; &quot;main&quot; &#123;<br>      ~ cidr              = &quot;192.168.1.0/24&quot; -&gt; &quot;192.168.2.0/24&quot; # forces replacement<br>      ~ gateway_ip        = &quot;192.168.1.1&quot; -&gt; &quot;192.168.2.1&quot; # forces replacement<br>      ~ id                = &quot;73b58ff0-0a3c-43db-927a-a4804e600a2d&quot; -&gt; (known after apply)<br>        name              = &quot;zone1-1&quot;<br>      ~ primary_dns       = &quot;100.125.17.29&quot; -&gt; (known after apply)<br>      ~ region            = &quot;cn-east-2&quot; -&gt; (known after apply)<br>      ~ secondary_dns     = &quot;100.125.135.29&quot; -&gt; (known after apply)<br>      ~ subnet_id         = &quot;a5870016-b575-45ec-b7a7-538f35c46b13&quot; -&gt; (known after apply)<br>      - tags              = &#123;&#125; -&gt; null<br>        # (4 unchanged attributes hidden)<br>    &#125;<br><br>Plan: 1 to add, 0 to change, 1 to destroy.<br><br>Do you want to perform these actions?<br>  Terraform will perform the actions described above.<br>  Only &#x27;yes&#x27; will be accepted to approve.<br><br>  Enter a value: yes<br><br>huaweicloud_vpc_subnet.main: Destroying... [id=73b58ff0-0a3c-43db-927a-a4804e600a2d]<br>huaweicloud_vpc_subnet.main: Destruction complete after 9s<br>huaweicloud_vpc_subnet.main: Creating...<br>huaweicloud_vpc_subnet.main: Creation complete after 9s [id=efc326dd-b911-4ce4-b6b4-11cc53bf690e]<br><br>Apply complete! Resources: 1 added, 0 changed, 1 destroyed.<br></code></pre></td></tr></table></figure><p>可以看到，修改子网网段是一个forces replacement的行为，这会导致旧资源先被释放，然后再创建新资源，从而实现修改操作（destroy and then create replacement）。</p><p>需要注意的是，释放的资源无法实现回滚，即数据无法恢复，因此在apply前一定要通过plan仔细查看哪些资源会被重建，以免造成不可恢复的错误。</p><h3 id="2-4、查看资源">2.4、查看资源</h3><h4 id="2-4-1、查看所有资源">2.4.1、查看所有资源</h4><p>想要查看已经创建了哪些资源，最简单的方式是执行show命令，此时terraform会输出所有已创建资源及其属性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">terraform show</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">huaweicloud_vpc.main:</span><br>resource &quot;huaweicloud_vpc&quot; &quot;main&quot; &#123;<br>    cidr                  = &quot;192.168.0.0/16&quot;<br>    enterprise_project_id = &quot;0&quot;<br>    id                    = &quot;867655c8-7641-4fbf-b8c4-34989e560d46&quot;<br>    name                  = &quot;net&quot;<br>    region                = &quot;cn-east-2&quot;<br>    routes                = []<br>    shared                = false<br>    status                = &quot;OK&quot;<br>    tags                  = &#123;&#125;<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">huaweicloud_vpc_subnet.main:</span><br>resource &quot;huaweicloud_vpc_subnet&quot; &quot;main&quot; &#123;<br>    availability_zone = &quot;cn-east-2a&quot;<br>    cidr              = &quot;192.168.2.0/24&quot;<br>    dhcp_enable       = true<br>    dns_list          = [<br>        &quot;100.125.17.29&quot;,<br>        &quot;100.125.135.29&quot;,<br>    ]<br>    gateway_ip        = &quot;192.168.2.1&quot;<br>    id                = &quot;77bc0afc-9bf8-492d-af83-bdbe76dfbdda&quot;<br>    name              = &quot;zone1-1&quot;<br>    primary_dns       = &quot;100.125.17.29&quot;<br>    region            = &quot;cn-east-2&quot;<br>    secondary_dns     = &quot;100.125.135.29&quot;<br>    subnet_id         = &quot;6a63bd78-7fba-43f0-89ae-df25b4f19b93&quot;<br>    vpc_id            = &quot;867655c8-7641-4fbf-b8c4-34989e560d46&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法虽然简单，但如果资源非常多的时候，输出的信息就会让人眼花缭乱了。此时，就可以使用state命令了</p><h4 id="2-4-2、查看特定资源">2.4.2、查看特定资源</h4><p>首先，我们可以执行state list罗列出当前所有的资源，每个资源的显示格式为：<code>&lt;资源类型&gt;.&lt;资源名称&gt;</code>，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">terraform state list</span><br>huaweicloud_vpc.main<br>huaweicloud_vpc_subnet.main<br></code></pre></td></tr></table></figure><p>接着，在找到目标资源后，执行state show <code>&lt;资源类型&gt;.&lt;资源名称&gt;</code>，即可实现对特定资源的查看，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">terraform state show huaweicloud_vpc_subnet.main</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">huaweicloud_vpc_subnet.main:</span><br>resource &quot;huaweicloud_vpc_subnet&quot; &quot;main&quot; &#123;<br>    availability_zone = &quot;cn-east-2a&quot;<br>    cidr              = &quot;192.168.2.0/24&quot;<br>    dhcp_enable       = true<br>    dns_list          = [<br>        &quot;100.125.17.29&quot;,<br>        &quot;100.125.135.29&quot;,<br>    ]<br>    gateway_ip        = &quot;192.168.2.1&quot;<br>    id                = &quot;77bc0afc-9bf8-492d-af83-bdbe76dfbdda&quot;<br>    name              = &quot;zone1-1&quot;<br>    primary_dns       = &quot;100.125.17.29&quot;<br>    region            = &quot;cn-east-2&quot;<br>    secondary_dns     = &quot;100.125.135.29&quot;<br>    subnet_id         = &quot;6a63bd78-7fba-43f0-89ae-df25b4f19b93&quot;<br>    vpc_id            = &quot;867655c8-7641-4fbf-b8c4-34989e560d46&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5、释放资源">2.5、释放资源</h3><h4 id="2-5-1、释放所有资源">2.5.1、释放所有资源</h4><p>想要释放资源，只需要执行destroy命令即可，但是该命令会将模板中定义的所有资源都释放掉，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">terraform destroy</span><br><br>An execution plan has been generated and is shown below.<br>Resource actions are indicated with the following symbols:<br>  - destroy<br><br>Terraform will perform the following actions:<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">huaweicloud_vpc.main will be destroyed</span><br>  - resource &quot;huaweicloud_vpc&quot; &quot;main&quot; &#123;<br>      - cidr                  = &quot;192.168.0.0/16&quot; -&gt; null<br>      - enterprise_project_id = &quot;0&quot; -&gt; null<br>      - id                    = &quot;867655c8-7641-4fbf-b8c4-34989e560d46&quot; -&gt; null<br>      - name                  = &quot;net&quot; -&gt; null<br>      - region                = &quot;cn-east-2&quot; -&gt; null<br>      - routes                = [] -&gt; null<br>      - shared                = false -&gt; null<br>      - status                = &quot;OK&quot; -&gt; null<br>      - tags                  = &#123;&#125; -&gt; null<br>    &#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">huaweicloud_vpc_subnet.main will be destroyed</span><br>  - resource &quot;huaweicloud_vpc_subnet&quot; &quot;main&quot; &#123;<br>      - availability_zone = &quot;cn-east-2a&quot; -&gt; null<br>      - cidr              = &quot;192.168.2.0/24&quot; -&gt; null<br>      - dhcp_enable       = true -&gt; null<br>      - dns_list          = [<br>          - &quot;100.125.17.29&quot;,<br>          - &quot;100.125.135.29&quot;,<br>        ] -&gt; null<br>      - gateway_ip        = &quot;192.168.2.1&quot; -&gt; null<br>      - id                = &quot;77bc0afc-9bf8-492d-af83-bdbe76dfbdda&quot; -&gt; null<br>      - name              = &quot;zone1-1&quot; -&gt; null<br>      - primary_dns       = &quot;100.125.17.29&quot; -&gt; null<br>      - region            = &quot;cn-east-2&quot; -&gt; null<br>      - secondary_dns     = &quot;100.125.135.29&quot; -&gt; null<br>      - subnet_id         = &quot;6a63bd78-7fba-43f0-89ae-df25b4f19b93&quot; -&gt; null<br>      - vpc_id            = &quot;867655c8-7641-4fbf-b8c4-34989e560d46&quot; -&gt; null<br>    &#125;<br><br>Plan: 0 to add, 0 to change, 2 to destroy.<br><br>Do you really want to destroy all resources?<br>  Terraform will destroy all your managed infrastructure, as shown above.<br>  There is no undo. Only &#x27;yes&#x27; will be accepted to confirm.<br><br>  Enter a value: n<br><br>Destroy cancelled.<br></code></pre></td></tr></table></figure><h4 id="2-5-2、释放特定资源">2.5.2、释放特定资源</h4><p>如果想要删除某个特定的资源，可以通过<code>-target=&lt;资源类型&gt;.&lt;资源名称&gt;</code>来指定要资源的资源，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">terraform destroy -target=huaweicloud_vpc_subnet.main</span><br><br>An execution plan has been generated and is shown below.<br>Resource actions are indicated with the following symbols:<br>  - destroy<br><br>Terraform will perform the following actions:<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">huaweicloud_vpc_subnet.main will be destroyed</span><br>  - resource &quot;huaweicloud_vpc_subnet&quot; &quot;main&quot; &#123;<br>      - availability_zone = &quot;cn-east-2a&quot; -&gt; null<br>      - cidr              = &quot;192.168.2.0/24&quot; -&gt; null<br>      - dhcp_enable       = true -&gt; null<br>      - dns_list          = [<br>          - &quot;100.125.17.29&quot;,<br>          - &quot;100.125.135.29&quot;,<br>        ] -&gt; null<br>      - gateway_ip        = &quot;192.168.2.1&quot; -&gt; null<br>      - id                = &quot;77bc0afc-9bf8-492d-af83-bdbe76dfbdda&quot; -&gt; null<br>      - name              = &quot;zone1-1&quot; -&gt; null<br>      - primary_dns       = &quot;100.125.17.29&quot; -&gt; null<br>      - region            = &quot;cn-east-2&quot; -&gt; null<br>      - secondary_dns     = &quot;100.125.135.29&quot; -&gt; null<br>      - subnet_id         = &quot;6a63bd78-7fba-43f0-89ae-df25b4f19b93&quot; -&gt; null<br>      - vpc_id            = &quot;867655c8-7641-4fbf-b8c4-34989e560d46&quot; -&gt; null<br>    &#125;<br><br>Plan: 0 to add, 0 to change, 1 to destroy.<br><br><br>Warning: Resource targeting is in effect<br><br>You are creating a plan with the -target option, which means that the result<br>of this plan may not represent all of the changes requested by the current<br>configuration.<br><br>The -target option is not for routine use, and is provided only for<br>exceptional situations such as recovering from errors or mistakes, or when<br>Terraform specifically suggests to use it as part of an error message.<br><br>Do you really want to destroy all resources?<br>  Terraform will destroy all your managed infrastructure, as shown above.<br>  There is no undo. Only &#x27;yes&#x27; will be accepted to confirm.<br><br>  Enter a value: yes<br><br>huaweicloud_vpc_subnet.main: Destroying... [id=77bc0afc-9bf8-492d-af83-bdbe76dfbdda]<br>huaweicloud_vpc_subnet.main: Destruction complete after 10s<br><br>Warning: Applied changes may be incomplete<br><br>The plan was created with the -target option in effect, so some changes<br>requested in the configuration may have been ignored and the output values may<br>not be fully updated. Run the following command to verify that no other<br>changes are pending:<br>    terraform plan<br><br>Note that the -target option is not suitable for routine use, and is provided<br>only for exceptional situations such as recovering from errors or mistakes, or<br>when Terraform specifically suggests to use it as part of an error message.<br><br><br>Destroy complete! Resources: 1 destroyed.<br></code></pre></td></tr></table></figure><p>除此之外，还有一种间接删除资源的方式：归功于Terraform状态一致性的特点，当模板发生变更后，再次执行apply命令时，它会检查模板与状态文件是否一致，从而触发变更操作，因此，我们可以在模板中把要释放的资源删除，然后执行apply命令来完成资源的释放。</p><h2 id="三、Data-Source：资源信息的动态查询">三、Data Source：资源信息的动态查询</h2><p>对资源的查询是一个很常用的操作，比如，查看某个Region下有哪些可用区，某个可用区下有哪些实例规格，每个Region下有哪些镜像，当前账号下有多少机器等等。通过对资源及其属性的查询，可以帮助和引导我们进行下一步的操作。</p><p>除此之外，在编写Terraform模板时，Resource使用的参数有些是固定的静态变量，但有些情况下参数变量不确定、可选值不清楚或者参数可能随时变化。比如，我们创建ECS实现时，通常需要指定镜像ID和实例规格，首先我们要知道某个镜像ID对应的字符串、特定CPU核数和内存对应的实例规格。</p><p>以上这些信息虽然可以通过控制台或帮助文档手动查询到，但是一方面查询不方便，另一方面，我们的模板可能随时会更新。如果将这些信息硬编码在代码中，一旦我们这些信息发生变化，就需要重新修改代码，非常不灵活。</p><p>在Terraform中，Data Source就是用来查询资源信息的，每个Data Source实现对一个特定资源的动态查询。在模板中定义过滤条件，执行plan或者apply即可动态返回符合条件的资源。在编写模板时，可以通过引用的方式将Data Source的结果动态呈现更Resource。</p><h2 id="四、State：资源的状态存储">四、State：资源的状态存储</h2><p>到这里，我们应该会发现一个现象：在执行show和state list命令时，执行速度非常快，随着命令的结束，资源的属性很快就被展示出来了，而其它命令的执行都需要等几秒甚至几分钟，这个就跟Terraform的实现机制有关了。</p><p>Terraform是一个有状态的应用，在完成资源的创建和修改之后，它会将资源最新的状态和属性存储在一个称之为state的文件中，该文件的名称默认为terraform.tfstate，存储位置默认为资源模板所在的目录。state文件可以看作是Terraform存储资源属性的“数据库”，当执行show和state list命令时，Terraform直接读取的是state文件，无需调用云平台的API，而其它的命令需要与API交互后才返回。</p><p>state文件非常重要，它只从属于一个特定的模板，模板变了state就会跟着变。因此，如果state文件被损坏或者被删除，Terraform就会认为其管理的资源发生了变更和移除，此时再执行apply命令将会按照模板的定义变更或重建资源，直到模板对资源的定义与state中保存的内容保持一致。</p><p>state与模板的依附关系在团队协作时尤为重要，在拷贝模板代码的同时，如果想维护同一套资源，state也需要一起拷贝，而这无形中就增加了代码的维护成本。为了解决这个问题，Terraform提供了远端存储state的能力remote state，它可以将state文件存放在远端的共享存储上，以实现模板与state的管理分离。</p><p>模板与state的高度一致性也是Terraform的一大亮点。Terraform虽然是面向客户端的，但它也是有状态的，这意味着Terraform所管理的资源，不能通过其他工具和服务（如Web控制台，API等）来变更，否则，在下次执行apply时，Terrafrom会因为状态的不一致而触发变更。</p><h2 id="五、参考">五、参考</h2>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Terraform</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Terraform快速入门</title>
    <link href="/2021/01/04/Terraform%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2021/01/04/Terraform%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>todo</p><h2 id="一、安装">一、安装</h2><p>Terraform是以二进制可执行文件发布的，只需下载terraform，然后将terraform可执行文件添加到系统环境变量PATH中即可。下面以Linux系统为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p ~/terraform &amp;&amp; cd $_<br>wget https://releases.hashicorp.com/terraform/0.14.3/terraform_0.14.3_linux_amd64.zip<br>unzip terraform_0.14.3_linux_amd64.zip<br>sudo mv terraform /usr/local/bin/<br></code></pre></td></tr></table></figure><h2 id="二、认证鉴权">二、认证鉴权</h2><p>使用Terraform管理云资源前，需要获取云平台的AK/SK，并在Terraform中进行配置，从而实现认证鉴权。认证信息的配置方式是由各云厂商实现的provider决定的，详细信息可参考各云的provider文档。但常用的方式有两种：静态文件和环境变量。下面我们分别讨论。</p><h3 id="2-1、静态文件">2.1、静态文件</h3><p>静态文件，就是直接在配置文件中添加AK、SK信息，如下示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hcl">provider &quot;huaweicloud&quot; &#123;<br>  region     = &quot;cn-north-1&quot;<br>  access_key = &quot;my-access-key&quot;<br>  secret_key = &quot;my-secret-key&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>region：区域，即要管理哪个区域的资源。</li><li>access_key：密钥ID，即AK。</li><li>secret_key：访问密钥，即SK。</li></ul><h3 id="2-2、环境变量">2.2、环境变量</h3><p>环境变量，就是将认证信息配置成系统环境变量，下面以华为云为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">export</span> HW_REGION_NAME=<span class="hljs-string">&quot;cn-north-1&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">export</span> HW_ACCESS_KEY=<span class="hljs-string">&quot;my-access-key&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">export</span> HW_SECRET_KEY=<span class="hljs-string">&quot;my-secret-key&quot;</span></span><br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>HW_REGION_NAME：区域，即要管理哪个区域的资源。</li><li>HW_ACCESS_KEY：密钥ID，即AK。</li><li>HW_SECRET_KEY：访问密钥，即SK。</li></ul><h2 id="三、使用Terraform创建云上网络">三、使用Terraform创建云上网络</h2><p>下面，我们以华为云为例，使用Terraform创建一个VPC网络</p><h3 id="3-1、搭建本地registry">3.1、搭建本地registry</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://releases.hashicorp.com/terraform-provider-huaweicloud/1.20.0/terraform-provider-huaweicloud_1.20.0_linux_amd64.zip<br><br>mkdir -p ~/.terraform.d/plugins/local-registry/huaweicloud/huaweicloud/1.20.0/linux_amd64<br>unzip terraform-provider-huaweicloud_1.20.0_linux_amd64.zip -d ~/.terraform.d/plugins/local-registry/huaweicloud/huaweicloud/1.20.0/linux_amd64<br></code></pre></td></tr></table></figure><h3 id="3-2、配置registry">3.2、配置registry</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; ~/terraform/versions.tf &lt;&lt; EOF<br>terraform &#123;<br>  required_providers &#123;<br>    huaweicloud = &#123;<br>      source = &quot;local-registry/huaweicloud/huaweicloud&quot;<br>      version = &quot;1.20.0&quot;<br>    &#125;<br>  &#125;<br>&#125;<br>EOF<br></code></pre></td></tr></table></figure><h3 id="3-3、定义资源">3.3、定义资源</h3><p>创建“<a href="http://main.tf">main.tf</a>”文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs hcl">cat &gt; ~/terraform/main.tf &lt;&lt; EOF<br># Configure the HuaweiCloud Provider<br>provider &quot;huaweicloud&quot; &#123;<br>  region      = &quot;cn-south-1&quot;<br>  domain_name = &quot;Kuberxy&quot;<br>  access_key  = &quot;access_key&quot;<br>  secret_key  = &quot;access_key&quot;<br>&#125;<br><br># Create a VPC<br>resource &quot;huaweicloud_vpc&quot; &quot;example&quot; &#123;<br>  name = &quot;gz_vpc&quot;<br>  cidr = &quot;192.168.0.0/16&quot;<br>&#125;<br>EOF<br></code></pre></td></tr></table></figure><p>该文件：</p><ul><li>上半部分为HuaweiCloud Provider的配置，包含认证鉴权的内容；如果使用环境变量方式认证鉴权，可以省略该部分内容。</li><li>下半部分描述一个名为example的VPC资源，该VPC在云平台上的名称为gz_vpc，cidr为192.168.0.0/16。</li></ul><h3 id="3-4、初始化">3.4、初始化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">terraform init<br></code></pre></td></tr></table></figure><p>如果使用的是网络registry，首次执行时会访问公网下载Provider并安装。该命令的输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">Initializing the backend...<br><br>Initializing provider plugins...<br>- Finding local-registry/huaweicloud/huaweicloud versions matching &quot;1.20.0&quot;...<br>- Installing local-registry/huaweicloud/huaweicloud v1.20.0...<br>- Installed local-registry/huaweicloud/huaweicloud v1.20.0 (unauthenticated)<br><br>Terraform has created a lock file .terraform.lock.hcl to record the provider<br>selections it made above. Include this file in your version control repository<br>so that Terraform can guarantee to make the same selections by default when<br>you run &quot;terraform init&quot; in the future.<br><br>Terraform has been successfully initialized!<br><br>You may now begin working with Terraform. Try running &quot;terraform plan&quot; to see<br>any changes that are required for your infrastructure. All Terraform commands<br>should now work.<br><br>If you ever set or change modules or backend configuration for Terraform,<br>rerun this command to reinitialize your working directory. If you forget, other<br>commands will detect it and remind you to do so if necessary.<br></code></pre></td></tr></table></figure><h3 id="3-5、查看要创建的资源">3.5、查看要创建的资源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">terraform plan<br></code></pre></td></tr></table></figure><p>该命令会显示要创建哪些资源，输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">An execution plan has been generated and is shown below.<br>Resource actions are indicated with the following symbols:<br>  + create<br><br>Terraform will perform the following actions:<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">huaweicloud_vpc.example will be created</span><br>  + resource &quot;huaweicloud_vpc&quot; &quot;example&quot; &#123;<br>      + cidr                  = &quot;192.168.0.0/16&quot;<br>      + enterprise_project_id = (known after apply)<br>      + id                    = (known after apply)<br>      + name                  = &quot;gz_vpc&quot;<br>      + region                = (known after apply)<br>      + routes                = (known after apply)<br>      + shared                = (known after apply)<br>      + status                = (known after apply)<br>    &#125;<br><br>Plan: 1 to add, 0 to change, 0 to destroy.<br><br>------------------------------------------------------------------------<br><br>Note: You didn&#x27;t specify an &quot;-out&quot; parameter to save this plan, so Terraform<br>can&#x27;t guarantee that exactly these actions will be performed if<br>&quot;terraform apply&quot; is subsequently run.<br></code></pre></td></tr></table></figure><h3 id="3-6、创建资源">3.6、创建资源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">terraform apply<br></code></pre></td></tr></table></figure><p>该命令后需要我们进行确认后，才会真正的创建资源。根据提示输入“yes”即可，输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell">An execution plan has been generated and is shown below.<br>Resource actions are indicated with the following symbols:<br>  + create<br><br>Terraform will perform the following actions:<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">huaweicloud_vpc.example will be created</span><br>  + resource &quot;huaweicloud_vpc&quot; &quot;example&quot; &#123;<br>      + cidr                  = &quot;192.168.0.0/16&quot;<br>      + enterprise_project_id = (known after apply)<br>      + id                    = (known after apply)<br>      + name                  = &quot;gz_vpc&quot;<br>      + region                = (known after apply)<br>      + routes                = (known after apply)<br>      + shared                = (known after apply)<br>      + status                = (known after apply)<br>    &#125;<br><br>Plan: 1 to add, 0 to change, 0 to destroy.<br><br>Do you want to perform these actions?<br>  Terraform will perform the actions described above.<br>  Only &#x27;yes&#x27; will be accepted to approve.<br><br>  Enter a value: yes<br><br>huaweicloud_vpc.example: Creating...<br>huaweicloud_vpc.example: Creation complete after 7s [id=420c4ed2-20e5-4dca-b4bf-3758535ccbfc]<br><br>Apply complete! Resources: 1 added, 0 changed, 0 destroyed.<br></code></pre></td></tr></table></figure><h3 id="3-7、查看资源信息">3.7、查看资源信息</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">terraform <span class="hljs-keyword">show</span><br></code></pre></td></tr></table></figure><p>该命令会显示资源的详细信息，输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">huaweicloud_vpc.example:</span><br>resource &quot;huaweicloud_vpc&quot; &quot;example&quot; &#123;<br>    cidr                  = &quot;192.168.0.0/16&quot;<br>    enterprise_project_id = &quot;0&quot;<br>    id                    = &quot;420c4ed2-20e5-4dca-b4bf-3758535ccbfc&quot;<br>    name                  = &quot;gz_vpc&quot;<br>    region                = &quot;cn-east-2&quot;<br>    routes                = []<br>    shared                = false<br>    status                = &quot;OK&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-8、删除资源">3.8、删除资源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">terraform destroy<br></code></pre></td></tr></table></figure><p>该命令也需要进行确认，根据提示输入“yes”即可，输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell">An execution plan has been generated and is shown below.<br>Resource actions are indicated with the following symbols:<br>  - destroy<br><br>Terraform will perform the following actions:<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">huaweicloud_vpc.example will be destroyed</span><br>  - resource &quot;huaweicloud_vpc&quot; &quot;example&quot; &#123;<br>      - cidr                  = &quot;192.168.0.0/16&quot; -&gt; null<br>      - enterprise_project_id = &quot;0&quot; -&gt; null<br>      - id                    = &quot;420c4ed2-20e5-4dca-b4bf-3758535ccbfc&quot; -&gt; null<br>      - name                  = &quot;gz_vpc&quot; -&gt; null<br>      - region                = &quot;cn-east-2&quot; -&gt; null<br>      - routes                = [] -&gt; null<br>      - shared                = false -&gt; null<br>      - status                = &quot;OK&quot; -&gt; null<br>    &#125;<br><br>Plan: 0 to add, 0 to change, 1 to destroy.<br><br>Do you really want to destroy all resources?<br>  Terraform will destroy all your managed infrastructure, as shown above.<br>  There is no undo. Only &#x27;yes&#x27; will be accepted to confirm.<br><br>  Enter a value: yes<br><br>huaweicloud_vpc.example: Destroying... [id=420c4ed2-20e5-4dca-b4bf-3758535ccbfc]<br>huaweicloud_vpc.example: Still destroying... [id=420c4ed2-20e5-4dca-b4bf-3758535ccbfc, 10s elapsed]<br>huaweicloud_vpc.example: Destruction complete after 11s<br><br>Destroy complete! Resources: 1 destroyed.<br></code></pre></td></tr></table></figure><h2 id="四、参考">四、参考</h2><p><a href="https://support.huaweicloud.com/qs-terraform/index.html">快速入门</a></p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Terraform</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Terraform简介</title>
    <link href="/2021/01/04/Terraform%E7%AE%80%E4%BB%8B/"/>
    <url>/2021/01/04/Terraform%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>基础设施即代码（Infrastructure as Code），是指将云资源、服务或操作步骤以代码的形式定义在模板中，借助编排引擎，实现资源的自动化管理。而这也是资源编排最高效的实现模式。下面，我们就来认识一下Terraform这个IaC工具。</p><h2 id="一、我们为什么需要Terraform">一、我们为什么需要Terraform</h2><p>在传统运维模式下，业务上线需经过设备采购、机器上架、网络搭建和系统安装等准备阶段。随着云计算的兴起，各大公有云厂商均提供了非常友好的交互界面，用户通过一个浏览器就可以按需采购各种云资源，从而快速实现业务架构的搭建。</p><p>然而，随着业务架构的不断扩展，云资源采购的规模和种类也会不断增加。当我们需要快速采购大量不同类型的云资源时，Web控制台上大量的交互操作反而会降低云资源的采购效率。此外，工作成果的不可复制性，带来的是夸Region和跨云平台场景下的重复劳动。</p><p>作为用户，在使用公有云时，我们关心的是资源的操作结果，并不关心资源的操作步骤。如果有一份完整的云资源采购清单，这张清单上清楚的记录了所需要购买的云资源的种类、规格、数量以及各云资源之间的关系，然后一键完成购买，并且当业务需求发生变化时，只需要变更清单就可以实现对云资源的快速变更，那么效率就会提高很多。而这在云计算中就是资源编排，目前很多云厂商已经提供了资源编排能力，比如阿里云的ROS、AWS的CloudFormation等。</p><p>然而，各云厂商自家的云编排服务带来的是高昂的学习成本、低效的代码复用率和复杂的多云协同工作流程。每一种服务仅限于管理自家的云平台，无法满足对多个云平台，多种层级（如IaaS，PaaS）资源的统一管理。</p><blockquote><p>是否可以使用统一的编排工具，共用一套语法实现多云平台的统一管理呢？</p></blockquote><h2 id="二、Terraform是什么">二、Terraform是什么</h2><p>Terraform是由Hashicorp公司于2014年推出的一个开源项目，是一个典型的IaC工具。在Terraform中，Infrastructure是一个很广泛的抽象，它几乎涵盖了云平台上所有可以被管理的资源和服务，如网络资源、计算资源、存储资源、数据库资源等。</p><p>Terraform与各云厂商自家的资源编排服务（如阿里云的ROS、AWS的CloudFormation）相比，具有如下几个特点：</p><ul><li>开源。从诞生之初，Terraform就是一个开源项目，任何开发者都可以对其贡献代码。</li><li>多云管理。用户只需学习统一的Terraform语法，选择各云厂商提供的provider，定义相应的资源模板即可管理多个云平台上的资源。</li><li>面向客户端。在一台机器上安装好Terraform，编写好相应的资源模板后，就可以通过几个简单的Terraform命令实现对云资源的一键管理，而无需与API、SDK等方式进行集成。</li></ul><h2 id="三、Terraform-vs-Ansible">三、Terraform vs Ansible</h2><p>目前，市场上的IaC工具大体可以分为两类：</p><ul><li>配置管理类，典型代表是Ansible。</li><li>资源编排类，典型代表是Terraform。</li></ul><p>我们对Ansible可能更加熟悉，并且认为它也能完成Terrform的工作。比如，阿里云的Ansible Module同样可以实现对阿里云VPC、ECS、SLB等云资源的配置和管理。但我们需要知道的是，两者存在很大的差别：</p><ul><li>使用场景不同。配置管理工具侧重于操作系统级别的配置和管理，比如，软件的安装、配置，服务的启停等，其目的是为了实现对操作系统及其上应用的管理；而资源编排工具侧重于基础设施整体资源栈（计算、网络、存储等）的配置和管理。</li><li>工作模式不同。资源编排是声明式的，它只关心最终的操作结果，因为作为用户，我们只关心定义的资源是否都已经创建了。如果结果和声明的不一致，就会触发变更操作；配置管理工具则是过程式的，它需要关心每一步的操作结果，在执行时通常是串行的，会按顺序自动化执行所有的操作。</li></ul><h2 id="四、参考">四、参考</h2><p><a href="https://mp.weixin.qq.com/s/eMsUOUwcoKMj469shyRpCQ?spm=a2c6h.12873639.0.0.59527dd9CEtO9t">听说“一分钟就能部署阿里云ECS集群”？</a></p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Terraform</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lua面向对象</title>
    <link href="/2020/12/21/Lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2020/12/21/Lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>对象由属性和方法组成。Lua中最基本的结构是表，因此可以使用表描述对象属性，用Lua的函数来表示方法。即，Lua中的类可以通过表+函数模拟出来。至于继承，则可以通过元表模拟出来（不推荐使用，在Lua中模拟最基本的对象特性，通常情况下就够用了）。</p><h2 id="一、Lua中的面向对象">一、Lua中的面向对象</h2><p>Lua中的表在某种意义上就是一种对象。我们可以使用表和函数实现面向对象，将函数和相关数据放置于同一个表中就形成了一个对象。我们来看一个简单的例子：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- Meta class</span><br><span class="hljs-keyword">local</span> rectangle = &#123; length = <span class="hljs-number">0</span>, breadth = <span class="hljs-number">0</span>, area = <span class="hljs-number">0</span> &#125;<br><br><span class="hljs-comment">-- 类方法 new</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rectangle.new</span><span class="hljs-params">(self, obj, length, breadth)</span></span><br>    obj = obj <span class="hljs-keyword">or</span> &#123;&#125;<br>    <span class="hljs-built_in">setmetatable</span>(obj, <span class="hljs-built_in">self</span>)<br>    <span class="hljs-built_in">self</span>.<span class="hljs-built_in">__index</span> = <span class="hljs-built_in">self</span><br>    <span class="hljs-built_in">self</span>.length = length <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br>    <span class="hljs-built_in">self</span>.breadth = breadth <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br>    <span class="hljs-built_in">self</span>.area = length * breadth<br>    <span class="hljs-keyword">return</span> obj<br><span class="hljs-keyword">end</span><br>    <br><span class="hljs-comment">-- 类方法 printarea</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rectangle.printarea</span><span class="hljs-params">(self)</span></span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;rectangle area is: &quot;</span>, <span class="hljs-built_in">self</span>.area)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这个类包含了3个属性（length、breadth、area）和1个方法（printarea）。对于一个类我们常做的操作有：</p><ul><li>实例化类：</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">r = rectangle:new(<span class="hljs-literal">nil</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><ul><li>访问属性：</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(r.length)<br></code></pre></td></tr></table></figure><ul><li>访问方法：</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">r:printarea()<br></code></pre></td></tr></table></figure><ul><li>方法重写：</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">r:printarea</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;square area is: &quot;</span>, <span class="hljs-built_in">self</span>.area)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="二、继承">二、继承</h2><p>继承是指一个对象直接使用另一个对象的属性和方法，可用于扩展基础类的属性和方法。在Lua中，继承可通过元表来实现。我们来看一个具体的例子：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs LUA"><span class="hljs-comment">-- Meta class</span><br>Shape = &#123; area = <span class="hljs-number">0</span> &#125;<br><br><span class="hljs-comment">-- 基础类方法 new</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Shape.new</span><span class="hljs-params">(self, o, side)</span></span><br>    o = o <span class="hljs-keyword">or</span> &#123;&#125;<br>    <span class="hljs-built_in">setmetatable</span>(o, <span class="hljs-built_in">self</span>)<br>    <span class="hljs-built_in">self</span>.<span class="hljs-built_in">__index</span> = sself<br>    side = side <span class="hljs-keyword">or</span> &#123;&#125;<br>    <span class="hljs-built_in">self</span>.data = side * side<br>    <span class="hljs-keyword">return</span> o<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 基础类方法 printarea</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Shape:printarea</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;shape are is: &quot;</span>, <span class="hljs-built_in">self</span>.area)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 创建对象</span><br>myshape = Shape:new(<span class="hljs-literal">nil</span>, <span class="hljs-number">10</span>)<br>myshape.printarea()<br><br><br>Square = Shape:new()<br><br><span class="hljs-comment">-- 派生类方法 new</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Square.new</span><span class="hljs-params">(self, o, side)</span></span><br>    o = o <span class="hljs-keyword">or</span> Shape:new(o, side)<br>    <span class="hljs-built_in">setmetatable</span>(o, <span class="hljs-built_in">self</span>)<br>    <span class="hljs-built_in">self</span>.<span class="hljs-built_in">__index</span> = <span class="hljs-built_in">self</span><br>    <span class="hljs-keyword">return</span> o<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 派生类方法 printarea</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Square:printarea</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;square area is &quot;</span>, <span class="hljs-built_in">self</span>.area)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 创建对象</span><br>mysquare = Square:new(<span class="hljs-literal">nil</span>, <span class="hljs-number">10</span>)<br>mysquare:printarea()<br><br><br>Rectangle = Shape:new()<br><br><span class="hljs-comment">-- 派生类方法 new</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle.new</span><span class="hljs-params">(self, o, length, breadth)</span></span><br>    o = o <span class="hljs-keyword">or</span> Shape:new(o)<br>    <span class="hljs-built_in">setmetatable</span>(o, <span class="hljs-built_in">self</span>)<br>    <span class="hljs-built_in">self</span>.<span class="hljs-built_in">__index</span> = <span class="hljs-built_in">self</span><br>    <span class="hljs-built_in">self</span>.area = length * breadth<br>    <span class="hljs-keyword">return</span> o<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 派生类方法 printarea</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle:printarea</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;rectangle area is &quot;</span>, <span class="hljs-built_in">self</span>.area)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 创建对象</span><br>myrectangle = Rectangle:new(<span class="hljs-literal">nil</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>myrectangle.printarea()<br></code></pre></td></tr></table></figure><p>其运行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br></code></pre></td></tr></table></figure><h2 id="三、成员私有性">三、成员私有性</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Lua元表</title>
    <link href="/2020/12/20/Lua%E5%85%83%E8%A1%A8/"/>
    <url>/2020/12/20/Lua%E5%85%83%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>在Lua中，一个表可以通过key访问到对应的value，但是无法直接对两个表进行操作。因此，Lua提供了元表（metable），它允许改变表的行为，而每个行为都会有对应的元方法。</p><h2 id="一、理解Lua元表">一、理解Lua元表</h2><p>Lua中，元表的表现行为类似与C++中的操作符重载。比如，我们可以通过重载<code>__add</code>元方法，来计算两个Lua数组的并集，如下示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 定义两个集合</span><br><span class="hljs-keyword">local</span> set1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br><span class="hljs-keyword">local</span> set2 = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>&#125;<br><br><span class="hljs-comment">-- 定义一个用于重载__add元方法的函数。注意：函数的第一个参数是self</span><br><span class="hljs-keyword">local</span> union = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self, another)</span></span><br>    <span class="hljs-keyword">local</span> set = &#123;&#125;<br>    <span class="hljs-keyword">local</span> result = &#123;&#125;<br><br>    <span class="hljs-comment">-- 借助表来保证集合的互异性</span><br>    <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(<span class="hljs-built_in">self</span>) <span class="hljs-keyword">do</span><br>        set[v] = <span class="hljs-literal">true</span> <br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(another) <span class="hljs-keyword">do</span><br>        set[v] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-comment">-- 加入结果集合</span><br>    <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(set) <span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(result,v)<br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> result<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 重载set1的__add元方法</span><br><span class="hljs-built_in">setmetatable</span>(set1, &#123; <span class="hljs-built_in">__add</span> = union &#125;)<br><br><span class="hljs-keyword">local</span> set = set1 + set2<br><span class="hljs-keyword">for</span> _, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(set) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(v)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>其运行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">1<br>2<br>3<br>4<br>5<br>6<br></code></pre></td></tr></table></figure><p>当我们对两个表进行相加操作时，Lua的执行流程如下：</p><ul><li><p>首先，检查两者之一是否有元表，</p></li><li><p>然后，检查元表中是否有key为“<code>__add</code>”的元素，</p></li><li><p>最后，调用key为“<code>__add</code>”的元素的值。</p></li></ul><p>在这里，我们将key为“<code>__add</code>”的元素的值称为元方法。</p><h2 id="二、设置元表">二、设置元表</h2><p>通过setmetatable函数，我们可以为一个表设置元表，如下示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> mt = &#123;&#125;<br><span class="hljs-keyword">local</span> t = &#123;&#125;<br><br><span class="hljs-keyword">local</span> res = <span class="hljs-built_in">setmetatable</span>(t, mt)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(res), res)<br></code></pre></td></tr></table></figure><p>以上代码可以简写为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> res = <span class="hljs-built_in">setmetatable</span>(&#123;&#125;, &#123;&#125;)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(res), res)<br></code></pre></td></tr></table></figure><p>其执行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tabletable: 0x564da1a6ef00<br></code></pre></td></tr></table></figure><p>我们可以看到，setmetatable函数并不会直接修改原表，然是会返回一个新表</p><h2 id="三、获取元表">三、获取元表</h2><p>通过getmetatable函数，我们可以获取到一个表的元表，如下示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> t = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">local</span> res = <span class="hljs-built_in">getmetatable</span>(t)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(res), res)<br><span class="hljs-built_in">print</span>()<br><br><span class="hljs-keyword">local</span> mt = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>&#125;<br><span class="hljs-keyword">local</span> t = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">local</span> t = <span class="hljs-built_in">setmetatable</span>(t, mt) <br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(k,v)<br><span class="hljs-keyword">end</span><br><span class="hljs-built_in">print</span>()<br><br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(<span class="hljs-built_in">getmetatable</span>(t)) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(k,v)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>其执行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">nilnil<br><br>11<br>23<br>35<br><br>12<br>24<br>36<br></code></pre></td></tr></table></figure><p>我们可以看到，一个表的元表并不能直接被访问到，需要借助getmetatable方法。</p>]]></content>
    
    
    <categories>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lua元表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集群部署2：搭建一个完整的Kubernetes集群</title>
    <link href="/2020/12/18/%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B22%EF%BC%9A%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84Kubernetes%E9%9B%86%E7%BE%A4/"/>
    <url>/2020/12/18/%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B22%EF%BC%9A%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84Kubernetes%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<p>todo</p><h2 id="一、准备工作">一、准备工作</h2><p>首先，准备机器。最好能有三台或三台以上的机器，虚拟机和物理机都行。这些机器最好能满足如下要求：</p><ul><li>2核CPU、8GB内存；</li><li>30GB磁盘（注：磁盘上要有未使用的分区，否则就要多加一块为使用的磁盘）；</li><li>64位的Linux操作系统、3.10 及以上的内核版本；</li><li>内网互通；</li><li>能访问外网；</li><li>禁用防火墙和Swap；</li></ul><p>然后，实际部署前我们先明确一下目标：</p><ul><li>在所有节点上安装 Docker 和 kubeadm；</li><li>部署 Kubernetes Master；</li><li>部署容器网络插件；</li><li>部署 Kubernetes Worker；</li><li>部署 Dashboard 可视化插件；</li><li>部署容器存储插件。</li></ul><h2 id="二、安装Docker和Kubeadm">二、安装Docker和Kubeadm</h2><p>对于Docker和Kubeadm的安装，我们可以直接使用操作系统的包管理工具来安装，这里以ubuntu18.04为例。需要注意的是，由于国内访问国外资源被限制，因此，我将所有的网络资源替换为了国内站点。</p><h3 id="2-1、安装Docker">2.1、安装Docker</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Import key</span><br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Create repo</span><br>sudo tee /etc/apt/sources.list.d/docker-ce.list &lt;&lt; EOF<br>deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable<br>EOF<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Install Docker</span><br>sudo apt-get update &amp;&amp; sudo apt-get install -y docker-ce=18.06.3~ce~3-0~ubuntu<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Config Docker</span><br>sudo mkdir -p /etc/docker<br><br>sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;<br>&#123;<br>  &quot;dns&quot;: [&quot;223.5.5.5&quot;, &quot;223.6.6.6&quot;],<br>  &quot;registry-mirrors&quot;: [&quot;https://jfb4kjfb.mirror.aliyuncs.com&quot;],<br>  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],<br>  &quot;log-driver&quot;: &quot;json-file&quot;,<br>  &quot;log-opts&quot;: &#123;<br>    &quot;max-size&quot;: &quot;100m&quot;<br>  &#125;,<br>  &quot;storage-driver&quot;: &quot;overlay2&quot;<br>&#125;<br>EOF<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Start Docker</span><br>sudo systemctl daemon-reload<br><br>sudo systemctl restart docker.service<br>sudo systemctl enable docker.service<br>sudo usermod -aG docker $USER<br></code></pre></td></tr></table></figure><h3 id="2-2、安装Kubeadm">2.2、安装Kubeadm</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Import key</span><br>curl -fsSL https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Create repo</span><br>sudo bash -c &#x27;<br>cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list<br>deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main<br>EOF<br>&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Install</span><br>sudo apt-get update<br>sudo apt-get install -y kubernetes-cni=0.8.6-00 kubelet=1.16.14-00 kubeadm=1.16.14-00 kubectl=1.16.14-00<br></code></pre></td></tr></table></figure><h2 id="三、配置高可用环境">三、配置高可用环境</h2><p>使用kubeadm工具，虽然可以通过部署多个master节点和worker节点来保证kubernetes相关组件的高可用，但是apiserver作为一个HTTP服务，仍需要通过负载均衡来提供统一的入口，从而实现真正意义上的高可用。对于apiserver的高可用，kubernetes社区提供了三种解决方案：</p><ul><li>使用传统的部署方式，直接在操作系统上部署keepalived和haproxy</li><li>使用kubelet的static pod特性，通过容器部署keepalived和haproxy</li><li>使用kubelet的static pod特性，通过容器部署kube-vip</li></ul><p>接下来，我们以第三种方案为例，构建一个高可用环境。在我的环境中，有三个master节点node1、node2和node3。需要注意的是，由于kube-vip采用的是raft算法，因此组建高可用集群时至少需要三个节点。</p><p>首先，在maste节点上生成kube-vip的配置文件，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">node1</span><br>sudo mkdir -p /etc/kube-vip/<br>sudo tee /etc/kube-vip/config.yaml &lt;&lt;EOF<br>localPeer:<br>  id: node1<br>  address: 192.168.3.150<br>  port: 10000<br>remotePeers:<br>- id: node2<br>  address: 192.168.3.141<br>  port: 10000<br>- id: node3<br>  address: 192.168.3.146<br>  port: 10000<br>vip: 192.168.3.100<br>gratuitousARP: true<br>singleNode: false<br>startAsLeader: true<br>interface: eth0<br>loadBalancers:<br>- name: API Server Load Balancer<br>  type: tcp<br>  port: 64436<br>  bindToVip: false<br>  backends:<br>  - address: 192.168.3.150<br>    port: 6443<br>  - address: 192.168.3.141<br>    port: 6443<br>  - address: 192.168.3.146<br>    port: 6443<br>EOF<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">node2</span><br>sudo mkdir -p /etc/kube-vip/<br>sudo tee /etc/kube-vip/config.yaml &lt;&lt;EOF<br>localPeer:<br>  id: node2<br>  address: 192.168.3.141<br>  port: 10000<br>remotePeers:<br>- id: node1<br>  address: 192.168.3.150<br>  port: 10000<br>- id: node3<br>  address: 192.168.3.146<br>  port: 10000<br>vip: 192.168.3.100<br>gratuitousARP: true<br>singleNode: false<br>startAsLeader: false<br>interface: eth0<br>loadBalancers:<br>- name: API Server Load Balancer<br>  type: tcp<br>  port: 64436<br>  bindToVip: false<br>  backends:<br>  - address: 192.168.3.150<br>    port: 6443<br>  - address: 192.168.3.141<br>    port: 6443<br>  - address: 192.168.3.146<br>    port: 6443<br>EOF<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">node3</span><br>sudo mkdir -p /etc/kube-vip/<br>sudo tee /etc/kube-vip/config.yaml &lt;&lt;EOF<br>localPeer:<br>  id: node3<br>  address: 192.168.3.146<br>  port: 10000<br>remotePeers:<br>- id: node1<br>  address: 192.168.3.150<br>  port: 10000<br>- id: node2<br>  address: 192.168.3.141<br>  port: 10000<br>vip: 192.168.3.100<br>gratuitousARP: true<br>singleNode: false<br>startAsLeader: false<br>interface: eth0<br>loadBalancers:<br>- name: API Server Load Balancer<br>  type: tcp<br>  port: 64436<br>  bindToVip: false<br>  backends:<br>  - address: 192.168.3.150<br>    port: 6443<br>  - address: 192.168.3.141<br>    port: 6443<br>  - address: 192.168.3.146<br>    port: 6443<br>EOF<br></code></pre></td></tr></table></figure><p>然后，在master节点上执行如下命令，生成kube-vip容器的资源描述性文件kube-vip.yaml：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">on all mater node</span><br>mkdir -p /etc/kubernetes/manifests<br>sudo docker run -it --rm plndr/kube-vip:0.1.1 /kube-vip sample manifest \<br>    | sed &quot;s|plndr/kube-vip:&#x27;|plndr/kube-vip:0.1.1&#x27;|&quot; \<br>    | sudo tee /etc/kubernetes/manifests/kube-vip.yaml<br></code></pre></td></tr></table></figure><p>这样，当我们初始化集群（执行kubeadm init）时，kubelet就会通过static pod机制运行kube-vip。</p><h2 id="四、部署Kubernetes的Master节点">四、部署Kubernetes的Master节点</h2><p>首先，我们在一台master节点上执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">生成配置文件</span><br>mkdir -p ~/conf<br><br>cat &gt; ~/conf/kubeadm-config.yaml &lt;&lt; EOF<br>apiVersion: kubeadm.k8s.io/v1beta2<br>kind: ClusterConfiguration<br>kubernetesVersion: 1.16.0<br>imageRepository: &quot;registry.aliyuncs.com/google_containers&quot;<br>apiServer:<br>  certSANs:<br>  - &quot;192.168.3.100&quot;<br>controlPlaneEndpoint: &quot;192.168.3.100:64436&quot;<br>networking:<br>  serviceSubnet: &quot;10.244.0.0/16&quot;<br>  podSubnet: &quot;10.243.0.0/16&quot;<br>EOF<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">预下载镜像</span><br>sudo kubeadm config images pull --config ~/conf/kubeadm-config.yaml<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行初始化</span><br>sudo kubeadm init --config ~/conf/kubeadm-config.yaml --upload-certs<br></code></pre></td></tr></table></figure><p>如果看到类似如下的输出，就说明初始化成功了，否则，就是失败，此时可以根据提示信息进行排错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs shell">[init] Using Kubernetes version: v1.16.0<br>[preflight] Running pre-flight checks<br>[preflight] Pulling images required for setting up a Kubernetes cluster<br>[preflight] This might take a minute or two, depending on the speed of your internet connection<br>[preflight] You can also perform this action in beforehand using &#x27;kubeadm config images pull&#x27;<br>[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;<br>[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;<br>[kubelet-start] Activating the kubelet service<br>[certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot;<br>[certs] Generating &quot;ca&quot; certificate and key<br>[certs] Generating &quot;apiserver&quot; certificate and key<br>[certs] apiserver serving cert is signed for DNS names [test1 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.244.0.1 192.168.3.150 192.168.3.100 192.168.3.100]<br>[certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key<br>[certs] Generating &quot;front-proxy-ca&quot; certificate and key<br>[certs] Generating &quot;front-proxy-client&quot; certificate and key<br>[certs] Generating &quot;etcd/ca&quot; certificate and key<br>[certs] Generating &quot;etcd/server&quot; certificate and key<br>[certs] etcd/server serving cert is signed for DNS names [test1 localhost] and IPs [192.168.3.150 127.0.0.1 ::1]<br>[certs] Generating &quot;etcd/peer&quot; certificate and key<br>[certs] etcd/peer serving cert is signed for DNS names [test1 localhost] and IPs [192.168.3.150 127.0.0.1 ::1]<br>[certs] Generating &quot;etcd/healthcheck-client&quot; certificate and key<br>[certs] Generating &quot;apiserver-etcd-client&quot; certificate and key<br>[certs] Generating &quot;sa&quot; key and public key<br>[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;<br>[endpoint] WARNING: port specified in controlPlaneEndpoint overrides bindPort in the controlplane address<br>[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file<br>[endpoint] WARNING: port specified in controlPlaneEndpoint overrides bindPort in the controlplane address<br>[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file<br>[endpoint] WARNING: port specified in controlPlaneEndpoint overrides bindPort in the controlplane address<br>[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file<br>[endpoint] WARNING: port specified in controlPlaneEndpoint overrides bindPort in the controlplane address<br>[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file<br>[control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot;<br>[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;<br>[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;<br>[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;<br>[etcd] Creating static Pod manifest for local etcd in &quot;/etc/kubernetes/manifests&quot;<br>[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;/etc/kubernetes/manifests&quot;. This can take up to 4m0s<br>[apiclient] All control plane components are healthy after 27.556250 seconds<br>[upload-config] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace<br>[kubelet] Creating a ConfigMap &quot;kubelet-config-1.16&quot; in namespace kube-system with the configuration for the kubelets in the cluster<br>[upload-certs] Storing the certificates in Secret &quot;kubeadm-certs&quot; in the &quot;kube-system&quot; Namespace<br>[upload-certs] Using certificate key:<br>becb9899b6f143931d1112da0b6c92e94f1bc694458d5d6b761b55c8c49cfd8a<br>[mark-control-plane] Marking the node test1 as control-plane by adding the label &quot;node-role.kubernetes.io/master=&#x27;&#x27;&quot;<br>[mark-control-plane] Marking the node test1 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]<br>[bootstrap-token] Using token: 8zsbwe.8hu68ikz58gw93os<br>[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles<br>[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials<br>[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token<br>[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster<br>[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace<br>[addons] Applied essential addon: CoreDNS<br>[endpoint] WARNING: port specified in controlPlaneEndpoint overrides bindPort in the controlplane address<br>[addons] Applied essential addon: kube-proxy<br><br>Your Kubernetes control-plane has initialized successfully!<br><br>To start using your cluster, you need to run the following as a regular user:<br><br>  mkdir -p $HOME/.kube<br>  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<br>  sudo chown $(id -u):$(id -g) $HOME/.kube/config<br><br>You should now deploy a pod network to the cluster.<br>Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:<br>  https://kubernetes.io/docs/concepts/cluster-administration/addons/<br><br>You can now join any number of the control-plane node running the following command on each as root:<br><br>  kubeadm join 192.168.3.100:64436 --token 8zsbwe.8hu68ikz58gw93os \<br>    --discovery-token-ca-cert-hash sha256:0c6a1f0591b3fdff6353e777f8ecf008c4fddeb6a48446369fe0b8dd65a3e55a \<br>    --control-plane --certificate-key becb9899b6f143931d1112da0b6c92e94f1bc694458d5d6b761b55c8c49cfd8a<br><br>Please note that the certificate-key gives access to cluster sensitive data, keep it secret!<br>As a safeguard, uploaded-certs will be deleted in two hours; If necessary, you can use <br>&quot;kubeadm init phase upload-certs --upload-certs&quot; to reload certs afterward.<br><br>Then you can join any number of worker nodes by running the following on each as root:<br><br>kubeadm join 192.168.3.100:64436 --token 8zsbwe.8hu68ikz58gw93os \<br>    --discovery-token-ca-cert-hash sha256:0c6a1f0591b3fdff6353e777f8ecf008c4fddeb6a48446369fe0b8dd65a3e55a<br></code></pre></td></tr></table></figure><p>到这里，我们还无法直接使用集群，初始化操作完成后还需要执行如下操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p $HOME/.kube<br>sudo cp -a /etc/kubernetes/admin.conf $HOME/.kube/config<br>sudo chown $(id -u):$(id -g) $HOME/.kube/config<br></code></pre></td></tr></table></figure><p>此时，如果我们查看当前集群中的节点数，会发现只有一个master角色的节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get node</span><br>NAME    STATUS     ROLES    AGE   VERSION<br>test1   NotReady   master   18m   v1.16.14<br></code></pre></td></tr></table></figure><p>而如果想要将其它节点作为master角色加入到集群中，就需要在待加入的节点上执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">生成配置文件</span><br>mkdir -p ~/conf<br><br>cat &gt; ~/conf/kubeadm-config.yaml &lt;&lt; EOF<br>apiVersion: kubeadm.k8s.io/v1beta2<br>kind: ClusterConfiguration<br>kubernetesVersion: 1.16.0<br>imageRepository: &quot;registry.aliyuncs.com/google_containers&quot;<br>apiServer:<br>  certSANs:<br>  - &quot;192.168.3.100&quot;<br>controlPlaneEndpoint: &quot;192.168.3.100:64436&quot;<br>networking:<br>  serviceSubnet: &quot;10.244.0.0/16&quot;<br>  podSubnet: &quot;10.243.0.0/16&quot;<br>EOF<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">预下载镜像</span><br>sudo kubeadm config images pull --config ~/conf/kubeadm-config.yaml<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">加入集群</span><br>sudo kubeadm join 192.168.3.100:64436 --token 8zsbwe.8hu68ikz58gw93os \<br>  --discovery-token-ca-cert-hash sha256:0c6a1f0591b3fdff6353e777f8ecf008c4fddeb6a48446369fe0b8dd65a3e55a \<br>  --control-plane --certificate-key becb9899b6f143931d1112da0b6c92e94f1bc694458d5d6b761b55c8c49cfd8a \<br>  --ignore-preflight-errors=DirAvailable--etc-kubernetes-manifests<br></code></pre></td></tr></table></figure><p>如果看到类似如下的输出，就说明加入成功了，否则，就是失败，此时可以根据提示信息进行排错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs shell">[preflight] Running pre-flight checks<br>[WARNING DirAvailable--etc-kubernetes-manifests]: /etc/kubernetes/manifests is not empty<br>[preflight] Reading configuration from the cluster...<br>[preflight] FYI: You can look at this config file with &#x27;kubectl -n kube-system get cm kubeadm-config -oyaml&#x27;<br>[preflight] Running pre-flight checks before initializing the new control plane instance<br>[preflight] Pulling images required for setting up a Kubernetes cluster<br>[preflight] This might take a minute or two, depending on the speed of your internet connection<br>[preflight] You can also perform this action in beforehand using &#x27;kubeadm config images pull&#x27;<br>[download-certs] Downloading the certificates in Secret &quot;kubeadm-certs&quot; in the &quot;kube-system&quot; Namespace<br>[certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot;<br>[certs] Generating &quot;apiserver&quot; certificate and key<br>[certs] apiserver serving cert is signed for DNS names [test2 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.244.0.1 192.168.3.141 192.168.3.100 192.168.3.100]<br>[certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key<br>[certs] Generating &quot;etcd/peer&quot; certificate and key<br>[certs] etcd/peer serving cert is signed for DNS names [test2 localhost] and IPs [192.168.3.141 127.0.0.1 ::1]<br>[certs] Generating &quot;etcd/healthcheck-client&quot; certificate and key<br>[certs] Generating &quot;apiserver-etcd-client&quot; certificate and key<br>[certs] Generating &quot;etcd/server&quot; certificate and key<br>[certs] etcd/server serving cert is signed for DNS names [test2 localhost] and IPs [192.168.3.141 127.0.0.1 ::1]<br>[certs] Generating &quot;front-proxy-client&quot; certificate and key<br>[certs] Valid certificates and keys now exist in &quot;/etc/kubernetes/pki&quot;<br>[certs] Using the existing &quot;sa&quot; key<br>[kubeconfig] Generating kubeconfig files<br>[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;<br>[endpoint] WARNING: port specified in controlPlaneEndpoint overrides bindPort in the controlplane address<br>[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file<br>[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file<br>[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file<br>[control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot;<br>[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;<br>[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;<br>[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;<br>[check-etcd] Checking that the etcd cluster is healthy<br>[kubelet-start] Downloading configuration for the kubelet from the &quot;kubelet-config-1.16&quot; ConfigMap in the kube-system namespace<br>[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;<br>[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;<br>[kubelet-start] Activating the kubelet service<br>[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...<br>[etcd] Announced new etcd member joining to the existing etcd cluster<br>[etcd] Creating static Pod manifest for &quot;etcd&quot;<br>[etcd] Waiting for the new etcd member to join the cluster. This can take up to 40s<br>[kubelet-check] Initial timeout of 40s passed.<br>[upload-config] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace<br>[mark-control-plane] Marking the node test2 as control-plane by adding the label &quot;node-role.kubernetes.io/master=&#x27;&#x27;&quot;<br>[mark-control-plane] Marking the node test2 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]<br><br>This node has joined the cluster and a new control plane instance was created:<br><br>* Certificate signing request was sent to apiserver and approval was received.<br>* The Kubelet was informed of the new secure connection details.<br>* Control plane (master) label and taint were applied to the new node.<br>* The Kubernetes control plane instances scaled up.<br>* A new etcd member was added to the local/stacked etcd cluster.<br><br>To start administering your cluster from this node, you need to run the following as a regular user:<br><br>mkdir -p $HOME/.kube<br>sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<br>sudo chown $(id -u):$(id -g) $HOME/.kube/config<br><br>Run &#x27;kubectl get nodes&#x27; to see this node join the cluster.<br></code></pre></td></tr></table></figure><h2 id="五、部署容器网络插件">五、部署容器网络插件</h2><p>得益于kubernetes一切皆容器的设计理念，部署网络插件非常简单，只需要执行一句kubectl apply命令即可，这里以weave插件为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">获取flannel配置文件</span><br>wget -O ~/conf/kube-weave.yml https://github.com/weaveworks/weave/releases/download/latest_release/weave-daemonset-k8s-1.11.yaml<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取flannel镜像</span><br>awk &#x27;/image/&#123;print &quot;sudo docker pull &quot; $2&#125;&#x27; ~/conf/kube-weave.yml | bash<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装flannel网络</span><br>kubectl apply -f ~/conf/kube-weave.yml<br></code></pre></td></tr></table></figure><h2 id="六、部署Kubernetes的Worker节点">六、部署Kubernetes的Worker节点</h2><p>有了kubeadm后，worker节点的部署也变得非常简单，在worker节点上安装好docker和kubelet之后，执行初始化master节点时生成的join指令即可，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo kubeadm join 192.168.104.100:64436 --token nhb7g9.mqe2do308eda9m6g \<br>    --discovery-token-ca-cert-hash sha256:d9e07db543a2deaecad8946d18a8c8a7a956d255bf30b0c29f1adb0d4237cdf7<br></code></pre></td></tr></table></figure><p>如果看到类似如下的输出，就说明加入成功了，否则，就是失败，此时可以根据提示信息进行排错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[preflight] Running pre-flight checks<br>[preflight] Reading configuration from the cluster...<br>[preflight] FYI: You can look at this config file with &#x27;kubectl -n kube-system get cm kubeadm-config -oyaml&#x27;<br>[kubelet-start] Downloading configuration for the kubelet from the &quot;kubelet-config-1.16&quot; ConfigMap in the kube-system namespace<br>[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;<br>[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;<br>[kubelet-start] Activating the kubelet service<br>[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...<br><br>This node has joined the cluster:<br>* Certificate signing request was sent to apiserver and a response was received.<br>* The Kubelet was informed of the new secure connection details.<br><br>Run &#x27;kubectl get nodes&#x27; on the control-plane to see this node join the cluster.<br></code></pre></td></tr></table></figure><h2 id="七、调整Master节点的运行机制">七、调整Master节点的运行机制</h2><h3 id="7-1、Taint-Toleration机制">7.1、Taint/Toleration机制</h3><p>在默认情况下，master节点是不允许运行用户Pod的。而Kubernetes之所以能做到这一点，依靠的是一个叫做Taint/Toleration的机制。</p><p>该机制的原理非常简单：一旦某个节点被加上了某个Taint，即被“打上了污点”，那么所有的Pod就都不能在这个节点上运行，因为Kubernetes的Pod都是有“洁癖”的。除非，Pod自己声明能“容忍”这个“污点”，即在资源描述文件中定义了Toleration，它才能在这个有“污点”的节点上运行。</p><h3 id="7-2、给节点打“污点”">7.2、给节点打“污点”</h3><blockquote><p>那么，如何给节点打“污点”呢？</p></blockquote><p>要为节点打上“污点”也很简单，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl taint nodes node1 foo=bar:NoSchedule<br></code></pre></td></tr></table></figure><p>这时，节点node1上就会增加一个键值对格式的Taint，即：foo=bar:NoSchedule。在这里foo就是键，bar:NoSchedule就是值，其中，值里面的NoSchedule表示这个Taint只会在调度新Pod时才会产生作用，而不会影响已经在node1上运行的Pod，哪怕它并没有定义能“容忍”的“污点”（Toleration）。</p><h3 id="7-3、设置Pod能“容忍”的“污点”">7.3、设置Pod能“容忍”的“污点”</h3><blockquote><p>那么，Pod又是如何定义Toleration的呢？</p></blockquote><p>我们只要在Pod的.yaml文件中的spec部分，加入tolerations字段即可，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-string">...</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">tolerations:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;foo&quot;</span><br>    <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Equal&quot;</span><br>    <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;bar&quot;</span><br>    <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoSchedule&quot;</span><br></code></pre></td></tr></table></figure><p>这个Toleration的含义是，该Pod能“容忍”所有键值对为foo=bar的Taint，其中<code>operator: &quot;Equal&quot;</code>表示等于操作。</p><h3 id="7-4、查看节点的“污点”">7.4、查看节点的“污点”</h3><p>现在，回到我们刚刚搭建的集群上来。此时，如果我们通过kubectl describe检查一下master节点的Taint字段，就会发现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe node node1 | grep Taint</span><br>Taints:             node-role.kubernetes.io/master:NoSchedule<br></code></pre></td></tr></table></figure><p>master节点默认被加上了一个&quot;污点&quot;，这个“污点”的“键”<a href="http://xn--node-role-pr6s.kubernetes.io/master%EF%BC%8C%E8%80%8C%E6%B2%A1%E6%9C%89%E6%8F%90%E4%BE%9B%E2%80%9C%E5%80%BC%E2%80%9D%E3%80%82">是node-role.kubernetes.io/master，而没有提供“值”。</a></p><p>此时，如果我们想要将某个Pod运行在master节点上，就需要像下面这样描述Pod，用“Exists”操作符来声明，该Pod能够“容忍”所有以“<a href="http://node-role.kubernetes.io/master%E2%80%9D%E4%B8%BA%E9%94%AE%E7%9A%84Taint%EF%BC%9A">node-role.kubernetes.io/master”为键的Taint：</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-string">...</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">tolerations:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;node-role.kubernetes.io/master&quot;</span><br>    <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Exists&quot;</span><br>    <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoSchedule&quot;</span><br></code></pre></td></tr></table></figure><p>这样，这个Pod才能在master节点上运行。</p><h3 id="7-5、删除节点的“污点”">7.5、删除节点的“污点”</h3><p>当然，如果我们想要在master节点上运行所有的pod，只需要删除这个Taint即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl taint nodes --all node-role.kubernetes.io/master-<br></code></pre></td></tr></table></figure><p>如上，我们在“<a href="http://node-role.kubernetes.io/master%E2%80%9D%E8%BF%99%E4%B8%AA%E9%94%AE%E5%90%8E%E9%9D%A2%E5%8A%A0%E4%B8%8A%E4%BA%86%E4%B8%80%E4%B8%AA%E5%87%8F%E5%8F%B7%E2%80%9C-%E2%80%9D,%E8%BF%99%E8%A1%A8%E7%A4%BA%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E4%BB%A5%E2%80%9Cnode-role.kubernetes.io/master%E2%80%9D%E4%B8%BA%E9%94%AE%E9%A2%9DTaint%E3%80%82">node-role.kubernetes.io/master”这个键后面加上了一个减号“-”,这表示删除所有以“node-role.kubernetes.io/master”为键额Taint。</a></p><h2 id="八、部署Dashboard可视化插件">八、部署Dashboard可视化插件</h2><p>在Kubernetes社区中，提供了一个Dashboard项目，通过它我们可以通过Web界面来查看当前集群的各种信息，这个项目的部署也非常简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.1.0/aio/deploy/recommended.yaml<br></code></pre></td></tr></table></figure><p>部署完成之后，我们就可以查看 Dashboard 对应的 Pod 的状态了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get pods -n kubernetes-dashboard<br></code></pre></td></tr></table></figure><p>需要注意的是，由于 Dashboard 是一个 Web Server，很多人经常会在自己的公有云上无意地暴露 Dashboard 的端口，从而造成安全隐患。所以，1.7 版本之后的 Dashboard 项目部署完成后，默认只能通过 Proxy 的方式在本地访问。具体的操作，可以查看 Dashboard 项目的官方文档。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">https://github.com/kubernetes/dashboard<br></code></pre></td></tr></table></figure><p>而如果想从集群外访问这个 Dashboard 的话，可参考如下链接中提供的几种方法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/kubernetes/</span>dashboard<span class="hljs-regexp">/blob/m</span>aster<span class="hljs-regexp">/docs/u</span>ser<span class="hljs-regexp">/accessing-dashboard/</span>README.md<br></code></pre></td></tr></table></figure><h2 id="九、部署容器存储插件">九、部署容器存储插件</h2><p>在这里，我们还需要完成Kubernetes部署的最后一步：容器持久化存储。</p><p>很多时候我们需要用数据卷（Volume）把宿主机上的目录或者文件挂载进容器的 Mount Namespace 中，从而达到容器和宿主机共享这些目录或者文件的目的。容器里的应用，也就可以在这些数据卷中新建和写入文件。</p><p>容器最典型的特征之一就是：无状态。而容器的持久化存储，就是用来保存容器存储状态的重要手段：存储插件会在容器里挂载一个基于网络或者其他机制的远程数据卷，使得在容器里创建的文件，实际上是保存在远程存储服务器上，或者以分布式的方式保存在多个节点上，而与当前宿主机没有任何绑定关系。</p><p>这样，无论在其他哪个宿主机上启动新的容器，都可以请求挂载指定的持久化存储卷，从而访问到数据卷里保存的内容。这就是“持久化”的含义。</p><p>由于 Kubernetes 本身的松耦合设计，绝大多数存储项目，比如 Ceph、GlusterFS、NFS 等，都可以为 Kubernetes 提供持久化存储能力。接下来，我们将部署一个很重要的 Kubernetes 存储插件项目：Rook。</p><p>Rook 项目是一个基于 Ceph 的 Kubernetes 存储插件（它后期也在加入对更多存储实现的支持）。不过，不同于对 Ceph 的简单封装，Rook 在自己的实现中加入了水平扩展、迁移、灾难备份、监控等大量的企业级功能，使得这个项目变成了一个完整的、生产级别可用的容器存储插件。</p><p>得益于容器化技术，用几条指令，Rook 就可以把复杂的 Ceph 存储后端部署起来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone --single-branch --branch v1.5.7 https://github.com/rook/rook.git<br>cd rook/cluster/examples/kubernetes/ceph<br><br>kubectl apply -f crds.yaml<br>kubectl apply -f common.yaml<br>kubectl apply -f operator.yaml<br><br>kubectl -n rook-ceph create secret generic rook-ceph-crash-collector-keyring<br><br>kubectl apply -f cluster.yaml<br></code></pre></td></tr></table></figure><p>部署完成后，就可以看到 Rook 项目会将自己的 Pod 放置在由它自己管理的两个 Namespace 当中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods -n rook-ceph-system</span><br>NAME                                  READY     STATUS    RESTARTS   AGE<br>rook-ceph-agent-7cv62                 1/1       Running   0          15s<br>rook-ceph-operator-78d498c68c-7fj72   1/1       Running   0          44s<br>rook-discover-2ctcv                   1/1       Running   0          15s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods -n rook-ceph</span><br>NAME                   READY     STATUS    RESTARTS   AGE<br>rook-ceph-mon0-kxnzh   1/1       Running   0          13s<br>rook-ceph-mon1-7dn2t   1/1       Running   0          2s<br></code></pre></td></tr></table></figure><p>这样，一个基于 Rook 持久化存储集群就以容器的方式运行起来了，而接下来在 Kubernetes 项目上创建的所有 Pod 就能够通过 Persistent Volume（PV）和 Persistent Volume Claim（PVC）的方式，在容器里挂载由 Ceph 提供的数据卷了。而 Rook 项目，则会负责这些数据卷的生命周期管理、灾难备份等运维工作。</p><blockquote><p>这时候，我们可能会有个疑问：为什么要选择 Rook 项目呢？</p></blockquote><p>其实，是因为这个项目很有前途。如果去研究一下 Rook 项目的实现，就会发现它巧妙地依赖了 Kubernetes 提供的编排能力，合理的使用了很多诸如 Operator、CRD 等重要的扩展特性（这些特性我都会在后面的文章中逐一讲解到）。这使得 Rook 项目，成为了目前社区中基于 Kubernetes API 构建的最完善也最成熟的容器存储插件。</p><p>备注：其实，在很多时候，大家说的所谓“云原生”，就是“Kubernetes 原生”的意思。而像 Rook、Istio 这样的项目，正是贯彻这个思路的典范。</p>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lua Table库</title>
    <link href="/2020/12/17/Lua%20Table%E5%BA%93/"/>
    <url>/2020/12/17/Lua%20Table%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>Lua表的功能十分强大，几乎能存储Lua中的所有数据类型。在Lua编程中经常会对表进行一些操作，Lua内建了一些操作表的函数，通过它们可以极大的提高编程效率。</p><h2 id="一、getn">一、getn</h2><p>getn函数用于获取表的长度，等同于一元操作符<code>#</code>，其语法为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">table</span>.gent(t)<br></code></pre></td></tr></table></figure><p>我们来看如下代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> t = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">table</span>.<span class="hljs-built_in">getn</span>(t))<br><span class="hljs-built_in">print</span>(#t)<br><span class="hljs-built_in">print</span>()<br><br><span class="hljs-keyword">local</span> t = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">nil</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">table</span>.<span class="hljs-built_in">getn</span>(t))<br><span class="hljs-built_in">print</span>(#t)<br><span class="hljs-built_in">print</span>()<br><br><span class="hljs-keyword">local</span> t = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,k=<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">table</span>.<span class="hljs-built_in">getn</span>(t))<br><span class="hljs-built_in">print</span>(#t)<br></code></pre></td></tr></table></figure><p>其执行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">4<br>4<br><br>5<br>5<br><br>4<br>4<br></code></pre></td></tr></table></figure><p>可以看到getn函数只对普通值有效。</p><h2 id="二、maxn">二、maxn</h2><p>maxn函数用于获取表元素的最大索引号，其语法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">table</span>.<span class="hljs-built_in">maxn</span>(t)<br></code></pre></td></tr></table></figure><p>我们来看如下代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> t = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">table</span>.<span class="hljs-built_in">maxn</span>(t))<br><span class="hljs-built_in">print</span>(#t)<br><span class="hljs-built_in">print</span>()<br><br><span class="hljs-keyword">local</span> t = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">nil</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">table</span>.<span class="hljs-built_in">maxn</span>(t))<br><span class="hljs-built_in">print</span>(#t)<br><span class="hljs-built_in">print</span>()<br><br><span class="hljs-keyword">local</span> t = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,k=<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">table</span>.<span class="hljs-built_in">maxn</span>(t))<br><span class="hljs-built_in">print</span>(#t)<br></code></pre></td></tr></table></figure><p>其执行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">4<br>4<br><br>5<br>5<br><br>4<br>4<br></code></pre></td></tr></table></figure><h2 id="三、sort">三、sort</h2><p>sort函数用于对表元素进行排序，其语法为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">table</span>.<span class="hljs-built_in">sort</span>(t[, func])<br></code></pre></td></tr></table></figure><p>我们来看如下代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> t = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;<br><span class="hljs-built_in">table</span>.<span class="hljs-built_in">sort</span>(t)<br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(k,v)<br><span class="hljs-keyword">end</span><br><span class="hljs-built_in">print</span>()<br><br><br><span class="hljs-keyword">local</span> t = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,a=<span class="hljs-string">&#x27;a&#x27;</span>,b=<span class="hljs-string">&#x27;b&#x27;</span>,aa=<span class="hljs-string">&#x27;aa&#x27;</span>,ab=<span class="hljs-string">&#x27;ab&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;<br><span class="hljs-built_in">table</span>.<span class="hljs-built_in">sort</span>(t)<br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(k,v)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>其执行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">11<br>22<br>33<br>44<br><br>11<br>22<br>33<br>44<br>bb<br>abab<br>aa<br>aaaa<br></code></pre></td></tr></table></figure><h2 id="四、concat">四、concat</h2><p>concat函数用于将表元素连接成字符串</p><h2 id="五、insert">五、insert</h2><p>insert函数用于向表中插入元素</p><h2 id="六、remote">六、remote</h2><p>remote函数用于从表中删除元素</p>]]></content>
    
    
    <categories>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Table库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lua数据类型</title>
    <link href="/2020/12/17/Lua%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2020/12/17/Lua%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>Lua是动态类型语言，因此，变量不需要类型定义，只需要为变量赋值。而值可以存储在变量中，作为参数传递或作为结果返回。在Lua中，有8种基本数据类型：</p><ul><li>nil：无效值，在条件表达式中相当于false。该类型只有nil这一个值</li><li>boolean：布尔值，包含两个值false和true</li><li>number：数字，Lua中的数字实际上是双精度类型的浮点数</li><li>string：字符串，由一对 单引号 / 双引号 / 双方括号 表示</li><li>table：表，Lua中的表实际上是一个“关联数组”，其索引可以是数字或字符串</li><li>function：函数，由C或Lua实现的函数</li><li>thread：执行的独立线程，用于执行协同程序</li><li>userdata：自定义类型，表示任意存储在变量中的C数据结构</li></ul><h2 id="一、nil（空）">一、nil（空）</h2><p>nil类型表示没有任何有效值，该类型只有一个值：nil。例如，打印一个没有赋值的变量，便会输出nil值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">&gt; <span class="hljs-built_in">print</span>(key) <br><span class="hljs-literal">nil</span><br>&gt; <br></code></pre></td></tr></table></figure><p>对于全局变量和table来说，nil还有“删除”作用，给全局变量或者将table表里的变量赋值为nil，等同于把它们删掉，我们来看如下代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> t = &#123;k1 = <span class="hljs-string">&#x27;v1&#x27;</span>, k2 = <span class="hljs-string">&#x27;v2&#x27;</span>, <span class="hljs-string">&#x27;v3&#x27;</span>&#125;<br><br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(k,v)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>()<br><br>t.k1 = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">print</span>(k,v)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>()<br><br>t[<span class="hljs-number">1</span>] = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(k,v)<br><span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><p>其执行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">1v3<br>k1v1<br>k2v2<br><br>1v3<br>k2v2<br><br>k2v2<br></code></pre></td></tr></table></figure><h2 id="二、boolean（布尔）">二、boolean（布尔）</h2><h2 id="三、number（数字）">三、number（数字）</h2><h2 id="四、string（字符串）">四、string（字符串）</h2><h2 id="五、table（表）">五、table（表）</h2><p>在Lua中，table的创建是通过“构造表达式”完成的，最简单的构造表达式是{}，它用来创建一个空表。当然，在初始化表时可以在表里添加一些数据。比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 创建一个空表</span><br><span class="hljs-keyword">local</span> t1 = &#123;&#125;<br><br><span class="hljs-comment">-- 直接初始化表</span><br><span class="hljs-keyword">local</span> t2 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br></code></pre></td></tr></table></figure><p>我们要知道的是，Lua中的表实际是一个“关联数组”，数组的索引可以是数字或者字符串。比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> t = &#123;&#125;<br><br>t[<span class="hljs-string">&#x27;k&#x27;</span>] = <span class="hljs-string">&#x27;v&#x27;</span><br><br>k = <span class="hljs-number">1</span><br>t[k] = <span class="hljs-number">22</span><br><br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(k,v)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>其执行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kv<br>122<br></code></pre></td></tr></table></figure><p>不同于其他语言把0作为数组的初始索引，在Lua中，表的默认初始索引以1开始。我们来如下代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> t = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;<br><br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(k,v)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>其执行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">14<br>23<br>32<br>41<br></code></pre></td></tr></table></figure><p>需要注意的是，表的长度大小是不固定的，在添加新数据时表的长度会自动增长；当索引一个没有初始化（不存在）的值时会返回nil；Lua在内部实现上，采用哈希表和数组分别保存键值对和普通值，因此不推荐混合使用这两种赋值方式。</p><h2 id="六、function（函数）">六、function（函数）</h2><h2 id="七、thread（线程）">七、thread（线程）</h2><h2 id="八、userdata（自定义类型）">八、userdata（自定义类型）</h2>]]></content>
    
    
    <categories>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lua、数据类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lua String库</title>
    <link href="/2020/12/15/Lua%20String%E5%BA%93/"/>
    <url>/2020/12/15/Lua%20String%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="一、byte">一、byte</h2><h2 id="二、char">二、char</h2><p>char函数用于索引 ASCII 码。其语法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">string</span>.<span class="hljs-built_in">char</span>(...)<br></code></pre></td></tr></table></figure><p>它可以接收0个或多个整数（范围为：0~255）,并会返回这些整数所对应的ASCII字符所组成的字符串。当参数为空时，默认是0。我们来看如下代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">char</span>())<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">char</span>(<span class="hljs-number">97</span>,<span class="hljs-number">98</span>,<span class="hljs-number">99</span>))<br></code></pre></td></tr></table></figure><p>其执行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>abc<br></code></pre></td></tr></table></figure><p>该函数适用于从具体的字节码构造出二进制字符串，其效率优于字符串连接运算符<code>..</code>和table.concat函数。</p><h2 id="三、upper">三、upper</h2><h2 id="四、lower">四、lower</h2><h2 id="五、len">五、len</h2><h2 id="六、format">六、format</h2><h2 id="七、find">七、find</h2><h2 id="八、match">八、match</h2><h2 id="九、gmatch">九、gmatch</h2><h2 id="十、rep">十、rep</h2><h2 id="十一、sub">十一、sub</h2><p>sub函数用于索引字符串，其语法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">string</span>.<span class="hljs-built_in">sub</span>(s,i[, j])<br></code></pre></td></tr></table></figure><p>它会返回字符串s中，从索引i到索引j之间的子字符串。可选参数j的默认值为-1，表示字符串的最后位置。我们来看如下代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">sub</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>,<span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">sub</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-2</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">sub</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">sub</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">sub</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">-1</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">sub</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>其执行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">Hello World<br>Hello Worl<br>Hello<br><br>World<br>H<br></code></pre></td></tr></table></figure><p>我们可以看到，当i&lt;j时，将返回一个空字符串。</p><h2 id="十二、gsub">十二、gsub</h2><p>gsub函数用于替换字符串的内容。其语法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">string</span>.<span class="hljs-built_in">gsub</span>(s, p, r[, n])<br></code></pre></td></tr></table></figure><p>它会将字符串s中的p替换成r。可选参数n，表示替换的个数，默认情况下会替换所有的p。该函数会返回两个值，第一个是替换后的新字符串，第二个是替换的个数。我们来看如下代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">gsub</span>(<span class="hljs-string">&#x27;hello hello hello&#x27;</span>,<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;H&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">gsub</span>(<span class="hljs-string">&#x27;hello hello hello&#x27;</span>,<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>()<br><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br>uri = <span class="hljs-string">&#x27;/localhost/upstream/nginx/nginx1&#x27;</span><br><span class="hljs-built_in">string</span>.<span class="hljs-built_in">gsub</span>(uri,<span class="hljs-string">&#x27;([^/]+)&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(c)</span></span> t[#t + <span class="hljs-number">1</span>] = c <span class="hljs-keyword">end</span>)<br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(t) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(k,v)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>其执行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">Hello Hello Hello3<br>Hello hello hello1<br><br>1localhost<br>2upstream<br>3nginx<br>4nginx1<br></code></pre></td></tr></table></figure><p>我们可以看到，参数p实际上是正则表达式，而参数r不仅可以是字符串，还可以是一个函数。需要注意的是，该函数不能被LuaJIT编译，只能被解释执行。因此，不推荐使用该函数，推荐使用ngx_lua模块提供的ngx.re.gsub函数。</p><h2 id="十三、reverse">十三、reverse</h2><h2 id="十四、参考">十四、参考</h2><p><a href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/lua/string_library.html">https://moonbingbing.gitbooks.io/openresty-best-practices/content/lua/string_library.html</a></p><p><a href="https://www.lua.org/pil/20.html">https://www.lua.org/pil/20.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lua、String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lua错误处理</title>
    <link href="/2020/12/14/Lua%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <url>/2020/12/14/Lua%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>程序运行中进行错误处理是必须的。任何语言在运行过程中都会出现不可预期的错误，如果不注重错误处理，就有可能会造成信息泄露，程序无法正常运行等情况。</p><h2 id="一、错误类型">一、错误类型</h2><p>在任何语言中，都会出现错误。Lua的错误类型有语法错误、运行错误。</p><h3 id="1-1、语法错误">1.1、语法错误</h3><h3 id="1-2、运行错误">1.2、运行错误</h3><h2 id="二、抛出错误">二、抛出错误</h2><h3 id="2-1、error函数">2.1、error函数</h3><p>error函数用于显示的抛出一个错误，它会终止正在执行的程序，并输出错误信息。需要注意的是，error函数永远不会返回（因此它直接中断了程序）。其语法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">error</span>(message [,level])<br></code></pre></td></tr></table></figure><p>其中，message就是要输出的错误信息。在输出错误信息的，error函数会在message前插入一些错误位置信息，而level参数（默认为1）就是用来定义如何获取错误位置信息的：</p><ul><li><p>level=0：表示不获取错误位置信息。</p></li><li><p>level=1：表示获取error函数的位置信息（文件名+行号）。</p></li><li><p>level=2：表示获取error函数调用者的位置信息（文件名+行号）。</p></li></ul><p>下面，我们来看一个具体的例子，示例代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;here is my error&quot;</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;==== error level is 0 ====&#x27;</span>)<br>func()<br></code></pre></td></tr></table></figure><p>当level为0时，执行结果为：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">==== error level is 0 ====</span><br>luajit: here is my error<br>stack traceback:<br><span class="hljs-code">[C]: in function &#x27;error&#x27;</span><br><span class="hljs-code">test.lua:2: in function &#x27;func&#x27;</span><br><span class="hljs-code">test.lua:6: in main chunk</span><br><span class="hljs-code">[C]: at 0x55f390ecd440</span><br></code></pre></td></tr></table></figure><p>当level为1时，执行结果为：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">==== error level <span class="hljs-keyword">is</span> <span class="hljs-number">1</span> ====<br>luajit: test.<span class="hljs-keyword">lu</span><span class="hljs-variable">a:2</span>: here <span class="hljs-keyword">is</span> my error<br>stack traceback:<br>[C]: in <span class="hljs-keyword">function</span> <span class="hljs-string">&#x27;error&#x27;</span><br>test.<span class="hljs-keyword">lu</span><span class="hljs-variable">a:2</span>: in <span class="hljs-keyword">function</span> <span class="hljs-string">&#x27;func&#x27;</span><br>test.<span class="hljs-keyword">lu</span><span class="hljs-variable">a:6</span>: in main chunk<br>[C]: at <span class="hljs-number">0</span>x55db23316440<br></code></pre></td></tr></table></figure><p>当level为2时，执行结果为：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">==== error level <span class="hljs-keyword">is</span> <span class="hljs-number">2</span> ====<br>luajit: test.<span class="hljs-keyword">lu</span><span class="hljs-variable">a:6</span>: here <span class="hljs-keyword">is</span> my error<br>stack traceback:<br>[C]: in <span class="hljs-keyword">function</span> <span class="hljs-string">&#x27;error&#x27;</span><br>test.<span class="hljs-keyword">lu</span><span class="hljs-variable">a:2</span>: in <span class="hljs-keyword">function</span> <span class="hljs-string">&#x27;func&#x27;</span><br>test.<span class="hljs-keyword">lu</span><span class="hljs-variable">a:6</span>: in main chunk<br>[C]: at <span class="hljs-number">0</span>x559c71e57440<br></code></pre></td></tr></table></figure><h3 id="2-2、assert函数">2.2、assert函数</h3><p>assert函数用于对传入的参数进行断言。我们先来看一下assert函数的语法格式，如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">assert</span> (v [, message])<br></code></pre></td></tr></table></figure><p>当参数v为nil或false时，调用error函数；否则，传入什么就返回什么。message为调用error函数时传入的参数，默认为&quot;<code>assertion failed!</code>&quot;。我们来看如下示例代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> ret = <span class="hljs-built_in">assert</span>(func)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(ret))<br><br><span class="hljs-keyword">local</span> ret = <span class="hljs-built_in">assert</span>(func())<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(ret))<br><br><span class="hljs-keyword">local</span> ret = <span class="hljs-built_in">assert</span>(<span class="hljs-literal">nil</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;here is error&quot;</span>)<br></code></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">function<br>boolean<br>luajit: test.lua:11: assertion failed!<br>stack traceback:<br>[C]: in function &#x27;assert&#x27;<br>test.lua:11: in main chunk<br>[C]: at 0x56451c2ba440<br></code></pre></td></tr></table></figure><h2 id="三、捕获错误">三、捕获错误</h2><p>在Lua中。处理错误可以使用pcall和xpcall包装需要执行的代码。</p><h3 id="3-1、pcall函数">3.1、pcall函数</h3><p>pcall接收一个函数和要传递给该函数的参数，并执行。如果没有错误，返回true；如果有错误，返回false和errorinfo。其语法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">pcall</span> (f [, arg1, ···])<br></code></pre></td></tr></table></figure><p>pcall会以一种“保护模式”调用传入的函数，因此，pcall可以捕获函数执行中的任意错误。我们来看下面的代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span><span class="hljs-params">(i)</span></span><br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> ok, err = <span class="hljs-built_in">pcall</span>(func, <span class="hljs-number">33</span>)<br><span class="hljs-built_in">print</span>(ok, err)<br><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span><span class="hljs-params">(i)</span></span><br>    <span class="hljs-built_in">print</span>(i)<br>    <span class="hljs-built_in">error</span>(<span class="hljs-string">&#x27;error ...&#x27;</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> ok, err = <span class="hljs-built_in">pcall</span>(func, <span class="hljs-number">33</span>)<br><span class="hljs-built_in">print</span>(ok, err)<br></code></pre></td></tr></table></figure><p>其执行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">33<br>truenil<br>33<br>falsetest.lua:11: error ...<br></code></pre></td></tr></table></figure><h3 id="3-2、xpcall函数">3.2、xpcall函数</h3><p>在发生错误时，我们通常希望获取更多的调试信息，而不仅仅是发生错误的位置。但pcall返回时，已经销毁了调用栈的内容。因此，Lua提供了xpcall函数，它能接收两个函数：一个执行函数，一个错误处理函数。其语法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">xpcall</span> (f, msgh [, arg1, ···])<br></code></pre></td></tr></table></figure><p>当发生错误时，xpcall会在调用栈查看引起错误的调用，所以，可以在这个函数中使用debug.traceback获取关于错误的额外信息。我们来看如下代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span><span class="hljs-params">(err)</span></span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ERROR: &quot;</span>, err)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">debug</span>.<span class="hljs-built_in">traceback</span>())<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br>    n = <span class="hljs-number">1</span> / <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">status</span> = <span class="hljs-built_in">xpcall</span>(func, handler)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">status</span>)<br><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br>    n = <span class="hljs-number">1</span> / <span class="hljs-literal">nil</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">status</span> = <span class="hljs-built_in">xpcall</span>(func, handler)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">status</span>)<br></code></pre></td></tr></table></figure><p>其执行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">true<br>ERROR: test.lua:15: attempt to perform arithmetic on a nil value<br>stack traceback:<br>test.lua:3: in function &#x27;__div&#x27;<br>test.lua:15: in function &lt;test.lua:14&gt;<br>[C]: in function &#x27;xpcall&#x27;<br>test.lua:18: in main chunk<br>[C]: at 0x563ac1f67440<br>false<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>错误处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集群部署1：理解kubeadm</title>
    <link href="/2020/12/14/%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B21%EF%BC%9A%E7%90%86%E8%A7%A3kubeadm/"/>
    <url>/2020/12/14/%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B21%EF%BC%9A%E7%90%86%E8%A7%A3kubeadm/</url>
    
    <content type="html"><![CDATA[<p>todo</p><h2 id="一、容器化Kubernetes的难点在哪？">一、容器化Kubernetes的难点在哪？</h2><p>我们知道，Kubernetes的每一个组件都是一个需要被执行的、单独的二进制文件。像Ansible这样的运维工具或者由社区维护的部署脚本，就是把这些二进制文件传输到指定的机器当中，然后编写控制脚本来启停这些组件。</p><p>在学习了容器技术之后，我们可能会萌生这样的想法：是否使用容器部署Kubernetes？这样，我们只要为每个组件做一个容器镜像，然后在每台宿主机上用docker run指令启动这些组件容器，部署不就完成了吗？</p><p>实际上，在Kubernetes项目早期的部署脚本中，确实有一个用Docker部署Kubernetes的脚本，这个脚本相比于Ansible等部署方式要简单不少。但是，这样部署的方式会带来一个比较棘手的问题，即，如何容器化kubelet？</p><p>我们知道，kubelet作为Kubernetes集群节点的agent，除了跟容器运行时打交道外，还会在管理容器数据卷、配置容器网络时直接操作宿主机。而如果将kubelet运行在一个容器里，那么直接操作宿主机就会变得很麻烦。</p><p>对于网络配置来说，kubelet容器可以通过不开启Network Namespace（即Docker的host network模式）的方式，直接共享宿主机的网络栈。但是，要让kubelet隔着容器的文件系统和Mount Namespace，操作宿主机的文件系统，那就有点儿困难了。比如，如果我们想要使用NFS做容器的持久化数据卷，那么kubelet就需要在容器进行绑定挂载前，在宿主机的指定目录上，先挂载NFS的远程目录。</p><p>这时候问题又来了。由于现在kubelet运行在容器中，这就意味着“mount -F nfs”这个挂载远程目录的命令，被隔离在了一个单独的Mount Namespace当中。也就是说，kubelet做的挂载操作，不能被“传播”到宿主机上。对于这个问题，有人说，可以使用setns()系统调用，在宿主机的Mount Namespace中执行这些操作；也有人说，可以让Docker支持一个-mnt=host的参数。但是，到目前为止，在容器里运行kubelet，依然没有很好的解决办法，因此，不推荐使用容器部署Kubernetes项目。</p><p>正因为如此，kubeadm选择了一种妥协方案：把kubelet直接运行在宿主机上，然后使用容器部署其他的Kubernetes组件。所以，我们使用kubeadm的第一步，是在机器上手动安装kubeadm、kubelet和kubectl这三个二进制文件。当然，kubeadm 已经为各个发行版的 Linux 准备好了安装包，所以我们只需要配置好软件仓库，使用包管理直接安装就可以了。</p><h2 id="二、kubeadm-init的工作流程">二、kubeadm init的工作流程</h2><p>在安装了kubeadm、kubelet和kubectl这个三个组件之后，我们接下来要做的就是使用“kubeadm init”部署Master节点了。</p><h3 id="2-1、Preflight-Checks">2.1、Preflight Checks</h3><p>当我们执行了kubeadm init命令后，kubeadm首先要做的，是一系列的检查工作，以确定这台机器可以被用来部署Kubernetes。对于这一步检查工作，我们称为“Preflight Checks”，它包括了很多方面，比如：</p><ul><li>Linux内核版本是否是3.10以上？</li><li>Linux Cgroups 模块是否可用？</li><li>机器的 hostname 是否标准？ 在 Kubernetes 项目里，机器的名字以及一切存储在 Etcd 中的 API 对象，都必须使用标准的 DNS 命名（RFC 1123）。</li><li>安装的 kubeadm 和 kubelet 的版本是否匹配？</li><li>机器上是不是已经安装了 Kubernetes 的二进制文件？</li><li>Kubernetes 的工作端口 10250/10251/10252 端口是不是已经被占用？</li><li>ip、mount 等 Linux 指令是否存在？</li><li>Docker 是否已经安装？</li><li>…</li></ul><h3 id="2-2、生成证书">2.2、生成证书</h3><p>在通过了 Preflight Checks 之后，kubeadm 要做的是生成 Kubernetes 对外提供服务所需的各种证书和对应的目录。Kubernetes 对外提供服务时，除非专门开启“不安全模式”，否则都要通过 HTTPS 才能访问 kube-apiserver。这就需要为 Kubernetes 集群配置好证书文件。</p><p>kubeadm 为 Kubernetes 项目生成的证书文件都放在 Master 节点的 /etc/kubernetes/pki 目录下。在这个目录下，最主要的证书文件是 ca.crt 和对应的私钥 ca.key。</p><p>此外，用户使用 kubectl 获取容器日志等 streaming 操作时，需要通过 kube-apiserver 向 kubelet 发起请求，这个连接也必须是安全的。kubeadm 为这一步生成的是 apiserver-kubelet-client.crt 文件，对应的私钥是 apiserver-kubelet-client.key。</p><p>除此之外，Kubernetes 集群中还有 Aggregate APIServer 等特性，也需要用到专门的证书，这里就不再一一列举了。需要指出的是，我们可以选择不让 kubeadm 为你生成这些证书，而是拷贝现有的证书到如下证书的目录里：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/etc/kubernetes/pki/ca.&#123;crt,key&#125;<br></code></pre></td></tr></table></figure><p>这时，kubeadm 就会跳过证书生成的步骤，把它完全交给用户处理。</p><h3 id="2-3、生成访问kube-apiserver所需的配置文件">2.3、生成访问kube-apiserver所需的配置文件</h3><p>证书生成后，kubeadm 接下来会为其他组件生成访问 kube-apiserver 所需的配置文件。这些文件的路径是：/etc/kubernetes/xxx.conf：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">ls</span> /etc/kubernetes/</span><br>admin.conf  controller-manager.conf  kubelet.conf  scheduler.conf<br></code></pre></td></tr></table></figure><p>这些文件里面记录的是，当前这个 Master 节点的服务器地址、监听端口、证书目录等信息。这样，对应的客户端（比如 scheduler，kubelet 等），可以直接加载相应的文件，使用里面的信息与 kube-apiserver 建立安全连接。</p><h3 id="2-4、生成集群组件的Pod配置文件">2.4、生成集群组件的Pod配置文件</h3><p>接下来，kubeadm 会为 Master 组件生成 Pod 配置文件。我们知道 Kubernetes 有三个 Master 组件 kube-apiserver、kube-controller-manager、kube-scheduler，而它们都会以 Pod 的方式被部署起来。</p><blockquote><p>我们可能会有疑问：此时，Kubernetes 集群尚不存在，难道 kubeadm 会直接执行 docker run 来启动这些容器吗？</p></blockquote><p>当然不是。我们要知道的是：在 Kubernetes 中，有一种特殊的容器启动方法叫做“Static Pod”。它允许我们把要部署的 Pod 的 YAML 文件放在一个指定的目录里。这样，当这台机器上的 kubelet 启动时，它会自动检查这个目录，加载所有的 Pod YAML 文件，然后在这台机器上启动它们。从这一点也可以看出，kubelet 在 Kubernetes 项目中的地位非常高，在设计上它就是一个完全独立的组件，而其他 Master 组件，则更像是辅助性的系统容器。</p><p>在 kubeadm 中，Master 组件的 YAML 文件会被生成在 /etc/kubernetes/manifests 路径下。比如，kube-apiserver.yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">scheduler.alpha.kubernetes.io/critical-pod:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">component:</span> <span class="hljs-string">kube-apiserver</span><br>    <span class="hljs-attr">tier:</span> <span class="hljs-string">control-plane</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube-apiserver</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">command:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">kube-apiserver</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">--authorization-mode=Node,RBAC</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">--runtime-config=api/all=true</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">--advertise-address=10.168.0.2</span><br>    <span class="hljs-string">...</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">--tls-cert-file=/etc/kubernetes/pki/apiserver.crt</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">--tls-private-key-file=/etc/kubernetes/pki/apiserver.key</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">k8s.gcr.io/kube-apiserver-amd64:v1.11.1</span><br>    <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>    <span class="hljs-attr">livenessProbe:</span><br>      <span class="hljs-string">...</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">kube-apiserver</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">250m</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/ca-certificates</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">usr-share-ca-certificates</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-string">...</span><br>  <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">priorityClassName:</span> <span class="hljs-string">system-cluster-critical</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">hostPath:</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/etc/ca-certificates</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">DirectoryOrCreate</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">etc-ca-certificates</span><br>  <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>对于上面的YAML文件，我们需要关注这样几个信息：</p><ul><li>这个 Pod 里只定义了一个容器，它使用的镜像是：<a href="http://k8s.gcr.io/kube-apiserver-amd64:v1.11.1">k8s.gcr.io/kube-apiserver-amd64:v1.11.1</a> 。这个镜像是 Kubernetes 官方维护的一个组件镜像。</li><li>这个容器的启动命令（commands）是 kube-apiserver --authorization-mode=Node,RBAC …，这样一句非常长的命令。其实，它就是容器里 kube-apiserver 这个二进制文件再加上指定的配置参数而已。</li><li>如果我们要修改一个已有集群的 kube-apiserver 的配置，就需要修改这个 YAML 文件。</li></ul><p>注：这些组件的参数可以在部署时指定。</p><p>在这一步完成后，kubeadm 还会再生成一个 Etcd 的 Pod YAML 文件，此时，同样会通过 Static Pod 的方式启动 Etcd。所以，最后 Master 组件的 Pod YAML 文件如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /etc/kubernetes/manifests/</span><br>etcd.yaml  kube-apiserver.yaml  kube-controller-manager.yaml  kube-scheduler.yaml<br></code></pre></td></tr></table></figure><h3 id="2-5、创建Pod">2.5、创建Pod</h3><p>一旦上面这些 YAML 文件出现在了被 kubelet 监视的 /etc/kubernetes/manifests 目录下，kubelet 就会自动创建这些 YAML 文件中定义的 Pod，即 Master 组件的容器。</p><h3 id="2-6、生成token">2.6、生成token</h3><p>当 Master 组件容器启动后，kubeadm 会通过检查 localhost:6443/healthz 这个 Master 组件的健康检查 URL，等待 Master 组件完全运行起来。然后，kubeadm 就会为集群生成一个 bootstrap token。之后，只要持有这个 token，任何一个安装了 kubelet 和 kubadm 的节点，都可以通过 kubeadm join 加入到这个集群当中。</p><p>注：这个 token 的值和使用方法，会在 kubeadm init 结束后被打印出来。</p><h3 id="2-7、在Etcd中保存节点信息">2.7、在Etcd中保存节点信息</h3><p>在 token 生成之后，kubeadm 会将 ca.crt 等 Master 节点的重要信息，通过 ConfigMap 的方式保存在 Etcd 当中，供后续部署 Node 节点使用。这个 ConfigMap 的名字是 cluster-info。</p><h3 id="2-8、安装默认插件">2.8、安装默认插件</h3><p>kubeadm init 的最后一步，就是安装默认插件。Kubernetes 默认 kube-proxy 和 DNS 这两个插件是必须安装的。它们分别用来提供整个集群的服务发现和 DNS 功能。其实，这两个插件也只是两个容器镜像而已，所以 kubeadm 只要用 Kubernetes 客户端创建两个 Pod 就可以了。</p><h2 id="三、理解kubeadm-join">三、理解kubeadm join</h2><p>在kubeadm init生成 bootstrap token 之后，我们就可以在任意一台安装了 kubelet 和 kubeadm 的机器上执行 kubeadm join 了。</p><blockquote><p>可是，为什么执行 kubeadm join 需要这样一个 token 呢？</p></blockquote><p>因为，任何一台机器想要成为 Kubernetes 集群中的一个节点，就必须在集群的 kube-apiserver 上注册。可是，要想跟 apiserver 打交道，这台机器就必须要获取到相应的证书文件（CA 文件）。可是，为了能够一键安装，我们就不能让用户去 Master 节点上手动拷贝这些文件。所以，kubeadm 至少需要向kube-apiserver发起一次“不安全模式”的访问，从而拿到保存在 ConfigMap 中的 cluster-info（它保存了 APIServer 的授权信息）。而 bootstrap token，扮演的就是这个过程中的安全验证的角色。</p><p>只要有了 cluster-info 里的 kube-apiserver 的地址、端口、证书，kubelet 就可以以“安全模式”连接到 apiserver 上，这样一个新的节点就部署完成了。接下来，我们只要在其他节点上重复这个指令就可以了。</p><h2 id="四、定制集群参数">四、定制集群参数</h2><p>到这里，我们一定会有这样的疑问：kubeadm 确实简单易用，可是我们又该如何定制我们的集群组件参数呢？比如，我们要指定 kube-apiserver 的启动参数，该怎么办？</p><p>其实，在使用 kubeadm init 部署 Master 节点时，可以使用下面这条指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubeadm init --config kubeadm.yaml</span><br></code></pre></td></tr></table></figure><p>在这里，我们给 kubeadm 提供一个 YAML 文件（比如，kubeadm.yaml），它的内容如下所示（这里仅列举了主要部分）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kubeadm.k8s.io/v1alpha2</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">MasterConfiguration</span><br><span class="hljs-attr">kubernetesVersion:</span> <span class="hljs-string">v1.11.0</span><br><span class="hljs-attr">api:</span><br>  <span class="hljs-attr">advertiseAddress:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.102</span><br>  <span class="hljs-attr">bindPort:</span> <span class="hljs-number">6443</span><br>  <span class="hljs-string">...</span><br><span class="hljs-attr">etcd:</span><br>  <span class="hljs-attr">local:</span><br>    <span class="hljs-attr">dataDir:</span> <span class="hljs-string">/var/lib/etcd</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-attr">imageRepository:</span> <span class="hljs-string">k8s.gcr.io</span><br><span class="hljs-attr">kubeProxy:</span><br>  <span class="hljs-attr">config:</span><br>    <span class="hljs-attr">bindAddress:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>    <span class="hljs-string">...</span><br><span class="hljs-attr">kubeletConfiguration:</span><br>  <span class="hljs-attr">baseConfig:</span><br>    <span class="hljs-attr">address:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>    <span class="hljs-string">...</span><br><span class="hljs-attr">networking:</span><br>  <span class="hljs-attr">dnsDomain:</span> <span class="hljs-string">cluster.local</span><br>  <span class="hljs-attr">podSubnet:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">serviceSubnet:</span> <span class="hljs-number">10.96</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">/12</span><br><span class="hljs-attr">nodeRegistration:</span><br>  <span class="hljs-attr">criSocket:</span> <span class="hljs-string">/var/run/dockershim.sock</span><br>  <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>通过制定这样一个部署参数配置文件，我们就可以很方便地在这个文件里填写各种自定义的部署参数了。比如，我们现在要指定 kube-apiserver 的参数，那么我们只要在这个文件里加上这样一段信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">...</span><br><span class="hljs-attr">apiServerExtraArgs:</span><br>  <span class="hljs-attr">advertise-address:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span><br>  <span class="hljs-attr">anonymous-auth:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">enable-admission-plugins:</span> <span class="hljs-string">AlwaysPullImages,DefaultStorageClass</span><br>  <span class="hljs-attr">audit-log-path:</span> <span class="hljs-string">/home/johndoe/audit.log</span><br></code></pre></td></tr></table></figure><p>然后，kubeadm 就会使用上面这些信息替换 /etc/kubernetes/manifests/kube-apiserver.yaml 里的 command 字段里的参数了。</p><p>这个 YAML 文件提供的可配置项远不止这些。比如，我们还可以修改 kubelet 和 kube-proxy 的配置，修改 Kubernetes 使用的基础镜像的 URL（<a href="http://xn--k8s-2w2hj51gzcy.gcr.io/xxx%E9%95%9C%E5%83%8F">默认的k8s.gcr.io/xxx镜像</a> URL 在国内访问是有困难的），指定自己的证书文件，指定特殊的容器运行时等等。</p><h2 id="五、小结">五、小结</h2><p>在这篇文章中，我们主要讨论了kubeadm的工作原理，我们需要知道的是：</p><ul><li>容器化Kubernetes的难点在于如何容器化kubelet？作为kubernetes集群节点的agent，kubelet不仅会同容器运行时交互，而且还会直接操作宿主机。尤其是直接操作宿主机文件系统，这对容器来说是一个不小的挑战，因此，kubeadm选择了一种折中方案：直接在宿主机上运行kubelet，然后使用容器部署kubenetes集群的其他组件。</li><li>kubeadm在容器化kubenetes集群组件时，使用到了一种特殊的容器启动方式：Static Pod。它允许我们事先将要部署的Pod的YAML文件放到一个指定的目录下，这样，当kubelet启动时，就会自动检查这个目录（/etc/kubernetes/manifests），加载所有的Pod YAML文件，然后启动它们。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes、kubeadm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个简单API Server框架</title>
    <link href="/2020/12/09/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95API-Server%E6%A1%86%E6%9E%B6/"/>
    <url>/2020/12/09/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95API-Server%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们讨论REST相关的概念，以及REST在OpenResty中的应用。接下来，我们尝试使用OpenResty中搭建一个简单的API Server。</p><h2 id="一、需求">一、需求</h2><p>实现一个能计算加减乘除的数学计算器</p><h2 id="二、实现">二、实现</h2><p>我们先来看看一个最简陋的实现版本：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<br><span class="hljs-attribute">error_log</span> logs/<span class="hljs-literal">error</span>.log;<br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span> <span class="hljs-number">1024</span>;<br>&#125;<br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br><br>        <span class="hljs-comment"># 加法</span><br>        <span class="hljs-section">location</span> /addition &#123;<br>           <span class="hljs-section">content_by_lua_block</span> &#123;<br>                <span class="hljs-attribute">local</span> args = ngx.req.get_uri_args()<br>                ngx.say(args.x + args.y)<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment"># 减法</span><br>        location /subtraction &#123;<br>            <span class="hljs-section">content_by_lua_block</span> &#123;<br>                <span class="hljs-attribute">local</span> args = ngx.req.get_uri_args()<br>                ngx.say(args.x - args.y)<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment"># 乘法</span><br>        location /multiplication &#123;<br>            <span class="hljs-section">content_by_lua_block</span> &#123;<br>                <span class="hljs-attribute">local</span> args = ngx.req.get_uri_args()<br>                ngx.say(args.x * args.y)<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment"># 除法</span><br>        location /division &#123;<br>            <span class="hljs-section">content_by_lua_block</span> &#123;<br>                <span class="hljs-attribute">local</span> args = ngx.req.get_uri_args()<br>                ngx.say(args.x / args.y)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，整个配置文件看起来非常复杂，下面我们来优化一下</p><h2 id="三、优化">三、优化</h2><p>首先，入口要统一，接口的实现要独立，保持简洁：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<br><span class="hljs-attribute">error_log</span> logs/<span class="hljs-literal">error</span>.log;<br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span> <span class="hljs-number">1024</span>;<br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-comment"># 设置默认 lua 搜索路径</span><br>    <span class="hljs-comment"># 此处写相对路径时，需要注意启动 nginx 的路径，因为它会影响自定义模块的导入</span><br>    <span class="hljs-comment"># 绝对路径当然也没问题，但是不可移植，因此应使用变量 $prefix 或 $&#123;prefix&#125;</span><br>    <span class="hljs-attribute">lua_package_path</span> <span class="hljs-string">&#x27;<span class="hljs-variable">$prefix</span>/lua/?.lua;/blah/?.lua;;&#x27;</span>;<br><br>    <span class="hljs-comment"># 这里设置为 off，是为了避免每次修改之后都要重新 reload 的麻烦。</span><br>    <span class="hljs-comment"># 在生产环境上务必确保 lua_code_cache 设置成 on。</span><br>    <span class="hljs-attribute">lua_code_cache</span> <span class="hljs-literal">off</span>;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br><br>        <span class="hljs-comment"># 在代码路径中使用nginx变量</span><br>        <span class="hljs-comment"># 注意： nginx var 的变量一定要谨慎，否则将会带来非常大的风险</span><br>        <span class="hljs-section">location</span> <span class="hljs-regexp">~ ^/api/([-_a-zA-Z0-9/]+)</span> &#123;<br>            <span class="hljs-attribute">content_by_lua_file</span> lua/<span class="hljs-variable">$1</span>.lua;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>${prefix}/lua目录下的文件分别如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- ========== &#123;$prefix&#125;/lua/addition.lua</span><br><span class="hljs-keyword">local</span> args = ngx.req.get_uri_args()<br>ngx.say(args.x + args.y)<br><br><span class="hljs-comment">-- ========== &#123;$prefix&#125;/lua/subtraction.lua</span><br><span class="hljs-keyword">local</span> args = ngx.req.get_uri_args()<br>ngx.say(args.x - args.y)<br><br><span class="hljs-comment">-- ========== &#123;$prefix&#125;/lua/multiplication.lua</span><br><span class="hljs-keyword">local</span> args = ngx.req.get_uri_args()<br>ngx.say(args.x * args.y)<br><br><span class="hljs-comment">-- ========== &#123;$prefix&#125;/lua/division.lua</span><br><span class="hljs-keyword">local</span> args = ngx.req.get_uri_args()<br>ngx.say(args.x / args.y)<br></code></pre></td></tr></table></figure><h2 id="四、迭代">四、迭代</h2><p>对于一个后端程序来说，怎么可以容忍输入参数不检查呢？万一客户端传入的不是数字或者为空怎么办？所以这些都要过滤掉。我们会发现，这些接口的参数检查过滤方法应该是统一的，那么如何在这几个 API 中如何共享这个方法呢？这时候就需要 Lua 模块来完成了：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<br><span class="hljs-attribute">error_log</span> logs/<span class="hljs-literal">error</span>.log;<br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span> <span class="hljs-number">1024</span>;<br>&#125;<br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br><br>        <span class="hljs-section">location</span> <span class="hljs-regexp">~ ^/api/([-_a-zA-Z0-9/]+)</span> &#123;<br>            <span class="hljs-comment"># 准入阶段完成参数验证</span><br>            <span class="hljs-attribute">access_by_lua_file</span>  lua/access_check.lua;<br><br>            <span class="hljs-attribute">content_by_lua_file</span> lua/<span class="hljs-variable">$1</span>.lua;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处，我们将验证逻辑的执行时机放到了准入阶段，${prefix}/lua/access_check.lua的内容如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> param= <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;comm.param&quot;</span>)<br><span class="hljs-keyword">local</span> args = ngx.req.get_uri_args()<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> args.x <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> args.y <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> param.is_number(args.x, args.y) <span class="hljs-keyword">then</span><br>    ngx.<span class="hljs-built_in">exit</span>(ngx.HTTP_BAD_REQUEST)<br>    <span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>模块comm.param的路径为{$prefix}/lua/comm/param.lua，其内如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> _M = &#123;&#125;<br><br><span class="hljs-comment">-- 对输入参数逐个进行校验，只要有一个不是数字类型，则返回 false</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.is_number</span><span class="hljs-params">(...)</span></span><br>    <span class="hljs-keyword">local</span> <span class="hljs-built_in">arg</span> = &#123;...&#125;<br><br>    <span class="hljs-keyword">local</span> num<br>    <span class="hljs-keyword">for</span> _,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(<span class="hljs-built_in">arg</span>) <span class="hljs-keyword">do</span><br>        num = <span class="hljs-built_in">tonumber</span>(v)<br>        <span class="hljs-keyword">if</span> <span class="hljs-literal">nil</span> == num <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> _M<br></code></pre></td></tr></table></figure><h2 id="五、小结">五、小结</h2><p>通过如上几个步骤，一个简单的API Server就搭建完成了，最终整体的目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">.<br>├── conf<br>│   ├── nginx.conf<br>├── logs<br>│   ├── error.log<br>│   └── nginx.pid<br>├── lua<br>│   ├── access_check.lua<br>│   ├── addition.lua<br>│   ├── subtraction.lua<br>│   ├── multiplication.lua<br>│   ├── division.lua<br>│   └── comm<br>│       └── param.lua<br>└── sbin<br>    └── nginx<br></code></pre></td></tr></table></figure><h2 id="六、参考">六、参考</h2><p><a href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/">简单API Server框架</a></p>]]></content>
    
    
    <categories>
      
      <category>OpenResty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>API Server框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>API的设计</title>
    <link href="/2020/12/09/API%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/12/09/API%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>OpenResty最擅长的应用场景之一就是API Server。一提到API Server我们的脑海里一定会冒出许多与REST相关的概念，下面我们来看看在OpenResty中如何实现REST风格的API Server。</p><h2 id="一、为什么要使用REST">一、为什么要使用REST</h2><p>首先，我们先来看看不采用REST的API Server长什么样，如下示例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  localhost;<br><br>    <span class="hljs-section">location</span> /app/set &#123;<br>        <span class="hljs-section">content_by_lua_block</span> &#123;<br>             ngx.say(&#x27;<span class="hljs-attribute">set</span> data<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    location /app/get &#123;</span><br><span class="hljs-string">        content_by_lua_block &#123;</span><br><span class="hljs-string">            ngx.say(&#x27;</span>get data<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    location /app/del &#123;</span><br><span class="hljs-string">        content_by_lua_block &#123;</span><br><span class="hljs-string">            ngx.say(&#x27;</span>del data<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    ...</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>可以看到，如果我们的API Server提供了很多的接口服务，那么上面的nginx配置文件就会变得非常冗杂。可读性、可维护性都会降低。因此，我们更推荐采用REST风格来开发API Server。</p><h2 id="二、什么是REST">二、什么是REST</h2><p>REST是Representational State Transfer的简称，即表述性状态转移，是2000年Roy Fielding博士在他的博士论文中提出来的一种<code>软件架构风格</code>。它是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。</p><p>从资源的角度来看整个网络，分布在各处的资源都由URI来标识的，而客户端应用则是通过URI来获取资源的表现形式。所谓表述性状态转移是指，客户端获取资源的表现形式致使其状态发生转变。随着客户端不断地获取资源的表现形式，其状态也会不断地进行转变。以上观点并不是凭空臆造的，而是通过对Web运行方式的观察而抽象出来的。Roy Fielding博士认为：</p><blockquote><p>设计良好的网络应用表现为一系列的网页，这些网页可以看作是虚拟的状态机。用户选择一个链接会导致下一个网页传输到用户端并展现给用户，而这正代表了状态的转变。</p></blockquote><p>REST是设计风格而不是标准。REST通常基于HTTP、URI，XML和HTML等这些现有的、广泛流行的协议和标准：</p><ul><li>资源由URI来标识</li><li>对资源的操作包括获取、创建、修改和删除，这些操作正好对应HTTP协议提供GET、POST、PUT、DELETE方法</li><li>通过操作资源的表现形式来操作资源。</li><li>资源的表现形式是HTML还是XML，取决于获取资源的是机器还是人，是消费Web服务端的客户端软件还是Web浏览器。</li></ul><p>REST要求：</p><ul><li>客户端和服务器（C/S）结构</li><li>连接协议具有无状态性</li><li>能够利用Cache机制提高性能</li><li>层次化的系统</li></ul><h2 id="三、OpenResty-REST">三、OpenResty &amp; REST</h2><p>按照 REST 的风格引导，有关数据的 API Server 就可以变成这样：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  localhost;<br><br>    <span class="hljs-section">location</span> /app/task01 &#123;<br>        <span class="hljs-section">content_by_lua_block</span> &#123;<br>            ngx.say(ngx.req.get_method() .. &#x27; task01&#x27;)<br>        &#125;<br>    &#125;<br>    <span class="hljs-section">location</span> /app/task02 &#123;<br>        <span class="hljs-section">content_by_lua_block</span> &#123;<br>            ngx.say(ngx.req.get_method() .. &#x27; task02&#x27;)<br>        &#125;<br>    &#125;<br>    <span class="hljs-section">location</span> /app/task03 &#123;<br>        <span class="hljs-section">content_by_lua_block</span> &#123;<br>            ngx.say(ngx.req.get_method() .. &#x27; task03&#x27;)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 <code>/app/task01</code> 接口（资源），这时候我们可以用下面的方法，完成对应的方法调用（操作）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -X GET http://127.0.0.1/app/task01<br>curl -X PUT http://127.0.0.1/app/task01<br>curl -X DELETE http://127.0.0.1/app/task01<br></code></pre></td></tr></table></figure><p>如果 task 类型（接口）非常多，那么后面这个配置依然会随着业务的调整而调整，随之也会引来一系列的问题。那么，能否在简洁一些呢？这里引用一下 HttpLuaModule 官方示例代码：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># use nginx var in code path</span><br><span class="hljs-comment"># WARNING: contents in nginx var must be carefully filtered,</span><br><span class="hljs-comment"># otherwise there&#x27;ll be great security risk!</span><br><span class="hljs-section">location</span> <span class="hljs-regexp">~ ^/app/([-_a-zA-Z0-9/]+)</span> &#123;<br>    <span class="hljs-attribute">set</span> <span class="hljs-variable">$path</span> <span class="hljs-variable">$1</span>;<br>    <span class="hljs-attribute">content_by_lua_file</span> /path/to/lua/app/root/<span class="hljs-variable">$path</span>.lua;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们再也不用去修改 Nginx 主配置了。另外，强制了入口文件命名规则。对于后期检查维护更容易。</p><h2 id="四、REST的缺点">四、REST的缺点</h2><p>REST 推崇使用 HTTP 返回码来区分返回结果, 但最大的问题在于 HTTP 的错误返回码 (4xx 系列为主) 不够多，而且订得很随意。比如，用 API 创建一个用户，那么错误可能有：</p><ul><li>调用格式错误(一般返回 400, 405)</li><li>授权错误(一般返回 403)</li><li>&quot;运行期&quot;错误<ul><li>用户名不合法</li><li>用户名冲突</li><li>email 不合法</li><li>email 冲突</li><li>…</li></ul></li></ul><p>此外，REST具有一定的学习成本。想要理解REST，必须具备HTTP、URI、HTML和XML等相关知识。</p><h2 id="五、小结">五、小结</h2>]]></content>
    
    
    <categories>
      
      <category>OpenResty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web服务、REST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>限流该怎么做</title>
    <link href="/2020/12/06/%E9%99%90%E6%B5%81%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A/"/>
    <url>/2020/12/06/%E9%99%90%E6%B5%81%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A/</url>
    
    <content type="html"><![CDATA[<p>限流的核心在于：能“限”在被限制对象的能力上限附近。简单来说就是，设定的阈值要接近被限制对象的能力。一方面，如果阈值过高，限流形同虚设，达不到相应的效果；另一方面，如果阈值过低，频繁触发干预，就会造成误伤。最终都会导致很差的用户体验。因此：</p><ul><li><p>首先，要明确限流对象</p></li><li><p>然后，要获得被限制对象的能力上限</p></li><li><p>其次，要制定干预流量的策略</p></li><li><p>最后，就是限流方案的选择与实现</p></li></ul><h2 id="一、确定限流对象">一、确定限流对象</h2><p>大体上，我们可以从两个方向来确定限流对象：</p><ul><li>客户端，可以对“每个客户”能够发起的连接数、请求数或请求大小等进行限制。</li><li>服务端，可以对“每个服务”能够处理的连接数、请求数或请求大小等进行限制。</li></ul><p>总的来说，就是要确定是要对客户端的请求能力进行限制，还是要对服务端的处理能力进行限制，又或者是要对两者一起进行限制。</p><h2 id="二、获得能力上限">二、获得能力上限</h2><p>在确定了具体限流对象之后，我们就需要对其能力上限进行评估。</p><ul><li>对于客户端来说，“每个客户”的请求能力不仅受自身所使用的工具影响，而且受所请求系统的业务场景影响。一般来说，我们可以通过分析系统的请求日志（比如，Nginx的访问日志）得出一个理想的阈值。</li><li>对于服务端来说，“每个服务”的处理能力不仅受自身特性影响，而且受具体业务场景影响。通常，我们会基于业务场景对系统进行压力测试得出一个理想的阈值。</li></ul><p>总的来说，我们可以通过日志分析获得客户端的请求能力，通过压力测试获得服务端的处理能力。</p><h2 id="三、制定干预策略">三、制定干预策略</h2><p>在获得了限流对象的能力上限后，我们就需要采用一定的策略对流量进行干预。常用的策略有4种：”两窗两桶“，具体可参考<a href="">浅谈限流策略</a>一文。在这里我们主要谈谈对这4种策略的选择：</p><ul><li>首先，固定窗口。一般来说，如非时间紧迫，不建议选择这个方案。但是，如果为了能快速止损解决眼前问题，可以作为临时应急的方案。</li><li>其次，滑动窗口。该方案是对固定窗口的改进，适用于对异常结果“高容忍”的场景。相比于“两桶”少了一个缓冲区。但是，实现起来比较简单。</li><li>然后，漏桶。该方案最适合作为一个通用方案。虽然说在资源的利用率上不是极致的，但是&quot;宽进严出&quot;的思路在保护系统的同时还留有一些余地，使得它的使用场景更广。</li><li>最后，令牌桶。当我们需要尽可能的压榨系统性能（此时桶的最大容量大于等于系统的最大并发能力），并且所处的场景流量进入波动不是很大（不至于一瞬间取完令牌）时，就可以使用该方案。</li></ul><h2 id="四、实现限流方案">四、实现限流方案</h2><p>完成如上几个步骤之后，一个具体的限流方案基本上也就确定下来了，最后就是实现这个方案了。限流可以做到客户端，也可以做到服务端。那么，我们该如何选择呢？</p><p>从效果上看，客户端模式肯定是优于服务端模式的。因为当处于限流状态时，在客户端模式下，建立连接的动作都省去了。另一个潜在的好处是，与集中式的服务端模式相比，可以把服务端的压力分散掉。但是，在客户端做成本很高，因此它是去中心化的，假如需要多个节点之间的数据共通的话，是一个很麻烦的事情。</p><p>总的来说，如果考虑成本就服务端模式，考虑效果就客户端模式。当然也不是绝对，比如一个服务端的流量大部分都来源于某一个客户端，那么就可以直接在这个客户端做限流。</p><h2 id="五、小结">五、小结</h2><p>限流就好比保险丝，根据我们制定的标准，达到了就拉闸。当然，触发限流后的干预措施除了延迟或丢弃请求之外，还可以进行降级。</p><h2 id="六、参考">六、参考</h2><p><a href="https://www.infoq.cn/article/UhixHoWebU_TYJewJwcL">分布式系统关注点——限流该怎么做？</a></p>]]></content>
    
    
    <categories>
      
      <category>系统容量</category>
      
    </categories>
    
    
    <tags>
      
      <tag>限流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈常用限流策略</title>
    <link href="/2020/12/06/%E6%B5%85%E8%B0%88%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5/"/>
    <url>/2020/12/06/%E6%B5%85%E8%B0%88%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p>在实际的应用场景中，常用的限流策略可以概括为一个词：两窗两桶。其中，两窗是指固定窗口和滑动窗口；两桶是指漏桶和令牌桶。</p><h2 id="一、固定窗口">一、固定窗口</h2><p>固定窗口，是指设定一个固定的统计周期（比如，30秒或1分钟），然后通过累加计数器对每个周期内的流量进行统计。在一个周期内，如果流量达到了设定的阈值，就进行流量干预，直到进入下一个统计周期，计数器清零，流量接收恢复正常。该策略可以用如下示意图来理解：</p><p><img src="/img/image-20201206113313676.png" alt="image-20201206113313676"></p><h2 id="二、滑动窗口">二、滑动窗口</h2><p>滑动窗口，基于固定窗口做了进一步的细分，它将固定窗口的时间周期（颗粒）切得更细（比如，将1分钟的的“大”窗口切分为60个1秒的“小”窗口），并且统计的窗口会随着时间的流逝而后移。简单来说，滑动窗口统计的是从 <code>当前时间 - 窗口大小</code> 到 <code>当前时间</code> 内的流量。该策略可以用如下示意图来理解：</p><p><img src="/img/image-20201206113401043.png" alt="image-20201206113401043"></p><h2 id="三、漏桶">三、漏桶</h2><p>漏铜的核心是固定&quot;出口&quot;速率。不管一次来多少流量，反正每一次每次出去的流量是固定的。如果进来的量累积到”桶都装不下了“，那么就触发流量干预。该策略可以用如下示意图来理解：</p><p><img src="/img/image-20201206113416104.png" alt="image-20201206113416104"></p><h2 id="四、令牌桶">四、令牌桶</h2><p>令牌桶的核心是固定”入口“速率。进入的请求先拿令牌，拥有了令牌才能被处理，如果拿不到令牌就触发流量干预。因此，当令牌的生成速度等于请求被处理的速度，那么此刻就是系统的处理极限。该策略可以用如下示意图来理解：</p><p><img src="/img/image-20201206114518339.png" alt="image-20201206114518339"></p><h2 id="五、参考">五、参考</h2><p><a href="https://www.infoq.cn/article/UhixHoWebU_TYJewJwcL">分布式系统关注点——限流该怎么做？</a></p><p><a href="https://www.infoq.cn/article/L1FThcLIgzHSYlIaDk0R">预案三板斧的限流大法</a></p>]]></content>
    
    
    <categories>
      
      <category>系统容量</category>
      
    </categories>
    
    
    <tags>
      
      <tag>限流策略</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作业调度5：GPU管理与Device Plugin机制</title>
    <link href="/2020/10/13/%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A65%EF%BC%9AGPU%E7%AE%A1%E7%90%86%E4%B8%8EDevice-Plugin%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/10/13/%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A65%EF%BC%9AGPU%E7%AE%A1%E7%90%86%E4%B8%8EDevice-Plugin%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>todo</p><h2 id="一、从人工智能说起">一、从人工智能说起</h2><p>2016 年，随着 AlphaGo 的走红和 TensorFlow 项目的异军突起，一场名为 AI 的技术革命迅速从学术界蔓延到了工业界，所谓的 AI 元年，就此拉开帷幕。</p><p>当然，机器学习或者说人工智能，并不是什么新鲜的概念。而这次热潮的背后，云计算服务的普及与成熟，以及算力的巨大提升，其实正是将人工智能从象牙塔带到工业界的一个重要推手。</p><p>而与之相对应的，从 2016 年开始，Kubernetes 社区就不断收到来自不同渠道的大量诉求，希望能够在 Kubernetes 集群上运行 TensorFlow 等机器学习框架所创建的训练（Training）和服务（Serving）任务。而这些诉求中，除了前面讨论过的 Job、Operator 等离线作业管理需要用到的编排概念之外，还有一个亟待实现的功能，就是对 GPU 等硬件加速设备管理的支持。</p><h2 id="二、Kubernetes对GPU管理的实现">二、Kubernetes对GPU管理的实现</h2><p>正如同 TensorFlow 之于 Google 的战略意义一样，支持 GPU 对于 Kubernetes 项目来说，其实也有着超过技术本身的考虑。所以，尽管在硬件加速器这个领域里，Kubernetes 上游有着不少来自 NVIDIA 和 Intel 等芯片厂商的工程师，但这个特性本身，却从一开始就是以 Google Cloud 的需求为主导来推进的。</p><p>对于云的用户来说，在 GPU 的支持上，他们最基本的诉求其实非常简单：我只要在 Pod 的 YAML 里面，声明某容器需要的 GPU 个数，那么 Kubernetes 为我们创建的容器里就应该出现对应的 GPU 设备，以及它对应的驱动目录。以 NVIDIA 的 GPU 设备为例，上面的需求就意味着当用户的容器被创建之后，这个容器里必须出现如下两部分：</p><ul><li>GPU 设备路径，比如 /dev/nvidia0</li><li>GPU 驱动目录，比如 /usr/local/nvidia/*</li></ul><p>其中，GPU 设备路径，正是该容器启动时的 Devices 参数；而 GPU 驱动目录，则是该容器启动时的 Volume 参数。所以，在 Kubernetes 的 GPU 支持的实现里，kubelet 实际上就是将上述两部分内容，设置在了创建该容器的 CRI （Container Runtime Interface）参数里面。这样，等到该容器启动之后，对应的容器里就会出现 GPU 设备和驱动路径了。</p><h3 id="1-1、创建一个使用GPU的Pod">1.1、创建一个使用GPU的Pod</h3><p>不过，Kubernetes 在 Pod 的 API 对象里，并没有为 GPU 专门设置一个资源类型字段，而是使用了一种叫作 Extended Resource（ER）的特殊字段来负责传递 GPU 的信息。比如下面这个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">cuda-vector-add</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">cuda-vector-add</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;k8s.gcr.io/cuda-vector-add:v0.1&quot;</span><br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">limits:</span><br>          <span class="hljs-attr">nvidia.com/gpu:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>可以看到，在上述 Pod 的 limits 字段里，<a href="http://xn--nvidia-ov7i051bxx3b2rr55tnmjzk7dmth.com/gpu%EF%BC%8C%E5%AE%83%E7%9A%84%E5%80%BC%E6%98%AF">这个资源的名称是nvidia.com/gpu，它的值是</a> 1。也就是说，这个 Pod 声明了自己要使用一个 NVIDIA 类型的 GPU。</p><p>而在 kube-scheduler 里面，它其实并不关心这个字段的具体含义，只会在计算的时候，一律将调度器里保存的该类型资源的可用量，直接减去 Pod 声明的数值即可。所以说，Extended Resource，其实是 Kubernetes 为用户设置的一种对自定义资源的支持。</p><h3 id="1-2、自定义资源的可用量">1.2、自定义资源的可用量</h3><p>为了能够让调度器知道这个自定义类型的资源在每台宿主机上的可用量，宿主机节点本身，就必须能够向 API Server 汇报该类型资源的可用数量。在 Kubernetes 里，各种类型的资源可用量，其实是 Node 对象 Status 字段的内容，比如下面这个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Node</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">node-1</span><br><span class="hljs-string">...</span><br><span class="hljs-attr">Status:</span><br>  <span class="hljs-attr">Capacity:</span><br>   <span class="hljs-attr">cpu:</span>  <span class="hljs-number">2</span><br>   <span class="hljs-attr">memory:</span>  <span class="hljs-string">2049008Ki</span><br></code></pre></td></tr></table></figure><p>而为了能够在上述 Status 字段里添加自定义资源的数据，我们就必须使用 PATCH API 来对该 Node 对象进行更新，加上我们的自定义资源的数量。这个 PATCH 操作，可以简单地使用 curl 命令来发起，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动 Kubernetes 的客户端 proxy，这样你就可以直接使用 curl 来跟 Kubernetes  的API Server 进行交互了</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl proxy</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行 PACTH 操作</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl --header <span class="hljs-string">&quot;Content-Type: application/json-patch+json&quot;</span> \</span><br><span class="language-bash">--request PATCH \</span><br><span class="language-bash">--data <span class="hljs-string">&#x27;[&#123;&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/status/capacity/nvidia.com/gpu&quot;, &quot;value&quot;: &quot;1&quot;&#125;]&#x27;</span> \</span><br><span class="language-bash">http://localhost:8001/api/v1/nodes/&lt;your-node-name&gt;/status</span><br></code></pre></td></tr></table></figure><p>PATCH 操作完成后，我们可以看到 Node 的 Status 变成了如下所示的内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Node</span><br><span class="hljs-string">...</span><br><span class="hljs-attr">Status:</span><br>  <span class="hljs-attr">Capacity:</span><br>   <span class="hljs-attr">cpu:</span>  <span class="hljs-number">2</span><br>   <span class="hljs-attr">memory:</span>  <span class="hljs-string">2049008Ki</span><br>   <span class="hljs-attr">nvidia.com/gpu:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这样在调度器里，它就能够在缓存里记录下 node-1 <a href="http://xn--nvidia-9o7ig77y.com/gpu%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%B5%84%E6%BA%90%E7%9A%84%E6%95%B0%E9%87%8F%E6%98%AF">上的nvidia.com/gpu类型的资源的数量是</a> 1。</p><p>当然，在 Kubernetes 的 GPU 支持方案里，我们并不需要真正去做上述关于 Extended Resource 的这些操作。在 Kubernetes 中，对所有硬件加速设备进行管理的功能，都是由一种叫作 Device Plugin 的插件来负责的。这其中，当然也就包括了对该硬件的 Extended Resource 进行汇报的逻辑。</p><h2 id="三、理解Device-Plugin机制">三、理解Device Plugin机制</h2><p>Kubernetes 的 Device Plugin 机制，我们可以用如下所示的一幅示意图来解释清楚。</p><p><img src="/img/image-20201027082100768.png" alt="image-20201027082100768"></p><p>我们先从这幅示意图的右侧开始看起。</p><p>对于每一种硬件设备，都需要有它所对应的 Device Plugin 进行管理，这些 Device Plugin，都通过 gRPC 的方式，同 kubelet 连接起来。以 NVIDIA GPU 为例，它对应的插件叫作NVIDIA GPU device plugin。</p><p>这个 Device Plugin 会通过一个叫作 ListAndWatch 的 API，定期向 kubelet 汇报该 Node 上 GPU 的列表。比如，在我们的例子里，一共有三个 GPU（GPU0、GPU1 和 GPU2）。这样，kubelet 在拿到这个列表之后，就可以直接在它向 APIServer 发送的心跳里，以 Extended Resource 的方式，加上这些 GPU 的数量，<a href="http://xn--nvidia-hh4kj42j.com/gpu=3%E3%80%82%E6%89%80%E4%BB%A5%E8%AF%B4%EF%BC%8C%E7%94%A8%E6%88%B7%E5%9C%A8%E8%BF%99%E9%87%8C%E6%98%AF%E4%B8%8D%E9%9C%80%E8%A6%81%E5%85%B3%E5%BF%83">比如nvidia.com/gpu=3。所以说，用户在这里是不需要关心</a> GPU 信息向上的汇报流程的。</p><p>需要注意的是，ListAndWatch 向上汇报的信息，只有本机上 GPU 的 ID 列表，而不会有任何关于 GPU 设备本身的信息。而且 kubelet 在向 API Server 汇报的时候，只会汇报该 GPU 对应的 Extended Resource 的数量。当然，kubelet 本身，也会将这个 GPU 的 ID 列表保存在自己的内存里，并通过 ListAndWatch API 定时更新。</p><p>当一个 Pod 想要使用一个 GPU 的时候，它只需要在 Pod 的 limits <a href="http://xn--nvidia-9m3kv2nn72an3m.com/gpu:">字段声明nvidia.com/gpu:</a> 1。那么接下来，Kubernetes 的调度器就会从它的缓存里，寻找 GPU 数量满足条件的 Node，然后将缓存里的 GPU 数量减 1，完成 Pod 与 Node 的绑定。</p><p>这个调度成功后的 Pod 信息，自然就会被对应的 kubelet 拿来进行容器操作。而当 kubelet 发现这个 Pod 的容器请求一个 GPU 的时候，kubelet 就会从自己持有的 GPU 列表里，为这个容器分配一个 GPU。此时，kubelet 就会向本机的 Device Plugin 发起一个 Allocate() 请求。这个请求携带的参数，正是即将分配给该容器的设备 ID 列表。</p><p>当 Device Plugin 收到 Allocate 请求之后，它就会根据 kubelet 传递过来的设备 ID，从 Device Plugin 里找到这些设备对应的设备路径和驱动目录。当然，这些信息，正是 Device Plugin 周期性的从本机查询到的。比如，在 NVIDIA Device Plugin 的实现里，它会定期访问 nvidia-docker 插件，从而获取到本机的 GPU 信息。</p><p>而被分配的 GPU 对应的设备路径和驱动目录信息被返回给 kubelet 之后，kubelet 就完成了为一个容器分配 GPU 的操作。接下来，kubelet 会把这些信息追加在创建该容器所对应的 CRI 请求当中。这样，当这个 CRI 请求发给 Docker 之后，Docker 为我们创建出来的容器里，就会出现这个 GPU 设备，并把它所需要的驱动目录挂载进去。</p><p>至此，Kubernetes 为一个 Pod 分配一个 GPU 的流程就完成了。</p><p>对于其他类型硬件来说，要想在 Kubernetes 所管理的容器里使用这些硬件的话，也需要遵循上述 Device Plugin 的流程来实现如下所示的 Allocate 和 ListAndWatch API：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">service DevicePlugin &#123;<br>      <span class="hljs-comment">// ListAndWatch returns a stream of List of Devices</span><br>      <span class="hljs-comment">// Whenever a Device state change or a Device disappears, ListAndWatch</span><br>      <span class="hljs-comment">// returns the new list</span><br>      rpc ListAndWatch(Empty) returns (stream ListAndWatchResponse) &#123;&#125;<br>      <span class="hljs-comment">// Allocate is called during container creation so that the Device</span><br>      <span class="hljs-comment">// Plugin can run device specific operations and instruct Kubelet</span><br>      <span class="hljs-comment">// of the steps to make the Device available in the container</span><br>      rpc Allocate(AllocateRequest) returns (AllocateResponse) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>目前，Kubernetes 社区里已经实现了很多硬件插件，比如FPGA、SRIOV、RDMA等等。</p><h2 id="四、小结">四、小结</h2><p>在这篇文章中，我们主要讨论了如下概念：</p><ul><li>Device Plugin的设计，长期以来都是以Google Cloud的用户需求为主导的，即用户需要多个Device，就给到相应的个数</li><li>对于GPU等硬件设备的调度工作，实际上是有kubelete完成的。即，kubelet会负责从它所持有的硬件设备列表中，为容器挑选一个硬件设备，然后调用Device Plugin的Allocate API来完成这个分配操作</li><li>在对GPU等硬件设备的管理中，调度器扮演的角色，仅仅是为Pod寻找到可用的、支持这种硬件设备的节点而已</li><li>Kubernetes对硬件设备的管理，只能处理“设备个数”这唯一一种情况</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作业调度4：Kubernetes默认调度器的优先级与抢占机制</title>
    <link href="/2020/10/13/%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A64%EF%BC%9AKubernetes%E9%BB%98%E8%AE%A4%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E6%8A%A2%E5%8D%A0%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/10/13/%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A64%EF%BC%9AKubernetes%E9%BB%98%E8%AE%A4%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E6%8A%A2%E5%8D%A0%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们讨论了Kubernetes默认调度器的主要调度算法的工作原理。接下来，我们来看一下Kubernetes默认调度器的另一个重要机制：优先级（Priority）和抢占机制（Preemption）。</p><h2 id="一、从Pod调度失败说起">一、从Pod调度失败说起</h2><p>首先需要明确的是，优先级和抢占机制，解决的是 Pod 调度失败时该怎么办的问题。</p><p>正常情况下，当一个 Pod 调度失败后，它就会被暂时“搁置”起来，直到 Pod 被更新，或者集群状态发生变化，调度器才会对这个 Pod 进行重新调度。</p><p>但在有些时候，我们希望的是这样一个场景。当一个高优先级的 Pod 调度失败后，该 Pod 并不会被“搁置”，而是会“挤走”某个 Node 上的一些低优先级的 Pod 。这样就可以保证这个高优先级 Pod 的调度成功。这个特性，其实也是一直以来就存在于 Borg 以及 Mesos 等项目里的一个基本功能。</p><h2 id="二、理解优先级和抢占">二、理解优先级和抢占</h2><h3 id="2-1、创建PriorityClass对象">2.1、创建PriorityClass对象</h3><p>在 Kubernetes 里，优先级和抢占机制是在 1.10 版本后才逐步可用的。要使用这个机制，我们首先需要在 Kubernetes 里提交一个 PriorityClass 的定义，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">scheduling.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PriorityClass</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">high-priority</span><br><span class="hljs-attr">value:</span> <span class="hljs-number">1000000</span><br><span class="hljs-attr">globalDefault:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">&quot;This priority class should be used for high priority service pods only.&quot;</span><br></code></pre></td></tr></table></figure><p>上面这个 YAML 文件，定义的是一个名叫 high-priority 的 PriorityClass，其中 value 的值是 1,000,000 （一百万）。</p><p>Kubernetes 规定，优先级是一个 32 bit 的整数，最大值不超过 1,000,000,000（10 亿，1 billion），并且值越大代表优先级越高。而超出 10 亿的值，其实是被 Kubernetes 保留下来分配给系统 Pod 使用的。显然，这样做的目的，就是保证系统 Pod 不会被用户抢占掉。</p><p>而一旦上述 YAML 文件里的 globalDefault 被设置为 true 的话，那就意味着这个 PriorityClass 的值会成为系统的默认值。而如果这个值是 false，就表示我们只希望声明使用该 PriorityClass 的 Pod 拥有值为 1000000 的优先级，而对于没有声明 PriorityClass 的 Pod 来说，它们的优先级就是 0。</p><h3 id="2-2、使用PriorityClass对象">2.2、使用PriorityClass对象</h3><p>在创建了 PriorityClass 对象之后，Pod 就可以声明使用它了，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">env:</span> <span class="hljs-string">test</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>  <span class="hljs-attr">priorityClassName:</span> <span class="hljs-string">high-priority</span><br></code></pre></td></tr></table></figure><p>可以看到，这个 Pod 通过 priorityClassName 字段，声明了要使用名叫 high-priority 的 PriorityClass。当这个 Pod 被提交给 Kubernetes 之后，Kubernetes 的 PriorityAdmissionController 就会自动将这个 Pod 的 spec.priority 字段设置为 1000000。</p><h3 id="2-3、优先级-抢占">2.3、优先级 &amp; 抢占</h3><p>在前面的文章中我们曾提到过，调度器里维护着一个调度队列。所以，当 Pod 拥有了优先级之后，高优先级的 Pod 就可能会比低优先级的 Pod 提前出队，从而尽早完成调度过程。这个过程，就是“优先级”这个概念在 Kubernetes 里的主要体现。</p><p>而当一个高优先级的 Pod 调度失败的时候，调度器的抢占能力就会被触发。这时，调度器就会试图从当前集群里寻找一个节点，使得当这个节点上的一个或者多个低优先级 Pod 被删除后，待调度的高优先级 Pod 就可以被调度到这个节点上。这个过程，就是“抢占”这个概念在 Kubernetes 里的主要体现。</p><h3 id="2-4、抢占流程">2.4、抢占流程</h3><blockquote><p>为了方便叙述，我们接下来会把待调度的高优先级 Pod 称为“抢占者”（Preemptor）。</p></blockquote><p>当上述抢占过程发生时，抢占者并不会立刻被调度到被抢占的 Node 上。事实上，调度器只会将抢占者的 spec.nominatedNodeName 字段，设置为被抢占的 Node 的名字。然后，抢占者会重新进入下一个调度周期，在新的调度周期里来决定是不是要将Pod运行在被抢占的节点上。这当然也就意味着，即使在下一个调度周期，调度器也不会保证抢占者一定会运行在被抢占的节点上。</p><p>这样设计的一个重要原因是，调度器只会通过标准的 DELETE API 来删除被抢占的 Pod，所以，这些 Pod 必然是有一定的“优雅退出”时间（默认是 30s）的。而在这段时间里，其他的节点也是有可能变成可调度的，或者直接有新的节点被添加到这个集群中来。所以，鉴于优雅退出期间，集群的可调度性可能会发生的变化，把抢占者交给下一个调度周期再处理，是一个非常合理的选择。</p><p>而在抢占者等待被调度的过程中，如果有其他更高优先级的 Pod 也要抢占同一个节点，那么调度器就会清空原抢占者的 spec.nominatedNodeName 字段，从而允许更高优先级的抢占者执行抢占，并且，这也就使得原抢占者本身，也有机会去重新抢占其他节点。这些，都是设置 nominatedNodeName 字段的主要目的。</p><h2 id="三、抢占机制的设计">三、抢占机制的设计</h2><blockquote><p>那么，Kubernetes 调度器里的抢占机制，又是如何设计的呢？</p></blockquote><p>我们在前面已经提到过，抢占发生的原因，一定是一个高优先级的 Pod 调度失败。这一次，我们还是称这个 Pod 为“抢占者”，称被抢占的 Pod 为“牺牲者”（victims）。</p><h3 id="3-1、activeQ-unschedulableQ">3.1、activeQ &amp; unschedulableQ</h3><p>Kubernetes 的默认调度器实现抢占算法的一个最重要的设计，就是在调度队列的实现里，使用了两个不同的队列：</p><ul><li><p>第一个队列，叫作 activeQ。凡是在 activeQ 里的 Pod，都是下一个调度周期需要被调度的对象。所以，当我们在 Kubernetes 集群里新创建一个 Pod 的时候，调度器会将这个 Pod 入队到 activeQ 里面。而我们在前面提到过的、调度器不断从队列里出队（Pop）一个 Pod 进行调度，实际上都是从 activeQ 里出队的。</p></li><li><p>第二个队列，叫作 unschedulableQ，是专门用来存放调度失败的 Pod。</p></li></ul><p>这里的一个关键点就在于，当一个 unschedulableQ 里的 Pod 被更新之后，调度器会自动把这个 Pod 移动到 activeQ 里，从而给这些调度失败的 Pod “重新做人”的机会。</p><h3 id="3-2、评估抢占">3.2、评估抢占</h3><p>回到我们的抢占者调度失败这个时间点上来。调度失败之后，抢占者就会被放进 unschedulableQ 里面。然后，这次失败事件就会触发调度器为抢占者寻找牺牲者的流程：</p><ul><li><p>第一步，调度器会检查这次失败事件的原因，来确认抢占是不是可以帮助抢占者找到一个新节点。这是因为有很多 Predicates 的失败是不能通过抢占来解决的。比如，PodFitsHost 算法（负责的是，检查 Pod 的 nodeSelector 与 Node 的名字是否匹配），这种情况下，除非 Node 的名字发生变化，否则即使删除再多的 Pod，抢占者也不可能调度成功。</p></li><li><p>第二步，如果确定抢占可以发生，那么调度器就会把自己缓存的所有节点信息复制一份，然后使用这个副本来模拟抢占过程。</p></li></ul><h3 id="3-3、模拟抢占">3.3、模拟抢占</h3><p>这里的抢占过程很容易理解。调度器会检查缓存副本里的每一个节点，然后从该节点上最低优先级的 Pod 开始，逐一“删除”这些 Pod。而每删除一个低优先级 Pod，调度器都会检查一下抢占者是否能够运行在该 Node 上。一旦可以运行，调度器就记录下这个 Node 的名字和被删除 Pod 的列表，这就是一次抢占过程的结果了。</p><p>当遍历完所有的节点之后，调度器会在上述模拟产生的所有抢占结果里做一个选择，找出最佳结果。而这一步的判断原则，就是尽量减少抢占对整个系统的影响。比如，需要抢占的 Pod 越少越好，需要抢占的 Pod 的优先级越低越好，等等。</p><h3 id="3-4、执行抢占">3.4、执行抢占</h3><p>在得到了最佳的抢占结果之后，这个结果里的 Node，就是即将被抢占的 Node；被删除的 Pod 列表，就是牺牲者。所以接下来，调度器就可以真正开始抢占的操作了，这个过程，可以分为三步。</p><ul><li><p>第一步，调度器会检查牺牲者列表，清理这些 Pod 所携带的 nominatedNodeName 字段。</p></li><li><p>第二步，调度器会把抢占者的 nominatedNodeName，设置为被抢占的 Node 的名字。</p></li><li><p>第三步，调度器会开启一个 Goroutine，同步地删除牺牲者。</p></li></ul><p>而第二步对抢占者 Pod 的更新操作，就会触发到我们前面提到的“重新做人”的流程，从而让抢占者在下一个调度周期重新进入调度流程。</p><p>所以接下来，调度器就会通过正常的调度流程把抢占者调度成功。这也是为什么，我们前面会说调度器并不保证抢占的结果：在这个正常的调度流程里，是一切皆有可能的。</p><h2 id="四、抢占机制下的待调度Pod">四、抢占机制下的待调度Pod</h2><p>对于任意一个待调度 Pod 来说，因为有了上述抢占者的存在，它的调度过程，其实是有一些特殊情况需要特殊处理的。具体来说，在为某一对 Pod 和 Node 执行 Predicates 算法的时候，如果待检查的 Node 是一个即将被抢占的节点，即：调度队列里有 nominatedNodeName 字段值是该 Node 名字的 Pod 存在（可以称之为：“潜在的抢占者”）。那么，调度器就会对这个 Node ，将同样的 Predicates 算法运行两遍：</p><ul><li><p>第一遍， 调度器会假设上述“潜在的抢占者”已经运行在这个节点上，然后执行 Predicates 算法；</p></li><li><p>第二遍， 调度器会正常执行 Predicates 算法，即：不考虑任何“潜在的抢占者”。</p></li></ul><p>只有这两遍 Predicates 算法都能通过时，这个 Pod 和 Node 才会被认为是可以绑定（bind）的。</p><p>不难想到，这里需要执行第一遍 Predicates 算法的原因，是由于 InterPodAntiAffinity 规则的存在。由于 InterPodAntiAffinity 规则关心待考察节点上所有 Pod 之间的互斥关系，所以我们在执行调度算法时必须考虑，如果抢占者已经存在于待考察 Node 上时，待调度 Pod 还能不能调度成功。当然，这也就意味着，我们在这一步只需要考虑那些优先级等于或者大于待调度 Pod 的抢占者。毕竟对于其他较低优先级 Pod 来说，待调度 Pod 总是可以通过抢占运行在待考察 Node 上。</p><p>而我们需要执行第二遍 Predicates 算法的原因，则是因为“潜在的抢占者”最后不一定会运行在待考察的 Node 上。关于这一点，我们在前面已经讲解过了：Kubernetes 调度器并不保证抢占者一定会运行在当初选定的被抢占的 Node 上。</p><h2 id="五、小结">五、小结</h2><p>在这篇文章中，我们主要讨论了如下概念：</p><ul><li>优先级和抢占机制是了解决调度失败问题而产生的</li><li>我们可以通过PriorityClass对象为Pod设置优先级。具有高优先级的Pod会优先从调度队列中出队，而当高优先级的Pod调度失败时，就会触发抢占。</li><li>抢占，就是在一个节点上删除一些低优先级的Pod，然后将高优先级的Pod调度到该节点。当触发抢占时，kubernetes并不会立即执行抢占，而是会在进入下一个调度周期后决定是否执行抢占。</li><li>为了实现抢占机制，kubernetes在调度队列里实现了两个不同的队列：ActiveQ和unschedulableQ。其中，ActiveQ，存放下一个调度周期需要调度的Pod；unschedulableQ，存放调度失败的Pod。</li><li>一个完整的抢占过程包括：评估抢占、模拟抢占、执行抢占等过程。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作业调度3：Kubernetes默认调度器的调度策略</title>
    <link href="/2020/10/13/%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A63%EF%BC%9AKubernetes%E9%BB%98%E8%AE%A4%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/"/>
    <url>/2020/10/13/%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A63%EF%BC%9AKubernetes%E9%BB%98%E8%AE%A4%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们讨论了Kubernete默认调度器的设计以及走向。接下来，我们重点讨论Predicates和Priorities这两个重要的调度过程。</p><h2 id="一、理解Predicates的工作原理">一、理解Predicates的工作原理</h2><p>首先，我们一起看看 Predicates。</p><p>Predicates 在调度过程中的作用，可以理解为 Filter，即：它按照调度策略，从当前集群的所有节点中，“过滤”出一系列符合条件的节点。这些节点，都是可以运行待调度 Pod 的宿主机。而在 Kubernetes 中，默认的过滤策略可以总结为四种类型。</p><h3 id="1-1、通用过滤规则">1.1、通用过滤规则</h3><p>第一种类型，叫作 GeneralPredicates。</p><p>顾名思义，这一组通用的过滤规则，负责的是最基础的调度策略。比如，PodFitsResources 计算的就是宿主机的 CPU 和内存资源等是否够用。当然，PodFitsResources 检查的只是 Pod 的 requests 字段。需要注意的是，Kubernetes 的调度器并没有为 GPU 等硬件资源定义具体的资源类型，而是统一用一种名叫 Extended Resource 的、Key-Value 格式的扩展字段来描述的。比如下面这个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">extended-resource-demo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">extended-resource-demo-ctr</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">alpha.kubernetes.io/nvidia-gpu:</span> <span class="hljs-number">2</span><br>      <span class="hljs-attr">limits:</span><br>        <span class="hljs-attr">alpha.kubernetes.io/nvidia-gpu:</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>可以看到，这个 Pod <a href="http://xn--alpha-3w3pes.kubernetes.io/nvidia-gpu=2%E8%BF%99%E6%A0%B7%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%A3%B0%E6%98%8E%E4%BD%BF%E7%94%A8%E4%BA%86%E4%B8%A4%E4%B8%AA">通过alpha.kubernetes.io/nvidia-gpu=2这样的定义方式，声明使用了两个</a> NVIDIA 类型的 GPU。而在 PodFitsResources 里面，调度器其实并不知道这个字段 Key 的含义是 GPU，而是直接使用后面的 Value 进行计算。当然，在 Node 的 Capacity 字段里，我们也得相应地加上这台宿主机上 GPU 的总数，比如：<a href="http://alpha.kubernetes.io/nvidia-gpu=4%E3%80%82">alpha.kubernetes.io/nvidia-gpu=4。</a></p><p>而 PodFitsHost 检查的是，宿主机的名字是否跟 Pod 的 spec.nodeName 一致。</p><p>PodFitsHostPorts 检查的是，Pod 申请的宿主机端口（spec.nodePort）是不是跟已经被使用的端口有冲突。</p><p>PodMatchNodeSelector 检查的是，Pod 的 nodeSelector 或者 nodeAffinity 指定的节点，是否与待考察节点匹配，等等。</p><p>可以看到，像上面这样一组 GeneralPredicates，正是 Kubernetes 考察一个 Pod 能不能运行在一个 Node 上最基本的过滤条件。所以，GeneralPredicates 也会被其他组件（比如 kubelet）直接调用。</p><p>在前面的文章中我们已经提到过，kubelet 在启动 Pod 前，会执行一个 Admit 操作来进行二次确认。这里二次确认的规则，就是执行一遍 GeneralPredicates。</p><h3 id="1-2、与-Volume-相关的过滤规则">1.2、与 Volume 相关的过滤规则</h3><p>第二种类型，是与 Volume 相关的过滤规则。</p><p>这一组过滤规则，负责的是跟容器持久化 Volume 相关的调度策略。其中，NoDiskConflict 检查的条件，是多个 Pod 声明挂载的持久化 Volume 是否有冲突。比如，AWS EBS 类型的 Volume，是不允许被两个 Pod 同时使用的。所以，当一个名叫 A 的 EBS Volume 已经被挂载在了某个节点上时，另一个同样声明使用这个 A Volume 的 Pod，就不能被调度到这个节点上了。</p><p>而 MaxPDVolumeCountPredicate 检查的条件，则是一个节点上某种类型的持久化 Volume 是不是已经超过了一定数目，如果是的话，那么声明使用该类型持久化 Volume 的 Pod 就不能再调度到这个节点上了。</p><p>而 VolumeZonePredicate，则是检查持久化 Volume 的 Zone（高可用域）标签，是否与待考察节点的 Zone 标签相匹配。</p><p>此外，这里还有一个叫作 VolumeBindingPredicate 的规则。它负责检查的是，该 Pod 对应的 PV 的 nodeAffinity 字段，是否跟某个节点的标签相匹配。在前面讨论持久化存储时，我们曾提到过，Local Persistent Volume（本地持久化卷），必须使用 nodeAffinity 来跟某个具体的节点绑定。这其实也就意味着，在 Predicates 阶段，Kubernetes 就必须能够根据 Pod 的 Volume 属性来进行调度。此外，如果该 Pod 的 PVC 还没有跟具体的 PV 绑定的话，调度器还要负责检查所有待绑定 PV，当有可用的 PV 存在并且该 PV 的 nodeAffinity 与待考察节点一致时，这条规则才会返回“成功”。比如下面这个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-local-pv</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">capacity:</span><br>    <span class="hljs-attr">storage:</span> <span class="hljs-string">500Gi</span><br>  <span class="hljs-attr">accessModes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-string">Retain</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">local-storage</span><br>  <span class="hljs-attr">local:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/mnt/disks/vol1</span><br>  <span class="hljs-attr">nodeAffinity:</span><br>    <span class="hljs-attr">required:</span><br>      <span class="hljs-attr">nodeSelectorTerms:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">matchExpressions:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">kubernetes.io/hostname</span><br>          <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>          <span class="hljs-attr">values:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">my-node</span><br></code></pre></td></tr></table></figure><p>可以看到，这个 PV 对应的持久化目录，只会出现在名叫 my-node 的宿主机上。所以，任何一个通过 PVC 使用这个 PV 的 Pod，都必须被调度到 my-node 上才可以正常工作。VolumeBindingPredicate，正是调度器里完成这个决策的位置。</p><h3 id="1-3、与宿主机相关的过滤规则">1.3、与宿主机相关的过滤规则</h3><p>第三种类型，是与宿主机相关的过滤规则。</p><p>这一组规则，主要考察待调度 Pod 是否满足 Node 本身的某些条件。比如，PodToleratesNodeTaints，负责检查的就是我们前面经常用到的 Node 的“污点”机制。只有当 Pod 的 Toleration 字段与 Node 的 Taint 字段能够匹配的时候，这个 Pod 才能被调度到该节点上。而 NodeMemoryPressurePredicate，检查的是当前节点的内存是不是已经不够充足，如果是的话，那么待调度 Pod 就不能被调度到该节点上。</p><h3 id="1-4、与-Pod-相关的过滤规则">1.4、与 Pod 相关的过滤规则</h3><p>第四种类型，是与 Pod 相关的过滤规则。</p><p>这一组规则，跟 GeneralPredicates 大多数是重合的。而比较特殊的是， PodAffinityPredicate。这个规则的作用，是检查待调度 Pod 与 Node 上的已有 Pod 之间的亲密（affinity）和反亲密（anti-affinity）关系。比如下面这个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">with-pod-antiaffinity</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">affinity:</span><br>    <span class="hljs-attr">podAntiAffinity:</span> <br>      <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">weight:</span> <span class="hljs-number">100</span>  <br>        <span class="hljs-attr">podAffinityTerm:</span><br>          <span class="hljs-attr">labelSelector:</span><br>            <span class="hljs-attr">matchExpressions:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">security</span> <br>              <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span> <br>              <span class="hljs-attr">values:</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">S2</span><br>          <span class="hljs-attr">topologyKey:</span> <span class="hljs-string">kubernetes.io/hostname</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">with-pod-affinity</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/ocpqe/hello-pod</span><br></code></pre></td></tr></table></figure><p>这个例子里的 PodAntiAffinity 规则，就指定了这个 Pod 不希望跟任何携带了 security=S2 标签的 Pod 存在于同一个 Node 上。需要注意的是，PodAffinityPredicate 是有作用域的，比如上面这条规则，就仅对携带了 Key <a href="http://xn--kubernetes-g07u.io/hostname%E6%A0%87%E7%AD%BE%E7%9A%84">是kubernetes.io/hostname标签的</a> Node 有效。这正是 topologyKey 这个关键词的作用。</p><p>而与 podAntiAffinity 相反的，就是 PodAffinity，比如下面这个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">with-pod-affinity</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">affinity:</span><br>    <span class="hljs-attr">podAffinity:</span> <br>      <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">labelSelector:</span><br>          <span class="hljs-attr">matchExpressions:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">security</span> <br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span> <br>            <span class="hljs-attr">values:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">S1</span> <br>        <span class="hljs-attr">topologyKey:</span> <span class="hljs-string">failure-domain.beta.kubernetes.io/zone</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">with-pod-affinity</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/ocpqe/hello-pod</span><br></code></pre></td></tr></table></figure><p>这个例子里的 Pod，就只会被调度到已经有携带了 security=S1 标签的 Pod 运行的 Node 上。而这条规则的作用域，则是所有携带 Key <a href="http://xn--failure-domain-f023a.beta.kubernetes.io/zone%E6%A0%87%E7%AD%BE%E7%9A%84">是failure-domain.beta.kubernetes.io/zone标签的</a> Node。</p><p>此外，上面这两个例子里的 requiredDuringSchedulingIgnoredDuringExecution 字段的含义是：这条规则必须在 Pod 调度时进行检查（requiredDuringScheduling）；但是如果是已经在运行的 Pod 发生变化，比如 Label 被修改，造成了该 Pod 不再适合运行在这个 Node 上的时候，Kubernetes 不会进行主动修正（IgnoredDuringExecution）。</p><h3 id="1-5、小结">1.5、小结</h3><p>上面这四种类型的 Predicates，就构成了默认调度器确定一个 Node 是否可以运行待调度 Pod 的基本策略。</p><p>在具体执行的时候， 当开始调度一个 Pod 时，Kubernetes 调度器会同时启动 16 个 Goroutine，来并发地为集群里的所有 Node 计算 Predicates，最后返回可以运行这个 Pod 的宿主机列表。</p><p>需要注意的是，在为每个 Node 执行 Predicates 时，调度器会按照固定的顺序来进行检查。这个顺序，是按照 Predicates 本身的含义来确定的。比如，与宿主机相关的 Predicates 会被放在相对靠前的位置进行检查。要不然的话，在一台资源已经严重不足的宿主机上，一上来就开始计算 PodAffinityPredicate，是没有实际意义的。</p><h2 id="二、理解Priorities的工作原理">二、理解Priorities的工作原理</h2><p>接下来，我们再来看一下 Priorities。</p><p>在 Predicates 阶段完成了节点的“过滤”之后，Priorities 阶段的工作就是为这些节点打分。这里打分的范围是 0-10 分，得分最高的节点就是最后被 Pod 绑定的最佳节点。</p><h3 id="2-1、与宿主机相关的打分规则">2.1、与宿主机相关的打分规则</h3><p>Priorities 里最常用到的一个打分规则，是 LeastRequestedPriority。它的计算方法，可以简单地总结为如下所示的公式：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">score = (<span class="hljs-name">cpu</span>((<span class="hljs-name">capacity-sum</span>(<span class="hljs-name">requested</span>))<span class="hljs-number">10</span>/capacity) + memory((<span class="hljs-name">capacity-sum</span>(<span class="hljs-name">requested</span>))<span class="hljs-number">10</span>/capacity))/2<br></code></pre></td></tr></table></figure><p>可以看到，这个算法实际上就是在选择空闲资源（CPU 和 Memory）最多的宿主机。</p><p>而与 LeastRequestedPriority 一起发挥作用的，还有 BalancedResourceAllocation。它的计算公式如下所示：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">score</span> = <span class="hljs-number">10</span> - variance(cpuFraction,memoryFraction,volumeFraction)*<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>其中，每种资源的 Fraction 的定义是 ：Pod 请求的资源 / 节点上的可用资源。而 variance 算法的作用，则是计算每两种资源 Fraction 之间的“距离”。而最后选择的，则是资源 Fraction 差距最小的节点。所以说，BalancedResourceAllocation 选择的，其实是调度完成后，所有节点里各种资源分配最均衡的那个节点，从而避免一个节点上 CPU 被大量分配、而 Memory 大量剩余的情况。</p><h3 id="2-2、与宿主机上运行的Pod相关的打分规则">2.2、与宿主机上运行的Pod相关的打分规则</h3><p>此外，还有 NodeAffinityPriority、TaintTolerationPriority 和 InterPodAffinityPriority 这三种 Priority。顾名思义，它们与前面的 PodMatchNodeSelector、PodToleratesNodeTaints 和 PodAffinityPredicate 这三个 Predicate 的含义和计算方法是类似的。但是作为 Priority，一个 Node 满足上述规则的字段数目越多，它的得分就会越高。</p><p>在默认 Priorities 里，还有一个叫作 ImageLocalityPriority 的策略。它是在 Kubernetes v1.12 里新开启的调度规则，即：如果待调度 Pod 需要使用的镜像很大，并且已经存在于某些 Node 上，那么这些 Node 的得分就会比较高。当然，为了避免这个算法引发调度堆叠，调度器在计算得分的时候还会根据镜像的分布进行优化，即：如果大镜像分布的节点数目很少，那么这些节点的权重就会被调低，从而“对冲”掉引起调度堆叠的风险。</p><h3 id="2-3、小结">2.3、小结</h3><p>以上，就是 Kubernetes 调度器的 Predicates 和 Priorities 里默认调度规则的主要工作原理了。</p><p>在实际的执行过程中，调度器里关于集群和 Pod 的信息都已经缓存化，所以这些算法的执行过程还是比较快的。</p><p>此外，对于比较复杂的调度算法来说，比如 PodAffinityPredicate，它们在计算的时候不只关注待调度 Pod 和待考察 Node，还需要关注整个集群的信息，比如，遍历所有节点，读取它们的 Labels。这时，Kubernetes 调度器会在为每个待调度 Pod 执行该调度算法之前，先将算法需要的集群信息初步计算一遍，然后缓存起来。这样，在真正执行该算法的时候，调度器只需要读取缓存信息进行计算即可，从而避免了为每个 Node 计算 Predicates 的时候反复获取和计算整个集群的信息。</p><h2 id="三、小结">三、小结</h2><p>在这篇文章中，我们主要讨论了如下概念：</p><ul><li>在Kubernetes的默认调度器中两个重要的调度流程Predicates和Priorities。其中，Predicates是一系列的过滤规则，Priorites是一系列的打分规则。</li><li>Predicates会过滤出所有可以运行待调度Pod的宿主机，Priorites则会为这些被过滤出的宿主机打分，而得分最高的宿主机就是Pod最终的调度结果。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作业调度2：Kubernetes的默认调度器</title>
    <link href="/2020/10/13/%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A62%EF%BC%9AKubernetes%E7%9A%84%E9%BB%98%E8%AE%A4%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    <url>/2020/10/13/%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A62%EF%BC%9AKubernetes%E7%9A%84%E9%BB%98%E8%AE%A4%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们主要讨论了 Kubernetes 里关于资源模型的设计。接下来，我们来讨论一下 Kubernetes 的默认调度器（default scheduler）。</p><h2 id="一、默认调度器的设计">一、默认调度器的设计</h2><h3 id="1-1、从默认调度器的职责说起">1.1、从默认调度器的职责说起</h3><p>在 Kubernetes 项目中，默认调度器的主要职责，就是为一个新创建出来的 Pod，寻找一个最合适的节点（Node）。而这里“最合适”的含义，包括两层：</p><ul><li>从集群所有的节点中，根据调度算法挑选出所有可以运行该 Pod 的节点；</li><li>从第一步的结果中，再根据调度算法挑选一个最符合条件的节点作为最终结果。</li></ul><h3 id="1-2、默认调度器的调度机制">1.2、默认调度器的调度机制</h3><p>在具体的调度流程中，默认调度器会首先调用一组叫作 Predicate 的调度算法，来检查每个 Node。然后，再调用一组叫作 Priority 的调度算法，来给上一步得到的结果里的每个 Node 打分。最终的调度结果，就是得分最高的那个 Node。</p><p>而我们知道，调度器对一个 Pod 调度成功，实际上就是将它的 spec.nodeName 字段填上调度结果的节点名字。</p><h3 id="1-3、默认调度器的工作原理">1.3、默认调度器的工作原理</h3><p>在 Kubernetes 中，上述调度机制的工作原理，可以用如下所示的一幅示意图来表示：</p><p><img src="/img/image-20201015082929311.png" alt="image-20201015082929311"></p><p>可以看到，Kubernetes 默认调度器的核心，实际上就是两个相互独立的控制循环。</p><h4 id="1-3-1、Informer-Path">1.3.1、Informer Path</h4><p>第一个控制循环，我们可以称之为 Informer Path。</p><p>Informer Path 它的主要目的，是启动一系列 Informer，用来监听（Watch）Etcd 中 Pod、Node、Service 等与调度相关的 API 对象的变化。比如，当一个待调度 Pod（即：它的 nodeName 字段是空的）被创建出来之后，调度器就会通过 Pod Informer 的 Handler，将这个待调度 Pod 添加进调度队列。而在默认情况下，Kubernetes 的调度队列是一个 PriorityQueue（优先级队列），并且当集群的某些信息发生变化的时候，调度器还会对调度队列里的内容进行一些特殊操作。这样的设计，主要是出于调度优先级和抢占的考虑。</p><p>此外，Kubernetes 的默认调度器还要负责对调度器缓存（即：scheduler cache）进行更新。事实上，对Kubernetes 调度部分进行性能优化的一个最根本原则，就是尽最大可能将集群信息 Cache 化，以便从根本上提高 Predicate 和 Priority 调度算法的执行效率。</p><h4 id="1-3-2、Scheduling-Path">1.3.2、Scheduling Path</h4><p>第二个控制循环，是负责 Pod 调度的主循环，我们可以称之为 Scheduling Path。</p><p>Scheduling Path 的主要逻辑，就是不断地从调度队列里出队一个 Pod。</p><p>然后，调用 Predicates 算法进行“过滤”。这一步“过滤”得到的一组 Node，就是所有可以运行这个 Pod 的宿主机列表。当然，Predicates 算法需要的 Node 信息，都是从 Scheduler Cache 里直接拿到的，这是调度器保证算法执行效率的主要手段之一。</p><p>接下来，调度器就会再调用 Priorities 算法为上述列表里的 Node 打分，分数从 0 到 10。得分最高的 Node，就会作为这次调度的结果。</p><p>调度算法执行完成后，调度器就需要将 Pod 对象的 nodeName 字段的值，修改为上述 Node 的名字。这个步骤在 Kubernetes 里面被称作 Bind。</p><h4 id="1-3-3、乐观绑定">1.3.3、乐观绑定</h4><p>为了不在关键调度路径里远程访问 APIServer，Kubernetes 的默认调度器在 Bind 阶段，只会更新 Scheduler Cache 里的 Pod 和 Node 的信息。而这种基于“乐观”假设的 API 对象更新方式，在 Kubernetes 里被称作 Assume。</p><p>Assume 之后，调度器才会创建一个 Goroutine 来异步地向 APIServer 发起更新 Pod 的请求，来真正完成 Bind 操作。如果这次异步的 Bind 过程失败了，其实也没有太大关系，等 Scheduler Cache 同步之后一切就会恢复正常。</p><p>当然，正是由于上述 Kubernetes 调度器的“乐观”绑定的设计，当一个新的 Pod 完成调度在某个节点上运行起来之前，该节点上的 kubelet 还会通过一个叫作 Admit 的操作来再次验证该 Pod 是否确实能够运行在该节点上。这一步 Admit 操作，实际上就是把一组叫作 GeneralPredicates 的、最基本的调度算法（比如：“资源是否可用”、“端口是否冲突”等）再执行一遍，作为 kubelet 端的二次确认。</p><h4 id="1-3-4、无锁化">1.3.4、无锁化</h4><p>除了上述的“Cache 化”和“乐观绑定”，Kubernetes 的默认调度器还有一个重要的设计，那就是“无锁化”。</p><p>在 Scheduling Path 上，调度器会启动多个 Goroutine 以节点为粒度并发执行 Predicates 算法，从而提高这一阶段的执行效率。而与之类似的，Priorities 算法也会以 MapReduce 的方式并行计算然后再进行汇总。</p><p>而在这些所有需要并发的路径上，调度器会避免设置任何全局的竞争资源，从而免去了使用锁进行同步带来的巨大的性能损耗。</p><p>所以，在这种思想的指导下，如果我们再查看一下前面的调度器原理图，就会发现，Kubernetes 的默认调度器只有在对调度队列和 Scheduler Cache 进行操作时，才需要加锁。而这两部分操作，都不在 Scheduling Path 的算法执行路径上。</p><h2 id="二、默认调度器的走向">二、默认调度器的走向</h2><p>当然，Kubernetes 调度器的上述设计思想，也是在集群规模不断增长的演进过程中逐步实现的。尤其是 “Cache 化”，这个变化其实是最近几年 Kubernetes 调度器性能得以提升的一个关键演化。</p><p>随着 Kubernetes 项目发展到今天，它的默认调度器也已经来到了一个关键的十字路口。事实上，Kubernetes 现今发展的主旋律，是整个开源项目的“民主化”。也就是说，Kubernetes 下一步发展的方向，是组件的轻量化、接口化和插件化。所以，我们才有了 CRI、CNI、CSI、CRD、Aggregated APIServer、Initializer、Device Plugin 等各个层级的可扩展能力。可是，默认调度器，却成了 Kubernetes 项目里最后一个没有对外暴露出良好定义过的、可扩展的组件。</p><p>当然，这是有一定的历史原因的。在过去几年，Kubernetes 发展的重点，都是以功能性需求的实现和完善为核心。在这个过程中，它的很多决策，还是以优先服务公有云的需求为主，而性能和规模则居于相对次要的位置。</p><p>而现在，随着 Kubernetes 项目逐步趋于稳定，越来越多的用户开始把 Kubernetes 用在规模更大、业务更加复杂的私有集群当中。很多以前的 Mesos 用户，也开始尝试使用 Kubernetes 来替代其原有架构。在这些场景下，对默认调度器进行扩展和重新实现，就成了社区对 Kubernetes 项目最主要的一个诉求。</p><p>所以，Kubernetes 的默认调度器，是目前这个项目里为数不多的、正在经历大量重构的核心组件之一。这些正在进行的重构其目的，一方面是将默认调度器里大量的“技术债”清理干净；另一方面，是为默认调度器的可扩展性设计进行铺垫。而 Kubernetes 默认调度器的可扩展性设计，可以用如下所示的一幅示意图来描述：</p><p><img src="/img/image-20201016080726350.png" alt="image-20201016080726350"></p><p>可以看到，默认调度器的可扩展机制，在 Kubernetes 里面叫作 Scheduler Framework。顾名思义，这个设计的主要目的，就是在调度器生命周期的各个关键点上，为用户暴露出可以进行扩展和实现的接口，从而实现由用户自定义调度器的能力。</p><p>上图中，每一个绿色的箭头都是一个可以插入自定义逻辑的接口。比如，上面的 Queue 部分，就意味着我们可以在这一部分提供一个自己的调度队列的实现，从而控制每个 Pod 开始被调度（出队）的时机。而 Predicates 部分，则意味着我们可以提供自己的过滤算法实现，根据自己的需求，来决定选择哪些机器。</p><p>需要注意的是，上述这些可插拔式逻辑，都是标准的 Go 语言插件机制（Go plugin 机制），也就是说，我们需要在编译的时候选择把哪些插件编译进去。</p><p>有了上述设计之后，扩展和自定义 Kubernetes 的默认调度器就变成了一件非常容易实现的事情。这也意味着默认调度器在后面的发展过程中，必然不会在现在的实现上再添加太多的功能，反而还会对现在的实现进行精简，最终成为 Scheduler Framework 的一个最小实现。而调度领域更多的创新和工程工作，就可以交给整个社区来完成了。</p><p>不过，这样的 Scheduler Framework 也有一个不小的问题，那就是一旦这些插入点的接口设计不合理，就会导致整个生态没办法很好地把这个插件机制使用起来。而与此同时，这些接口本身的变更又是一个费时费力的过程，一旦把控不好，就很可能会把社区推向另一个极端，即：Scheduler Framework 没法实际落地，大家只好都再次 fork kube-scheduler。</p><h2 id="三、小结">三、小结</h2><p>在这篇文章中，我们主要讨论了如下内容：</p><ul><li>Kubernetes默认调度器的主要职责是：将Pod调度到最合适的节点上。在具体的流程上，默认调度器首先会通过Predicate算法挑选出所有可以运行该Pod的节点，然后再通过Priority算法给这些节点打分，而得分最高的节点就是最合适的节点。</li><li>默认调度器在具体的实现上就是两个独立的控制循环：Informer Path和Scheduling Path。其中：<ul><li>Informer Path的主要作用是监听各种API对象的变化，及时将待调度资源入队，以及更新调度器缓存；</li><li>Scheduling Path的主要作用是从调度队列中将待调度资源出队，然后调用Predicate算法和Priority算法得出最合适的节点，最后执行bind操作（即设置nodeName 字段的值）。</li></ul></li><li>Cache化、乐观绑定、无锁化是Kubernetes默认调度器中的几个重要设计思想，这些设计大大提高了Kubernetes的调度效率。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>作业调度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作业调度1：Kubernetes的资源模型</title>
    <link href="/2020/10/13/%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A61%EF%BC%9AKubernetes%E7%9A%84%E8%B5%84%E6%BA%90%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/10/13/%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A61%EF%BC%9AKubernetes%E7%9A%84%E8%B5%84%E6%BA%90%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>作为一个编排与管理容器集群的项目，Kubernetes 为用户提供的基础设施能力，不仅包括了对应用的定义和描述，还包括了对应用的资源管理和调度。接下来，我们重点讨论后面这部分内容。</p><h2 id="一、从Kubernetes的资源模型说起">一、从Kubernetes的资源模型说起</h2><h3 id="1-1、两种资源类型">1.1、两种资源类型</h3><p>我们知道，在 Kubernetes 里，Pod 是最小的原子调度单位。这也就意味着，所有跟调度和资源管理相关的属性都应该属于 Pod 对象的字段。而这其中最重要的部分，就是 Pod 的 CPU 和内存配置，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">frontend</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">db</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">env:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD</span><br>      <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;password&quot;</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;64Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;250m&quot;</span><br>      <span class="hljs-attr">limits:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;128Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;500m&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">wp</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">wordpress</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;64Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;250m&quot;</span><br>      <span class="hljs-attr">limits:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;128Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;500m&quot;</span><br></code></pre></td></tr></table></figure><p>在 Kubernetes 中，像 CPU 这样的资源被称作“可压缩资源”（compressible resources）。它的典型特点是，当可压缩资源不足时，Pod 只会“饥饿”，但不会退出。而像内存这样的资源，则被称作“不可压缩资源（incompressible resources）。当不可压缩资源不足时，Pod 就会因为 OOM（Out-Of-Memory）被内核杀掉。</p><p>由于 Pod 可以由多个 Container 组成，所以 CPU 和内存资源的限额，要配置在每个 Container 的定义上。这样，Pod 整体的资源配置，就由这些 Container 的配置值累加得到。</p><h3 id="1-2、CPU资源限额">1.2、CPU资源限额</h3><p>在Kubernetes 中为 CPU 设置的单位是“CPU 的个数”。比如，cpu=1 指的就是，这个 Pod 的 CPU 限额是 1 个 CPU。</p><blockquote><p>那么，具体的“1 个 CPU”在宿主机上如何解释呢？是 1 个 CPU 核心，还是 1 个 vCPU，还是 1 个 CPU 的超线程（Hyperthread）？</p></blockquote><p>答案是，完全取决于宿主机的 CPU 实现方式。Kubernetes 只负责保证 Pod 能够使用到“1 个 CPU”的计算能力。</p><p>此外，Kubernetes 允许我们将 CPU 限额设置为分数，比如在上面的例子中，CPU limits 的值就是 500m。所谓 500m，指的就是 500 millicpu，也就是 0.5 个 CPU 的意思。这样，这个 Pod 就会被分配到 1 个 CPU 一半的计算能力。当然，我们也可以直接把这个配置写成 cpu=0.5。但在实际使用时，还是推荐使用 500m 的写法，毕竟这才是 Kubernetes 内部通用的 CPU 表示方式。</p><h3 id="1-3、内存资源限额">1.3、内存资源限额</h3><p>对于内存资源来说，它的单位自然就是 bytes。Kubernetes 支持我们使用 Ei、Pi、Ti、Gi、Mi、Ki（或者 E、P、T、G、M、K）的方式来作为 bytes 的值。比如，在上面的例子中，Memory requests 的值就是 64MiB (2 的 26 次方 bytes) 。这里要注意区分 MiB（mebibyte）和 MB（megabyte）的区别：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">1Mi=1024*1024<br>1M=1000*1000<br></code></pre></td></tr></table></figure><h3 id="1-4、理解-requests-limits">1.4、理解 requests &amp; limits</h3><p>在 Kubernetes 中， Pod 的 CPU 和内存资源，实际上还分为 requests 和 limits 两种情况，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">spec.containers[].resources.requests.cpu</span><br><span class="hljs-string">spec.containers[].resources.requests.memory</span><br><span class="hljs-string">spec.containers[].resources.limits.cpu</span><br><span class="hljs-string">spec.containers[].resources.limits.memory</span><br></code></pre></td></tr></table></figure><p>这两者的区别其实非常简单：在调度的时候，kube-scheduler 只会按照 requests 的值进行计算。而在真正设置 Cgroups 限制的时候，kubelet 则会按照 limits 的值来进行设置。</p><p>更确切地说，当我们指定了 requests.cpu=250m 之后，相当于将 Cgroups 的 cpu.shares 的值设置为 (250/1000)*1024。而当我们没有设置 requests.cpu 的时候，cpu.shares 默认则是 1024。这样，Kubernetes 就通过 cpu.shares 完成了对 CPU 时间的按比例分配。</p><p>而如果我们指定了 limits.cpu=500m 之后，则相当于将 Cgroups 的 cpu.cfs_quota_us 的值设置为 (500/1000)*100ms，而 cpu.cfs_period_us 的值始终是 100ms。这样，Kubernetes 就为我们设置了这个容器只能用到宿主机CPU 的 50%。</p><p>对于内存来说，当我们指定了 limits.memory=128Mi 之后，相当于将 Cgroups 的 memory.limit_in_bytes 设置为 128 * 1024 * 1024。而在调度的时候，调度器只会使用 requests.memory=64Mi 来进行判断。</p><p>综上所述，requests是Pod能接受的资源下限（供调度时使用），而于limits则是Pod能使用的资源上限。</p><h3 id="1-5、小结">1.5、小结</h3><p>Kubernetes 这种对 CPU 和内存资源限额的设计，实际上参考了 Borg 论文中对“动态资源边界”的定义，即：容器化作业在提交时所设置的资源边界，并不一定是调度系统所必须严格遵守的，这是因为在实际场景中，大多数作业使用到的资源其实远小于它所请求的资源限额。基于这种假设，Borg 在作业被提交后，会主动减小它的资源限额配置，以便容纳更多的作业、提升资源利用率。而当作业资源使用量增加到一定阈值时，Borg 会通过“快速恢复”过程，还原作业原始的资源限额，防止出现异常情况。</p><p>Kubernetes 的 requests+limits 的做法，其实就是上述思路的一个简化版：用户在提交 Pod 时，可以声明一个相对较小的 requests 值供调度器使用，而 Kubernetes 真正设置给容器 Cgroups 的，则是相对较大的 limits 值。不难看到，这跟 Borg 的思路是相通的。</p><h2 id="二、Kubernetes中的QoS模型">二、Kubernetes中的QoS模型</h2><p>在理解了 Kubernetes 资源模型设计之后，我们再来讨论一下 Kubernetes 里的 QoS 模型。在 Kubernetes 中，不同的 requests 和 limits 设置，其实会将这个 Pod 划分到不同的 QoS 级别当中。</p><h3 id="2-1、三种QoS级别">2.1、三种QoS级别</h3><h4 id="2-1-1、Guaranteed">2.1.1、Guaranteed</h4><p>当 Pod 里的每一个 Container 都同时设置了 requests 和 limits，并且 requests 和 limits 值相等的时候，这个 Pod 就属于 Guaranteed 类别，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">qos-demo</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">qos-example</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">qos-demo-ctr</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">limits:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;200Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;700m&quot;</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;200Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;700m&quot;</span><br></code></pre></td></tr></table></figure><p>当创建这个 Pod 之后，它的 qosClass 字段就会被 Kubernetes 自动设置为 Guaranteed。需要注意的是，当 Pod 仅设置了 limits 没有设置 requests 的时候，Kubernetes 会自动为它设置与 limits 相同的 requests 值，所以，这也属于 Guaranteed 情况。</p><h4 id="2-1-2、Burstable">2.1.2、Burstable</h4><p>当 Pod 不满足 Guaranteed 的条件，但至少有一个 Container 设置了 requests。那么这个 Pod 就会被划分到 Burstable 类别。比如下面这个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">qos-demo-2</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">qos-example</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">qos-demo-2-ctr</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-string">limits</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;200Mi&quot;</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;100Mi&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-1-3、BestEffort">2.1.3、BestEffort</h4><p>如果一个 Pod 既没有设置 requests，也没有设置 limits，那么它的 QoS 类别就是 BestEffort。比如下面这个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">qos-demo-3</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">qos-example</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">qos-demo-3-ctr</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure><h3 id="2-2、划分QoS级别的目的">2.2、划分QoS级别的目的</h3><blockquote><p>那么，Kubernetes 为 Pod 设置这三种 QoS 类别，具体有什么作用呢？</p></blockquote><p>实际上， 划分QoS级别的主要应用场景，是当宿主机资源紧张的时候，kubelet 对 Pod 进行 Eviction（即资源回收）时会用到。</p><p>具体来说，当 Kubernetes 所管理的宿主机上的不可压缩资源短缺时，就有可能触发 Eviction。比如，可用内存（memory.available）、可用的宿主机磁盘空间（nodefs.available），以及容器运行时镜像存储空间（imagefs.available）等等。</p><h3 id="2-3、Eviction的阈值设置">2.3、Eviction的阈值设置</h3><p>目前，Kubernetes 为我们设置的 Eviction 的默认阈值如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">memory.available&lt;100Mi<br>nodefs.available&lt;10%<br>nodefs.inodesFree&lt;5%<br>imagefs.available&lt;15%<br></code></pre></td></tr></table></figure><p>当然，上述各个触发条件在 kubelet 里都是可配置的。比如下面这个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubelet \<br>--eviction-hard=imagefs.available&lt;10%,memory.available&lt;500Mi,nodefs.available&lt;5%,nodefs.inodesFree&lt;5% \<br>--eviction-soft=imagefs.available&lt;30%,nodefs.available&lt;10% \<br>--eviction-soft-grace-period=imagefs.available=2m,nodefs.available=2m \<br>--eviction-max-pod-grace-period=600<br></code></pre></td></tr></table></figure><p>在这个配置中，我们可以看到 Eviction 在 Kubernetes 里其实分为 Soft 和 Hard 两种模式。其中，Soft Eviction 允许我们为 Eviction 过程设置一段“优雅时间”，比如上面例子里的 imagefs.available=2m，就意味着当 imagefs 不足的阈值达到 2 分钟之后，kubelet 才会开始 Eviction 的过程。而在 Hard Eviction 模式下，Eviction 过程会在阈值达到之后立刻开始。</p><h3 id="2-4、Eviction的执行策略">2.4、Eviction的执行策略</h3><p>Kubernetes 计算 Eviction 阈值的数据来源，主要依赖于从 Cgroups 读取到的值，以及使用 cAdvisor 监控到的数据。当宿主机的 Eviction 阈值达到后，就会进入 MemoryPressure 或者 DiskPressure 状态，从而避免新的 Pod 被调度到这台宿主机上。而当 Eviction 发生的时候，kubelet 具体会挑选哪些 Pod 进行删除操作，就需要参考这些 Pod 的 QoS 类别了：</p><ul><li><p>首当其冲的，自然是 BestEffort 类别的 Pod。</p></li><li><p>其次，是属于 Burstable 类别、并且发生“饥饿”的资源使用量已经超出了 requests 的 Pod。</p></li><li><p>最后，才是 Guaranteed 类别。并且，Kubernetes 会保证只有当 Guaranteed 类别的 Pod 的资源使用量超过了其 limits 的限制，或者宿主机本身正处于 Memory Pressure 状态时，Guaranteed 的 Pod 才可能被选中进行 Eviction 操作。</p></li></ul><p>当然，对于同 QoS 类别的 Pod 来说，Kubernetes 还会根据 Pod 的优先级来进行进一步地排序和选择。</p><h2 id="三、cpuset">三、cpuset</h2><p>在理解了 Kubernetes 里的 QoS 类别的设计之后，我们再来讨论一下Kubernetes 里一个非常有用的特性：cpuset 。</p><p>我们知道，在使用容器的时候，可以通过设置 cpuset 把容器绑定到某个 CPU 的核上，而不是像 cpushare 那样共享 CPU 的计算能力。这种情况下，由于操作系统在 CPU 之间进行上下文切换的次数大大减少，容器里应用的性能会得到大幅提升。事实上，cpuset 方式，是生产环境里部署在线应用类型的 Pod 时，非常常用的一种方式。</p><blockquote><p>可是，这样的需求在 Kubernetes 里又该如何实现呢？</p></blockquote><p>其实非常简单。首先，我们的 Pod 的QoS 类型必须为 Guaranteed；然后，我们只需要将 Pod 的 CPU 资源的 requests 和 limits 设置为同一个相等的整数值即可。比如下面这个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">limits:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;200Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;2&quot;</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;200Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;2&quot;</span><br></code></pre></td></tr></table></figure><p>这时候，该 Pod 就会被绑定在 2 个独占的 CPU 核上。当然，具体是哪两个 CPU 核，则是由 kubelet 为我们分配的。</p><h2 id="四、小结">四、小结</h2><p>在这篇文章中，我们主要讨论了如下概念：</p><ul><li>在Kubernetes中资源被分为可压缩资源（比如，CPU）和不可压缩资源（比如，内存和磁盘）。当可压缩资源不足时，Pod会饥饿但不会退出；当不可压缩资源不足时，Pod就会退出。</li><li>Kubernetes支持requests和limits两种限额设置。其中，requests值是调度器进行Pod调度时的参考，limits值则是Cgroups为Pod设置的可用资源上限。</li><li>Kubernetes根据requests和limits的设置情况划分出了三种QoS级别，它们分别是：Guaranteed、Burstable、BestEffort。<ul><li>当Pod中的所有Container即没有设置requests，又没有设置limits时，该Pod就属于BestEffort级别；</li><li>当Pod中的每个Container同时设置requests和limits（或者仅设置了limits），并且requests和limits的值相等时，该Pod就属于Guaranteed级别；</li><li>当Pod中至少有一个Container设置了requests，且不满足Guaranteed条件时，该Pod就属于Burstable级别。</li></ul></li><li>QoS是kubelet进行Eviction的重要参考。当不可压缩资源出现不足时，就会发生Eviction。而kubelet在进行Eviction时，会遵循先BestEffort、再Burstable、后Guaranteed的策略</li><li>cpuset是kubernetes中一个非常有用的特性。通过它可以将容器绑定当某个CPU上。这样可以减少上下文切换，提高容器的性能。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>作业调度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GoReplay入门</title>
    <link href="/2020/10/10/GoReplay%E5%85%A5%E9%97%A8/"/>
    <url>/2020/10/10/GoReplay%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>随着应用功能的不断增加，测试它所需的工作量也会成倍增加。GoReplay则为我们提供了一个简单而快速的测试方法，即重用现有流量进行测试。它能够记录和分析应用程序的流量，且不会对应用程序造成影响。</p><h2 id="一、简介">一、简介</h2><p>GoReplay，又称Gor，是一个采用Golang编写的、开源的HTTP实时流量捕获和重放工具。通过它可以完成流量复制、负载测试、流量监控和流量分析等工作。它以守护进程（而不是Proxy）的形式运行在集群的入口服务器上（比如，nginx），同时不会入侵现有的集群架构。Gor的工作原理如下：</p><p><img src="/img/image-20201010161023899.png" alt="image-20201010161023899"></p><h2 id="二、安装">二、安装</h2><p>Gor的安装十分简单，下载官网的二进制包，然后解压的任意PATH目录下即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p ~/download/<br>wget -O ~/download/gor_v1.2.0_x64.tar.gz https://github.com/buger/goreplay/releases/download/v1.2.0/gor_v1.2.0_x64.tar.gz<br>sudo tar xf ~/download/gor_v1.2.0_x64.tar.gz -C /usr/local/bin/<br></code></pre></td></tr></table></figure><h2 id="三、实时捕获HTTP流量">三、实时捕获HTTP流量</h2><h3 id="3-1、运行Web服务">3.1、运行Web服务</h3><p>Gor通常运行在集群的入口服务器上捕获用户的请求。这里，为了便于演示在安装了Gor的服务器上使用Docker启动了一个Nginx服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p 8080:80 --name web nginx<br></code></pre></td></tr></table></figure><h3 id="3-2、捕获流量">3.2、捕获流量</h3><p>想要捕获HTTP流量只需执行如下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo gor --input-raw :8080 --output-stdout<br></code></pre></td></tr></table></figure><p>该命令会监听8080端口上的所有网络活动，并会将捕获到的数据记录到stdout。此时，如果我们再打开一个终端并执行<code>curl -I 127.0.0.1:8080</code>，在原来的终端上则会看到类似如下的输出信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">1 d06a877080ceafe56b851d62d7411a7d7c58e762 1602318552165570232 185093<br>HEAD / HTTP/1.1<br>Host: 127.0.0.1:8080<br>User-Agent: curl/7.58.0<br>Accept: */*<br></code></pre></td></tr></table></figure><p>需要注意的是，默认情况下GoReplay不追踪响应，可以使用<code>--output-http-track-response</code>参数启用它。</p><h2 id="四、实时重放HTTP流量">四、实时重放HTTP流量</h2><h3 id="4-1、运行Web服务">4.1、运行Web服务</h3><p>这次我们在安装了Gor的服务器上的运行两个Nginx服务，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p 8081:80 --name web1 nginx<br>docker run -d -p 8082:80 --name web2 nginx<br></code></pre></td></tr></table></figure><h3 id="4-2、重放流量">4.2、重放流量</h3><p>重放流量也很简单，执行如下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo gor --input-raw :8081 --output-http=&quot;http://127.0.0.1:8082&quot;<br></code></pre></td></tr></table></figure><p>此时，如果我们访问web1，在web2的访问日志中会看到有同样的请求存在：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl http://127.0.0.1:8081</span><br>...<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs -f web2</span><br>...<br>172.17.0.1 - - [10/Oct/2020:08:52:01 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.58.0&quot; &quot;-&quot;<br></code></pre></td></tr></table></figure><h2 id="五、离线重放">五、离线重放</h2><p>当然，除了实时重放外，Gor还支持将捕获到的数据保存在文件中，以供之后再进行重放。</p><h3 id="5-1、运行Web服务">5.1、运行Web服务</h3><p>这里我们还是在安装了Gor的服务器上的运行一个Nginx服务，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p 80:80 --name nginx nginx<br></code></pre></td></tr></table></figure><h3 id="5-2、捕获流量，并存入文件">5.2、捕获流量，并存入文件</h3><p>要想将捕获到的HTTP流量存入文件也很简单，执行如下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo gor --input-raw :80 --output-file=requests.gor --output-file-append<br></code></pre></td></tr></table></figure><p>需要注意的是，默认情况下gor会将捕获到的数据写入到多个文件中，可以使用<code>--output-file-append</code>参数关闭它。</p><p>访问web服务后，在文件requests.gor中可以看到类似如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">cat</span> requests.gor</span> <br>1 de21503b1ba356be5c585fc3e989b3dbba5e51ca 1602320715010273170 724411<br>GET / HTTP/1.1<br>Host: 127.0.0.1<br>User-Agent: curl/7.58.0<br>Accept: */*<br><br><br>🐵🙈🙉<br>1 a110b64c69f71e9e370296e2ffd10d71290998c7 1602320715010715372 364743<br>...<br></code></pre></td></tr></table></figure><h3 id="5-3、重放请求">5.3、重放请求</h3><p>重放请求也是一条命令的事，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo gor --input-file requests.gor --output-http=&quot;http://127.0.0.1&quot;<br></code></pre></td></tr></table></figure><p>此时，我们如果观察nginx的访问日志，会有如下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs -f nginx</span><br>...<br>172.17.0.1 - - [10/Oct/2020:09:14:15 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.58.0&quot; &quot;-&quot;<br>172.17.0.1 - - [10/Oct/2020:09:14:15 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.58.0&quot; &quot;-&quot;<br>172.17.0.1 - - [10/Oct/2020:09:14:15 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.58.0&quot; &quot;-&quot;<br>...<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>流量复制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>怎样制定一份科学的跑步方案？</title>
    <link href="/2020/10/08/%E6%80%8E%E6%A0%B7%E5%88%B6%E5%AE%9A%E4%B8%80%E4%BB%BD%E7%A7%91%E5%AD%A6%E7%9A%84%E8%B7%91%E6%AD%A5%E6%96%B9%E6%A1%88%EF%BC%9F/"/>
    <url>/2020/10/08/%E6%80%8E%E6%A0%B7%E5%88%B6%E5%AE%9A%E4%B8%80%E4%BB%BD%E7%A7%91%E5%AD%A6%E7%9A%84%E8%B7%91%E6%AD%A5%E6%96%B9%E6%A1%88%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>todo</p><h2 id="一、体脂率（跑步训练的启动指标）">一、体脂率（跑步训练的启动指标）</h2><h3 id="1-1、什么是体脂率">1.1、什么是体脂率</h3><p>体脂率是指体内的脂肪占体重总数的百分比。</p><p>比如，男性的体脂率高于26%就属于肥胖，如果能维持在14%左右就可以在腹部看到肌肉。女性的体脂率高于32%就属于肥胖，如果能维持在23%左右就能看到肌肉线条。</p><h3 id="1-2、体脂率的作用">1.2、体脂率的作用</h3><p>体脂率不仅是判断身体是否肥胖的参考指标，而且还是能否开始跑步的参考指标。当男性的体脂率低于26%、女性的体脂率低于32%时，也就是体脂秤显示体脂率不在肥胖区间时，就可以考虑开始跑步。</p><h3 id="1-3、怎样测体脂率">1.3、怎样测体脂率</h3><p>测量体脂率最简单的方法是用体脂秤测量。</p><p>体脂秤是靠微电流通过全身，利用水分导电、体脂不导电的原理，根据最终电流的通过速度分辨出脂肪和肌肉的含量，按照公式得出最终的体脂率结果。</p><p>需要注意的是，这种测量方法受身体水分含量的影响比较大，比如喝一打杯水后再用体脂秤测量，结果可能就显示体脂率降低了。所以，用这种方法测量体脂率，最好选择在同一个时间，比如，每条早上起床后测量。</p><h2 id="二、最大摄氧量（确定跑步舒适区间的指标）">二、最大摄氧量（确定跑步舒适区间的指标）</h2><h3 id="2-1、什么是最大摄氧量">2.1、什么是最大摄氧量</h3><p>简单来说，最大摄氧量就是我们在运动过程中获取氧气的最大能力。</p><p>这个指标越高，代表我们的心肺功能和肌肉线粒体的功能越好。一般来说，男性达到40ml/kg·min，女性达到36ml/kg·min，才算及格，及格线以下都是比较危险的。</p><h3 id="2-2、最大摄氧量的作用">2.2、最大摄氧量的作用</h3><p>最大摄氧量（VO2max）是衡量人体心肺功能的量化指标。</p><p>测试最大摄氧量不仅能测试出心肺系统的功能，还能测试出肌肉线粒体的功能。肌肉线粒体是进行有氧呼吸的主要场所，身体的氧化反应是在肌肉线粒体中完成的，它的数量决定着人体可以消耗能量的多少。</p><h3 id="2-3、怎样测最大摄氧量">2.3、怎样测最大摄氧量</h3><p>推荐购买专业的运动手表。这类运动手表除了可以检测最大摄氧量的数据，还可以测试心率等其他指标，可以反应出心肺功能的整体状态。</p><h2 id="三、心率（制定跑步强度的指标）">三、心率（制定跑步强度的指标）</h2><h3 id="3-1、为什么要监测心率">3.1、为什么要监测心率</h3><p>运动计划如果只有时间或距离，是无法保持合理强度的。</p><p>因为只有距离标准，比如今天的计划是跑完5km，可能为了完成这段距离，越跑越快，导致运动强度过大；而只有时间标准，比如今天慢跑30分钟，可能让自己越跑越慢，导致运动强度不够。</p><p>在运动时，加入心率指标，让心率保持在合适的区间，再加上时间或距离标准，就能保证合理的运动强度和良好的运动效果。</p><h3 id="3-2、怎样测心率">3.2、怎样测心率</h3><h4 id="3-2-1、最大心率">3.2.1、最大心率</h4><p>使用网上最常见的计算公式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">最大心率（次/分） = 220 - 年龄<br></code></pre></td></tr></table></figure><p>需要注意的是，这种方法计算得出的是平均值，忽略了个体之间的差异性。</p><p>我们也可以用心率手表自己进行测验。比如，在操场上跑出自己的最大心率。热身后，跑3次全力跑的800米，每次之间休息3分钟，然后查看手表记录的最高心率值。当然，还可以在跑步机上进行测试。热身后，以自己平时的跑步速度跑步，每两分钟把坡度提升1%，重复这个过程，直到无法继续时，坚持跑完最后的30秒，结束后手表记录的最高心率值就是自己的最大心率。</p><h4 id="3-2-2、静态心率">3.2.2、静态心率</h4><p>选一个睡眠充足的早晨，起床后站起来静止1分钟，这1分钟内的心跳就是跑步时的静态心率。</p><h2 id="四、疲劳指数（调整跑步强度的指标）">四、疲劳指数（调整跑步强度的指标）</h2><p>每天早上起床时看一下心率，如果比静态心率高5~10下，说明前一天运动量过大，体力尚未完全恢复或者没有休息好，要适当地调整运动量或增加休息时间。</p>]]></content>
    
    
    <categories>
      
      <category>精力管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跑步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器网络8：Service与Ingress</title>
    <link href="/2020/10/07/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C8%EF%BC%9AService%E4%B8%8EIngress/"/>
    <url>/2020/10/07/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C8%EF%BC%9AService%E4%B8%8EIngress/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们讨论了将Service 暴露给外界的三种方法。接下来，我们重点讨论另外一种方法：Ingreess。</p><h2 id="一、什么是Ingress">一、什么是Ingress</h2><p>在将 Service 暴露给外界的三种方法。其中有一个叫作 LoadBalancer 类型的 Service，它会为我们在 Cloud Provider（比如：Google Cloud 或者 OpenStack）里创建一个与该 Service 对应的负载均衡服务。</p><p>但是，由于每个 Service 都要有一个负载均衡服务，所以这个做法实际上既浪费成本又高。作为用户，其实更希望看到 Kubernetes 为我们内置一个全局的负载均衡器。然后，通过我们访问的 URL，把请求转发给不同的后端 Service。</p><p>这种全局的、为了代理不同后端 Service 而设置的负载均衡服务，就是 Kubernetes 里的 Ingress 服务。所以，Ingress 的功能其实很容易理解：所谓 Ingress，就是 Service 的“Service”。</p><h2 id="二、理解Ingress对象">二、理解Ingress对象</h2><blockquote><p>假如我们现在有这样一个站点：<a href="https://cafe.example.com">https://cafe.example.com</a>。其中，<a href="https://cafe.example.com/coffee%EF%BC%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E6%98%AF%E2%80%9C%E5%92%96%E5%95%A1%E7%82%B9%E9%A4%90%E7%B3%BB%E7%BB%9F%E2%80%9D%E3%80%82%E8%80%8Chttps://cafe.example.com/tea%EF%BC%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E5%88%99%E6%98%AF%E2%80%9C%E8%8C%B6%E6%B0%B4%E7%82%B9%E9%A4%90%E7%B3%BB%E7%BB%9F%E2%80%9D%E3%80%82%E8%BF%99%E4%B8%A4%E4%B8%AA%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%88%86%E5%88%AB%E7%94%B1%E5%90%8D%E5%8F%AB">https://cafe.example.com/coffee，对应的是“咖啡点餐系统”。而https://cafe.example.com/tea，对应的则是“茶水点餐系统”。这两个系统，分别由名叫</a> coffee 和 tea 这样两个 Deployment 来提供服务。那么现在，如何使用 Kubernetes 的 Ingress 来创建一个统一的负载均衡器，从而实现当用户访问不同的域名时，能够访问到不同的 Deployment 呢？</p></blockquote><p>要实现上述功能，就需要在 Kubernetes 里通过 Ingress 对象来描述，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">cafe-ingress</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">tls:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">cafe.example.com</span><br>    <span class="hljs-attr">secretName:</span> <span class="hljs-string">cafe-secret</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">cafe.example.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/tea</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">tea-svc</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/coffee</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">coffee-svc</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>在上面这个yaml 文件中，最值得我们关注的，是 rules 字段。在 Kubernetes 里，这个字段叫作：IngressRule。</p><p>IngressRule 的 Key，就叫做：host。它必须是一个标准的域名格式（Fully Qualified Domain Name）的字符串，而不能是 IP 地址。而 host 字段定义的值，就是这个 Ingress 的入口。这也就意味着，当用户访问 <a href="http://cafe.example.com">cafe.example.com</a> 的时候，实际上访问到的是这个 Ingress 对象。这样，Kubernetes 就能使用 IngressRule 来对请求进行下一步转发。</p><p>而接下来 IngressRule 规则的定义，则依赖于 path 字段。我们可以简单地理解为，这里的每一个 path 都对应一个后端 Service。所以在我们的例子里，定义了两个 path，它们分别对应 coffee 和 tea 这两个 Deployment 的 Service（即：coffee-svc 和 tea-svc）。</p><p>通过上面的讲解，不难看到，所谓 Ingress 对象，其实就是 Kubernetes 项目对“反向代理”的一种抽象。一个 Ingress 对象的主要内容，实际上就是一个“反向代理”服务（比如：Nginx）的配置文件的描述。而这个代理服务对应的转发规则，就是 IngressRule。</p><p>这就是为什么在每条 IngressRule 里，需要有一个 host 字段来作为这条 IngressRule 的入口，然后还需要有一系列 path 字段来声明具体的转发策略。这其实跟 Nginx、HAproxy 等项目的配置文件的写法是一致的。</p><h2 id="三、实践Ingress">三、实践Ingress</h2><p>有了 Ingress 这样一个统一的抽象，Kubernetes 的用户就无需关心 Ingress 的具体细节了。在实际的使用中，我们只需要从社区里选择一个具体的 Ingress Controller，把它部署在 Kubernetes 集群里即可。</p><p>然后，这个 Ingress Controller 会根据我们定义的 Ingress 对象，提供对应的代理能力。目前，业界常用的各种反向代理项目，比如 Nginx、HAProxy、Envoy、Traefik 等，都已经为 Kubernetes 专门维护了对应的 Ingress Controller。</p><p>接下来，我们就以最常用的 Nginx Ingress Controller 为例，在使用 kubeadm 部署的 Bare-metal 环境中，实践一下 Ingress 机制的使用过程。</p><h3 id="3-1、部署Nginx-Ingress-Controller">3.1、部署Nginx Ingress Controller</h3><p>部署 Nginx Ingress Controller 的方法非常简单，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/mandatory.yaml</span><br></code></pre></td></tr></table></figure><p>其中，在mandatory.yaml这个文件里，正是 Nginx 官方为我们维护的 Ingress Controller 的定义。我们来看一下它的内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-configuration</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">ingress-nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">ingress-nginx</span><br>    <span class="hljs-attr">app.kubernetes.io/part-of:</span> <span class="hljs-string">ingress-nginx</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-ingress-controller</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">ingress-nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">ingress-nginx</span><br>    <span class="hljs-attr">app.kubernetes.io/part-of:</span> <span class="hljs-string">ingress-nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">ingress-nginx</span><br>      <span class="hljs-attr">app.kubernetes.io/part-of:</span> <span class="hljs-string">ingress-nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">ingress-nginx</span><br>        <span class="hljs-attr">app.kubernetes.io/part-of:</span> <span class="hljs-string">ingress-nginx</span><br>      <span class="hljs-attr">annotations:</span><br>        <span class="hljs-string">...</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">nginx-ingress-serviceaccount</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-ingress-controller</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.20.0</span><br>          <span class="hljs-attr">args:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">/nginx-ingress-controller</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--configmap=$(POD_NAMESPACE)/nginx-configuration</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--publish-service=$(POD_NAMESPACE)/ingress-nginx</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--annotations-prefix=nginx.ingress.kubernetes.io</span><br>          <span class="hljs-attr">securityContext:</span><br>            <span class="hljs-attr">capabilities:</span><br>              <span class="hljs-attr">drop:</span><br>                <span class="hljs-bullet">-</span> <span class="hljs-string">ALL</span><br>              <span class="hljs-attr">add:</span><br>                <span class="hljs-bullet">-</span> <span class="hljs-string">NET_BIND_SERVICE</span><br>            <span class="hljs-comment"># www-data -&gt; 33</span><br>            <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">33</span><br>          <span class="hljs-attr">env:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">POD_NAME</span><br>              <span class="hljs-attr">valueFrom:</span><br>                <span class="hljs-attr">fieldRef:</span><br>                  <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.name</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">POD_NAMESPACE</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>              <span class="hljs-attr">valueFrom:</span><br>                <span class="hljs-attr">fieldRef:</span><br>                  <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.namespace</span><br>          <span class="hljs-attr">ports:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>              <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">https</span><br>              <span class="hljs-attr">containerPort:</span> <span class="hljs-number">443</span><br></code></pre></td></tr></table></figure><p>可以看到，在上述 YAML 文件中，定义了一个使用 nginx-ingress-controller 镜像的 Pod。需要注意的是，这个 Pod 的启动命令需要使用该 Pod 所在的 Namespace 作为参数。而这个信息，当然是通过 Downward API 拿到的，即：Pod 的 env 字段里的定义（env.valueFrom.fieldRef.fieldPath）。</p><h3 id="3-2、理解Nginx-Ingress-Controller">3.2、理解Nginx Ingress Controller</h3><p>上述 Pod ，其实就是一个监听 Ingress 对象以及它所代理的后端 Service 变化的控制器。</p><p>当一个新的 Ingress 对象由用户创建后，nginx-ingress-controller 就会根据 Ingress 对象里定义的内容，生成一份对应的 Nginx 配置文件（/etc/nginx/nginx.conf），并使用这个配置文件启动一个 Nginx 服务。</p><p>而一旦 Ingress 对象被更新，nginx-ingress-controller 就会更新这个配置文件。需要注意的是，如果这里只是被代理的 Service 对象被更新，nginx-ingress-controller 所管理的 Nginx 服务是不需要重新加载（reload）的。这当然是因为 nginx-ingress-controller 通过Nginx Lua方案实现了 Nginx Upstream 的动态配置。</p><p>此外，nginx-ingress-controller 还允许我们通过 Kubernetes 的 ConfigMap 对象来对上述 Nginx 配置文件进行定制。这个 ConfigMap 的名字，需要以参数的方式传递给 nginx-ingress-controller。而我们在这个 ConfigMap 里添加的字段，将会被合并到最后生成的 Nginx 配置文件当中。</p><p>可以看到，一个 Nginx Ingress Controller 为我们提供的服务，其实是一个可以根据 Ingress 对象和被代理后端 Service 的变化，来自动进行更新的 Nginx 负载均衡器。</p><h3 id="3-3、创建Service">3.3、创建Service</h3><p>为了能够让用户访问到这个 Nginx，我们需要创建一个 Service 来把 Nginx Ingress Controller 管理的对象暴露出去，如下所示：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/provider/baremetal/service-nodeport.yaml</span><br></code></pre></td></tr></table></figure><p>由于我们使用的是 Bare-metal 环境，所以 service-nodeport.yaml 文件里的内容，就是一个 NodePort 类型的 Service，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ingress-nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">ingress-nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">ingress-nginx</span><br>    <span class="hljs-attr">app.kubernetes.io/part-of:</span> <span class="hljs-string">ingress-nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">https</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">443</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">443</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">ingress-nginx</span><br>    <span class="hljs-attr">app.kubernetes.io/part-of:</span> <span class="hljs-string">ingress-nginx</span><br></code></pre></td></tr></table></figure><p>可以看到，这个 Service 的唯一工作，就是将所有携带 ingress-nginx 标签的 Pod 的 80 和 433 端口暴露出去。</p><p>而如果是公有云上的环境，需要创建的就是 LoadBalancer 类型的 Service 了。</p><h3 id="3-4、查看Service-的访问入口">3.4、查看Service 的访问入口</h3><p>上述操作完成后，一定要记录下这个 Service 的访问入口，即：宿主机的地址和 NodePort 的端口，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc -n ingress-nginx</span><br>NAME            TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)                      AGE<br>ingress-nginx   NodePort   10.105.72.96   &lt;none&gt;        80:30044/TCP,443:31453/TCP   3h<br></code></pre></td></tr></table></figure><p>为了后面方便使用，我们把上述访问入口设置为环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">IC_IP=10.168.0.2 <span class="hljs-comment"># 任意一台宿主机的地址</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">IC_HTTPS_PORT=31453 <span class="hljs-comment"># NodePort端口</span></span><br></code></pre></td></tr></table></figure><p>在 Ingress Controller 和它所需要的 Service 部署完成后，我们就可以使用它了。</p><h3 id="3-5、使用Nginx-Ingress-Controller">3.5、使用Nginx Ingress Controller</h3><p>首先，我们要在集群里部署我们的应用 Pod 和它们对应的 Service，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f cafe.yaml</span><br></code></pre></td></tr></table></figure><p>然后，我们需要创建 Ingress 所需的 SSL 证书（tls.crt）和密钥（tls.key），这些信息都是通过 Secret 对象定义好的，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f cafe-secret.yaml</span><br></code></pre></td></tr></table></figure><p>这一步完成后，我们就可以创建一开始定义的 Ingress 对象了，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f cafe-ingress.yaml</span><br></code></pre></td></tr></table></figure><p>这时候，我们就可以查看一下这个 Ingress 对象的信息，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get ingress</span><br>NAME           HOSTS              ADDRESS   PORTS     AGE<br>cafe-ingress   cafe.example.com             80, 443   2h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe ingress cafe-ingress</span><br>Name:             cafe-ingress<br>Namespace:        default<br>Address:          <br>Default backend:  default-http-backend:80 (&lt;none&gt;)<br>TLS:<br>  cafe-secret terminates cafe.example.com<br>Rules:<br>  Host              Path  Backends<br>  ----              ----  --------<br>  cafe.example.com  <br>                    /tea      tea-svc:80 (&lt;none&gt;)<br>                    /coffee   coffee-svc:80 (&lt;none&gt;)<br>Annotations:<br>Events:<br>  Type    Reason  Age   From                      Message<br>  ----    ------  ----  ----                      -------<br>  Normal  CREATE  4m    nginx-ingress-controller  Ingress default/cafe-ingress<br></code></pre></td></tr></table></figure><p>可以看到，这个 Ingress 对象最核心的部分，正是 Rules 字段。其中，我们定义的 Host <a href="http://xn--cafe-zi0i.example.com">是cafe.example.com</a>，它有两条转发规则（Path），分别转发给 tea-svc 和 coffee-svc。当然，在 Ingress 的 YAML 文件里，我们还可以定义多个 Host，<a href="http://xn--restaurant-lv8rx27o.example.com">比如restaurant.example.com</a>、movie.example.com等等，来为更多的域名提供负载均衡服务。</p><h3 id="3-6、访问Nginx-Ingress">3.6、访问Nginx Ingress</h3><p>接下来，我们就可以通过访问这个 Ingress 的地址和端口，访问到我们前面部署的应用了，比如，当我们访问<a href="https://cafe.example.com:443/coffee%E6%97%B6%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%98%AF">https://cafe.example.com:443/coffee时，应该是</a> coffee 这个 Deployment 负责响应我的请求。我们可以来尝试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl --resolve cafe.example.com:<span class="hljs-variable">$IC_HTTPS_PORT</span>:<span class="hljs-variable">$IC_IP</span> https://cafe.example.com:<span class="hljs-variable">$IC_HTTPS_PORT</span>/coffee --insecureServer address: 10.244.1.56:80</span><br>Server name: coffee-7dbb5795f6-vglbv<br>Date: 03/Nov/2018:03:55:32 +0000<br>URI: /coffee<br>Request ID: e487e672673195c573147134167cf898<br></code></pre></td></tr></table></figure><p>我们可以看到，访问这个 URL 得到的返回信息是：Server name: coffee-7dbb5795f6-vglbv。这正是 coffee 这个 Deployment 的名字。</p><p>而当我们访问<a href="https://cafe.example.com:433/tea%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%88%99%E5%BA%94%E8%AF%A5%E6%98%AF">https://cafe.example.com:433/tea的时候，则应该是</a> tea 这个 Deployment 负责响应我的请求（Server name: tea-7d57856c44-lwbnp），如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl --resolve cafe.example.com:<span class="hljs-variable">$IC_HTTPS_PORT</span>:<span class="hljs-variable">$IC_IP</span> https://cafe.example.com:<span class="hljs-variable">$IC_HTTPS_PORT</span>/tea --insecure</span><br>Server address: 10.244.1.58:80<br>Server name: tea-7d57856c44-lwbnp<br>Date: 03/Nov/2018:03:55:52 +0000<br>URI: /tea<br>Request ID: 32191f7ea07cb6bb44a1f43b8299415c<br></code></pre></td></tr></table></figure><p>可以看到，Nginx Ingress Controller 为我们创建的 Nginx 负载均衡器，已经成功地将请求转发给了对应的后端 Service。</p><p>以上，就是 Kubernetes 里 Ingress 的设计思想和使用方法了。</p><blockquote><p>不过，我们可能会有一个疑问，如果我们的请求没有匹配到任何一条 IngressRule，那么会发生什么呢？</p></blockquote><p>首先，既然 Nginx Ingress Controller 是用 Nginx 实现的，那么它当然会返回一个 Nginx 的 404 页面。</p><p>不过，Ingress Controller 也允许我们通过 Pod 启动命令里的–default-backend-service 参数，设置一条默认规则，比如：–default-backend-service=nginx-default-backend。</p><p>这样，任何匹配失败的请求，就都会被转发到这个名叫 nginx-default-backend 的 Service。所以，我们就可以通过部署一个专门的 Pod，来为用户返回自定义的 404 页面了。</p><h3 id="3-7、小结">3.7、小结</h3><p>Ingress 实际上就是 Kubernetes 对“反向代理”的抽象。目前，Ingress 只能工作在七层，而 Service 只能工作在四层。所以当你想要在 Kubernetes 里为应用进行 TLS 配置等 HTTP 相关的操作时，都必须通过 Ingress 来进行。当然，正如同很多负载均衡项目可以同时提供七层和四层代理一样，将来 Ingress 的进化中，也会加入四层代理的能力。这样，一个比较完善的“反向代理”机制就比较成熟了。</p><h2 id="四、小结">四、小结</h2><p>在这这篇文章中，我们主要谈论了如下内容：</p><ul><li>Ingress其实就是一个能代理多个不同Service对象的反向代理服务。</li><li>一个Ingress对象可以看作是Nginx服务中一个特定域名下的Location配置。</li><li>Ingress对象是由Ingress Controller来处理的。我们可以将Ingress Controller看作是一个运行中的反向代理服务，而Ingress对象就是这个反向代理的配置。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器网络7：从外部访问Service</title>
    <link href="/2020/10/07/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C7%EF%BC%9A%E4%BB%8E%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AEService/"/>
    <url>/2020/10/07/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C7%EF%BC%9A%E4%BB%8E%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AEService/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们讨论了Kubernetes内部的Pod之间如何互相访问。接下来，我们重点讨论如何从外部访问Kubernetes内部的Pod。</p><h2 id="一、NodePort">一、NodePort</h2><p>通过前面的讲解，我们应该能够明白这样一个事实：Service 的访问信息在 Kubernetes 集群之外，其实是无效的。这其实也容易理解：所谓 Service 的访问入口，其实就是每台宿主机上由 kube-proxy 生成的 iptables 规则，以及 kube-dns 生成的 DNS 记录。而一旦离开了这个集群，这些信息对用户来说，也就没有作用了。</p><p>所以，在使用 Kubernetes 的 Service 时，一个必须要面对和解决的问题就是：如何从外部（Kubernetes 集群之外），访问到 Kubernetes 里创建的 Service？</p><p>这里最常用的一种方式就是：NodePort。我们先来看这个例子。</p><h3 id="1-1、创建NodePort-Service">1.1、创建NodePort Service</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">my-nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">nodePort:</span> <span class="hljs-number">8080</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">nodePort:</span> <span class="hljs-number">443</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">https</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">my-nginx</span><br></code></pre></td></tr></table></figure><p>在这个 Service 的定义里，我们声明它的类型是，type=NodePort。然后，在 ports 字段里声明了 Service 的 8080 端口代理 Pod 的 80 端口，Service 的 443 端口代理 Pod 的 443 端口。</p><p>当然，如果我们不显式地声明 nodePort 字段，Kubernetes 就会为我们分配随机的可用端口来设置代理。这个端口的范围默认是 30000-32767，我们可以通过 kube-apiserver 的–service-node-port-range 参数来修改它。</p><h3 id="1-2、访问Service">1.2、访问Service</h3><p>要访问这个 Service，我们只需要访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;任何一台宿主机的IP地址&gt;:8080<br></code></pre></td></tr></table></figure><p>就可以访问到某一个被代理的 Pod 的 80 端口了。</p><h3 id="1-3、理解NodePort模式">1.3、理解NodePort模式</h3><p>在理解了Service 的工作原理之后，NodePort 模式也就非常容易理解了。显然，kube-proxy 要做的，就是在每台宿主机上生成这样一条 iptables 规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;default/my-nginx: nodePort&quot; -m tcp --dport 8080 -j KUBE-SVC-67RL4FN6JRUPOJYM<br></code></pre></td></tr></table></figure><p>而我们在前面已经讲到，KUBE-SVC-67RL4FN6JRUPOJYM 其实就是一组随机模式的 iptables 规则。所以接下来的流程，就跟 ClusterIP 模式完全一样了。</p><h3 id="1-4、理解SNAT操作的作用">1.4、理解SNAT操作的作用</h3><p>需要注意的是，在 NodePort 方式下，Kubernetes 会在 IP 包离开宿主机发往目的 Pod 时，对这个 IP 包做一次 SNAT 操作，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-A KUBE-POSTROUTING -m comment --comment &quot;kubernetes service traffic requiring SNAT&quot; -m mark --mark 0x4000/0x4000 -j MASQUERADE<br></code></pre></td></tr></table></figure><p>可以看到，这条规则设置在 POSTROUTING 检查点，也就是说，它给即将离开这台主机的 IP 包，进行了一次 SNAT 操作，将这个 IP 包的源地址替换成了这台宿主机上的 CNI 网桥地址，或者宿主机本身的 IP 地址（如果 CNI 网桥不存在的话）。</p><p>当然，这个 SNAT 操作只需要对 Service 转发出来的 IP 包进行（否则普通的 IP 包就被影响了）。而 iptables 做这个判断的依据，就是查看该 IP 包是否有一个“0x4000”的“标志”。这个标志正是在 IP 包被执行 DNAT 操作之前被打上去的。</p><blockquote><p>可是，为什么一定要对流出的包做 SNAT操作呢？</p></blockquote><p>这里的原理其实很简单，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">          client<br>            \ ^<br>             \ \<br>              v \<br>  node 1 &lt;--- node 2<br>   | ^   SNAT<br>   | |   ---&gt;<br>   v |<br>endpoint<br></code></pre></td></tr></table></figure><p>当一个外部的 client 通过 node 2 的地址访问一个 Service 的时候，node 2 上的负载均衡规则，有可能把这个 IP 包转发给一个在 node 1 上的 Pod。这里没有任何问题。</p><p>而当 node 1 上的这个 Pod 处理完请求之后，它就会按照这个 IP 包的源地址发出回复。</p><p>可是，如果没有做 SNAT 操作的话，这时候，被转发来的 IP 包的源地址就是 client 的 IP 地址。所以此时，Pod 就会直接将回复发给client。对于 client 来说，它的请求明明发给了 node 2，收到的回复却来自 node 1，这个 client 很可能会报错。</p><p>所以，在上图中，当 IP 包离开 node 2 之后，它的源 IP 地址就会被 SNAT 改成 node 2 的 CNI 网桥地址或者 node 2 自己的地址。这样，Pod 在处理完成之后就会先回复给 node 2（而不是 client），然后再由 node 2 发送给 client。</p><p>当然，这也就意味着这个 Pod 只知道该 IP 包来自于 node 2，而不是外部的 client。对于 Pod 需要明确知道所有请求来源的场景来说，这是不可以的。</p><h3 id="1-5、externalTrafficPolicy字段的作用">1.5、externalTrafficPolicy字段的作用</h3><p>我们可以将 Service 的 spec.externalTrafficPolicy 字段设置为 local，这就保证了所有 Pod 通过 Service 收到请求之后，一定可以看到真正的、外部 client 的源地址。</p><p>而这个机制的实现原理也非常简单：这时候，一台宿主机上的 iptables 规则，会设置为只将 IP 包转发给运行在这台宿主机上的 Pod。所以这时候，Pod 就可以直接使用源地址将回复包发出，不需要事先进行 SNAT 了。这个流程，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">      client<br>      ^ /   \<br>     / /     \<br>    / v       X<br>  node 1     node 2<br>   ^ |<br>   | |<br>   | v<br>endpoint<br></code></pre></td></tr></table></figure><p>当然，这也就意味着如果在一台宿主机上，没有任何一个被代理的 Pod 存在，比如上图中的 node 2，那么我们使用 node 2 的 IP 地址访问这个 Service，就是无效的。此时，请求会直接被 DROP 掉。</p><h2 id="二、LoadBalancer">二、LoadBalancer</h2><p>从外部访问 Service 的第二种方式，适用于公有云上的 Kubernetes 服务。这时候，我们可以指定一个 LoadBalancer 类型的 Service，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8765</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">example</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">LoadBalancer</span><br></code></pre></td></tr></table></figure><p>在公有云提供的 Kubernetes 服务里，都使用了一个叫作 CloudProvider 的转接层，来跟公有云本身的 API 进行对接。所以，在上述 LoadBalancer 类型的 Service 被提交后，Kubernetes 就会调用 CloudProvider 在公有云上为我们创建一个负载均衡服务，并且把被代理的 Pod 的 IP 地址配置给负载均衡服务做后端。</p><h2 id="三、ExternalName">三、ExternalName</h2><p>第三种方式，是 Kubernetes 在 1.7 之后支持的一个新特性，叫作 ExternalName。举个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ExternalName</span><br>  <span class="hljs-attr">externalName:</span> <span class="hljs-string">my.database.example.com</span><br></code></pre></td></tr></table></figure><p>在上述 Service 的 YAML 文件中，指定了一个 <a href="http://externalName=my.database.example.com">externalName=my.database.example.com</a> 的字段。而且我们应该会注意到，这个 YAML 文件里不需要指定 selector。</p><p>这时候，当我们通过 Service 的 DNS 名字访问它的时候，比如访问：my-service.default.svc.cluster.local。那么，Kubernetes <a href="http://xn--my-ff8cz5rppoy0x7i3b.database.example.com">返回的就是my.database.example.com</a>。所以说，ExternalName 类型的 Service，其实是在 kube-dns 里添加了一条 CNAME 记录。这时，访问 my-service.default.svc.cluster.local 就和访问 <a href="http://my.database.example.com">my.database.example.com</a> 这个域名是一个效果了。</p><h2 id="四、ExternalIP">四、ExternalIP</h2><p>此外，Kubernetes 的 Service 还允许我们为 Service 分配公有 IP 地址，比如下面这个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">MyApp</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span><br>  <span class="hljs-attr">externalIPs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-number">80.11</span><span class="hljs-number">.12</span><span class="hljs-number">.10</span><br></code></pre></td></tr></table></figure><p>在上述 Service 中，我们为它指定的 externalIPs=80.11.12.10，那么此时，就可以通过访问 80.11.12.10:80 访问到被代理的 Pod 了。不过，在这里 Kubernetes 要求 externalIPs 必须是至少能够路由到一个 Kubernetes 的节点。</p><h2 id="五、Service故障定位">五、Service故障定位</h2><p>在理解了 Kubernetes Service 机制的工作原理之后，很多与 Service 相关的问题，其实都可以通过分析 Service 在宿主机上对应的 iptables 规则（或者 IPVS 配置）得到解决。</p><h3 id="5-1、确认-kube-dns运行正常">5.1、确认 kube-dns运行正常</h3><p>比如，当我们的 Service 没办法通过 DNS 访问到的时候。我们就需要区分到底是 Service 本身的配置问题，还是集群的 DNS 出了问题。一个行之有效的方法，就是检查 Kubernetes 自己的 Master 节点的 Service DNS 是否正常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在一个Pod里执行</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">nslookup kubernetes.default</span><br>Server:    10.0.0.10<br>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local<br><br>Name:      kubernetes.default<br>Address 1: 10.0.0.1 kubernetes.default.svc.cluster.local<br></code></pre></td></tr></table></figure><p>如果上面访问 kubernetes.default 返回的值都有问题，那就需要检查 kube-dns 的运行状态和日志了。否则的话，应该去检查自己的 Service 定义是不是有问题。</p><h3 id="5-2、检查Service的Endpoints">5.2、检查Service的Endpoints</h3><p>而如果 Service 没办法通过 ClusterIP 访问到的时候，首先应该检查的是这个 Service 是否有 Endpoints：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get endpoints hostnames</span><br>NAME        ENDPOINTS<br>hostnames   10.244.0.5:9376,10.244.0.6:9376,10.244.0.7:9376<br></code></pre></td></tr></table></figure><p>需要注意的是，如果Pod 的 readniessProbe 没通过，它也不会出现在 Endpoints 列表里。</p><h3 id="5-3、确认kube-proxy正常运行">5.3、确认kube-proxy正常运行</h3><p>而如果 Endpoints 正常，那么就需要确认 kube-proxy 是否在正确运行。在通过 kubeadm 部署的集群里，应该看到 kube-proxy 输出的日志如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">I1027 22:14:53.995134    5063 server.go:200] Running in resource-only container &quot;/kube-proxy&quot;<br>I1027 22:14:53.998163    5063 server.go:247] Using iptables Proxier.<br>I1027 22:14:53.999055    5063 server.go:255] Tearing down userspace rules. Errors here are acceptable.<br>I1027 22:14:54.038140    5063 proxier.go:352] Setting endpoints for &quot;kube-system/kube-dns:dns-tcp&quot; to [10.244.1.3:53]<br>I1027 22:14:54.038164    5063 proxier.go:352] Setting endpoints for &quot;kube-system/kube-dns:dns&quot; to [10.244.1.3:53]<br>I1027 22:14:54.038209    5063 proxier.go:352] Setting endpoints for &quot;default/kubernetes:https&quot; to [10.240.0.2:443]<br>I1027 22:14:54.038238    5063 proxier.go:429] Not syncing iptables until Services and Endpoints have been received from master<br>I1027 22:14:54.040048    5063 proxier.go:294] Adding new service &quot;default/kubernetes:https&quot; at 10.0.0.1:443/TCP<br>I1027 22:14:54.040154    5063 proxier.go:294] Adding new service &quot;kube-system/kube-dns:dns&quot; at 10.0.0.10:53/UDP<br>I1027 22:14:54.040223    5063 proxier.go:294] Adding new service &quot;kube-system/kube-dns:dns-tcp&quot; at 10.0.0.10:53/TCP<br></code></pre></td></tr></table></figure><h3 id="5-4、检查宿主机iptables规则">5.4、检查宿主机iptables规则</h3><p>如果 kube-proxy 一切正常，就应该仔细查看宿主机上的 iptables 了。而一个 iptables 模式的 Service 对应的规则包括：</p><ul><li>KUBE-SERVICES 或者 KUBE-NODEPORTS 规则对应的 Service 的入口链，这个规则应该与 VIP 和 Service 端口一一对应；</li><li>KUBE-SEP-(hash) 规则对应的是 DNAT 链，这些规则应该与 Endpoints 一一对应；</li><li>KUBE-SVC-(hash) 规则对应的是负载均衡链，这些规则的数目应该与 Endpoints 数目一致；</li><li>如果是 NodePort 模式的话，还有 POSTROUTING 处的 SNAT 链。</li></ul><p>通过查看这些链的数量、转发目的地址、端口、过滤条件等信息，就能很容易发现一些异常的蛛丝马迹。</p><h3 id="5-5、检查hairpin-mode">5.5、检查hairpin-mode</h3><p>当然，还有一种典型问题，就是 Pod 没办法通过 Service 访问到自己。这往往就是因为 kubelet 的 hairpin-mode 没有被正确设置。此时，只需要确保将 kubelet 的 hairpin-mode 设置为 hairpin-veth 或者 promiscuous-bridge 即可。</p><p>在 hairpin-veth 模式下，我们应该能看到 CNI 网桥对应的各个 VETH 设备，都将 Hairpin 模式设置为了 1，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> /sys/devices/virtual/net/cni0/brif/veth*/hairpin_mode; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$d</span> = <span class="hljs-subst">$(cat $d)</span>&quot;</span>; <span class="hljs-keyword">done</span></span><br>/sys/devices/virtual/net/cni0/brif/veth4bfbfe74/hairpin_mode = 1<br>/sys/devices/virtual/net/cni0/brif/vethfc2a18c5/hairpin_mode = 1<br></code></pre></td></tr></table></figure><p>而如果是 promiscuous-bridge 模式的话，我们应该看到 CNI 网桥的混杂模式（PROMISC）被开启，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ifconfig cni0 |grep PROMISC</span><br>UP BROADCAST RUNNING PROMISC MULTICAST  MTU:1460  Metric:1<br></code></pre></td></tr></table></figure><h2 id="六、小结">六、小结</h2><p>在这篇文章中，我们主要讨论了如下内容：</p><ul><li><p>Kubernetes提供了多种供集群外部访问的方式，包括NodePort模式、LoadBalancer模式、ExternalName模式以及ExternalIP模式。</p></li><li><p>Service NodePort模式的工作原理与clusterIP模式类似，不同之处在于，nodePort模式会在宿主机上为Service对象分配一个端口。集群外部的用户通过访问宿主机上的这个端口就能访问到Pod。</p></li><li><p>Service LoadBalancer模式适用于公有云提供的Kubernetes服务。当使用该类型的Service对象时，kubernetes会调用公有云的API，创建出相应的负载均衡服务。</p></li><li><p>Service ExternalName模式会在kube-dns中为Service的域名添加一条CNAME记录。</p></li><li><p>Service ExternalIP模式可以让我们为Service对象指定一个公有IP地址。</p></li><li><p>Service是由kube-dns、kube-proxy和iptables共同实现的。当Service无法被访问时，应该依次对他们进行检查。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器网络6：Service、DNS与服务发现</title>
    <link href="/2020/10/07/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C6%EF%BC%9AService%E3%80%81DNS%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    <url>/2020/10/07/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C6%EF%BC%9AService%E3%80%81DNS%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们讨论了kubernetes的“连通性”和“隔离性”。接下来，我们重点讨论一下一个Pod是如何被访问到的？</p><h2 id="一、理解Service-ClusterIP模式">一、理解Service ClusterIP模式</h2><p>Kubernetes 之所以需要 Service 对象，一方面是因为 Pod 的 IP 不是固定的，另一方面则是因为一组 Pod 实例之间总会有负载均衡的需求。</p><h3 id="1-1、创建Service">1.1、创建Service</h3><p>一个最典型的 Service 定义，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hostnames</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">hostnames</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">default</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span><br></code></pre></td></tr></table></figure><p>在这个 Service 中，使用了 selector 字段来声明这个 Service 只代理携带了 app=hostnames 标签的 Pod。并且，这个 Service 的 80 端口，代理的是 Pod 的 9376 端口。</p><h3 id="1-2、创建Deployment">1.2、创建Deployment</h3><p>然后，创建应用的 Deployment，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hostnames</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">hostnames</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">hostnames</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hostnames</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">k8s.gcr.io/serve_hostname</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">9376</span><br>          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br></code></pre></td></tr></table></figure><p>这个应用的作用，就是每次访问 9376 端口时，返回它自己的 hostname。</p><h3 id="1-3、查看Service的Endpoints">1.3、查看Service的Endpoints</h3><p>Service 的 selector 所选中的 Pod，被称为 Service 的 Endpoints，我们可以使用 kubectl get ep 命令看到它们，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get endpoints hostnames</span><br>NAME        ENDPOINTS<br>hostnames   10.244.0.5:9376,10.244.0.6:9376,10.244.0.7:9376<br></code></pre></td></tr></table></figure><p>需要注意的是，只有处于 Running 状态，且 readinessProbe 检查通过的 Pod，才会出现在 Service 的 Endpoints 列表里。并且，当某一个 Pod 出现问题时，Kubernetes 会自动把它从 Service 里摘除掉。</p><h3 id="1-4、访问Service">1.4、访问Service</h3><p>此时，通过该 Service 的 VIP 地址 10.0.1.175，我们就可以访问到它所代理的 Pod 了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc hostnames</span><br>NAME        TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE<br>hostnames   ClusterIP   10.0.1.175   &lt;none&gt;        80/TCP    5s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 10.0.1.175:80</span><br>hostnames-0uton<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 10.0.1.175:80</span><br>hostnames-yp2kp<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 10.0.1.175:80</span><br>hostnames-bvc05<br></code></pre></td></tr></table></figure><p>这个 VIP 地址是 Kubernetes 自动为 Service 分配的。而像上面这样，通过三次连续不断地访问 Service 的 VIP 地址和代理端口 80，它就为我们依次返回了三个 Pod 的 hostname。这也正印证了 Service 提供的是 Round Robin 方式的负载均衡。对于这种方式，我们称为：ClusterIP 模式的 Service。</p><h2 id="二、Service的工作原理">二、Service的工作原理</h2><blockquote><p>Kubernetes 里的 Service 究竟是如何工作的呢？</p></blockquote><p>实际上，Service 是由 kube-proxy 组件，加上 iptables 来共同实现的。</p><h3 id="2-1、KUBE-SERVICES规则">2.1、KUBE-SERVICES规则</h3><p>举个例子，对于我们前面创建的名叫 hostnames 的 Service 来说，一旦它被提交给 Kubernetes，那么 kube-proxy 就可以通过 Service 的 Informer 感知到这样一个 Service 对象的添加。而作为对这个事件的响应，它就会在宿主机上创建这样一条 iptables 规则（可以通过 iptables-save 看到它），如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-A KUBE-SERVICES -d 10.0.1.175/32 -p tcp -m comment --comment &quot;default/hostnames: cluster IP&quot; -m tcp --dport 80 -j KUBE-SVC-NWV5X2332I4OT4T3<br></code></pre></td></tr></table></figure><p>可以看到，这条 iptables 规则的含义是：凡是目的地址是 10.0.1.175、目的端口是 80 的 IP 包，都应该跳转到另外一条名叫 KUBE-SVC-NWV5X2332I4OT4T3 的 iptables 链进行处理。</p><p>而我们前面已经看到，10.0.1.175 正是这个 Service 的 VIP。所以这一条规则，为这个 Service 设置了一个固定的入口地址。并且，由于 10.0.1.175 只是一条 iptables 规则上的配置，并没有真正的网络设备，所以我们ping 这个地址，是不会有任何响应的。</p><h3 id="2-2、KUBE-SVC-规则">2.2、KUBE-SVC-*规则</h3><p>那么，即将跳转到的 KUBE-SVC-NWV5X2332I4OT4T3 规则，又有什么作用呢？实际上，它是一组规则的集合，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-WNBA2IHDGP2BOBGZ<br>-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-X3P2623AGDH6CDF3<br>-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -j KUBE-SEP-57KPRZ3JQVENLNBR<br></code></pre></td></tr></table></figure><p>可以看到，这一组规则，实际上是一组随机模式（–mode random）的 iptables 链。</p><p>而随机转发的目的地，分别是 KUBE-SEP-WNBA2IHDGP2BOBGZ、KUBE-SEP-X3P2623AGDH6CDF3 和 KUBE-SEP-57KPRZ3JQVENLNBR。而这三条链指向的最终目的地，其实就是这个 Service 代理的三个 Pod。所以这一组规则，就是 Service 实现负载均衡的位置。</p><p>需要注意的是，iptables 规则的匹配是从上到下逐条进行的，所以为了保证上述三条规则每条被选中的概率都相同，我们应该将它们的 probability 字段的值分别设置为 1/3（0.333…）、1/2 和 1。</p><p>这么设置的原理很简单：第一条规则被选中的概率就是 1/3；而如果第一条规则没有被选中，那么这时候就只剩下两条规则了，所以第二条规则的 probability 就必须设置为 1/2；类似地，最后一条就必须设置为 1。</p><h3 id="2-3、KUBE-SEP-规则">2.3、KUBE-SEP-*规则</h3><p>通过查看上述三条链的明细，我们就很容易理解 Service 进行转发的具体原理了，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">-A KUBE-SEP-57KPRZ3JQVENLNBR -s 10.244.3.6/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000<br>-A KUBE-SEP-57KPRZ3JQVENLNBR -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.3.6:9376<br><br>-A KUBE-SEP-WNBA2IHDGP2BOBGZ -s 10.244.1.7/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000<br>-A KUBE-SEP-WNBA2IHDGP2BOBGZ -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.1.7:9376<br><br>-A KUBE-SEP-X3P2623AGDH6CDF3 -s 10.244.2.3/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000<br>-A KUBE-SEP-X3P2623AGDH6CDF3 -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.2.3:9376<br></code></pre></td></tr></table></figure><p>可以看到，这三条链，其实是三条 DNAT 规则。但在 DNAT 规则之前，iptables 对流入的 IP 包还设置了一个“标志”（–set-xmark）。其中，DNAT 规则的作用，就是在 PREROUTING 检查点之前，也就是在路由之前，将流入的 IP 包的目的地址和端口，改成–to-destination 所指定的新的目的地址和端口。可以看到，这个目的地址和端口，正是被代理 Pod 的 IP 地址和端口。</p><p>这样，访问 Service VIP 的 IP 包经过上述 iptables 处理之后，就已经变成了访问具体某一个后端 Pod 的 IP 包了。不难理解，这些 Endpoints 对应的 iptables 规则，正是 kube-proxy 通过监听 Pod 的变化事件，在宿主机上生成并维护的。</p><p>以上，就是 Service 最基本的工作原理。</p><h2 id="三、IPVS模式">三、IPVS模式</h2><p>此外，Kubernetes 的 kube-proxy 还支持一种叫作 IPVS 的模式。这又是怎么一回事儿呢？</p><h3 id="3-1、iptables模式存在的问题">3.1、iptables模式存在的问题</h3><p>其实，通过上面的讲解，可以看到，kube-proxy 通过 iptables 处理 Service 的过程，其实需要在宿主机上设置相当多的 iptables 规则。而且，kube-proxy 还需要在控制循环里不断地刷新这些规则来确保它们始终是正确的。</p><p>不难想到，当宿主机上有大量 Pod 的时候，成百上千条 iptables 规则不断地被刷新，会大量占用该宿主机的 CPU 资源，甚至会让宿主机“卡”在这个过程中。所以说，一直以来，基于 iptables 的 Service 实现，都是制约 Kubernetes 项目承载更多量级的 Pod 的主要障碍。</p><p>而 IPVS 模式的 Service，就是解决这个问题的一个行之有效的方法。</p><h3 id="3-2、IPVS的工作原理">3.2、IPVS的工作原理</h3><h4 id="3-2-1、创建虚拟网卡">3.2.1、创建虚拟网卡</h4><p>IPVS 模式的工作原理，其实跟 iptables 模式类似。当我们创建了前面的 Service 之后，kube-proxy 首先会在宿主机上创建一个虚拟网卡（叫作：kube-ipvs0），并为它分配 Service VIP 作为 IP 地址，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ip addr</span><br>  ...<br>  73：kube-ipvs0：&lt;BROADCAST,NOARP&gt;  mtu 1500 qdisc noop state DOWN qlen 1000<br>  link/ether  1a:ce:f5:5f:c1:4d brd ff:ff:ff:ff:ff:ff<br>  inet 10.0.1.175/32  scope global kube-ipvs0<br>  valid_lft forever  preferred_lft forever<br></code></pre></td></tr></table></figure><h4 id="3-2-2、设置虚拟主机">3.2.2、设置虚拟主机</h4><p>而接下来，kube-proxy 就会通过 Linux 的 IPVS 模块，为这个 IP 地址设置三个 IPVS 虚拟主机，并设置这三个虚拟主机之间使用轮询模式 (rr) 来作为负载均衡策略。我们可以通过 ipvsadm 查看到这个设置，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ipvsadm -<span class="hljs-built_in">ln</span></span><br> IP Virtual Server version 1.2.1 (size=4096)<br>  Prot LocalAddress:Port Scheduler Flags<br>    -&gt;  RemoteAddress:Port           Forward  Weight ActiveConn InActConn     <br>  TCP  10.102.128.4:80 rr<br>    -&gt;  10.244.3.6:9376    Masq    1       0          0         <br>    -&gt;  10.244.1.7:9376    Masq    1       0          0<br>    -&gt;  10.244.2.3:9376    Masq    1       0          0<br></code></pre></td></tr></table></figure><p>可以看到，这三个 IPVS 虚拟主机的 IP 地址和端口，对应的正是三个被代理的 Pod。</p><p>这时候，任何发往 10.102.128.4:80 的请求，就都会被 IPVS 模块转发到某一个后端 Pod 上了。</p><h3 id="3-3、小结">3.3、小结</h3><p>相比于 iptables，IPVS 在内核中的实现其实也是基于 Netfilter 的 NAT 模式，所以在转发这一层上，理论上 IPVS 并没有显著的性能提升。但是，IPVS 并不需要在宿主机上为每个 Pod 设置 iptables 规则，而是把对这些“规则”的处理放到了内核态，从而极大地降低了维护这些规则的代价。这也正印证了我在前面提到过的，“将重要操作放入内核态”是提高性能的重要手段。</p><p>不过需要注意的是，IPVS 模块只负责上述的负载均衡和代理功能。而一个完整的 Service 流程正常工作所需要的包过滤、SNAT 等操作，还是要靠 iptables 来实现。只不过，这些辅助性的 iptables 规则数量有限，也不会随着 Pod 数量的增加而增加。</p><p>所以，在大规模集群里，非常建议为 kube-proxy 设置–proxy-mode=ipvs 来开启这个功能。它为 Kubernetes 集群规模带来的提升，还是非常巨大的。</p><h2 id="四、Service-DNS">四、Service &amp; DNS</h2><p>在 Kubernetes 中，Service 和 Pod 都会被分配对应的 DNS A 记录（从域名解析到 IP 的记录）。</p><h3 id="4-1、Service-ClusterIP-Headless-Service">4.1、Service ClusterIP &amp; Headless Service</h3><p>对于 ClusterIP 模式的 Service 来说（比如我们上面的例子），它的 A 记录的格式是：…svc.cluster.local。当我们访问这条 A 记录的时候，它解析到的就是该 Service 的 VIP 地址。</p><p>而对于指定了 clusterIP=None 的 Headless Service 来说，它的 A 记录的格式也是：…svc.cluster.local。但是，当我们访问这条 A 记录的时候，它返回的是所有被代理的 Pod 的 IP 地址的集合。当然，如果我们的客户端没办法解析这个集合的话，它可能会只会拿到第一个 Pod 的 IP 地址。</p><h3 id="4-2、Service-下的Pod">4.2、Service 下的Pod</h3><p>此外，对于 ClusterIP 模式的 Service 来说，它代理的 Pod 被自动分配的 A 记录的格式是：…pod.cluster.local。这条记录指向 Pod 的 IP 地址。</p><p>而对 Headless Service 来说，它代理的 Pod 被自动分配的 A 记录的格式是：…svc.cluster.local。这条记录也指向 Pod 的 IP 地址。</p><p>但如果我们为 Pod 指定了 Headless Service，并且 Pod 本身声明了 hostname 和 subdomain 字段，那么这时候 Pod 的 A 记录就会变成：&lt;pod 的 hostname&gt;…svc.cluster.local，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">apiVersion: v1<br>kind: Service<br>metadata:<br>  name: default-subdomain<br>spec:<br>  selector:<br>    name: busybox<br>  clusterIP: None<br>  ports:<br>  - name: foo<br>    port: 1234<br>    targetPort: 1234<br>---<br>apiVersion: v1<br>kind: Pod<br>metadata:<br>  name: busybox1<br>  labels:<br>    name: busybox<br>spec:<br>  hostname: busybox-1<br>  subdomain: default-subdomain<br>  containers:<br>  - image: busybox<br>    command:<br>      - sleep<br>      - &quot;3600&quot;<br>    name: busybox<br></code></pre></td></tr></table></figure><p>在上面这个 Service 和 Pod 被创建之后，你就可以通过 busybox-1.default-subdomain.default.svc.cluster.local 解析到这个 Pod 的 IP 地址了。</p><p>需要注意的是，在 Kubernetes 里，/etc/hosts 文件是单独挂载的，这也是为什么 kubelet 能够对 hostname 进行修改并且 Pod 重建后依然有效的原因。这跟 Docker 的 Init 层是一个原理。</p><h2 id="五、小结">五、小结</h2><p>在这篇文章中，我们主要讨论了如下概念：</p><ul><li>Service ClusterIP模式会为Servic对象分配一个稳定的IP地址，即VIP；而被Service的selector所选中的Pod会成为Service对象的Endpoint。当访问Service VIP时，就能访问到它所代理的Pod。</li><li>Service实际上是由kube-proxy和iptables共同实现的。当有Service对象被提交时，kube-proxy就会在宿主机上创建出相应的iptables规则。</li><li>在大规模集群中，kube-proxy可能需要维护成百上千条iptables规则，而这往往会导致性能瓶颈。此时，可以考虑使用ipvs模式，将大量的负载均衡和代理需求，交由内核处理。</li><li>Kubernetes会为Service和Pod对象生成相应的DNS A记录。在Service ClusterIP模式下，Service对象的A记录格式为：…svc.cluster.local，它所解析的地址就是Service VIP；Pod对象的A记录格式为：…pod.cluster.local，它所解析的地址就是Pod的IP地址。在Headless Service模式下，Service对象的A记录格式也是：…svc.cluster.local，但它所解析的地址是所代理Pod的IP集合；Pod对象的A记录格式为：…svc.cluster.local。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器网络5：NetworkPolicy</title>
    <link href="/2020/10/07/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C5%EF%BC%9ANetworkPolicy/"/>
    <url>/2020/10/07/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C5%EF%BC%9ANetworkPolicy/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们讨论了Kubernetes的网络“连通性”。接下来，我们重点讨论Kubernetes网络的“隔离性”。</p><h2 id="一、NetworkPolicy对象">一、NetworkPolicy对象</h2><h3 id="1-1、什么是NetworkPolicy">1.1、什么是NetworkPolicy</h3><p>在 Kubernetes 中，对网络隔离能力的定义，是依靠一种专门的 API 对象来描述的，即：NetworkPolicy。</p><p>Kubernetes 里的 Pod 默认都是“允许所有”（Accept All）的，即：Pod 可以接收来自任何发送方的请求；或者，向任何接收方发送请求。而如果我们要对这个情况作出限制，就必须通过 NetworkPolicy 对象来指定。</p><p>一旦 Pod 被某个 NetworkPolicy 选中，那么这个 Pod 就会进入“拒绝所有（Deny All）”的状态，即：这个 Pod 既不允许被外界随意访问，也不允许随意对外界发起访问，只能按“规则”行动。NetworkPolicy 定义的规则，其实就是“白名单”。</p><h3 id="1-2、定义NetworkPolicy">1.2、定义NetworkPolicy</h3><p>一个完整的 NetworkPolicy 对象的示例，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">NetworkPolicy</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-network-policy</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">podSelector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">role:</span> <span class="hljs-string">db</span><br>  <span class="hljs-attr">policyTypes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Ingress</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Egress</span><br>  <span class="hljs-attr">ingress:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">from:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">ipBlock:</span><br>        <span class="hljs-attr">cidr:</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">/16</span><br>        <span class="hljs-attr">except:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">172.17</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span><span class="hljs-string">/24</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">namespaceSelector:</span><br>        <span class="hljs-attr">matchLabels:</span><br>          <span class="hljs-attr">project:</span> <span class="hljs-string">myproject</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">podSelector:</span><br>        <span class="hljs-attr">matchLabels:</span><br>          <span class="hljs-attr">role:</span> <span class="hljs-string">frontend</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>  <span class="hljs-attr">egress:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">to:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">ipBlock:</span><br>        <span class="hljs-attr">cidr:</span> <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">/24</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">5978</span><br></code></pre></td></tr></table></figure><p>在上面这个例子里，我们首先会看到 podSelector 字段。它的作用，就是定义这个 NetworkPolicy 的限制范围，比如：当前 Namespace 里携带了 role=db 标签的 Pod。而如果我们把 podSelector 字段留空：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br> <span class="hljs-attr">podSelector:</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>那么这个 NetworkPolicy 就会作用于当前 Namespace 下的所有 Pod。</p><h3 id="1-3、理解NetworkPolicy的定义">1.3、理解NetworkPolicy的定义</h3><p>在上面的例子中，我们在 policyTypes 字段，定义了这个 NetworkPolicy 的类型是 ingress 和 egress，即：它既会影响流入（ingress）请求，也会影响流出（egress）请求。</p><p>然后，在 ingress 字段里，我们定义了 from 和 ports，即：允许流入的“白名单”和端口。其中，在这个允许流入的“白名单”里，我们指定了三种并列的情况，分别是：ipBlock、namespaceSelector 和 podSelector。</p><p>而在 egress 字段里，我们则定义了 to 和 ports，即：允许流出的“白名单”和端口。这里允许流出的“白名单”的定义方法与 ingress 类似。只不过，这一次 ipblock 字段指定的，是目的地址的网段。</p><p>而这个 NetworkPolicy 对象，指定的隔离规则是这样的：</p><ul><li>该隔离规则只对 default Namespace 下的，携带了 role=db 标签的 Pod 有效。限制的请求类型包括 ingress（流入）和 egress（流出）。</li><li>Kubernetes 会拒绝任何访问被隔离 Pod 的请求，除非这个请求是来自于以下“白名单”里的对象，并且访问的是被隔离 Pod 的 6379 端口。这些“白名单”对象包括：<ul><li>default Namespace 里的，携带了 role=fronted 标签的 Pod；</li><li>携带project=myproject 标签的 Namespace 里的任何 Pod；</li><li>任何源地址属于 172.17.0.0/16 网段，且不属于 172.17.1.0/24 网段的请求。</li></ul></li><li>Kubernetes 会拒绝被隔离 Pod 对外发起任何请求，除非请求的目的地址属于 10.0.0.0/24 网段，并且访问的是该网段地址的 5978 端口。</li></ul><h3 id="1-4、编写NetworkPolicy时的注意点">1.4、编写NetworkPolicy时的注意点</h3><p>需要注意的是，定义一个 NetworkPolicy 对象的过程，容易犯错的是“白名单”部分（from 和 to 字段）。举个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">...</span><br><span class="hljs-attr">ingress:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">from:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">namespaceSelector:</span><br>      <span class="hljs-attr">matchLabels:</span><br>        <span class="hljs-attr">user:</span> <span class="hljs-string">alice</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">podSelector:</span><br>      <span class="hljs-attr">matchLabels:</span><br>        <span class="hljs-attr">role:</span> <span class="hljs-string">client</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>像上面这样定义的 namespaceSelector 和 podSelector，是“或”（OR）的关系。所以说，这个 from 字段定义了两种情况，无论是 Namespace 满足条件，还是 Pod 满足条件，这个 NetworkPolicy 都会生效。</p><p>而下面这个例子，虽然看起来类似，但是它定义的规则却完全不同：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">...</span><br>  <span class="hljs-attr">ingress:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">from:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">namespaceSelector:</span><br>        <span class="hljs-attr">matchLabels:</span><br>          <span class="hljs-attr">user:</span> <span class="hljs-string">alice</span><br>      <span class="hljs-attr">podSelector:</span><br>        <span class="hljs-attr">matchLabels:</span><br>          <span class="hljs-attr">role:</span> <span class="hljs-string">client</span><br>  <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>注意看，这样定义的 namespaceSelector 和 podSelector，其实是“与”（AND）的关系。所以说，这个 from 字段只定义了一种情况，只有 Namespace 和 Pod 同时满足条件，这个 NetworkPolicy 才会生效。</p><p>这两种定义方式的区别，一定要分清楚。</p><h3 id="1-5、NetworkPolicy的依赖">1.5、NetworkPolicy的依赖</h3><p>此外，如果要使上面定义的 NetworkPolicy 在 Kubernetes 集群里真正产生作用，我们的 CNI 网络插件就必须是支持 Kubernetes 的 NetworkPolicy 的。</p><p>在具体实现上，凡是支持 NetworkPolicy 的 CNI 网络插件，都维护着一个 NetworkPolicy Controller，通过控制循环的方式对 NetworkPolicy 对象的增删改查做出响应，然后在宿主机上完成 iptables 规则的配置工作。</p><p>在 Kubernetes 生态里，目前已经实现了 NetworkPolicy 的网络插件包括 Calico、Weave 和 kube-router 等多个项目，但是并不包括 Flannel 项目。所以说，如果想要在使用 Flannel 的同时还使用 NetworkPolicy 的话，我们就需要再额外安装一个网络插件，比如 Calico 项目，来负责执行 NetworkPolicy。</p><h2 id="二、理解Iptables">二、理解Iptables</h2><blockquote><p>此时，我们可能会好奇，网络插件是如何根据 NetworkPolicy 对 Pod 进行隔离的？</p></blockquote><p>在回答这个问题之前，我们先来理解一下iptables的工作原理。</p><h3 id="2-1、Netfilter是什么">2.1、Netfilter是什么</h3><p>实际上，iptables 只是一个操作 Linux 内核 Netfilter 子系统的“界面”。顾名思义，Netfilter 子系统的作用，就是 Linux 内核里挡在“网卡”和“用户态进程”之间的一道“防火墙”。它们的关系，可以用如下的示意图来表示：</p><p><img src="/img/image-20201007114257452.png" alt="image-20201007114257452"></p><p>可以看到，这幅示意图中，IP 包“一进一出”的两条路径上，有几个关键的“检查点”，它们正是 Netfilter 设置“防火墙”的地方。在 iptables 中，这些“检查点”被称为：链（Chain）。这是因为这些“检查点”对应的 iptables 规则，是按照定义顺序依次进行匹配的。</p><h3 id="2-2、Netfilter的工作原理">2.2、Netfilter的工作原理</h3><p>Netfilter的具体工作原理，可以用如下所示的示意图来描述：</p><p><img src="/img/image-20201007114403525.png" alt="image-20201007114403525"></p><p>当一个 IP 包通过网卡进入主机之后，它就进入了 Netfilter 定义的流入路径（Input Path）里。</p><p>在这个路径中，IP 包要经过路由表路由来决定下一步的去向。而在路由之前，Netfilter 设置了一个名叫 PREROUTING 的“检查点”。经过路由之后，IP 包的去向可以分为两种：</p><ul><li><p>第一种，继续在本机处理；</p></li><li><p>第二种，被转发到其他目的地。</p></li></ul><p>注：在 Linux 内核的实现里，所谓“检查点”实际上就是内核网络协议栈代码里的 Hook（比如，在执行路由判断的代码之前，内核会先调用 PREROUTING 的 Hook）。</p><h4 id="2-2-1、第一种去向">2.2.1、第一种去向</h4><p>我们先说一下 IP 包的第一种去向。这时候，IP 包将继续向上层协议栈流动。在进入传输层之前，Netfilter 会设置一个名叫 INPUT 的“检查点”。到这里，IP 包流入路径（Input Path）结束。</p><p>接下来，这个 IP 包通过传输层进入用户空间，交给用户进程处理。而处理完成后，用户进程会通过本机发出返回的 IP 包。这时候，这个 IP 包就进入了流出路径（Output Path）。</p><p>此时，IP 包首先还是会经过主机的路由表进行路由。路由结束后，Netfilter 就会设置一个名叫 OUTPUT 的“检查点”。然后，在 OUTPUT 之后，再设置一个名叫 POSTROUTING“检查点”。</p><blockquote><p>这里，我们可能会奇怪，为什么在流出路径结束后，Netfilter 会连着设置两个“检查点”呢？</p></blockquote><p>这就要说到在流入路径里，路由判断后的第二种去向了。</p><h4 id="2-2-2、第二种去向">2.2.2、第二种去向</h4><p>在这种情况下，这个 IP 包不会进入传输层，而是会继续在网络层流动，从而进入到转发路径（Forward Path）。在转发路径中，Netfilter 会设置一个名叫 FORWARD 的“检查点”。</p><p>而在 FORWARD“检查点”完成后，IP 包就会来到流出路径。而转发的 IP 包由于目的地已经确定，它就不会再经过路由，也自然不会经过 OUTPUT，而是会直接来到 POSTROUTING“检查点”。</p><p>所以说，POSTROUTING 的作用，其实就是上述两条路径，最终汇聚在一起的“最终检查点”。</p><h3 id="2-3、Netfilter完整的流程图">2.3、Netfilter完整的流程图</h3><p>需要注意的是，在有网桥参与的情况下，上述 Netfilter 设置“检查点”的流程，实际上也会出现在链路层（二层），并且会跟网络层（三层）的流程有交互。而这些链路层的“检查点”对应的操作界面叫作 ebtables。</p><p>所以，准确地说，数据包在 Linux Netfilter 子系统里完整的流动过程，其实应该如下所示（这是一幅来自Netfilter 官方的原理图）：</p><p><img src="/img/image-20201007115517875.png" alt="image-20201007115517875"></p><p>可以看到，我们前面讲述的，正是上图中绿色部分，也就是网络层的 iptables 链的工作流程。</p><p>另外，我们应该还能看到，每一个白色的“检查点”上，还有一个绿色的“标签”，比如：raw、nat、filter 等等。在 iptables 里，这些标签叫作：表。比如，同样是 OUTPUT 这个“检查点”，filter Output 和 nat Output 在 iptables 里的语法和参数，就完全不一样，实现的功能也完全不同。</p><p>所以说，iptables 表的作用，就是在某个具体的“检查点”（比如 Output）上，按顺序执行几个不同的检查动作（比如，先执行 nat，再执行 filter）。</p><h2 id="三、NetworkPolicy的工作原理">三、NetworkPolicy的工作原理</h2><p>在理解了iptables的工作原理后，接下来，我们就以三层网络插件为例（比如 Calico），来分析一下NetworkPolicy 的原理。</p><h3 id="3-1、编写NetworkPolicy-对象">3.1、编写NetworkPolicy 对象</h3><p>为了方便讲解，这一次我们编写了一个比较简单的 NetworkPolicy 对象，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">NetworkPolicy</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-network-policy</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">podSelector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">role:</span> <span class="hljs-string">db</span><br>  <span class="hljs-attr">ingress:</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-attr">from:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-attr">namespaceSelector:</span><br>         <span class="hljs-attr">matchLabels:</span><br>           <span class="hljs-attr">project:</span> <span class="hljs-string">myproject</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-attr">podSelector:</span><br>         <span class="hljs-attr">matchLabels:</span><br>           <span class="hljs-attr">role:</span> <span class="hljs-string">frontend</span><br>     <span class="hljs-attr">ports:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">tcp</span><br>         <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><p>可以看到，我们指定的 ingress“白名单”，是携带 project=myproject 标签的Namespace 里的任意Pod；以及 default Namespace 里，携带了 role=frontend 标签的 Pod。允许被访问的端口是6379，协议为TCP。而被隔离的对象，是default Namespace 里所有携带了 role=db 标签的 Pod。</p><h3 id="3-2、生成对应的iptables规则">3.2、生成对应的iptables规则</h3><p>创建NetworkPolicy对象后，Kubernetes 的网络插件就会使用这个 NetworkPolicy 的定义，在宿主机上生成 iptables 规则。这个过程，我们可以通过如下所示的一段 Go 语言风格的伪代码来描述：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> dstIP := <span class="hljs-keyword">range</span> 所有被networkpolicy.spec.podSelector选中的Pod的IP地址<br>  <span class="hljs-keyword">for</span> srcIP := <span class="hljs-keyword">range</span> 所有被ingress.from.podSelector选中的Pod的IP地址<br>    <span class="hljs-keyword">for</span> port, protocol := <span class="hljs-keyword">range</span> ingress.ports &#123;<br>      iptables -A KUBE-NWPLCY-CHAIN -s $srcIP -d $dstIP -p $protocol -m $protocol --dport $port -j ACCEPT <br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这是一条最基本的、通过匹配条件决定下一步动作的 iptables 规则。</p><p>这条规则的名字是 KUBE-NWPLCY-CHAIN，其含义是：当 IP 包的源地址是 srcIP、目的地址是 dstIP、协议是 protocol、目的端口是 port 的时候，就允许它通过（ACCEPT）。而正如这段伪代码所示，匹配这条规则所需的这四个参数，都是从 NetworkPolicy 对象里读取出来的。</p><p>由此可以看出，Kubernetes 网络插件对 Pod 进行隔离，其实是靠在宿主机上生成 NetworkPolicy 对应的 iptable 规则来实现的。</p><h3 id="3-3、转发对被隔离Pod的请求">3.3、转发对被隔离Pod的请求</h3><p>在设置好上述“隔离”规则之后，网络插件还需要想办法，将所有对被隔离 Pod 的访问请求，都转发到上述 KUBE-NWPLCY-CHAIN 规则上去进行匹配。并且，如果匹配不通过，这个请求应该被“拒绝”。而在CNI 网络插件中，这个需求可以通过设置两组 iptables 规则来实现。</p><p>第一组规则，负责“拦截”对被隔离 Pod 的访问请求。生成这一组规则的伪代码，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> pod := <span class="hljs-keyword">range</span> 该Node上的所有Pod &#123;<br>    <span class="hljs-keyword">if</span> pod是networkpolicy.spec.podSelector选中的 &#123;<br>        iptables -A FORWARD -d $podIP -m physdev --physdev-is-bridged -j KUBE-POD-SPECIFIC-FW-CHAIN<br>        iptables -A FORWARD -d $podIP -j KUBE-POD-SPECIFIC-FW-CHAIN<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这里的的 iptables 规则使用到了内置链：FORWARD。它是什么意思呢？</p><ul><li><p>第一条 FORWARD 链“拦截”的是一种特殊情况：它对应的是同一台宿主机上容器之间经过 CNI 网桥进行通信的流入数据包。其中，–physdev-is-bridged 的意思就是，这个 FORWARD 链匹配的是，通过本机上的网桥设备，发往目的地址是 podIP 的 IP 包。当然，如果是像 Calico 这样的非网桥模式的 CNI 插件，就不存在这个情况了。而kube-router 其实是一个简化版的 Calico，它也使用 BGP 来维护路由信息，但是使用 CNI bridge 插件负责跟 Kubernetes 进行交互。</p></li><li><p>第二条 FORWARD 链“拦截”的则是最普遍的情况，即：容器跨主机通信。这时候，流入容器的数据包都是经过路由转发（FORWARD 检查点）来的。不难看到，这些规则最后都跳转（即：-j）到了名叫 KUBE-POD-SPECIFIC-FW-CHAIN 的规则上。它正是网络插件为 NetworkPolicy 设置的第二组规则。</p></li></ul><p>第二组规则，也就是这个 KUBE-POD-SPECIFIC-FW-CHAIN ，它的作用就是做出“允许”或者“拒绝”的判断。这部分功能的实现，可以简单描述为下面这样的 iptables 规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">iptables -A KUBE-POD-SPECIFIC-FW-CHAIN -j KUBE-NWPLCY-CHAIN<br>iptables -A KUBE-POD-SPECIFIC-FW-CHAIN -j REJECT --reject-with icmp-port-unreachable<br></code></pre></td></tr></table></figure><p>可以看到，首先在第一条规则里，我们会把 IP 包转交给前面定义的 KUBE-NWPLCY-CHAIN 规则去进行匹配。按照我们之前的讲述，如果匹配成功，那么 IP 包就会被“允许通过”。</p><p>而如果匹配失败，IP 包就会来到第二条规则上。可以看到，它是一条 REJECT 规则。通过这条规则，不满足 NetworkPolicy 定义的请求就会被拒绝掉，从而实现了对该容器的“隔离”。</p><p>以上，就是 CNI 网络插件实现 NetworkPolicy 的基本方法了。当然，对于不同的插件来说，上述实现过程可能有不同的手段，但根本原理是不变的。</p><h2 id="五、小结">五、小结</h2><p>在这篇文章中，我们主要讨论了以下几个概念：</p><ul><li>Kubernetes的隔离机制是通过NetworkPolicy对象实现的；</li><li>NetworkPolicy其实就是宿主机上的一系列Iptables规则；</li><li>NetworkPolicy的工作原理是：首先，生成NetworkPolicy相应的动作规则；然后，生成“将对被隔离Pod的请求”转发到这些规则上的转发规则。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器网络4：解读Kubernetes三层网络方案</title>
    <link href="/2020/10/06/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C4%EF%BC%9A%E8%A7%A3%E8%AF%BBKubernetes%E4%B8%89%E5%B1%82%E7%BD%91%E7%BB%9C%E6%96%B9%E6%A1%88/"/>
    <url>/2020/10/06/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C4%EF%BC%9A%E8%A7%A3%E8%AF%BBKubernetes%E4%B8%89%E5%B1%82%E7%BD%91%E7%BB%9C%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们讨论了Flannel UDP模式和Flannel VXLAN模式这两种“隧道”网络解决方案。接下来，我们重点讨论Flannel host-gw模式和Calico这两种纯三层网络解决方案。</p><h2 id="一、Flannel-host-gw模式">一、Flannel host-gw模式</h2><p>Flannel host-gw 模式的工作原理非常简单，我们用一张图就可以说清楚。为了方便叙述，接下来我们会称这张图为“host-gw 示意图”。</p><p><img src="/img/image-20201006145928359.png" alt="image-20201006145928359"></p><p>现在假设，Node 1 上的 Infra-container-1，要访问 Node 2 上的 Infra-container-2。</p><h3 id="1-1、路由">1.1、路由</h3><p>当我们设置 Flannel 使用 host-gw 模式之后，flanneld 会在宿主机上创建这样一条规则，以 Node 1 为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip route</span><br>...<br>10.244.1.0/24 via 10.168.0.3 dev eth0<br></code></pre></td></tr></table></figure><p>这条路由规则的含义是：目的 IP 地址属于 10.244.1.0/24 网段的 IP 包，应该经过本机的 eth0 设备发出去（即：dev eth0）；并且，它的下一跳地址（next-hop）是 10.168.0.3（即：via 10.168.0.3）。</p><p>所谓下一跳地址，就是如果 IP 包从主机 A 发到主机 B，需要经过路由设备 X 的中转。那么 X 的 IP 地址就应该配置为主机 A 的下一跳地址。而从 host-gw 示意图中我们可以看到，这个下一跳地址对应的，正是我们的目的宿主机 Node 2。</p><h3 id="1-2、发送数据包">1.2、发送数据包</h3><p>一旦配置了下一跳地址，那么接下来，当 IP 包从网络层进入链路层封装成帧的时候，eth0 设备就会使用下一跳地址对应的 MAC 地址，作为该数据帧的目的 MAC 地址。显然，这个 MAC 地址，正是 Node 2 的 MAC 地址。这样，这个数据帧就会从 Node 1 通过宿主机的二层网络顺利到达 Node 2 上。</p><h3 id="1-3、接收数据包">1.3、接收数据包</h3><p>而 Node 2 的内核网络栈从二层数据帧里拿到 IP 包后，会“看到”这个 IP 包的目的 IP 地址是 10.244.1.3，即 Infra-container-2 的 IP 地址。这时候，根据 Node 2 上的路由表，该目的地址会匹配到第二条路由规则（也就是 10.244.1.0 对应的路由规则），从而进入 cni0 网桥，进而进入到 Infra-container-2 当中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip route</span><br>...<br>10.244.1.0/24 dev cni0 proto kernel scope link src 10.244.1.1<br></code></pre></td></tr></table></figure><h3 id="1-4、小结">1.4、小结</h3><p>可以看到，host-gw 模式的工作原理，其实就是将每个 Flannel 子网（Flannel Subnet，比如：10.244.1.0/24）的“下一跳”，设置成了该子网对应的宿主机的 IP 地址。也就是说，这台“主机”（Host）会充当这条容器通信路径里的“网关”（Gateway）。这也正是“host-gw”的含义。</p><p>当然，Flannel 子网和主机的信息，都是保存在 Etcd 当中的。flanneld 只需要 WACTH 这些数据的变化，然后实时更新路由表即可。</p><blockquote><p>需要注意的是：在 Kubernetes v1.7 之后，类似 Flannel、Calico 的 CNI 网络插件都是可以直接连接 Kubernetes 的 APIServer 来访问 Etcd 的，无需额外部署 Etcd 给它们使用。</p></blockquote><p>在这种模式下，容器通信的过程就免除了额外的封包和解包带来的性能损耗。根据实际的测试，host-gw 的性能损失大约在 10% 左右，而其他所有基于 VXLAN“隧道”机制的网络方案，性能损失都在 20%~30% 左右。</p><p>当然，通过上面的叙述，我们也应该看到，host-gw 模式能够正常工作的核心，就在于 IP 包在封装成帧发送出去的时候，会使用路由表里的“下一跳”来设置目的 MAC 地址。这样，它就会经过二层网络到达目的宿主机。</p><p>所以说，Flannel host-gw 模式必须要求集群宿主机之间是二层连通的。</p><p>需要注意的是，宿主机之间二层不连通的情况也是广泛存在的。比如，宿主机分布在了不同的子网（VLAN）里。但是，在一个 Kubernetes 集群里，宿主机之间必须可以通过 IP 地址进行通信，也就是说至少是三层可达的。否则的话，我们的集群将不满足宿主机之间 IP 互通的假设（Kubernetes 网络模型）。当然，“三层可达”也可以通过为几个子网设置三层转发来实现。</p><h2 id="二、Calico">二、Calico</h2><p>在容器生态中，要说到像 Flannel host-gw 这样的三层网络方案，我们就不得不提到这个领域里的“龙头老大”Calico 项目了。</p><h3 id="2-1、从BGP说起">2.1、从BGP说起</h3><p>Calico 项目提供的网络解决方案，与 Flannel 的 host-gw 模式，几乎是完全一样的。也就是说，Calico 也会在每台宿主机上，添加一个格式如下所示的路由规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;目的容器IP地址段&gt; via &lt;网关的IP地址&gt; dev eth0<br></code></pre></td></tr></table></figure><p>其中，网关的 IP 地址，正是目的容器所在宿主机的 IP 地址。</p><p>而正如前所述，这个三层网络方案得以正常工作的核心，是为每个容器的 IP 地址，找到它所对应的、“下一跳”的网关。不过，不同于 Flannel 项目通过 Etcd 和宿主机上的 flanneld 来维护路由信息的做法，Calico 项目使用了一个“重型武器”来自动地在整个集群中分发路由信息。这个“重型武器”，就是 BGP。</p><h4 id="2-1-1、什么是BGP">2.1.1、什么是BGP</h4><p>BGP 的全称是 Border Gateway Protocol，即：边界网关协议。它是一个 Linux 内核原生就支持的、专门用在大规模数据中心里维护不同的“自治系统”之间路由信息的、无中心的路由协议。</p><p>这个概念可能听起来有点儿“吓人”，但实际上，我们可以用一个非常简单的例子来讲清楚。</p><h4 id="2-1-2、边界网关">2.1.2、边界网关</h4><p><img src="/img/image-20201006150937380.png" alt="image-20201006150937380"></p><p>在上面的图中，我们有两个自治系统（Autonomous System，简称为 AS）：AS 1 和 AS 2。而所谓的一个自治系统，指的是一个组织管辖下的所有 IP 网络和路由器的全体。我们可以把它想象成一个小公司里的所有主机和路由器。</p><p>在正常情况下，自治系统之间不会有任何“来往”。但是，如果这样两个自治系统里的主机，要通过 IP 地址直接进行通信，我们就必须使用路由器把这两个自治系统连接起来。比如，AS 1 里面的主机 10.10.0.2，要访问 AS 2 里面的主机 172.17.0.2的话。它发出的 IP 包，就会先到达自治系统 AS 1 上的路由器 Router 1。</p><p>而在此时，Router 1 的路由表里，有这样一条规则，即：目的地址是 172.17.0.2 的包，应该经过 Router 1 的 C 接口，发往网关 Router 2（即：自治系统 AS 2 上的路由器）。所以 IP 包就会到达 Router 2 上，然后经过 Router 2 的路由表，从 A 接口出来到达目的主机 172.17.0.2。</p><p>但是反过来，如果主机 172.17.0.2要访问 10.10.0.2，那么这个 IP 包，在到达 Router 2 之后，就不知道该去哪儿了。因为在 Router 2 的路由表里，并没有关于 AS 1 自治系统的任何路由规则。所以这时候，网络管理员就应该给 Router 2 也添加一条路由规则，比如：目标地址是 10.10.0.2 的 IP 包，应该经过 Router 2 的 C 接口，发往网关 Router 1。</p><p>像上面这样负责把自治系统连接在一起的路由器，我们就把它形象地称为：边界网关。它跟普通路由器的不同之处在于，它的路由表里拥有其他自治系统里的主机路由信息（在普通路由器中一般是网络路由信息）。</p><h4 id="2-1-3、理解BGP">2.1.3、理解BGP</h4><p>上面的这部分原理，相信我们理解起来应该很容易。毕竟，路由器这个设备本身的主要作用，就是连通不同的网络。</p><p>但是，我们可以想象一下，假设我们现在的网络拓扑结构非常复杂，每个自治系统都有成千上万个主机、无数个路由器，甚至是由多个公司、多个网络提供商、多个自治系统组成的复合自治系统呢？这时候，如果还要依靠人工来对边界网关的路由表进行配置和维护，那是绝对不现实的。</p><p>而这种情况下，BGP 大显身手的时刻就到了。在使用了 BGP 之后，我们可以认为，在每个边界网关上都会运行着一个小程序，它们会将各自的路由表信息，通过 TCP 传输给其他的边界网关。而其他边界网关上的这个小程序，则会对收到的这些数据进行分析，然后将需要的信息添加到自己的路由表里。</p><p>这样，上图中 Router 2 的路由表里，就会自动出现 10.10.0.2 和 10.10.0.3 对应的路由规则了。</p><p>所以说，所谓 BGP，就是在大规模网络中实现节点路由信息共享的一种协议。而 BGP 的这个能力，正好可以取代 Flannel 维护主机上路由表的功能。而且，BGP 这种原生就是为大规模网络环境而实现的协议，其可靠性和可扩展性，远非 Flannel 方案可比。</p><p>需要注意的是，BGP 协议实际上是最复杂的一种路由协议。我们在这里的讲述和所举的例子，仅是为了能够帮助建立对 BGP 的感性认识，并不代表 BGP 真正的实现方式。</p><h3 id="2-2、Calico的工作原理">2.2、Calico的工作原理</h3><p>在了解了 BGP 之后，Calico 项目的工作原理就非常容易理解了。它由三个部分组成：</p><ul><li><p>Calico 的 CNI 插件。这是 Calico 与 Kubernetes 对接的部分。</p></li><li><p>Felix。它是一个 DaemonSet，负责在宿主机上插入路由规则（即：写入 Linux 内核的 FIB 转发信息库），以及维护 Calico 所需的网络设备等工作。</p></li><li><p>BIRD。它就是 BGP 的客户端，专门负责在集群里分发路由规则信息。</p></li></ul><p>除了对路由信息的维护方式之外，Calico 项目与 Flannel  host-gw 模式的另一个不同之处，就是它不会在宿主机上创建任何网桥设备。Calico 的工作方式，可以用一幅示意图来描述，如下所示（在接下来的讲述中，统一用“BGP 示意图”来指代它）：</p><p><img src="/img/image-20201006152023664.png" alt="image-20201006152023664"></p><p>其中的绿色实线标出的路径，就是一个 IP 包从 Node 1 上的 Container 1，到达 Node 2 上的 Container 4 的完整路径。</p><h4 id="2-2-1、Veth-Pair">2.2.1、Veth Pair</h4><p>可以看到，Calico 的 CNI 插件会为每个容器设置一个 Veth Pair 设备，然后把其中的一端放置在宿主机上（它的名字以 cali 前缀开头）。</p><p>由于 Calico 没有使用 CNI 的网桥模式，Calico 的 CNI 插件还需要在宿主机上为每个容器的 Veth Pair 设备配置一条路由规则，用于接收传入的 IP 包。比如，宿主机 Node 2 上的 Container 4 对应的路由规则，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">10.233.2.3 dev cali5863f3 scope link<br></code></pre></td></tr></table></figure><p>即：发往 10.233.2.3 的 IP 包，应该进入 cali5863f3 设备。</p><p>基于上述原因，Calico 项目在宿主机上设置的路由规则，肯定要比 Flannel 项目多得多。不过，Flannel host-gw 模式使用 CNI 网桥的主要原因，其实是为了跟 VXLAN 模式保持一致。否则的话，Flannel 就需要维护两套 CNI 插件了。</p><h4 id="2-2-2、下一跳IP地址">2.2.2、下一跳IP地址</h4><p>在有了 Veth Pair 设备之后，容器发出的 IP 包就会经过 Veth Pair 设备出现在宿主机上。然后，宿主机网络栈就会根据路由规则的下一跳 IP 地址，把它们转发给正确的网关。</p><p>接下来的流程就跟 Flannel host-gw 模式完全一致了。其中，这里最核心的“下一跳”路由规则，就是由 Calico 的 Felix 进程负责维护的。这些路由规则信息，则是通过 BGP Client 也就是 BIRD 组件，使用 BGP 协议传输而来的。而这些通过 BGP 协议传输的消息，我们可以简单地理解为如下格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[BGP消息]<br>我是宿主机192.168.1.3<br>10.233.2.0/24网段的容器都在我这里<br>这些容器的下一跳地址是我<br></code></pre></td></tr></table></figure><p>不难发现，Calico 项目实际上将集群里的所有节点，都当作是边界路由器来处理，它们一起组成了一个全连通的网络，互相之间通过 BGP 协议交换路由规则。这些节点，我们称为 BGP Peer。</p><h4 id="2-2-3、Node-to-Node-Mesh-vs-Route-Reflector">2.2.3、Node-to-Node Mesh vs Route Reflector</h4><p>需要注意的是，Calico 维护的网络在默认配置下，是一个被称为“Node-to-Node Mesh”的模式。这时候，每台宿主机上的 BGP Client 都需要跟其他所有节点的 BGP Client 进行通信以便交换路由信息。但是，随着节点数量 N 的增加，这些连接的数量就会以 N²的规模快速增长，从而给集群本身的网络带来巨大的压力。</p><p>所以，Node-to-Node Mesh 模式一般推荐用在少于 100 个节点的集群里。而在更大规模的集群中，我们需要用到的是一个叫作 Route Reflector 的模式。</p><p>在这种模式下，Calico 会指定一个或者几个专门的节点，来负责跟所有节点建立 BGP 连接从而学习到全局的路由规则。而其他节点，只需要跟这几个专门的节点交换路由信息，就可以获得整个集群的路由规则信息了。</p><p>这些专门的节点，就是所谓的 Route Reflector 节点，它们实际上扮演了“中间代理”的角色，从而把 BGP 连接的规模控制在 N 的数量级上。</p><h4 id="2-2-4、IPIP模式">2.2.4、IPIP模式</h4><p>我们在前面提到过，Flannel host-gw 模式最主要的限制，就是要求集群宿主机之间是二层连通的。而这个限制对于 Calico 来说，也同样存在。</p><p>举个例子，假如我们有两台处于不同子网的宿主机 Node 1 和 Node 2，对应的 IP 地址分别是 192.168.1.2/24 和 192.168.2.2/24。需要注意的是，这两台机器通过路由器实现了三层转发，所以这两个 IP 地址之间是可以相互通信的。而我们现在的需求，还是 Container 1 要访问 Container 4。</p><p>按照我们前面的讲述，Calico 会尝试在 Node 1 上添加如下所示的一条路由规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">10.233.2.0/16 via 192.168.2.2 eth0<br></code></pre></td></tr></table></figure><p>但是，这时候问题就来了。上面这条规则里的下一跳地址是 192.168.2.2，可是它对应的 Node 2 跟 Node 1 根本不在一个子网里，没办法通过二层网络把 IP 包发送到下一跳地址。在这种情况下，我们就需要为 Calico 打开 IPIP 模式。我们把这个模式下容器通信的原理，总结成一张图片，如下所示（接下来会称之为：IPIP 示意图）：</p><p><img src="/img/image-20201006152810370.png" alt="image-20201006152810370"></p><p>在 Calico 的 IPIP 模式下，Felix 进程在 Node 1 上添加的路由规则，会稍微不同，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">10.233.2.0/24 via 192.168.2.2 tunl0<br></code></pre></td></tr></table></figure><p>可以看到，尽管这条规则的下一跳地址仍然是 Node 2 的 IP 地址，但这一次，要负责将 IP 包发出去的设备，变成了 tunl0。注意，是 T-U-N-L-0，而不是 Flannel UDP 模式使用的 T-U-N-0（tun0），这两种设备的功能是完全不一样的。</p><p>Calico 使用的这个 tunl0 设备，是一个 IP 隧道（IP tunnel）设备。在上面的例子中，IP 包进入 IP 隧道设备之后，就会被 Linux 内核的 IPIP 驱动接管。IPIP 驱动会将这个 IP 包直接封装在一个宿主机网络的 IP 包中，如下所示：</p><p><img src="/img/image-20201006152947551.png" alt="image-20201006152947551"></p><p>其中，经过封装后的新的 IP 包的目的地址（图中的 Outer IP Header 部分），正是原 IP 包的下一跳地址，即 Node 2 的 IP 地址：192.168.2.2。而原 IP 包本身，则会被直接封装成新 IP 包的 Payload。这样，原先从容器到 Node 2 的 IP 包，就被伪装成了一个从 Node 1 到 Node 2 的 IP 包。</p><p>由于宿主机之间已经使用路由器配置了三层转发，也就是设置了宿主机之间的“下一跳”。所以这个 IP 包在离开 Node 1 之后，就可以经过路由器，最终“跳”到 Node 2 上。</p><p>这时，Node 2 的网络内核栈会使用 IPIP 驱动进行解包，从而拿到原始的 IP 包。然后，原始 IP 包就会经过路由规则和 Veth Pair 设备到达目的容器内部。</p><h4 id="2-2-5、小结">2.2.5、小结</h4><p>以上，就是 Calico 项目主要的工作原理了。不难看出，当 Calico 使用 IPIP 模式的时候，集群的网络性能会因为额外的封包和解包工作而下降。在实际测试中，Calico IPIP 模式与 Flannel VXLAN 模式的性能大致相当。所以，在实际使用时，如非硬性需求，建议将所有宿主机节点放在一个子网里，避免使用 IPIP。</p><h3 id="2-3、将宿主机网关设置成-BGP-Peer">2.3、将宿主机网关设置成 BGP Peer</h3><p>通过上面对 Calico 工作原理的讲述，我们应该能发现这样一个事实：</p><blockquote><p>如果 Calico 项目能够让宿主机之间的路由设备（也就是网关），也通过 BGP 协议“学习”到 Calico 网络里的路由规则，那么从容器发出的 IP 包，不就可以通过这些设备路由到目的宿主机了么？</p></blockquote><p>比如，只要在上面“IPIP 示意图”中的 Node 1 上，添加如下所示的一条路由规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">10.233.2.0/24 via 192.168.1.1 eth0<br></code></pre></td></tr></table></figure><p>然后，在 Router 1 上（192.168.1.1），添加如下所示的一条路由规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">10.233.2.0/24 via 192.168.2.1 eth0<br></code></pre></td></tr></table></figure><p>那么 Container 1 发出的 IP 包，就可以通过两次“下一跳”，到达 Router 2（192.168.2.1）了。以此类推，我们可以继续在 Router 2 上添加“下一条”路由，最终把 IP 包转发到 Node 2 上。</p><p>遗憾的是，上述流程虽然简单明了，但是在 Kubernetes 被广泛使用的公有云场景里，却完全不可行。这里的原因在于：公有云环境下，宿主机之间的网关，肯定不会允许用户进行干预和设置。当然，在大多数公有云环境下，宿主机（公有云提供的虚拟机）本身往往就是二层连通的，所以这个需求也不强烈。</p><p>不过，在私有部署的环境下，宿主机属于不同子网（VLAN）反而是更加常见的部署状态。这时候，想办法将宿主机网关也加入到 BGP Mesh 里从而避免使用 IPIP，就成了一个非常迫切的需求。</p><p>而在 Calico 项目中，它已经为我们提供了两种将宿主机网关设置成 BGP Peer 的解决方案。</p><h4 id="2-3-1、所有宿主机都跟宿主机网关建立-BGP-Peer-关系">2.3.1、所有宿主机都跟宿主机网关建立 BGP Peer 关系</h4><p>第一种方案，就是所有宿主机都跟宿主机网关建立 BGP Peer 关系。</p><p>这种方案下，Node 1 和 Node 2 就需要主动跟宿主机网关 Router 1 和 Router 2 建立 BGP 连接。从而将类似于 10.233.2.0/24 这样的路由信息同步到网关上去。</p><p>需要注意的是，这种方式下，Calico 要求宿主机网关必须支持一种叫作 Dynamic Neighbors 的 BGP 配置方式。这是因为，在常规的路由器 BGP 配置里，运维人员必须明确给出所有 BGP Peer 的 IP 地址。考虑到 Kubernetes 集群可能会有成百上千个宿主机，而且还会动态地添加和删除节点，这时候再手动管理路由器的 BGP 配置就非常麻烦了。而 Dynamic Neighbors 则允许我们给路由器配置一个网段，然后路由器就会自动跟该网段里的主机建立起 BGP Peer 关系。</p><h4 id="2-3-2、使用一个或多个独立组件负责搜集路由信息">2.3.2、使用一个或多个独立组件负责搜集路由信息</h4><p>相比于第一种方案，更推荐第二种方案。</p><p>这种方案，是使用一个或多个独立组件负责搜集整个集群里的所有路由信息，然后通过 BGP 协议同步给网关。而我们前面提到，在大规模集群中，Calico 本身就推荐使用 Route Reflector 节点的方式进行组网。所以，这里负责跟宿主机网关进行沟通的独立组件，直接由 Route Reflector 兼任即可。</p><p>更重要的是，这种情况下网关的 BGP Peer 个数是有限并且固定的。所以我们就可以直接把这些独立组件配置成路由器的 BGP Peer，而无需 Dynamic Neighbors 的支持。</p><p>当然，这些独立组件的工作原理也很简单：它们只需要 WATCH Etcd 里的宿主机和对应网段的变化信息，然后把这些信息通过 BGP 协议分发给网关即可。</p><h2 id="三、小结">三、小结</h2><p>在本篇文章中，我们详细讨论了 Fannel host-gw 模式和 Calico 这两种纯三层网络方案的工作原理。需要注意的是：</p><ul><li>在大规模集群里，三层网络方案在宿主机上的路由规则可能会非常多，这会导致错误排查变得困难。</li><li>此外，在系统故障的时候，路由规则出现重叠冲突的概率也会变大。</li></ul><p>基于上述原因，如果是在公有云上，由于宿主机网络本身比较“直白”，一般会推荐更加简单的 Flannel host-gw 模式。</p>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器网络3：Kubernetes网络模型与CNI网络插件</title>
    <link href="/2020/10/06/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C3%EF%BC%9AKubernetes%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8ECNI%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6/"/>
    <url>/2020/10/06/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C3%EF%BC%9AKubernetes%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8ECNI%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们讨论了容器间的网络通信原理。接下来，我们一起看一看Kubernetes的网络通信原理。</p><h2 id="一、从CNI网桥说起">一、从CNI网桥说起</h2><p>我们知道，Flannel UDP 模式和Flannel VXLAN模式有一个共性，那就是用户的容器都连接在 docker0 网桥上。而Flannel网络插件则会在宿主机上创建了一个特殊的设备（UDP 模式创建的是 TUN 设备，VXLAN 模式创建的则是 VTEP 设备），docker0 与这个设备之间，通过 IP 转发（路由表）进行协作。然后，网络插件真正要做的事情，则是通过某种方法，把不同宿主机上的特殊设备连通，从而达到容器跨主机通信的目的。</p><p>实际上，上面这个流程，也正是 Kubernetes 对容器网络的主要处理方法。只不过，Kubernetes 是通过一个叫作 CNI 的接口，维护了一个单独的网桥来代替 docker0。这个网桥的名字就叫作：CNI 网桥，它在宿主机上的设备名称默认是：cni0。</p><p>以 Flannel 的 VXLAN 模式为例，在 Kubernetes 环境里，它的工作方式跟我们在前面文章中讲解的没有任何不同。只不过，docker0 网桥被替换成了 CNI 网桥而已，如下所示：</p><p><img src="/img/image-20201006123351516.png" alt="image-20201006123351516"></p><p>在这里，Kubernetes 为 Flannel 分配的子网范围是 10.244.0.0/16。这个参数可以在部署的时候指定，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubeadm init --pod-network-cidr=10.244.0.0/16</span><br></code></pre></td></tr></table></figure><p>也可以在部署完成后，通过修改 kube-controller-manager 的配置文件来指定。</p><p>这时候，假设 Infra-container-1 要访问 Infra-container-2（也就是 Pod-1 要访问 Pod-2），这个 IP 包的源地址就是 10.244.0.2，目的 IP 地址是 10.244.1.3。而此时，Infra-container-1 里的 eth0 设备，同样是以 Veth Pair 的方式连接在 Node 1 的 cni0 网桥上。所以这个 IP 包就会经过 cni0 网桥出现在宿主机上。此时，Node 1 上的路由表，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在Node 1上</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">route -n</span><br>Kernel IP routing table<br>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br>...<br>10.244.0.0      0.0.0.0         255.255.255.0   U     0      0        0 cni0<br>10.244.1.0      10.244.1.0      255.255.255.0   UG    0      0        0 flannel.1<br>172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0<br></code></pre></td></tr></table></figure><p>因为我们的 IP 包的目的 IP 地址是 10.244.1.3，所以它只能匹配到第二条规则，也就是 10.244.1.0 对应的这条路由规则。可以看到，这条规则指定了本机的 flannel.1 设备进行处理。并且，flannel.1 在处理完后，要将 IP 包转发到的网关（Gateway），正是“隧道”另一端的 VTEP 设备，也就是 Node 2 的 flannel.1 设备。所以，接下来的流程，就跟 Flannel VXLAN 模式完全一样了。</p><p>需要注意的是，CNI 网桥只是接管所有 CNI 插件负责的、Kubernetes 创建的容器（Pod）。而此时，如果我们用 docker run 单独启动一个容器，那么 Docker 项目还是会把这个容器连接到 docker0 网桥上。所以这个容器的 IP 地址，一定是属于 docker0 网桥的 172.17.0.0/16 网段。</p><p>Kubernetes 之所以要设置这样一个与 docker0 网桥功能几乎一样的 CNI 网桥，主要原因包括两个方面：</p><ul><li>一方面，Kubernetes 项目并没有使用 Docker 的网络模型（CNM），所以它并不希望、也不具备配置 docker0 网桥的能力；</li><li>另一方面，这还与 Kubernetes 如何配置 Pod，也就是 Infra 容器的 Network Namespace 密切相关。</li></ul><p>我们知道，Kubernetes 创建一个 Pod 的第一步，就是创建并启动一个 Infra 容器，用来“hold”住这个 Pod 的 Network Namespace。所以，CNI 的设计思想，就是：Kubernetes 在启动 Infra 容器之后，就可以直接调用 CNI 网络插件，为这个 Infra 容器的 Network Namespace，配置符合预期的网络栈。</p><blockquote><p>那么，这个网络栈的配置工作又是如何完成的呢？</p></blockquote><p>为了回答这个问题，我们就需要从 CNI 插件的部署和实现方式谈起了。</p><h2 id="二、CNI插件的部署">二、CNI插件的部署</h2><h3 id="2-1、CNI插件的基础可执行文件">2.1、CNI插件的基础可执行文件</h3><p>我们在部署 Kubernetes 的时候，有一个步骤是安装 kubernetes-cni 包，它的目的就是在宿主机上安装 CNI 插件所需的基础可执行文件。在安装完成后，我们可以在宿主机的 /opt/cni/bin 目录下看到它们，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al /opt/cni/bin/</span><br>total 73088<br>-rwxr-xr-x 1 root root  3890407 Aug 17  2017 bridge<br>-rwxr-xr-x 1 root root  9921982 Aug 17  2017 dhcp<br>-rwxr-xr-x 1 root root  2814104 Aug 17  2017 flannel<br>-rwxr-xr-x 1 root root  2991965 Aug 17  2017 host-local<br>-rwxr-xr-x 1 root root  3475802 Aug 17  2017 ipvlan<br>-rwxr-xr-x 1 root root  3026388 Aug 17  2017 loopback<br>-rwxr-xr-x 1 root root  3520724 Aug 17  2017 macvlan<br>-rwxr-xr-x 1 root root  3470464 Aug 17  2017 portmap<br>-rwxr-xr-x 1 root root  3877986 Aug 17  2017 ptp<br>-rwxr-xr-x 1 root root  2605279 Aug 17  2017 sample<br>-rwxr-xr-x 1 root root  2808402 Aug 17  2017 tuning<br>-rwxr-xr-x 1 root root  3475750 Aug 17  2017 vlan<br></code></pre></td></tr></table></figure><p>这些 CNI 的基础可执行文件，按照功能可以分为三类：</p><ul><li>第一类，叫作 Main 插件，它是用来创建具体网络设备的二进制文件。比如，bridge（网桥设备）、ipvlan、loopback（lo 设备）、macvlan、ptp（Veth Pair 设备），以及 vlan。我们在前面提到过的 Flannel、Weave 等项目，都属于“网桥”类型的 CNI 插件。所以在具体的实现中，它们往往会调用 bridge 这个二进制文件。</li><li>第二类，叫作 IPAM（IP Address Management）插件，它是负责分配 IP 地址的二进制文件。比如，dhcp，这个文件会向 DHCP 服务器发起请求；host-local，则会使用预先配置的 IP 地址段来进行分配。</li><li>第三类，是由 CNI 社区维护的内置 CNI 插件。比如：flannel，就是专门为 Flannel 项目提供的 CNI 插件；tuning，是一个通过 sysctl 调整网络设备参数的二进制文件；portmap，是一个通过 iptables 配置端口映射的二进制文件；bandwidth，是一个使用 Token Bucket Filter (TBF) 来进行限流的二进制文件。</li></ul><h3 id="2-2、如何实现一个Kubernetes网络方案">2.2、如何实现一个Kubernetes网络方案</h3><p>从上面这些二进制文件中，我们可以看到，如果要实现一个给 Kubernetes 用的容器网络方案，其实需要做两部分工作，以 Flannel 项目为例：</p><ul><li><p>首先，实现这个网络方案本身。这一部分需要编写的，其实就是 flanneld 进程里的主要逻辑。比如，创建和配置 flannel.1 设备、配置宿主机路由、配置 ARP 和 FDB 表里的信息等等。</p></li><li><p>然后，实现该网络方案对应的 CNI 插件。这一部分主要需要做的，就是配置 Infra 容器里面的网络栈，并把它连接在 CNI 网桥上。</p></li></ul><p>由于 Flannel 项目对应的 CNI 插件已经被内置了，所以它无需再单独安装。而对于 Weave、Calico 等其他项目来说，我们就必须在安装插件的时候，把对应的 CNI 插件的可执行文件放在 /opt/cni/bin/ 目录下。实际上，对于 Weave、Calico 这样的网络方案来说，它们的 DaemonSet 只需要挂载宿主机的 /opt/cni/bin/，就可以实现插件可执行文件的安装了。</p><p>接下来，我们就需要在宿主机上安装 flanneld（网络方案本身）。而在这个过程中，flanneld 启动后会在每台宿主机上生成它对应的 CNI 配置文件（它其实是一个 ConfigMap），从而告诉 Kubernetes，这个集群要使用 Flannel 作为容器网络方案。而这个 CNI 配置文件的内容如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /etc/cni/net.d/10-flannel.conflist</span> <br>&#123;<br>  &quot;name&quot;: &quot;cbr0&quot;,<br>  &quot;plugins&quot;: [<br>    &#123;<br>      &quot;type&quot;: &quot;flannel&quot;,<br>      &quot;delegate&quot;: &#123;<br>        &quot;hairpinMode&quot;: true,<br>        &quot;isDefaultGateway&quot;: true<br>      &#125;<br>    &#125;,<br>    &#123;<br>      &quot;type&quot;: &quot;portmap&quot;,<br>      &quot;capabilities&quot;: &#123;<br>        &quot;portMappings&quot;: true<br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，在 Kubernetes 中，处理容器网络相关的逻辑并不会在 kubelet 主干代码里执行，而是会在具体的 CRI（Container Runtime Interface，容器运行时接口）实现里完成。对于 Docker 项目来说，它的 CRI 实现叫作 dockershim，我们可以在 kubelet 的代码里找到它。所以，接下来 dockershim 会加载上述的 CNI 配置文件。</p><p>需要注意，Kubernetes 目前不支持多个 CNI 插件混用。如果我们在 CNI 配置目录（/etc/cni/net.d）里放置了多个 CNI 配置文件的话，dockershim 只会加载按字母顺序排序的第一个插件。但另一方面，CNI 允许我们在一个 CNI 配置文件里，通过 plugins 字段，定义多个插件进行协作。</p><p>比如，在我们上面这个例子里，Flannel 项目就指定了 flannel 和 portmap 这两个插件。这时候，dockershim 会把这个 CNI 配置文件加载起来，并且把列表里的第一个插件、也就是 flannel 插件，设置为默认插件。而在后面的执行过程中，flannel 和 portmap 插件会按照定义顺序被调用，从而依次完成“配置容器网络”和“配置端口映射”这两步操作。</p><h2 id="三、CNI插件的工作原理">三、CNI插件的工作原理</h2><p>接下来，我们讨论一下这样一个 CNI 插件的工作原理。</p><p>当 kubelet 组件需要创建 Pod 的时候，它第一个创建的一定是 Infra 容器。所以在这一步，dockershim 就会先调用 Docker API 创建并启动 Infra 容器，紧接着执行一个叫作 SetUpPod 的方法。这个方法的作用就是：为 CNI 插件准备参数，然后调用 CNI 插件为 Infra 容器配置网络。</p><h3 id="3-1、为CNI插件准备参数">3.1、为CNI插件准备参数</h3><p>这里要调用的 CNI 插件，就是 /opt/cni/bin/flannel；而调用CNI差价所需要的参数，分为两部分。</p><h4 id="3-1-1、CNI环境变量">3.1.1、CNI环境变量</h4><p>第一部分，是由 dockershim 设置的一组 CNI 环境变量。其中，最重要的环境变量参数叫作：CNI_COMMAND。它的取值只有两种：ADD 和 DEL。这个 ADD 和 DEL 操作，就是 CNI 插件唯一需要实现的两个方法。其中 ADD 操作的含义是：把容器添加到 CNI 网络里；DEL 操作的含义则是：把容器从 CNI 网络里移除掉。</p><p>而对于网桥类型的 CNI 插件来说，这两个操作意味着把容器以 Veth Pair 的方式“插”到 CNI 网桥上，或者从网桥上“拔”掉。接下来，我们以 ADD 操作为重点进行讲解。</p><p>CNI 的 ADD 操作需要的参数包括：容器里网卡的名字 eth0（CNI_IFNAME）、Pod 的 Network Namespace 文件的路径（CNI_NETNS）、容器的 ID（CNI_CONTAINERID）等。这些参数都属于上述环境变量里的内容。其中，Pod（Infra 容器）的 Network Namespace 文件的路径为：/proc/&lt; 容器进程的 PID&gt;/ns/net。</p><p>除此之外，在 CNI 环境变量里，还有一个叫作 CNI_ARGS 的参数。通过这个参数，CRI 实现（比如 dockershim）就可以以 Key-Value 的格式，传递自定义信息给网络插件。这是用户将来自定义 CNI 协议的一个重要方法。</p><h4 id="3-1-2、CNI插件的配置信息">3.1.2、CNI插件的配置信息</h4><p>第二部分，则是 dockershim 从 CNI 配置文件里加载到的、默认插件的配置信息。这个配置信息在 CNI 中被叫作 Network Configuration。dockershim 会把 Network Configuration 以 JSON 数据的格式，通过标准输入（stdin）的方式传递给 Flannel CNI 插件。</p><p>而有了这两部分参数，Flannel CNI 插件实现 ADD 操作的过程就非常简单了。</p><h3 id="3-2、调用delegate插件">3.2、调用delegate插件</h3><p>不过，需要注意的是，Flannel 的 CNI 配置文件（ /etc/cni/net.d/10-flannel.conflist）里有这么一个字段，叫作 delegate：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">...<br>     <span class="hljs-attr">&quot;delegate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;hairpinMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isDefaultGateway&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>      <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>Delegate 字段的意思是，这个 CNI 插件并不会自己做事儿，而是会调用 Delegate 指定的某种 CNI 内置插件来完成。对于 Flannel 来说，它调用的 Delegate 插件，就是前面介绍到的 CNI bridge 插件。</p><p>所以说，dockershim 对 Flannel CNI 插件的调用，其实就是走了个过场。Flannel CNI 插件唯一需要做的，就是对 dockershim 传来的 Network Configuration 进行补充。比如，将 Delegate 的 Type 字段设置为 bridge，将 Delegate 的 IPAM 字段设置为 host-local 等。经过 Flannel CNI 插件补充后的、完整的 Delegate 字段如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;hairpinMode&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;ipMasq&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;ipam&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;routes&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;dst&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;10.244.0.0/16&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;subnet&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;10.244.1.0/24&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;host-local&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;isDefaultGateway&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;isGateway&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;mtu&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1410</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;cbr0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bridge&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>其中，ipam 字段里的信息，比如 10.244.1.0/24，读取自 Flannel 在宿主机上生成的 Flannel 配置文件，即：宿主机上的 /run/flannel/subnet.env 文件。接下来，Flannel CNI 插件就会调用 CNI bridge 插件，也就是执行：/opt/cni/bin/bridge 二进制文件。</p><p>这一次，调用 CNI bridge 插件需要的两部分参数的第一部分、也就是 CNI 环境变量，并没有变化。所以，它里面的 CNI_COMMAND 参数的值还是“ADD”。而第二部分 Network Configration，正是上面补充好的 Delegate 字段。Flannel CNI 插件会把 Delegate 字段的内容以标准输入（stdin）的方式传递给 CNI bridge 插件。此外，Flannel CNI 插件还会把 Delegate 字段以 JSON 文件的方式，保存在 /var/lib/cni/flannel 目录下。这是为了给后面删除容器调用 DEL 操作时使用的。</p><p>有了这两部分参数，接下来 CNI bridge 插件就可以“代表”Flannel，进行“将容器加入到 CNI 网络里”这一步操作了。而这一部分内容，与容器 Network Namespace 密切相关，所以我们要详细讨论一下。</p><h3 id="3-3、将容器加入到CNI网络">3.3、将容器加入到CNI网络</h3><h4 id="3-3-1、检查CNI网桥是否存在">3.3.1、检查CNI网桥是否存在</h4><p>首先，CNI bridge 插件会在宿主机上检查 CNI 网桥是否存在。如果没有的话，那就创建它。这相当于在宿主机上执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在宿主机上</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip <span class="hljs-built_in">link</span> add cni0 <span class="hljs-built_in">type</span> bridge</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> cni0 up</span><br></code></pre></td></tr></table></figure><h4 id="3-3-2、创建Veth-Pair">3.3.2、创建Veth Pair</h4><p>接下来，CNI bridge 插件会通过 Infra 容器的 Network Namespace 文件，进入到这个 Network Namespace 里面，然后创建一对 Veth Pair 设备。紧接着，它会把这个 Veth Pair 的其中一端，“移动”到宿主机上。这相当于在容器里执行如下所示的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">在容器里</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建一对Veth Pair设备。其中一个叫作eth0，另一个叫作vethb4963f3</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip <span class="hljs-built_in">link</span> add eth0 <span class="hljs-built_in">type</span> veth peer name vethb4963f3</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动eth0设备</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth0 up</span> <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将Veth Pair设备的另一端（也就是vethb4963f3设备）放到宿主机（也就是Host Namespace）里</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> vethb4963f3 netns <span class="hljs-variable">$HOST_NS</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过Host Namespace，启动宿主机上的vethb4963f3设备</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$HOST_NS</span> ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> vethb4963f3 up</span><br></code></pre></td></tr></table></figure><p>这样，vethb4963f3 就出现在了宿主机上，而且这个 Veth Pair 设备的另一端，就是容器里面的 eth0。</p><p>当然，上述创建 Veth Pair 设备的操作，其实也可以先在宿主机上执行，然后再把该设备的一端放到容器的 Network Namespace 里，这个原理是一样的。不过，CNI 插件之所以要“反着”来，是因为 CNI 里对 Namespace 操作函数的设计就是如此，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">err := containerNS.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(hostNS ns.NetNS)</span></span> <span class="hljs-type">error</span> &#123;<br>  ...<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>这个设计其实很容易理解。在编程时，容器的 Namespace 是可以直接通过 Namespace 文件拿到的；而 Host Namespace，则是一个隐含在上下文的参数。所以，像上面这样，先通过容器 Namespace 进入容器里面，然后再反向操作 Host Namespace，对于编程来说要更加方便。</p><h4 id="3-3-3、将veth-pair接入CNI网桥">3.3.3、将veth pair接入CNI网桥</h4><p>接下来，CNI bridge 插件就可以把 vethb4963f3 设备连接在 CNI 网桥上。这相当于在宿主机上执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在宿主机上</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> vethb4963f3 master cni0</span><br></code></pre></td></tr></table></figure><h4 id="3-3-4、设置veth-pair的模式">3.3.4、设置veth pair的模式</h4><p>在将 vethb4963f3 设备连接在 CNI 网桥之后，CNI bridge 插件还会为它设置 Hairpin Mode（发夹模式）。这是因为，在默认情况下，网桥设备是不允许一个数据包从一个端口进来后，再从这个端口发出去的。但是，它允许我们为这个端口开启 Hairpin Mode，从而取消这个限制。这个特性，主要用在容器需要通过NAT（即：端口映射）的方式，“自己访问自己”的场景下。</p><p>举个例子，比如我们执行 docker run -p 8080:80，就是在宿主机上通过 iptables 设置了一条DNAT（目的地址转换）转发规则。这条规则的作用是，当宿主机上的进程访问“&lt; 宿主机的 IP 地址 &gt;:8080”时，iptables 会把该请求直接转发到“&lt; 容器的 IP 地址 &gt;:80”上。也就是说，这个请求最终会经过 docker0 网桥进入容器里面。</p><p>但如果我们是在容器里面访问宿主机的 8080 端口，那么这个容器里发出的 IP 包会经过 vethb4963f3 设备（端口）和 docker0 网桥，来到宿主机上。此时，根据上述 DNAT 规则，这个 IP 包又需要回到 docker0 网桥，并且还是通过 vethb4963f3 端口进入到容器里。所以，这种情况下，我们就需要开启 vethb4963f3 端口的 Hairpin Mode 了。</p><p>所以说，Flannel 插件要在 CNI 配置文件里声明 hairpinMode=true。这样，将来这个集群里的 Pod 才可以通过它自己的 Service 访问到自己。</p><h4 id="3-3-5、为容器分配IP地址">3.3.5、为容器分配IP地址</h4><p>接下来，CNI bridge 插件会调用 CNI ipam 插件，从 ipam.subnet 字段规定的网段里为容器分配一个可用的 IP 地址。然后，CNI bridge 插件就会把这个 IP 地址添加在容器的 eth0 网卡上，同时为容器设置默认路由。这相当于在容器里执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在容器里</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip addr add 10.244.0.2/24 dev eth0</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip route add default via 10.244.0.1 dev eth0</span><br></code></pre></td></tr></table></figure><h4 id="3-3-6、设置CNI网桥的IP地址">3.3.6、设置CNI网桥的IP地址</h4><p>最后，CNI bridge 插件会为 CNI 网桥添加 IP 地址。这相当于在宿主机上执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在宿主机上</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip addr add 10.244.0.1/24 dev cni0</span><br></code></pre></td></tr></table></figure><h4 id="3-3-7、设置Pod的Status字段">3.3.7、设置Pod的Status字段</h4><p>在执行完上述操作之后，CNI 插件会把容器的 IP 地址等信息返回给 dockershim，然后被 kubelet 添加到 Pod 的 Status 字段。至此，CNI 插件的 ADD 方法就宣告结束了。</p><p>需要注意的是，对于非网桥类型的 CNI 插件，上述“将容器添加到 CNI 网络”的操作流程，以及网络方案本身的工作原理，就都不太一样了。</p><h2 id="四、小结">四、小结</h2><p>在这篇文章中，我们主要讨论了如下概念：</p><ul><li>Kubernetes并没有直接使用docker0这个网桥，而是自己实现了一个名为cni0的网桥。</li><li>一个Kubernetes网络方案的实现，主要由网络方案本身和网络插件组成。其中，网络方案本身，就是网络模型的核心逻辑；网路插件，就是容器配置网络的接口。</li><li>CNI插件的工作原理就是，在需要创建Pod时，首先创建一个infra容器，然后执行SetUpPod方法为Pod准备网络。</li><li>SetUpPod方法的主要逻辑是，准备CNI插件的参数、调用delegate方法、将容器加入到CNI网络。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器网络2：深入解析容器跨主机网络</title>
    <link href="/2020/10/06/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C2%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%AE%B9%E5%99%A8%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/10/06/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C2%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%AE%B9%E5%99%A8%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们讨论了单机容器间通信的原理，并引出了“跨主机容器间通信问题”。接下来，我们重点讨论跨主机容器间通信的原理。</p><h2 id="一、从Flannel项目说起">一、从Flannel项目说起</h2><p>要理解容器“跨主机通信”的原理，就一定要先从 Flannel 这个项目说起。Flannel 项目是 CoreOS 公司主推的容器网络方案。事实上，Flannel 项目本身只是一个框架，真正为我们提供容器网络功能的，是 Flannel 的后端实现。目前，Flannel 支持三种后端实现，分别是：</p><ul><li><p>UDP</p></li><li><p>VXLAN</p></li><li><p>host-gw</p></li></ul><p>而这三种不同的后端实现，正代表了容器跨主机网络通信的三种主流实现方案。接下来，我们先来讨论前二种方案，即UDP和VXLAN。</p><h2 id="二、Flannel-UDP模式">二、Flannel UDP模式</h2><p>假设，我们现在有两台宿主机：</p><ul><li>宿主机 Node 1 上有一个容器 container-1，它的 IP 地址是 100.96.1.2，对应的 docker0 网桥的地址是：100.96.1.1/24。</li><li>宿主机 Node 2 上有一个容器 container-2，它的 IP 地址是 100.96.2.3，对应的 docker0 网桥的地址是：100.96.2.1/24。</li></ul><p>而我们现在的任务是，让 container-1 访问 container-2。</p><h3 id="2-1、路由">2.1、路由</h3><p>在这个场景中，container-1 容器里的进程发起的 IP 包，其源地址就是 100.96.1.2，目的地址就是 100.96.2.3。由于目的地址 100.96.2.3 并不在 Node 1 的 docker0 网桥的网段里，所以这个 IP 包会被交给默认路由规则，通过容器的网关进入 docker0 网桥，从而出现在宿主机上。</p><p>这时候，这个 IP 包的下一个目的地，就取决于宿主机上的路由规则了。此时，Flannel 已经在宿主机上创建出了一系列的路由规则，以 Node 1 为例，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在Node 1上</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip route</span><br>default via 10.168.0.1 dev eth0<br>100.96.0.0/16 dev flannel0  proto kernel  scope link  src 100.96.1.0<br>100.96.1.0/24 dev docker0  proto kernel  scope link  src 100.96.1.1<br>10.168.0.0/24 dev eth0  proto kernel  scope link  src 10.168.0.2<br></code></pre></td></tr></table></figure><p>可以看到，由于我们的 IP 包的目的地址是 100.96.2.3，它匹配不到本机 docker0 网桥对应的 100.96.1.0/24 网段，只能匹配到第二条、也就是 100.96.0.0/16 对应的这条路由规则，从而进入到一个叫作 flannel0 的设备中。而这个 flannel0 设备的类型就比较有意思了：它是一个 TUN 设备（Tunnel 设备）。</p><p>在 Linux 中，TUN 设备是一种工作在三层（Network Layer）的虚拟网络设备。TUN 设备的功能非常简单，就是在操作系统内核和用户应用程序之间传递 IP 包。以flannel0设备为例，像上面提到的情况，当操作系统将一个IP包发送给flannel0设备之后，flannerl0就会把这个IP包，交给创建这个设备的应用程序，也就是Flannel进程。而这是一个从内核态（Linux内核）向用户态（Flannel进程）的流动方向。反之，如果Flannel进程向flannel0设备发送了一个IP包，那么这个IP包就会出现在宿主机网络栈中，然后根据宿主机的路由表进行下一步处理。而这是一个从用户态向内核态的流动方向。</p><h3 id="2-3、发送数据包">2.3、发送数据包</h3><p>当 IP 包从容器经过 docker0 出现在宿主机，然后又根据路由表进入 flannel0 设备后，宿主机上的 flanneld 进程（Flannel 项目在每个宿主机上的主进程），就会收到这个 IP 包。然后，flanneld 看到了这个 IP 包的目的地址，是 100.96.2.3，就把它发送给了宿主机 Node 2 。</p><blockquote><p>可是，flanneld 又是如何知道这个 IP 地址对应的容器，是运行在 Node 2 上的呢？</p></blockquote><p>这里，就用到了 Flannel 项目里一个非常重要的概念：子网（Subnet）。事实上，在由 Flannel 管理的容器网络里，一台宿主机上的所有容器，都属于该宿主机被分配的一个“子网”。</p><p>在我们的例子中，Node 1 的子网是 100.96.1.0/24，container-1 的 IP 地址是 100.96.1.2。Node 2 的子网是 100.96.2.0/24，container-2 的 IP 地址是 100.96.2.3。而这些子网与宿主机的对应关系，正是保存在 Etcd 当中，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">etcdctl <span class="hljs-built_in">ls</span> /coreos.com/network/subnets</span><br>/coreos.com/network/subnets/100.96.1.0-24<br>/coreos.com/network/subnets/100.96.2.0-24<br>/coreos.com/network/subnets/100.96.3.0-24<br></code></pre></td></tr></table></figure><p>所以，flanneld 进程在处理由 flannel0 设备传入的 IP 包时，就可以根据目的 IP 的地址（比如 100.96.2.3），匹配到对应的子网（比如 100.96.2.0/24），从 Etcd 中找到这个子网对应的宿主机的 IP 地址是 10.168.0.3，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">etcdctl get /coreos.com/network/subnets/100.96.2.0-24</span><br>&#123;&quot;PublicIP&quot;:&quot;10.168.0.3&quot;&#125;<br></code></pre></td></tr></table></figure><p>而对于 flanneld进程 来说，只要 Node 1 和 Node 2 是互通的，那么 flanneld 作为 Node 1 上的一个普通进程，就一定可以通过上述 IP 地址（10.168.0.3）访问到 Node 2。</p><p>所以说，flanneld 在收到 container-1 发给 container-2 的 IP 包之后，就会把这个 IP 包直接封装在一个 UDP 包里，然后发送给 Node 2。不难理解，这个 UDP 包的源地址，就是 flanneld 所在的 Node 1 的地址，而目的地址，则是 container-2 所在的宿主机 Node 2 的地址。</p><p>当然，这个请求得以完成的原因是，每台宿主机上的 flanneld，都监听着一个 8285 端口，所以 flanneld 只要把 UDP 包发往 Node 2 的 8285 端口即可。</p><h3 id="2-3、接收数据包">2.3、接收数据包</h3><p>通过这样一个普通的、宿主机之间的 UDP 通信，一个 UDP 包就从 Node 1 到达了 Node 2。而 Node 2 上监听 8285 端口的进程也是 flanneld，所以这时候，flanneld 就可以从这个 UDP 包里解析出封装在里面的、container-1 发来的原 IP 包。而接下来 flanneld 的工作就非常简单了：flanneld 进程会直接把这个 IP 包发送给它所管理的 TUN 设备，即 flannel0 设备。</p><p>根据我们前面讲解的 TUN 设备的原理，这正是一个从用户态向内核态的流动方向（Flannel 进程向 TUN 设备发送数据包），所以 Linux 内核网络栈就会负责处理这个 IP 包，具体的处理方法，就是通过本机的路由表来寻找这个 IP 包的下一步流向。而 Node 2 上的路由表，跟 Node 1 非常类似，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在Node 2上</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip route</span><br>default via 10.168.0.1 dev eth0<br>100.96.0.0/16 dev flannel0  proto kernel  scope link  src 100.96.2.0<br>100.96.2.0/24 dev docker0  proto kernel  scope link  src 100.96.2.1<br>10.168.0.0/24 dev eth0  proto kernel  scope link  src 10.168.0.3<br></code></pre></td></tr></table></figure><p>由于这个 IP 包的目的地址是 100.96.2.3，它跟第三条也就是 100.96.2.0/24 网段对应的路由规则匹配更加精确。所以，Linux 内核就会按照这条路由规则，把这个 IP 包转发给 docker0 网桥。</p><p>接下来，docker0 网桥会扮演二层交换机的角色，将数据包发送给正确的端口，进而通过 Veth Pair 设备进入到 container-2 的 Network Namespace 里。</p><p>而 container-2 返回给 container-1 的数据包，则会经过与上述过程完全相反的路径回到 container-1 中。</p><h3 id="3-4、小结">3.4、小结</h3><p>需要注意的是，上述流程要正确工作还有一个重要的前提，那就是 docker0 网桥的地址范围必须是 Flannel 为宿主机分配的子网。这个很容易实现，以 Node 1 为例，我们只需要给它上面的 Docker Daemon 启动时配置如下所示的 bip 参数即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">FLANNEL_SUBNET=100.96.1.1/24</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">dockerd --bip=<span class="hljs-variable">$FLANNEL_SUBNET</span> ...</span><br></code></pre></td></tr></table></figure><p>以上，就是基于 Flannel UDP 模式的跨主通信的基本原理了。我们可以把它总结成了一幅原理图，如下所示：</p><p><img src="/img/image-20201006104328521.png" alt="image-20201006104328521"></p><p>可以看到，Flannel UDP 模式提供的其实是一个三层的 Overlay 网络，即：它首先对发出端的 IP 包进行 UDP 封装，然后在接收端进行解封装拿到原始的 IP 包，进而把这个 IP 包转发给目标容器。这就好比，Flannel 在不同宿主机上的两个容器之间打通了一条“隧道”，使得这两个容器可以直接使用 IP 地址进行通信，而无需关心容器和宿主机的分布情况。</p><p>UDP 模式有严重的性能问题，所以已经被废弃了。实际上，相比于两台宿主机之间的直接通信，基于 Flannel UDP 模式的容器通信多了一个额外的步骤，即 flanneld 的处理过程。而这个过程，由于使用到了 flannel0 这个 TUN 设备，仅在发出 IP 包的过程中，就需要经过三次用户态与内核态之间的数据拷贝，如下所示：</p><p><img src="/img/image-20201006104704247.png" alt="image-20201006104704247"></p><p>我们可以看到：</p><ul><li><p>用户态的容器进程发出的 IP 包经过 docker0 网桥进入内核态；</p></li><li><p>IP 包根据路由表进入 TUN（flannel0）设备，从而回到用户态的 flanneld 进程；</p></li><li><p>flanneld 进程进行 UDP 封包之后重新进入内核态，将 UDP 包通过宿主机的 eth0 发出去。</p></li></ul><p>此外，我们还可以看到，Flanneld 进程进行 UDP 封装（Encapsulation）和解封装（Decapsulation）的过程，也都是在用户态完成的。在 Linux 操作系统中，上述这些上下文切换和用户态操作的代价其实是比较高的，这也正是造成 Flannel UDP 模式性能不好的主要原因。</p><p>所以说，我们在进行系统级编程的时候，有一个非常重要的优化原则，就是要减少用户态到内核态的切换次数，并且把核心的处理逻辑都放在内核态进行。这也是为什么，Flannel 后来支持的VXLAN 模式，逐渐成为了主流的容器网络方案的原因。</p><h2 id="三、Flannel-VXLAN模式">三、Flannel VXLAN模式</h2><p>VXLAN，即 Virtual Extensible LAN（虚拟可扩展局域网），是 Linux 内核本身就支持的一种网络虚似化技术。VXLAN 可以完全在内核态实现上述封装和解封装的工作，从而通过与前面相似的“隧道”机制，构建出覆盖网络（Overlay Network）。</p><p>VXLAN 模式的覆盖网络的设计思想是：在现有的三层网络之上，“覆盖”一层虚拟的、由内核 VXLAN 模块负责维护的二层网络，使得连接在这个 VXLAN 二层网络上的“主机”（虚拟机或者容器都可以）之间，可以像在同一个局域网（LAN）里那样自由通信。当然，实际上，这些“主机”可能分布在不同的宿主机上，甚至是分布在不同的物理机房里。</p><p>为了能够在二层网络上打通“隧道”，VXLAN 会在宿主机上设置一个特殊的网络设备作为“隧道”的两端。这个设备就叫作 VTEP，即：VXLAN Tunnel End Point（虚拟隧道端点）。而 VTEP 设备的作用，其实跟前面的 flanneld 进程非常相似。只不过，它进行封装和解封装的对象，是二层数据帧（Ethernet frame）；而且这个工作的执行流程，全部是在内核里完成的（因为 VXLAN 本身就是 Linux 内核中的一个模块）。</p><p>基于 VTEP 设备进行“隧道”通信的流程，我们也可以总结成一幅图，如下所示：</p><p><img src="/img/image-20201006111549970.png" alt="image-20201006111549970"></p><p>可以看到，图中每台宿主机上名叫 flannel.1 的设备，就是 VXLAN 所需的 VTEP 设备，它既有 IP 地址，也有 MAC 地址。</p><h3 id="3-1、路由">3.1、路由</h3><p>现在假设，我们的 container-1 的 IP 地址是 10.1.15.2，要访问的 container-2 的 IP 地址是 10.1.16.3。与前面 UDP 模式的流程类似，当 container-1 发出请求之后，这个目的地址是 10.1.16.3 的 IP 包，会先出现在 docker0 网桥，然后会被路由到本机的 flannel.1 设备进行处理。也就是说，它来到了“隧道”的入口。为了方便叙述，我们接下来会把这个 IP 包称为“原始 IP 包”。</p><h3 id="3-2、内部封包">3.2、内部封包</h3><h4 id="3-2-1、确定目的VTEP设备">3.2.1、确定目的VTEP设备</h4><p>为了能够将“原始 IP 包”封装并且发送到正确的宿主机，VXLAN 就需要找到这条“隧道”的出口，即：目的宿主机的 VTEP 设备。而这个设备的信息，正是每台宿主机上的 flanneld 进程负责维护的。比如，当 Node 2 启动并加入 Flannel 网络之后，在 Node 1（以及所有其他节点）上，flanneld 就会添加一条如下所示的路由规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">route -n</span><br>Kernel IP routing table<br>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br>...<br>10.1.16.0       10.1.16.0       255.255.255.0   UG    0      0        0 flannel.1<br></code></pre></td></tr></table></figure><p>这条规则的意思是：凡是发往 10.1.16.0/24 网段的 IP 包，都需要经过 flannel.1 设备发出，并且，它最后被发往的网关地址是：10.1.16.0。从Flannel VXLAN 模式的流程图中我们可以看到，10.1.16.0 正是 Node 2 上的 VTEP 设备（也就是 flannel.1 设备）的 IP 地址。为了方便叙述，接下来我们把 Node 1 和 Node 2 上的 flannel.1 设备分别称为“源 VTEP 设备”和“目的 VTEP 设备”。</p><h4 id="3-2-2、确定目的VTEP设备的MAC地址">3.2.2、确定目的VTEP设备的MAC地址</h4><p>在这些 VTEP 设备之间，需要想办法组成一个虚拟的二层网络，即：通过二层数据帧进行通信。所以在我们的例子中，“源 VTEP 设备”收到“原始 IP 包”后，就要想办法把“原始 IP 包”加上一个目的 MAC 地址，封装成一个二层数据帧，然后发送给“目的 VTEP 设备”（当然，要这么做还是因为这个 IP 包的目的地址不是本机）。</p><blockquote><p>这里还需要解决的问题是：“目的 VTEP 设备”的 MAC 地址是什么？</p></blockquote><p>此时，根据前面的路由记录，我们已经知道了“目的 VTEP 设备”的 IP 地址。而要根据三层 IP 地址查询对应的二层 MAC 地址，这正是 ARP（Address Resolution Protocol ）表的功能。而这里要用到的 ARP 记录，也是 flanneld 进程在 Node 2 节点启动时，自动添加在 Node 1 上的。我们可以通过 ip 命令看到它，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在Node 1上</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip neigh show dev flannel.1</span><br>10.1.16.0 lladdr 5e:f8:4f:00:e3:37 PERMANENT<br></code></pre></td></tr></table></figure><p>这条记录的意思非常明确，即：IP 地址 10.1.16.0，对应的 MAC 地址是 5e:f8:4f:00:e3:37。最新版本的 Flannel 并不依赖 L3 MISS 事件和 ARP 学习，而会在每台节点启动时把它的 VTEP 设备对应的 ARP 记录，直接下放到其他每台宿主机上。</p><h4 id="2-2-3、内部二层封装">2.2.3、内部二层封装</h4><p>有了这个“目的 VTEP 设备”的 MAC 地址，Linux 内核就可以开始二层封包工作了。这个二层帧的格式，如下所示：</p><p><img src="/img/image-20201006113008762.png" alt="image-20201006113008762"></p><p>可以看到，Linux 内核会把“目的 VTEP 设备”的 MAC 地址，填写在图中的 Inner Ethernet Header 字段，得到一个二层数据帧。需要注意的是，上述封包过程只是加一个二层头，不会改变“原始 IP 包”的内容。所以图中的 Inner IP Header 字段，依然是 container-2 的 IP 地址，即 10.1.16.3。</p><p>但是，上面提到的这些 VTEP 设备的 MAC 地址，对于宿主机网络来说并没有什么实际意义。所以上面封装出来的这个数据帧，并不能在我们的宿主机二层网络里传输。为了方便叙述，我们把它称为“内部数据帧”（Inner Ethernet Frame）。</p><h4 id="3-2-4、VXLAN封装">3.2.4、VXLAN封装</h4><p>然后，Linux 内核还需要再把“内部数据帧”进一步封装成为宿主机网络里的一个普通的数据帧，好让它“载着”“内部数据帧”，通过宿主机的 eth0 网卡进行传输。我们把这次要封装出来的、宿主机对应的数据帧称为“外部数据帧”（Outer Ethernet Frame）。</p><p>为了实现“搭便车”的机制，Linux 内核会在“内部数据帧”的前面，加上一个特殊的 VXLAN 头（VXLAN Header），用来表示这个“乘客（内部数据帧）”实际上是一个 VXLAN 要使用的数据帧。这个 VXLAN 头里有一个重要的标志叫作 VNI，它是 VTEP 设备识别某个数据帧是不是应该归自己处理的重要标识。而在 Flannel 中，VNI 的默认值是 1，这也是为何，宿主机上的 VTEP 设备都叫作 flannel.1 的原因，这里的“1”，其实就是 VNI 的值。</p><h3 id="3-3、外部封包">3.3、外部封包</h3><p>最后，Linux 内核会把这个数据帧封装进一个 UDP 包里发出去。跟 UDP 模式类似，在宿主机看来，它会以为自己的 flannel.1 设备只是在向另外一台宿主机的 flannel.1 设备，发起了一次普通的 UDP 链接。它哪里会知道，这个 UDP 包里面，其实是一个完整的二层数据帧。这是不是跟特洛伊木马的故事非常像呢？</p><h4 id="3-3-1、确定UDP包的目的宿主机">3.3.1、确定UDP包的目的宿主机</h4><p>不过，不要忘了，一个 flannel.1 设备只知道另一端的 flannel.1 设备的 MAC 地址，却不知道对应的宿主机地址是什么。</p><blockquote><p>也就是说，这个 UDP 包该发给哪台宿主机呢？</p></blockquote><p>在这种场景下，flannel.1 设备实际上还要扮演一个“网桥”的角色，在二层网络进行 UDP 包的转发。而在 Linux 内核里面，“网桥”设备进行转发的依据，来自于一个叫作 FDB（Forwarding Database）的转发数据库。不难想到，这个 flannel.1“网桥”对应的 FDB 信息，也是 flanneld 进程负责维护的。它的内容可以通过 bridge fdb 命令查看到，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在Node 1上，使用“目的VTEP设备”的MAC地址进行查询</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">bridge fdb show flannel.1 | grep 5e:f8:4f:00:e3:37</span><br>5e:f8:4f:00:e3:37 dev flannel.1 dst 10.168.0.3 self permanent<br></code></pre></td></tr></table></figure><p>可以看到，在上面这条 FDB 记录里，指定了这样一条规则，即：发往我们前面提到的“目的 VTEP 设备”（MAC 地址是 5e:f8:4f:00:e3:37）的二层数据帧，应该通过 flannel.1 设备，发往 IP 地址为 10.168.0.3 的主机。显然，这台主机正是 Node 2，UDP 包要发往的目的地就找到了。</p><h4 id="3-3-2、外部封装">3.3.2、外部封装</h4><p>所以接下来的流程，就是一个正常的、宿主机网络上的封包工作。</p><p>我们知道，UDP 包是一个四层数据包，所以 Linux 内核会在它前面加上一个 IP 头，即原理图中的 Outer IP Header，组成一个 IP 包。并且，在这个 IP 头里，会填上前面通过 FDB 查询出来的目的主机的 IP 地址，即 Node 2 的 IP 地址 10.168.0.3。</p><p>然后，Linux 内核会在这个 IP 包前面加上二层数据帧头，即原理图中的 Outer Ethernet Header，并把 Node 2 的 MAC 地址填进去。这个 MAC 地址本身，是 Node 1 的 ARP 表要学习的内容，无需 Flannel 维护。这时候，我们封装出来的“外部数据帧”的格式，如下所示：</p><p><img src="/img/image-20201006114011219.png" alt="image-20201006114011219"></p><p>这样，封包工作就宣告完成了。</p><h3 id="3-4、发送数据包">3.4、发送数据包</h3><p>接下来，Node 1 上的 flannel.1 设备就可以把这个数据帧从 Node 1 的 eth0 网卡发出去。显然，这个帧会经过宿主机网络来到 Node 2 的 eth0 网卡。</p><p>这时候，Node 2 的内核网络栈会发现这个数据帧里有 VXLAN Header，并且 VNI=1。所以 Linux 内核会对它进行拆包，拿到里面的内部数据帧，然后根据 VNI 的值，把它交给 flannel.1 设备。而 flannel.1 设备则会进一步拆包，取出“原始 IP 包”。</p><p>接下来，就是单机容器网络的处理流程了。最终，IP 包就进入到了 container-2 容器的 Network Namespace 里。</p><h2 id="四、小结">四、小结</h2><p>在这篇文章中，我们主要讨论了如下概念：</p><ul><li>UDP模式，通过用户态进程（比如flanneld），对容器的IP包进行UDP再封装，从而构建起一个三层的虚拟网络。</li><li>VXLAN模式，借助Linux内核的VXLAN机制，对容器的数据帧进行UDP再封装，从而构建起一个二层的虚拟网络。</li></ul><p>UDP模式和VXLAN模式的最大区别在于：</p><ul><li>在UDP模式下，封装和解封工作需要在用户态完成，存在多次用户态与内核态的切换；</li><li>在VXLAN模式下，封装和解封工作都在内核态完成，不存在用户态到内核态的切换。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器网络1：浅谈容器网络</title>
    <link href="/2020/10/06/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C1%EF%BC%9A%E6%B5%85%E8%B0%88%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/10/06/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C1%EF%BC%9A%E6%B5%85%E8%B0%88%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们讨论了数据持久化方面的内容。接下来，我们重点讨论与容器网络相关的内容。</p><h2 id="一、从单机容器间如何通信说起">一、从单机容器间如何通信说起</h2><p>首先，我们需要知道的是，一个 Linux 容器能看见的“网络栈”，实际上是被隔离在它自己的 Network Namespace 当中的。而这里所谓的“网络栈”，就包括了：网卡（Network Interface）、回环设备（Loopback Device）、路由表（Routing Table）和 iptables 规则。对于一个进程来说，这些要素，其实就构成了它发起和响应网络请求的基本环境。</p><p>此外，需要指出的是，作为一个容器，它可以声明直接使用宿主机的网络栈（–net=host），即：不开启 Network Namespace，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run –d –net=host --name container-host container</span><br></code></pre></td></tr></table></figure><p>在这种情况下，这个容器启动后，直接监听的就是宿主机的 80 端口。像这样直接使用宿主机网络栈的方式，虽然可以为容器提供良好的网络性能，但也不可避免地引入了共享网络资源的问题，比如端口冲突。</p><p>在大多数情况下，我们都希望容器进程能使用自己 Network Namespace 里的网络栈，即：拥有属于自己的 IP 地址和端口。这时候，一个显而易见的问题就是：</p><blockquote><p>这个被隔离的容器进程，该如何跟其他 Network Namespace 里的容器进程进行交互呢？</p></blockquote><p>为了理解这个问题，我们其实可以把每一个容器看做一台主机，它们都有一套独立的“网络栈”。如果我们想要实现两台主机之间的通信，最直接的办法，就是把它们用一根网线连接起来；而如果我们想要实现多台主机之间的通信，那就需要用网线，把它们连接在一台交换机上。</p><h2 id="二、Linux-Bridge-Veth-Pair">二、Linux Bridge &amp; Veth Pair</h2><p>在 Linux 中，能够起到虚拟交换机作用的网络设备，是网桥（Bridge）。它是一个工作在数据链路层（Data Link）的设备，主要功能是根据 MAC 地址学习来将数据包转发到网桥的不同端口（Port）上。</p><p>为了实现上述目的，Docker 项目会默认在宿主机上创建一个名叫 docker0 的网桥，凡是连接在 docker0 网桥上的容器，就可以通过它来进行通信。</p><blockquote><p>可是，我们又该如何把一个容器“连接”到 docker0 这个网桥上呢？</p></blockquote><p>这时候，我们就需要使用一个名叫 Veth Pair 的虚拟设备了。Veth Pair 设备的特点是：它被创建出来后，总是以两张虚拟网卡（Veth Peer）的形式成对出现。并且，从其中一个“网卡”发出的数据包，可以直接出现在与它对应的另一张“网卡”上，哪怕这两个“网卡”在不同的 Network Namespace 里。这就使得 Veth Pair 常常被用作为连接不同 Network Namespace 的“网线”。</p><p>下面，我们通过一个简单例子，来看一看Veth Pair设备的“样子”。</p><h3 id="2-1、启动容器1">2.1、启动容器1</h3><p>首先，我们启动一个叫作 container-1 的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --<span class="hljs-built_in">rm</span> --name container-1 busybox <span class="hljs-built_in">sleep</span> 14400</span><br></code></pre></td></tr></table></figure><h3 id="2-2、查看容器1的网络">2.2、查看容器1的网络</h3><p>然后进入到这个容器中查看一下它的网络设备：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在宿主机上</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it container-1 /bin/sh</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在容器里</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ifconfig</span><br>eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 172.17.0.2  netmask 255.255.0.0  broadcast 0.0.0.0<br>        inet6 fe80::42:acff:fe11:2  prefixlen 64  scopeid 0x20&lt;link&gt;<br>        ether 02:42:ac:11:00:02  txqueuelen 0  (Ethernet)<br>        RX packets 364  bytes 8137175 (7.7 MiB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 281  bytes 21161 (20.6 KiB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br>        <br>lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536<br>        inet 127.0.0.1  netmask 255.0.0.0<br>        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;<br>        loop  txqueuelen 1000  (Local Loopback)<br>        RX packets 0  bytes 0 (0.0 B)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 0  bytes 0 (0.0 B)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br>        <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">route</span><br>Kernel IP routing table<br>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br>default         172.17.0.1      0.0.0.0         UG    0      0        0 eth0<br>172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0<br></code></pre></td></tr></table></figure><p>可以看到，这个容器里有一个叫作 eth0 的网卡，它正是一个 Veth Pair 设备在容器里的一端。通过 route 命令查看这个容器的路由表，我们可以看到，这个 eth0 网卡是这个容器里的默认路由设备；所有对 172.17.0.0/16 网段的请求，也会被交给 eth0 来处理（第二条 172.17.0.0 路由规则）。</p><h3 id="2-3、查看容器1在宿主机上的网络">2.3、查看容器1在宿主机上的网络</h3><p>而这个 Veth Pair 设备的另一端，则在宿主机上。我们可以通过查看宿主机的网络设备看到它，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在宿主机上</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ifconfig</span><br>...<br>docker0   Link encap:Ethernet  HWaddr 02:42:d8:e4:df:c1  <br>          inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0<br>          inet6 addr: fe80::42:d8ff:fee4:dfc1/64 Scope:Link<br>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br>          RX packets:309 errors:0 dropped:0 overruns:0 frame:0<br>          TX packets:372 errors:0 dropped:0 overruns:0 carrier:0<br> collisions:0 txqueuelen:0 <br>          RX bytes:18944 (18.9 KB)  TX bytes:8137789 (8.1 MB)<br>veth9c02e56 Link encap:Ethernet  HWaddr 52:81:0b:24:3d:da  <br>          inet6 addr: fe80::5081:bff:fe24:3dda/64 Scope:Link<br>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br>          RX packets:288 errors:0 dropped:0 overruns:0 frame:0<br>          TX packets:371 errors:0 dropped:0 overruns:0 carrier:0<br> collisions:0 txqueuelen:0 <br>          RX bytes:21608 (21.6 KB)  TX bytes:8137719 (8.1 MB)<br>          <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">brctl show</span><br>bridge name bridge id  STP enabled interfaces<br>docker0  8000.0242d8e4dfc1 no  veth9c02e56<br></code></pre></td></tr></table></figure><p>通过 ifconfig 命令的输出，我们可以看到，这个容器对应的 Veth Pair 设备，在宿主机上是一张虚拟网卡。它的名字叫作 veth9c02e56。并且，通过 brctl show 的输出，我们可以看到这张网卡被“插”在了 docker0 上。</p><h3 id="2-4、启动容器2">2.4、启动容器2</h3><p>这时候，如果我们在这台宿主机上启动另一个 Docker 容器，比如 container-2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --<span class="hljs-built_in">rm</span> --name container-2 busybox <span class="hljs-built_in">sleep</span> 14400</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">brctl show</span><br>bridge name bridge id  STP enabled interfaces<br>docker0  8000.0242d8e4dfc1 no  veth9c02e56<br>       vethb4963f3<br></code></pre></td></tr></table></figure><p>我们就会发现一个新的、名叫 vethb4963f3 的虚拟网卡，也被“插”在了 docker0 网桥上。此时，如果我们在 container-1 容器里 ping 一下 container-2 容器的 IP 地址（172.17.0.3），就会发现同一宿主机上的两个容器默认就是相互连通的。</p><h2 id="三、单机容器间网络通信的流程">三、单机容器间网络通信的流程</h2><blockquote><p>此时，我们可能会有这样的疑问，同一台主机上的容器之间是如何做到互相通信的？</p></blockquote><p>这其中的原理也非常简单，我们来详细谈论一下。</p><h3 id="3-1、路由">3.1、路由</h3><p>当我们在 container-1 容器里访问 container-2 容器的 IP 地址（比如 ping 172.17.0.3）的时候，这个目的 IP 地址会匹配到 container-1 容器里的第二条路由规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0<br></code></pre></td></tr></table></figure><p>可以看到，这条路由规则的网关（Gateway）是 0.0.0.0，这就意味着这是一条直连规则，即：凡是匹配到这条规则的 IP 包，应该经过本机的 eth0 网卡，通过二层网络直接发往目的主机。</p><h3 id="3-2、ARP广播">3.2、ARP广播</h3><p>要通过二层网络到达 container-2 容器，就需要有 172.17.0.3 这个 IP 地址对应的 MAC 地址。所以 container-1 容器的网络协议栈，就需要通过 eth0 网卡发送一个 ARP 广播，来通过 IP 地址查找对应的 MAC 地址。</p><p>我们知道，容器的 eth0 网卡，是一个 Veth Pair 设备，它的一端在这个 container-1 容器的 Network Namespace 里，而另一端则位于宿主机上（Host Namespace），并且被“插”在了宿主机的 docker0 网桥上。</p><p>一个虚拟网卡一旦被“插”在网桥上，它就会变成该网桥的“从设备”。从设备会被“剥夺”调用网络协议栈处理数据包的资格，从而“降级”成为网桥上的一个端口。而这个端口唯一的作用是：接收流入的数据包，然后把这些数据包的“生杀大权”（比如转发或者丢弃），全部交给对应的网桥。</p><p>所以，在收到这些 ARP 请求之后，docker0 网桥就会扮演二层交换机的角色，把 ARP 广播转发到其他被“插”在 docker0 上的虚拟网卡。这样，同样连接在 docker0 上的 container-2 容器的网络协议栈就会收到这个 ARP 请求，从而将 172.17.0.3 所对应的 MAC 地址回复给 container-1 容器。</p><h3 id="3-3、发送数据包">3.3、发送数据包</h3><p>在有了这个目的 MAC 地址后，container-1 容器的 eth0 网卡就可以将数据包发出去。而根据 Veth Pair 设备的原理，eth0 网卡发出的数据包会立刻出现在宿主机上的 veth9c02e56 虚拟网卡上。不过，此时这个 veth9c02e56 虚拟网卡的网络协议栈的资格已经被“剥夺”，所以这个数据包就直接流入到了 docker0 网桥里。</p><h3 id="3-4、转发数据包">3.4、转发数据包</h3><p>在这里 docker0 会扮演二层交换机的角色。此时，docker0 网桥根据数据包的目的 MAC 地址（也就是 container-2 容器的 MAC 地址），在它的 CAM 表（即交换机通过 MAC 地址学习维护的端口和 MAC 地址的对应表）里查到对应的端口（Port）为：vethb4963f3，然后把数据包发往这个端口。</p><p>而这个端口，正是 container-2 容器“插”在 docker0 网桥上的一个虚拟网卡，当然，它也是一个 Veth Pair 设备。这样，数据包会就进入到 container-2 容器的 Network Namespace 里。</p><h3 id="3-5、响应数据包">3.5、响应数据包</h3><p>所以，container-2 容器看到的情况是，它自己的 eth0 网卡上出现了流入的数据包。这样，container-2 的网络协议栈就会对请求进行处理，最后将响应（Pong）返回给 container-1。</p><h3 id="3-6、小结">3.6、小结</h3><p>我们可以把同一个宿主机上的不同容器通过 docker0 网桥进行通信的流程，总结成一幅示意图，如下所示：</p><p><img src="/img/image-20201006092259324.png" alt="image-20201006092259324"></p><p>需要注意的是，在实际的数据传递过程中，上述数据的传递在网络协议栈的不同层次上，都有 Linux 内核 Netfilter 的参与。我们可以通过打开 iptables 的 TRACE 功能查看到数据包的传输过程，具体方法如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在宿主机上执行</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo iptables -t raw -A PREROUTING -p icmp -j TRACE</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo iptables -t raw -A OUTPUT -p icmp -j TRACE</span><br></code></pre></td></tr></table></figure><p>通过上述设置，我们就可以在 /var/log/syslog 里看到数据包的传输日志了。</p><p>在熟悉了 docker0 网桥的工作方式后，我们就会明白：默认情况下，被限制在 Network Namespace 里的容器进程，实际上是通过 Veth Pair 设备 + 宿主机网桥的方式，实现跟同其他容器的数据交换。</p><p>与之类似地，当我们在一台宿主机上，访问该宿主机上的容器的 IP 地址时，这个请求的数据包，也是先根据路由规则到达 docker0 网桥，然后被转发到对应的 Veth Pair 设备，最后出现在容器里。这个过程的示意图，如下所示：</p><p><img src="/img/image-20201006100043222.png" alt="image-20201006100043222"></p><h2 id="四、跨主机容器间通信问题">四、跨主机容器间通信问题</h2><p>当一个容器想连接到另外一个宿主机时，比如：ping 10.168.0.3，它发出的请求数据包，首先经过 docker0 网桥出现在宿主机上。然后根据宿主机的路由表里的直连路由规则（10.168.0.0/24 via eth0)），对 10.168.0.3 的访问请求就会交给宿主机的 eth0 处理。</p><p>所以接下来，这个数据包就会经宿主机的 eth0 网卡转发到宿主机网络上，最终到达 10.168.0.3 对应的宿主机上。当然，这个过程的实现要求这两台宿主机本身是连通的。这个过程的示意图，如下所示：</p><p><img src="/img/image-20201006100256766.png" alt="image-20201006100256766"></p><p>因此，当我们遇到容器连不通“外网”时，应该先试试能否ping通docker网桥，然后查看一下跟docker0和Veth Pair设备相关的iptables规则是否有异常。</p><blockquote><p>这里，我们可能已经联想到了这样一个问题：如果在另外一台宿主机（比如：10.168.0.3）上，也有一个 Docker 容器。那么，我们的 container-1 容器又该如何访问它呢？</p></blockquote><p>这个问题，其实就是容器的“跨主机通信”问题。在 Docker 的默认配置下，一台宿主机上的 docker0 网桥，和其他宿主机上的 docker0 网桥，没有任何关联，它们互相之间也没办法连通。所以，连接在这些网桥上的容器，自然也没办法进行通信了。</p><p>不过，万变不离其宗。如果我们通过软件的方式，创建一个整个集群“公用”的网桥，然后把集群里的所有容器都连接到这个网桥上，不就可以相互通信了吗？这样一来，我们整个集群里的容器网络就会类似于下图所示的样子：</p><p><img src="/img/image-20201006100658954.png" alt="image-20201006100658954"></p><p>可以看到，构建这种容器网络的核心在于：我们需要在已有的宿主机网络上，再通过软件构建一个覆盖在已有宿主机网络之上的、可以把所有容器连通在一起的虚拟网络。所以，这种技术就被称为：Overlay Network（覆盖网络）。</p><p>而这个 Overlay Network 本身，可以由每台宿主机上的一个“特殊网桥”共同组成。比如，当 Node 1 上的 Container 1 要访问 Node 2 上的 Container 3 的时候，Node 1 上的“特殊网桥”在收到数据包之后，能够通过某种方式，把数据包发送到正确的宿主机，比如 Node 2 上。而 Node 2 上的“特殊网桥”在收到数据包后，也能够通过某种方式，把数据包转发给正确的容器，比如 Container 3。</p><p>甚至，每台宿主机上，都不需要有一个特殊的网桥存在，而仅仅是通过某种方式配置宿主机的路由表，就能够把数据包转发到正确的宿主机上。</p><h2 id="五、小结">五、小结</h2><p>在这篇文章中，我们主要讨论了如下概念：</p><ul><li>Linux Bridge是一个二层设备，相当于一个虚拟的交换机</li><li>Veth Pair则是一条可以将容器连接到Linux Bridge的“网线”。</li><li>单机容器间借助Linux Bridge + Veth Pair就能实现数据交换。</li><li>实现跨主机容器间通信的关键是，在已有的宿主机网络之上，构建一个可以把所有容器连接在一起的虚拟网络。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储管理6：Projected Volume</title>
    <link href="/2020/10/05/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%866%EF%BC%9AProjected%20Volume/"/>
    <url>/2020/10/05/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%866%EF%BC%9AProjected%20Volume/</url>
    
    <content type="html"><![CDATA[<p>在 Kubernetes 中，有几种特殊的 Volume，它们存在的意义不是为了存放容器里的数据，也不是用来进行容器和宿主机之间的数据交换。而是为容器提供预先定义好的数据。从容器的角度来看，这些 Volume 中的信息仿佛是被 Kubernetes“投射”（Project）到容器当中的。这正是 Projected Volume 的含义。到目前为止，Kubernetes 支持的 Projected Volume 一共有四种：</p><ul><li>Secret，存放容器要访问的加密数据。比如，数据库连接用户的用户名和密码</li><li>ConfigMap，存放容器要访问的配置信息。比如，一个 Java 应用所需的配置文件（.properties 文件）</li><li>Downward API，让容器能够直接获取到当前Pod对象本身的信息。</li><li>ServiceAccountToken，保存ServiceAccount对象的授权信息。</li></ul><h2 id="一、Secret">一、Secret</h2><p>Secret的作用是，帮我们把 Pod 想要访问的加密数据，存放到 Etcd 中。然后，我们就可以在 Pod 的容器里以挂载 Volume 的方式，访问到这些 Secret 里保存的信息。</p><h3 id="1-1、一个使用Secret的例子">1.1、一个使用Secret的例子</h3><p>Secret 最典型的使用场景，莫过于存放数据库的 Credential 信息了，比如下面这个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-projected-volume</span> <br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">test-secret-volume</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">args:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">sleep</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;86400&quot;</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-cred</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">&quot;/projected-volume&quot;</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-cred</span><br>    <span class="hljs-attr">projected:</span><br>      <span class="hljs-attr">sources:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">secret:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">user</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">secret:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">pass</span><br></code></pre></td></tr></table></figure><p>我们可以看到，这个Pod挂载了一个projected类型的Volume。而这个Volume的数据来源，是名为user和pass的两个Secret对象，它们分别对应的是数据库的用户名和密码。</p><h3 id="1-2、创建Secret对象">1.2、创建Secret对象</h3><p>创建secret对象有两种方式，命令行和yaml文件，下面我们分别来看。</p><h4 id="1-2-1、方式一：命令行">1.2.1、方式一：命令行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在文件中，以明文的形式写入用户名和密码</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> &gt; ./username.txt &lt;&lt;<span class="hljs-string">EOF</span></span><br>admin<br>EOF<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-string">cat &gt; ./password.txt &lt;&lt;EOF</span></span><br>c1oudc0w!<br>EOF<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建Secret对象</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create secret generic user --from-file=./username.txt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create secret generic pass --from-file=./password.txt</span><br></code></pre></td></tr></table></figure><p>在这里，username.txt 和 password.txt 文件里，存放的就是用户名和密码；而kubectl命令中的 user 和 pass，则是我们为 Secret 对象指定的名字。如果我们要查看这些 Secret 对象的话，只要执行一条 kubectl get 命令就可以了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get secrets</span><br>NAME           TYPE                                DATA      AGE<br>user          Opaque                                1         51s<br>pass          Opaque                                1         51s<br></code></pre></td></tr></table></figure><h4 id="1-2-2、方式二：yaml文件">1.2.2、方式二：yaml文件</h4><p>当然，除了使用 kubectl create secret 指令外，我们也可以直接通过编写 YAML 文件的方式来创建这个 Secret 对象，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">Opaque</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">user:</span> <span class="hljs-string">YWRtaW4=</span><br>  <span class="hljs-attr">pass:</span> <span class="hljs-string">MWYyZDFlMmU2N2Rm</span><br></code></pre></td></tr></table></figure><p>可以看到，通过编写 YAML 文件创建出来的 Secret 对象只有一个。但它的 data 字段，却以 Key-Value 的格式保存了两份 Secret 数据。其中，“user”就是第一份数据的 Key，“pass”则是第二份数据的 Key。</p><p>需要注意的是，Secret 对象要求这些数据必须是经过 Base64 转码的，以免出现明文密码的安全隐患。这个转码操作也很简单，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&#x27;admin&#x27;</span> | <span class="hljs-built_in">base64</span></span><br>YWRtaW4=<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&#x27;1f2d1e2e67df&#x27;</span> | <span class="hljs-built_in">base64</span></span><br>MWYyZDFlMmU2N2Rm<br></code></pre></td></tr></table></figure><p>这里需要注意的是，像这样创建的 Secret 对象，它里面的内容仅仅是经过了转码，而并没有被加密。在真正的生产环境中，我们需要在 Kubernetes 中开启 Secret 的加密插件，增强数据的安全性。</p><h3 id="1-3、创建Pod对象">1.3、创建Pod对象</h3><p>接下来，我们尝试一下创建这个 Pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f test-projected-volume.yaml</span><br></code></pre></td></tr></table></figure><p>当 Pod 变成 Running 状态之后，我们再验证一下这些 Secret 对象是不是已经在容器里了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it test-projected-volume -- /bin/sh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /projected-volume/</span><br>user<br>pass<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /projected-volume/user</span><br>admin<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /projected-volume/pass</span><br>1f2d1e2e67df<br></code></pre></td></tr></table></figure><p>从返回结果中，我们可以看到，保存在 Etcd 里的用户名和密码信息，已经以文件的形式出现在了容器的 Volume 目录里。而这个文件的名字，就是 kubectl create secret 指定的 Key，或者说是 Secret 对象的 data 字段指定的 Key。</p><h3 id="1-4、小结">1.4、小结</h3><p>Secret对象，可以为我们保存加密数据，更重要的是，它以挂载方式进入到容器里的 Secret，一旦其对应的 Etcd 里的数据被更新，这些 Volume 里的文件内容，同样也会被更新（ kubelet 组件在定时维护这些 Volume）。</p><p>需要注意的是，这个更新可能会有一定的延时。所以在编写应用程序时，在发起数据库连接的代码处写好重试和超时的逻辑，绝对是个好习惯。</p><h2 id="二、ConfigMap">二、ConfigMap</h2><p>ConfigMap 保存的是不需要加密的、应用所需的配置信息。ConfigMap 的用法几乎与 Secret 完全相同，我们可以使用 kubectl create configmap 从文件或者目录创建 ConfigMap 对象，也可以直接编写 ConfigMap 对象的 YAML 文件。</p><p>比如，一个 Java 应用所需的配置文件（.properties 文件），就可以通过下面这样的方式保存在 ConfigMap 里：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">.properties文件的内容</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> &gt; ./ui.properties &lt;&lt;<span class="hljs-string">EOF</span></span><br>color.good=purple<br>color.bad=yellow<br>allow.textmode=true<br>how.nice.to.look=fairlyNice<br>EOF<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">从.properties文件创建ConfigMap</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-string">kubectl create configmap ui-config --from-file=./ui.properties</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">查看这个ConfigMap里保存的信息(data)</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">注：kubectl get -o yaml 这样的参数，会将指定的 Pod API 对象以 YAML 的方式展示出来。</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-string">kubectl get configmaps ui-config -o yaml</span></span><br>apiVersion: v1<br>data:<br>  ui.properties: |<br>    color.good=purple<br>    color.bad=yellow<br>    allow.textmode=true<br>    how.nice.to.look=fairlyNice<br>kind: ConfigMap<br>metadata:<br>  name: ui-config<br>  ...<br></code></pre></td></tr></table></figure><h2 id="三、Downward-API">三、Downward API</h2><p>Downward API的作用是，让 Pod 里的容器能够直接获取到这个 Pod API 对象本身的信息。</p><h3 id="3-1、示例">3.1、示例</h3><p>我们来看如下示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-downwardapi-volume</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">zone:</span> <span class="hljs-string">us-est-coast</span><br>    <span class="hljs-attr">cluster:</span> <span class="hljs-string">test-cluster1</span><br>    <span class="hljs-attr">rack:</span> <span class="hljs-string">rack-22</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">client-container</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>      <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>]<br>      <span class="hljs-attr">args:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">while</span> <span class="hljs-literal">true</span><span class="hljs-string">;</span> <span class="hljs-string">do</span><br>          <span class="hljs-string">if</span> [[ <span class="hljs-string">-e</span> <span class="hljs-string">/etc/podinfo/labels</span> ]]<span class="hljs-string">;</span> <span class="hljs-string">then</span><br>            <span class="hljs-string">echo</span> <span class="hljs-string">-en</span> <span class="hljs-string">&#x27;\n\n&#x27;</span><span class="hljs-string">;</span> <span class="hljs-string">cat</span> <span class="hljs-string">/etc/podinfo/labels;</span> <span class="hljs-string">fi;</span><br>          <span class="hljs-string">sleep</span> <span class="hljs-number">5</span><span class="hljs-string">;</span><br>        <span class="hljs-string">done;</span><br>      <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">podinfo</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/podinfo</span><br>          <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">podinfo</span><br>      <span class="hljs-attr">projected:</span><br>        <span class="hljs-attr">sources:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">downwardAPI:</span><br>            <span class="hljs-attr">items:</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;labels&quot;</span><br>                <span class="hljs-attr">fieldRef:</span><br>                  <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.labels</span><br></code></pre></td></tr></table></figure><p>在这个 Pod 的 YAML 文件中，我们定义了一个简单的容器，声明了一个 projected 类型的 Volume。只不过这次 Volume 的数据来源，变成了 Downward API。而这个 Downward API Volume，则声明要暴露 Pod 的 metadata.labels 信息给容器。</p><p>通过这样的声明方式，当前 Pod 的 Labels 字段的值，就会被 Kubernetes 自动挂载成为容器里的 /etc/podinfo/labels 文件。而这个容器的启动命令，则是不断打印出 /etc/podinfo/labels 里的内容。所以，当我们创建了这个 Pod 之后，就可以通过 kubectl logs 指令，查看到这些 Labels 字段被打印出来，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f dapi-volume.yaml</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl logs test-downwardapi-volume</span><br>cluster=&quot;test-cluster1&quot;<br>rack=&quot;rack-22&quot;<br>zone=&quot;us-est-coast&quot;<br></code></pre></td></tr></table></figure><h3 id="3-2、能获取的信息">3.2、能获取的信息</h3><p>目前，Downward API 支持的字段已经非常丰富了，比如：</p><ul><li>使用fieldRef可以获取：<ul><li>spec.nodeName - 宿主机名字</li><li>status.hostIP - 宿主机IP</li><li><a href="http://metadata.name">metadata.name</a> - Pod的名字</li><li>metadata.namespace - Pod的Namespace</li><li>status.podIP - Pod的IP</li><li>spec.serviceAccountName - Pod的Service Account的名字</li><li>metadata.uid - Pod的UID</li><li>metadata.labels[‘&lt;KEY&gt;’] - 指定&lt;KEY&gt;的Label值</li><li>metadata.annotations[‘&lt;KEY&gt;’] - 指定&lt;KEY&gt;的Annotation值</li><li>metadata.labels - Pod的所有Label</li><li>metadata.annotations - Pod的所有Annotation</li></ul></li><li>使用resourceFieldRef可以获取：<ul><li>容器的CPU limit</li><li>容器的CPU request</li><li>容器的memory limit</li><li>容器的memory request</li></ul></li></ul><p>上面这个列表的内容，随着 Kubernetes 项目的发展肯定还会不断增加。不过，需要注意的是，Downward API 能够获取到的信息，一定是 Pod 里的容器进程启动之前就能够确定下来的信息。而如果我们想要获取 Pod 容器运行后才会出现的信息，比如，容器进程的 PID，那就肯定不能使用 Downward API 了，而应该考虑在 Pod 里定义一个 sidecar 容器。</p><h2 id="四、ServiceAccountToken">四、ServiceAccountToken</h2><p>假设我们现在有一个这样的需求：</p><blockquote><p>现在有了一个 Pod，我们能不能在这个 Pod 里安装一个 Kubernetes 的 Client，这样就可以从容器里直接访问并操作这个 Kubernetes 的 API ？</p></blockquote><p>这当然是可以的。不过，我们首先要解决 API Server 的授权问题。</p><h3 id="4-1、一个特殊的Secret对象">4.1、一个特殊的Secret对象</h3><p>我们需要知道的是，Service Account对象，是Kubernetes系统内置的一种“服务账户”，它是Kubernetes进行权限分配的对象。比如，Service Account A，可以只被允许对Kubernetes API进行GET操作，而Service Account B，则可以有Kubernetes API的所有操作权限。而Service Account 对象的授权信息和文件，则保存在它所绑定的一个特殊的 Secret 对象里。而这个特殊的 Secret 对象，就叫作 ServiceAccountToken。</p><p>任何运行在 Kubernetes 集群上的应用，都必须使用 ServiceAccountToken 里保存的授权信息，也就是 Token，才可以合法地访问 API Server。</p><p>所以说，Kubernetes 项目的 Projected Volume 其实只有三种，因为第四种 ServiceAccountToken，只是一种特殊的 Secret 而已。</p><h3 id="4-2、默认Service-Account">4.2、默认Service Account</h3><p>为了方便使用，Kubernetes 已经为我们提供了一个默认“服务账户”（default Service Account）。并且，任何一个运行在 Kubernetes 里的 Pod，都可以直接使用这个默认的 Service Account，而无需显示地声明挂载它。而这又是如何做到的呢？</p><p>当然还是靠 Projected Volume 机制。如果查看一下任意一个运行在 Kubernetes 集群里的 Pod，就会发现，每一个 Pod，都已经自动声明了一个类型是 Secret、名为 default-token-xxx 的 Volume，然后 自动挂载在每个容器的一个固定目录上。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe pod nginx-deployment-5c678cfb6d-lg9lw</span><br>Containers:<br>...<br>  Mounts:<br>    /var/run/secrets/kubernetes.io/serviceaccount from default-token-s8rbq (ro)<br>Volumes:<br>  default-token-s8rbq:<br>  Type:       Secret (a volume populated by a Secret)<br>  SecretName:  default-token-s8rbq<br>  Optional:    false<br></code></pre></td></tr></table></figure><p>这个 Secret 类型的 Volume，正是默认“服务账户”对应的 ServiceAccountToken。所以说，Kubernetes 其实在创建每个 Pod 的时候，自动在它的 spec.volumes 部分添加上了默认 ServiceAccountToken 的定义，然后自动给每个容器加上了对应的 volumeMounts 字段。这个过程对于用户来说是完全透明的。</p><h3 id="4-3、InClusterConfig">4.3、InClusterConfig</h3><p>一旦 Pod 创建完成，容器里的应用就可以直接从这个挂载了 ServiceAccountToken 的目录里访问到授权信息和文件。这个目录的路径在容器中是固定的，即：/var/run/secrets/kubernetes.io/serviceaccount ，而这个 Secret 类型的 Volume 里面的内容如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /var/run/secrets/kubernetes.io/serviceaccount</span> <br>ca.crt namespace  token<br></code></pre></td></tr></table></figure><p>所以，我们的应用程序只要直接加载这些授权文件，就可以访问并操作 Kubernetes API 了。而且，如果我们使用的是 Kubernetes 官方的 Client 包（<a href="http://k8s.io/client-go%EF%BC%89%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%AE%83%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E8%BF%99%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E6%88%91%E4%BB%AC%E5%81%9A%E4%BB%BB%E4%BD%95%E9%85%8D%E7%BD%AE%E6%88%96%E8%80%85%E7%BC%96%E7%A0%81%E6%93%8D%E4%BD%9C%E3%80%82">k8s.io/client-go）的话，它会自动加载这个目录下的文件，不需要我们做任何配置或者编码操作。</a></p><p>这种把 Kubernetes 客户端以容器的方式运行在集群里，然后使用 default Service Account 自动授权的方式，被称作“InClusterConfig”，它也是最推荐的进行 Kubernetes API 编程的授权方式。</p><p>当然，考虑到自动挂载默认 ServiceAccountToken 的潜在风险，Kubernetes 允许我们设置默认不为 Pod 里的容器自动挂载这个 Volume。</p><p>除了这个默认的 Service Account 外，我们很多时候还需要创建一些我们自己定义的 Service Account，来对应不同的权限设置。这样，Pod 里的容器就可以通过挂载这些 Service Account 对应的 ServiceAccountToken，来使用这些自定义的授权信息。</p><h2 id="五、小结">五、小结</h2><p>在这篇文章中，我们主要讨论了如下内容：</p><ul><li>Projected Volume的作用是，为容器提供预先设定好的数据；</li><li>Secret保存的是加密数据；</li><li>ConfigMap保存的是配置文件；</li><li>Downward API保存的是Pod本身的信息；</li><li>ServiceAccountToken，是一个特殊的Secret对象，它保存的是ServiceAccount对象的授权信息；</li></ul><p>我们需要知道的是，Secret、ConfigMap，以及 Downward API 这三种 Projected Volume 定义的信息，大多是可以通过环境变量的方式来定义。但是，通过环境变量获取这些信息的方式，不具备自动更新的能力。所以，一般情况下，建议使用 Volume 文件的方式获取这些信息。</p>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储管理5：实践Local PV</title>
    <link href="/2020/10/05/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%865%EF%BC%9A%E5%AE%9E%E8%B7%B5Local%20PV/"/>
    <url>/2020/10/05/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%865%EF%BC%9A%E5%AE%9E%E8%B7%B5Local%20PV/</url>
    
    <content type="html"><![CDATA[<p>在开始使用 Local Persistent Volume 之前，我们首先需要在集群里配置好磁盘或者块设备。在公有云上，这个操作等同于给虚拟机额外挂载一个磁盘，比如 GCE 的 Local SSD 类型的磁盘就是一个典型例子。而在我们部署的私有环境中，有两种办法来完成这个步骤。</p><ul><li><p>第一种，当然就是给宿主机挂载并格式化一个可用的本地磁盘，这也是最常规的操作；</p></li><li><p>第二种，对于实验环境，你其实可以在宿主机上挂载几个 RAM Disk（内存盘）来模拟本地磁盘。</p></li></ul><p>接下来，我们使用第二种方法，在本地实验环境的 Kubernetes 集群上进行实践。</p><h3 id="1-1、准备本地磁盘">1.1、准备本地磁盘</h3><p>首先，在名叫 node1 的宿主机上创建一个挂载点，比如 /mnt/disks；然后，用几个 RAM Disk 来模拟本地磁盘，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在node1上执行</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> /mnt/disks</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">for</span> vol <span class="hljs-keyword">in</span> vol1 vol2 vol3; <span class="hljs-keyword">do</span></span><br>    mkdir /mnt/disks/$vol<br>    mount -t tmpfs $vol /mnt/disks/$vol<br>done<br></code></pre></td></tr></table></figure><p>需要注意的是，如果我们希望其他节点也能支持 Local Persistent Volume 的话，那就需要为它们也执行上述操作，并且确保这些磁盘的名字（vol1、vol2 等）都不重复。</p><h3 id="1-2、创建PV">1.2、创建PV</h3><h4 id="1-2-1、定义PV">1.2.1、定义PV</h4><p>接下来，我们就可以为这些本地磁盘定义对应的 PV 了，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-pv</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">local:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/mnt/disks/vol1</span><br>  <span class="hljs-attr">capacity:</span><br>    <span class="hljs-attr">storage:</span> <span class="hljs-string">5Gi</span><br>  <span class="hljs-attr">accessModes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>  <span class="hljs-attr">volumeMode:</span> <span class="hljs-string">Filesystem</span><br>  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-string">Delete</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">local-storage</span><br>  <span class="hljs-attr">nodeAffinity:</span><br>    <span class="hljs-attr">required:</span><br>      <span class="hljs-attr">nodeSelectorTerms:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">matchExpressions:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">kubernetes.io/hostname</span><br>          <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>          <span class="hljs-attr">values:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">node1</span><br></code></pre></td></tr></table></figure><p>可以看到，在这个 PV 的定义里：local 字段，指定了它是一个 Local Persistent Volume；而 path 字段，指定的正是这个 PV 对应的本地磁盘的路径，即：/mnt/disks/vol1。当然了，这也就意味着如果 Pod 要想使用这个 PV，那它就必须运行在 node1 上。所以，在这个 PV 的定义里，需要有一个 nodeAffinity 字段指定 node1 这个节点的名字。这样，调度器在调度 Pod 的时候，就能够知道PV 与节点的对应关系，从而做出正确的选择。这正是 Kubernetes 实现“在调度的时候就考虑 Volume 分布”的主要方法。</p><h4 id="1-2-2、创建PV">1.2.2、创建PV</h4><p>接下来，我们就可以使用 kubectl create 来创建这个 PV，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f local-pv.yaml</span> <br>persistentvolume/example-pv created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pv</span><br>NAME         CAPACITY   ACCESS MODES   RECLAIM POLICY  STATUS      CLAIM             STORAGECLASS    REASON    AGE<br>example-pv   5Gi        RWO            Delete           Available                     local-storage             16s<br></code></pre></td></tr></table></figure><p>可以看到，这个 PV 创建后，进入了 Available（可用）状态。</p><h3 id="1-3、创建StorageClass">1.3、创建StorageClass</h3><p>正如我们在前面的文章中所建议的那样，使用 PV 和 PVC 的最佳实践，是要创建一个 StorageClass 来描述这个 PV.</p><h4 id="1-3-1、定义StorageClass">1.3.1、定义StorageClass</h4><p>首先，我们定义StorageClass，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">StorageClass</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">storage.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">local-storage</span><br><span class="hljs-attr">provisioner:</span> <span class="hljs-string">kubernetes.io/no-provisioner</span><br><span class="hljs-attr">volumeBindingMode:</span> <span class="hljs-string">WaitForFirstConsumer</span><br></code></pre></td></tr></table></figure><p>这个 StorageClass 的名字，叫作 local-storage。需要注意的是，在它的 provisioner 字段，我们指定的是 no-provisioner。这是因为 Local Persistent Volume 目前尚不支持 Dynamic Provisioning，所以它没办法在用户创建 PVC 的时候，就自动创建出对应的 PV。也就是说，我们前面创建 PV 的操作，是不可以省略的。</p><p>在这个 StorageClass 中还定义了一个 volumeBindingMode=WaitForFirstConsumer 的属性。它是 Local Persistent Volume 里一个非常重要的特性，即：延迟绑定。</p><h4 id="1-3-2、理解延迟绑定机制">1.3.2、理解延迟绑定机制</h4><p>我们知道，当我们提交了 PV 和 PVC 的 YAML 文件之后，Kubernetes 就会根据它们俩的属性，以及它们指定的 StorageClass 来进行绑定。只有绑定成功后，Pod 才能通过声明这个 PVC 来使用对应的 PV。可是，如果使用的是 Local Persistent Volume 的话，就会发现，这个流程根本行不通。</p><p>比如，现在我们有一个 Pod，它声明使用的 PVC 叫作 pvc1。并且，我们规定，这个 Pod 只能运行在 node2 上。而在 Kubernetes 集群中，有两个属性（比如：大小、读写权限）相同的 Local 类型的 PV。其中，第一个 PV 的名字叫作 pv1，它对应的磁盘所在的节点是 node1。而第二个 PV 的名字叫作 pv2，它对应的磁盘所在的节点是 node2。</p><p>假设现在，Kubernetes 的 Volume 控制循环里，首先检查到了 pvc1 和 pv1 的属性是匹配的，于是就将它们俩绑定在一起。然后，我们用 kubectl create 创建了这个 Pod。这时候，问题就出现了。调度器看到，这个 Pod 所声明的 pvc1 已经绑定了 pv1，而 pv1 所在的节点是 node1，根据“调度器必须在调度的时候考虑 Volume 分布”的原则，这个 Pod 自然会被调度到 node1 上。可是，我们前面已经规定过，这个 Pod 根本不允许运行在 node1 上。所以。最后的结果就是，这个 Pod 的调度必然会失败。这就是为什么，在使用 Local Persistent Volume 的时候，我们必须想办法推迟这个“绑定”操作。</p><blockquote><p>那么，具体推迟到什么时候呢？</p></blockquote><p>答案是：推迟到调度的时候。</p><p>所以说，StorageClass 里的 volumeBindingMode=WaitForFirstConsumer 的含义，就是告诉 Kubernetes 里的 Volume 控制循环：虽然我们已经发现这个 StorageClass 关联的 PVC 与 PV 可以绑定在一起，但请不要现在就执行绑定操作（即：设置 PVC 的 VolumeName 字段）。而要等到第一个声明使用该 PVC 的 Pod 在调度器中出现后，调度器再综合考虑所有的调度规则，当然也包括每个 PV 所在的节点位置，来统一决定，这个 Pod 声明的 PVC，到底应该跟哪个 PV 进行绑定。</p><p>这样，在上面的例子里，由于这个 Pod 不允许运行在 pv1 所在的节点 node1，所以它的 PVC 最后会跟 pv2 绑定，并且 Pod 也会被调度到 node2 上。所以，通过这个延迟绑定机制，原本实时发生的 PVC 和 PV 的绑定过程，就被延迟到了 Pod 第一次调度的时候在调度器中进行，从而保证了这个绑定结果不会影响 Pod 的正常调度。</p><p>当然，在具体实现中，调度器实际上维护了一个与 Volume Controller 类似的控制循环，专门负责为那些声明了“延迟绑定”的 PV 和 PVC 进行绑定工作。通过这样的设计，这个额外的绑定操作，并不会拖慢调度器的性能。而当一个 Pod 的 PVC 尚未完成绑定时，调度器也不会等待，而是会直接把这个 Pod 重新放回到待调度队列，等到下一个调度周期再做处理。</p><h4 id="1-3-3、创建StorageClass">1.3.3、创建StorageClass</h4><p>在明白了这个机制之后，我们就可以创建 StorageClass 了，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f local-sc.yaml</span> <br>storageclass.storage.k8s.io/local-storage created<br></code></pre></td></tr></table></figure><h3 id="1-4、创建PVC">1.4、创建PVC</h3><p>接下来，我们只需要定义一个非常普通的 PVC，就可以让 Pod 使用到上面定义好的 Local Persistent Volume 了</p><h4 id="1-4-1、定义PVC">1.4.1、定义PVC</h4><p>PVC的定义如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-local-claim</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">5Gi</span><br>  <span class="hljs-attr">accessModes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">local-storage</span><br></code></pre></td></tr></table></figure><p>可以看到，这个 PVC 没有任何特别的地方。唯一需要注意的是，它声明的 storageClassName 是 local-storage。所以，将来 Kubernetes 的 Volume Controller 在看到这个 PVC 的时候，不会为它进行绑定操作。</p><h4 id="1-4-2、创建PVC">1.4.2、创建PVC</h4><p>现在，我们来创建这个 PVC：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f local-pvc.yaml</span> <br>persistentvolumeclaim/example-local-claim created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pvc</span><br>NAME                  STATUS    VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS    AGE<br>example-local-claim   Pending                                       local-storage   7s<br></code></pre></td></tr></table></figure><p>可以看到，尽管这个时候，Kubernetes 里已经存在了一个可以与 PVC 匹配的 PV，但这个 PVC 依然处于 Pending 状态，也就是等待绑定的状态。</p><h3 id="1-5、创建Pod">1.5、创建Pod</h3><h4 id="1-5-1、定义Pod">1.5.1、定义Pod</h4><p>然后，我们编写一个 Pod 来声明使用这个 PVC，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-pv-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">example-pv-storage</span><br>      <span class="hljs-attr">persistentVolumeClaim:</span><br>       <span class="hljs-attr">claimName:</span> <span class="hljs-string">example-local-claim</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">example-pv-container</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>      <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;http-server&quot;</span><br>      <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">&quot;/usr/share/nginx/html&quot;</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">example-pv-storage</span><br></code></pre></td></tr></table></figure><p>这个 Pod 没有任何特别的地方，我们只需要注意，它的 volumes 字段声明要使用前面定义的、名叫 example-local-claim 的 PVC 即可。</p><h4 id="1-5-2、创建Pod">1.5.2、创建Pod</h4><p>我们一旦使用 kubectl create 创建这个 Pod，就会发现，我们前面定义的 PVC，会立刻变成 Bound 状态，与前面定义的 PV 绑定在了一起，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f local-pod.yaml</span> <br>pod/example-pv-pod created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pvc</span><br>NAME                  STATUS    VOLUME       CAPACITY   ACCESS MODES   STORAGECLASS    AGE<br>example-local-claim   Bound     example-pv   5Gi        RWO            local-storage   6h<br></code></pre></td></tr></table></figure><p>也就是说，在我们创建的 Pod 进入调度器之后，“绑定”操作才开始进行。</p><h3 id="1-6、测试Local-PV的持久性">1.6、测试Local PV的持久性</h3><p>这时候，我们可以尝试在这个 Pod 的 Volume 目录里，创建一个测试文件，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it example-pv-pod -- /bin/sh</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cd</span> /usr/share/nginx/html</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">touch</span> test.txt</span><br></code></pre></td></tr></table></figure><p>然后，登录到 node1 这台机器上，查看一下它的 /mnt/disks/vol1 目录下的内容，你就可以看到刚刚创建的这个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在node1上</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /mnt/disks/vol1</span><br>test.txt<br></code></pre></td></tr></table></figure><p>而如果我们重新创建这个 Pod 的话，就会发现，我们之前创建的测试文件，依然被保存在这个持久化 Volume 当中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete -f local-pod.yaml</span> <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f local-pod.yaml</span> <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it example-pv-pod -- /bin/sh</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">ls</span> /usr/share/nginx/html</span><br>test.txt<br></code></pre></td></tr></table></figure><p>这就说明，像 Kubernetes 这样构建出来的、基于本地存储的 Volume，完全可以提供容器持久化存储的功能。所以，像 StatefulSet 这样的有状态编排工具，也完全可以通过声明 Local 类型的 PV 和 PVC，来管理应用的存储状态。</p><h3 id="1-7、删除Local-PV的流程">1.7、删除Local PV的流程</h3><p>需要注意的是，我们上面手动创建 PV 的方式，即 Static 的 PV 管理方式，在删除 PV 时需要按如下流程执行操作：</p><ul><li><p>删除使用这个 PV 的 Pod；</p></li><li><p>从宿主机移除本地磁盘（比如，umount 它）；</p></li><li><p>删除 PVC；</p></li><li><p>删除 PV。</p></li></ul><p>如果不按照这个流程的话，这个 PV 的删除就会失败。</p><h3 id="1-8、自动化">1.8、自动化</h3><p>由于上面这些创建 PV 和删除 PV 的操作比较繁琐，Kubernetes 提供了一个 Static Provisioner 来帮助我们管理这些 PV。比如，我们所有的磁盘，都挂载在宿主机的 /mnt/disks 目录下。那么，当 Static Provisioner 启动后，它就会通过 DaemonSet，自动检查每个宿主机的 /mnt/disks 目录。然后，调用 Kubernetes API，为这些目录下面的每一个挂载，创建一个对应的 PV 对象出来。这些自动创建的 PV，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pv</span><br>NAME                CAPACITY    ACCESSMODES   RECLAIMPOLICY   STATUS      CLAIM     STORAGECLASS    REASON    AGE<br>local-pv-ce05be60   1024220Ki   RWO           Delete          Available             local-storage             26s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe pv local-pv-ce05be60</span> <br>Name:  local-pv-ce05be60<br>...<br>StorageClass: local-storage<br>Status:  Available<br>Claim:  <br>Reclaim Policy: Delete<br>Access Modes: RWO<br>Capacity: 1024220Ki<br>NodeAffinity:<br>  Required Terms:<br>      Term 0:  kubernetes.io/hostname in [node-1]<br>Message: <br>Source:<br>    Type: LocalVolume (a persistent volume backed by local storage on a node)<br>    Path: /mnt/disks/vol1<br></code></pre></td></tr></table></figure><p>这个 PV 里的各种定义，比如 StorageClass 的名字、本地磁盘挂载点的位置，都可以通过 provisioner 的配置文件指定。当然，provisioner 也会负责前面提到的 PV 的删除工作。而这个 provisioner 本身，其实是一个<a href="https://github.com/kubernetes-csi/external-provisioner">External Provisioner</a>。</p><h3 id="1-9、参考">1.9、参考</h3><p><a href="https://time.geekbang.org/column/intro/100015201">https://time.geekbang.org/column/intro/100015201</a></p>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储管理4：理解Local PV</title>
    <link href="/2020/10/05/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%864%EF%BC%9A%E7%90%86%E8%A7%A3Local%20PV/"/>
    <url>/2020/10/05/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%864%EF%BC%9A%E7%90%86%E8%A7%A3Local%20PV/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们都是基于一个外部的存储服务来提供PV。此时，我们可能有这样的疑问：能否直接使用宿主机上的目录或磁盘作为PV呢？答案是肯定的。这就是我们今天就要讨论的主题：Local Persistent Volume。</p><h3 id="1-1、什么是Local-PV">1.1、什么是Local PV</h3><p>Kubernetes 支持直接使用宿主机上目录或磁盘，而不依赖于远程存储服务来提供“持久化”的 Volume。这样做的好处显而易见：由于这个 Volume 直接使用的是本地磁盘，尤其是 SSD 盘，它的读写性能相比于大多数远程存储来说，要好得多。这个需求对部署在本地物理服务器上的私有 Kubernetes 集群来说，非常常见。所以，Kubernetes 在 v1.10 之后，就逐渐依靠 PV、PVC 体系实现了这个特性。这个特性的名字叫作：Local Persistent Volume。</p><p>这里，我们需要知道的是，Local Persistent Volume 并不适用于所有应用。事实上，它的适用范围非常固定，比如：高优先级的系统应用，需要在多个不同节点上存储数据，并且对 I/O 较为敏感。典型的应用包括：分布式数据存储比如 MongoDB、Cassandra 等，分布式文件系统比如 GlusterFS、Ceph 等，以及需要在本地磁盘上进行大量数据缓存的分布式应用。</p><p>相比于正常的 PV，一旦节点宕机且不能恢复时，Local Persistent Volume 的数据就可能丢失。这就要求使用 Local Persistent Volume 的应用必须具备数据备份和恢复的能力，允许我们把这些数据定时备份在其他位置。</p><h3 id="1-2、实现Local-PV的难点">1.2、实现Local PV的难点</h3><p>Local Persistent Volume 的设计，主要面临两个难点。</p><blockquote><p>第一个难点在于：如何把本地目录或磁盘抽象成 PV？</p></blockquote><p>此时，我们可能会有这样的想法，Local Persistent Volume，不就等同于 hostPath 加 NodeAffinity 吗？比如，一个 Pod 可以声明类型为 Local 的 PV，而这个 PV 其实就是一个 hostPath 类型的 Volume。如果这个 hostPath 对应的目录，已经在节点 A 上被事先创建好了。那么，我们只需要再给这个 Pod 加上一个 nodeAffinity=nodeA，不就可以使用这个 Volume 了吗？</p><p>这样使用确实没有问题，但在生产环境中，我们绝不应该把一个宿主机上的目录当作 PV 使用。这是因为，这种本地目录的存储行为完全不可控：它所在的磁盘随时都可能被应用写满，甚至造成整个宿主机宕机。而且，不同的本地目录之间也缺乏哪怕最基础的 I/O 隔离机制。所以，一个 Local Persistent Volume 对应的存储介质，一定是一块额外挂载在宿主机上的磁盘或者块设备（“额外”的意思是，它不应该是宿主机根目录所使用的主硬盘）。这个原则，我们可以称为“一个 PV 一块盘”。</p><blockquote><p>第二个难点在于：如何保证 Pod 始终被调度到正确的节点上？</p></blockquote><p>对于常规的 PV 来说，Kubernetes 都是先调度 Pod 到某个节点上，然后，再通过“两阶段处理”来“持久化”这台机器上的 Volume 目录，进而完成 Volume 目录与容器的绑定挂载。可是，对于 Local PV 来说，节点上可供使用的磁盘（或者块设备），必须是事先提前准备好的。它们在不同节点上的挂载情况可以完全不同，甚至有的节点可以没这种磁盘。</p><p>所以，这时候，调度器就必须能够知道所有节点与 Local Persistent Volume 对应的磁盘的关联关系，然后根据这个信息来调度 Pod。这个原则，我们可以称为“在调度的时候考虑 Volume 分布”。在 Kubernetes 的调度器里，有一个叫作 VolumeBindingChecker 的过滤条件专门负责这个事情。在 Kubernetes v1.11 中，这个过滤条件已经默认开启了。</p><h3 id="1-3、小结">1.3、小结</h3><p>在这篇文章中，我们主要讨论了如下内容：</p><ul><li>Local PV 就是将宿主机上的目录或磁盘作为PV，而无需一个额外的外部存储服务。</li><li>Local PV常常应用于对IO较为敏感的数据服务，比如，分布式数据存储、分布式文件系统、以及需要在本地磁盘上缓存数据的分布式应用。</li><li>Local PV所在节点一旦宕机且不能恢复时，会存在数据丢失问题，因此使用Local的应用必须具备数据备份和恢复的能力。</li><li>实现Local PV的难点在于：如何把本地目录或磁盘抽象成PV，以及如何保证Pod始终能被调度到正确的节点上。</li></ul><h3 id="1-4、参考">1.4、参考</h3><p><a href="https://time.geekbang.org/column/intro/100015201">https://time.geekbang.org/column/intro/100015201</a></p>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储管理3：理解StorageClass</title>
    <link href="/2020/10/05/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%863%EF%BC%9A%E7%90%86%E8%A7%A3StorageClass/"/>
    <url>/2020/10/05/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%863%EF%BC%9A%E7%90%86%E8%A7%A3StorageClass/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们通过手动方式创建出了所需要的PV。接下来，我们来看一种自动创建PV的方式。</p><h3 id="1-1、Static-Provisioning-Dynamic-Provisioning">1.1、Static Provisioning &amp; Dynamic Provisioning</h3><p>在一个大规模的Kubernetes集群中，集群用户可能会创建出成千上万个PVC，这时，集群管理员就需要不停地创建出满足一定条件的PV，否则新Pod就会因为PVC无法绑定PV而运行失败。显然，在实际操作中，完全依靠人工是不实现的。</p><p>Kubernetes 为我们提供了一套可以自动创建 PV 的机制，即：Dynamic Provisioning。与之对应的，人工创建 PV 的方式就叫作 Static Provisioning。而Dynamic Provisioning的核心，就在于一个名叫StorageClass的API对象。</p><h3 id="1-2、理解StorageClass对象">1.2、理解StorageClass对象</h3><p>StorageClass对象是一个用来自动创建PV的模板。具体来说，一个StorageClass对象通常会定义如下两部分内容：</p><ul><li><p>创建PV需要用到的存储插件。比如，Ceph等</p></li><li><p>PV的属性。比如，Volume大小等</p></li></ul><p>一旦有了这两个信息，kubernetes就能够根据用户提交的PVC，找到一个对应的StorageClass。然后，Kubernetes就会调用该StorageClass声明的存储插件，创建出所需要的PV。</p><p>下面我们通过一个示例来实践StorageClass对象的使用。</p><h4 id="1-2-1、创建StorageClass对象">1.2.1、创建StorageClass对象</h4><p>在这里，我们通过部署在本地的Kubernetes集群以及Rook存储服务来创建StorageClass对象。定义的内容如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">ceph.rook.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">CephBlockPool</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">replicapool</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">rook-ceph</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">failureDomain:</span> <span class="hljs-string">host</span><br>  <span class="hljs-attr">replicated:</span><br>    <span class="hljs-attr">size:</span> <span class="hljs-number">3</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">storage.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StorageClass</span><br><span class="hljs-attr">metadata:</span><br>   <span class="hljs-attr">name:</span> <span class="hljs-string">rook-ceph-block</span><br><span class="hljs-comment"># Change &quot;rook-ceph&quot; provisioner prefix to match the operator namespace if needed</span><br><span class="hljs-attr">provisioner:</span> <span class="hljs-string">rook-ceph.rbd.csi.ceph.com</span><br><span class="hljs-attr">parameters:</span><br>    <span class="hljs-comment"># clusterID is the namespace where the rook cluster is running</span><br>    <span class="hljs-attr">clusterID:</span> <span class="hljs-string">rook-ceph</span><br>    <span class="hljs-comment"># Ceph pool into which the RBD image shall be created</span><br>    <span class="hljs-attr">pool:</span> <span class="hljs-string">replicapool</span><br><br>    <span class="hljs-comment"># (optional) mapOptions is a comma-separated list of map options.</span><br>    <span class="hljs-comment"># For krbd options refer</span><br>    <span class="hljs-comment"># https://docs.ceph.com/docs/master/man/8/rbd/#kernel-rbd-krbd-options</span><br>    <span class="hljs-comment"># For nbd options refer</span><br>    <span class="hljs-comment"># https://docs.ceph.com/docs/master/man/8/rbd-nbd/#options</span><br>    <span class="hljs-comment"># mapOptions: lock_on_read,queue_depth=1024</span><br><br>    <span class="hljs-comment"># (optional) unmapOptions is a comma-separated list of unmap options.</span><br>    <span class="hljs-comment"># For krbd options refer</span><br>    <span class="hljs-comment"># https://docs.ceph.com/docs/master/man/8/rbd/#kernel-rbd-krbd-options</span><br>    <span class="hljs-comment"># For nbd options refer</span><br>    <span class="hljs-comment"># https://docs.ceph.com/docs/master/man/8/rbd-nbd/#options</span><br>    <span class="hljs-comment"># unmapOptions: force</span><br><br>    <span class="hljs-comment"># RBD image format. Defaults to &quot;2&quot;.</span><br>    <span class="hljs-attr">imageFormat:</span> <span class="hljs-string">&quot;2&quot;</span><br><br>    <span class="hljs-comment"># RBD image features. Available for imageFormat: &quot;2&quot;. CSI RBD currently supports only `layering` feature.</span><br>    <span class="hljs-attr">imageFeatures:</span> <span class="hljs-string">layering</span><br><br>    <span class="hljs-comment"># The secrets contain Ceph admin credentials.</span><br>    <span class="hljs-attr">csi.storage.k8s.io/provisioner-secret-name:</span> <span class="hljs-string">rook-csi-rbd-provisioner</span><br>    <span class="hljs-attr">csi.storage.k8s.io/provisioner-secret-namespace:</span> <span class="hljs-string">rook-ceph</span><br>    <span class="hljs-attr">csi.storage.k8s.io/controller-expand-secret-name:</span> <span class="hljs-string">rook-csi-rbd-provisioner</span><br>    <span class="hljs-attr">csi.storage.k8s.io/controller-expand-secret-namespace:</span> <span class="hljs-string">rook-ceph</span><br>    <span class="hljs-attr">csi.storage.k8s.io/node-stage-secret-name:</span> <span class="hljs-string">rook-csi-rbd-node</span><br>    <span class="hljs-attr">csi.storage.k8s.io/node-stage-secret-namespace:</span> <span class="hljs-string">rook-ceph</span><br><br>    <span class="hljs-comment"># Specify the filesystem type of the volume. If not specified, csi-provisioner</span><br>    <span class="hljs-comment"># will set default as `ext4`. Note that `xfs` is not recommended due to potential deadlock</span><br>    <span class="hljs-comment"># in hyperconverged settings where the volume is mounted on the same node as the osds.</span><br>    <span class="hljs-attr">csi.storage.k8s.io/fstype:</span> <span class="hljs-string">ext4</span><br><br><span class="hljs-comment"># Delete the rbd volume when a PVC is deleted</span><br><span class="hljs-attr">reclaimPolicy:</span> <span class="hljs-string">Delete</span><br><br><span class="hljs-comment"># Optional, if you want to add dynamic resize for PVC. Works for Kubernetes 1.14+</span><br><span class="hljs-comment"># For now only ext3, ext4, xfs resize support provided, like in Kubernetes itself.</span><br><span class="hljs-attr">allowVolumeExpansion:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>在这个 YAML 文件中，我们定义了一个名叫 block-service 的 StorageClass。这个 StorageClass 的 provisioner 字段的值是：<a href="http://ceph.rook.io/block%EF%BC%8C%E5%8D%B3%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AD%98%E5%82%A8%E6%8F%92%E4%BB%B6%E6%98%AFRook%E3%80%82%E6%9C%89%E5%85%B3%E5%AE%9A%E4%B9%89StorageClass%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF%E5%8F%AF%E5%8F%82%E8%80%83kubernetes">ceph.rook.io/block，即我们使用的存储插件是Rook。有关定义StorageClass对象的更多信息可参考kubernetes</a><a href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/">官方文档</a>。</p><h4 id="1-2-2、创建PVC">1.2.2、创建PVC</h4><p>创建好StorageClass对象之后，我们只需要在PVC中指定要使用的StorageClass的名字即可，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">claim1</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">30Gi</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">rook-ceph-block</span><br></code></pre></td></tr></table></figure><p>可以看到，在这个 PVC 对象中添加了一个叫作 storageClassName 的字段，它指定了该 PVC 所要使用的 StorageClass 是：block-service。当我们创建好这个PVC后，它就会和一个由kubernetes自动创建的PV相绑定，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">kubectl</span> <span class="hljs-string">describe</span> <span class="hljs-string">pvc</span> <span class="hljs-string">claim1</span> <br><span class="hljs-attr">Name:</span>          <span class="hljs-string">claim1</span><br><span class="hljs-attr">Namespace:</span>     <span class="hljs-string">default</span><br><span class="hljs-attr">StorageClass:</span>  <span class="hljs-string">rook-ceph-block</span><br><span class="hljs-attr">Status:</span>        <span class="hljs-string">Bound</span><br><span class="hljs-attr">Volume:</span>        <span class="hljs-string">pvc-312466a1-ad30-4d28-9d4a-088085fc5115</span><br><span class="hljs-attr">Labels:</span>        <span class="hljs-string">&lt;none&gt;</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><h4 id="1-2-3、查看PV">1.2.3、查看PV</h4><p>通过查看这个自动创建出来的 PV 的属性，我们就可以看到它跟我们在 PVC 里声明的存储的属性是一致的，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"> <span class="hljs-string">kubectl</span> <span class="hljs-string">describe</span> <span class="hljs-string">pv</span> <span class="hljs-string">pvc-312466a1-ad30-4d28-9d4a-088085fc5115</span><br><span class="hljs-attr">Name:</span>            <span class="hljs-string">pvc-312466a1-ad30-4d28-9d4a-088085fc5115</span><br><span class="hljs-attr">Labels:</span>          <span class="hljs-string">&lt;none&gt;</span><br><span class="hljs-attr">Annotations:     pv.kubernetes.io/provisioned-by:</span> <span class="hljs-string">rook-ceph.rbd.csi.ceph.com</span><br><span class="hljs-attr">Finalizers:</span>      [<span class="hljs-string">kubernetes.io/pv-protection</span>]<br><span class="hljs-attr">StorageClass:</span>    <span class="hljs-string">rook-ceph-block</span><br><span class="hljs-attr">Status:</span>          <span class="hljs-string">Bound</span><br><span class="hljs-attr">Claim:</span>           <span class="hljs-string">default/claim1</span><br><span class="hljs-attr">Reclaim Policy:</span>  <span class="hljs-string">Delete</span><br><span class="hljs-attr">Access Modes:</span>    <span class="hljs-string">RWO</span><br><span class="hljs-attr">VolumeMode:</span>      <span class="hljs-string">Filesystem</span><br><span class="hljs-attr">Capacity:</span>        <span class="hljs-string">30Gi</span><br><span class="hljs-attr">Node Affinity:</span>   <span class="hljs-string">&lt;none&gt;</span><br><span class="hljs-attr">Message:</span>         <br><span class="hljs-attr">Source:</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>此外，我们还可以看到，这个自动创建出来的 PV 的 StorageClass 字段的值，也是 block-service。这是因为，Kubernetes 只会将 StorageClass 相同的 PVC 和 PV 绑定起来。</p><h4 id="1-2-4、小结">1.2.4、小结</h4><p>在有了 Dynamic Provisioning 后，集群管理员只需要在 Kubernetes 集群里创建出数量有限的 StorageClass 对象就可以了。这就好比，运维人员在 Kubernetes 集群里创建出了各种各样的 PV 模板。后续，当开发人员提交了包含 StorageClassName 字段的 PVC 之后，Kubernetes 就会根据这个 StorageClass 创建出对应的 PV。</p><p>在 Kubernetes 的官方文档里已经列出了默认所支持的 Dynamic Provisioning 存储插件。对于不在文档里的插件，比如 NFS，或者其他非内置存储插件，我们其实可以通过kubernetes-incubator/external-storage这个库来自己编写一个外部插件完成这个工作。就如同 Rook一样，因为它内置了 external-storage 的实现，所以 Rook 是完全支持 Dynamic Provisioning 特性的。</p><p>需要注意的是，StorageClass 对象并不是专门为了 Dynamic Provisioning 而设计的。比如，在前面的文章中，我们在 PV 和 PVC 里都声明了 storageClassName=manual。而我们的集群里，实际上并没有一个名叫 manual 的 StorageClass 对象。但这完全没有问题，此时 Kubernetes 进行的是 Static Provisioning，但在做绑定决策的时候，它依然会考虑 PV 和 PVC 的 StorageClass 定义。这么做的好处也很明显：这个 PVC 和 PV 的绑定关系，完全在我们自己的掌控之中。</p><p>此外，如果集群开启了一个名叫 DefaultStorageClass 的 Admission Plugin，那么它就会为 PVC 和 PV 自动添加一个默认的 StorageClass；否则，PVC 的 storageClassName 的值就是“”，这也意味着它只能够跟 storageClassName 也是“”的 PV 进行绑定。</p><h3 id="1-3、小结">1.3、小结</h3><p>根据持久化存储的创建方式，Kubernetes将存储管理抽象成静态供应（Static Provisioning）和动态供应（Dynamic Provisioning）两种类型。其中：</p><ul><li>Static Provisioning是一种手动管理方式，创建PVC的同时需要手动创建相应的PV，适用于较小规模的集群；</li><li>Dynamic Provisioning则是一种动态管理方式，其核心是Storage Class对象。一个Storage Class对象就是一个事先创建好的PV模板，后续一旦有PVC提交，kubernetes就会通过相应Storage Class对象所声明的存储插件创建出满足条件的PV，适用于大规模集群。</li></ul><h3 id="1-4、参考">1.4、参考</h3><p><a href="https://time.geekbang.org/column/intro/100015201">https://time.geekbang.org/column/intro/100015201</a></p><p><a href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/">https://kubernetes.io/zh/docs/concepts/storage/storage-classes/</a></p>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储管理2：Kubernetes是如何准备持久化目录的</title>
    <link href="/2020/10/05/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%862%EF%BC%9AKubernetes%E6%98%AF%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E6%8C%81%E4%B9%85%E5%8C%96%E7%9B%AE%E5%BD%95%E7%9A%84/"/>
    <url>/2020/10/05/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%862%EF%BC%9AKubernetes%E6%98%AF%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E6%8C%81%E4%B9%85%E5%8C%96%E7%9B%AE%E5%BD%95%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>我们要知道的是，所谓的容器Volume，其实就是将宿主机上的一个目录，跟容器中的一个目录绑定挂载在一起。而所谓的“持久化Volume”，指的就是宿主机上的目录具备“持久性”。即，这个目录里的内容，即不会因为容器的删除而被清理掉，也不会跟当前的宿主机绑定。这样，当容器被重启或者在其它节点上重建，它仍然能通过挂载这个Volume，访问到这些内容。</p><p>那么，在Kubernetes中又是如何准备持久化目录的呢？</p><h3 id="1-1、两阶段处理">1.1、两阶段处理</h3><p>首先，我们需要知道的是，当一个 Pod 被调度到一个节点上之后，kubelet 就要负责为这个 Pod 创建它的 Volume 目录。默认情况下，kubelet 为 Volume 创建的目录是如下所示的一个宿主机上的路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/var/lib/kubelet/pods/&lt;Pod的ID&gt;/volumes/kubernetes.io~&lt;Volume类型&gt;/&lt;Volume名字&gt;<br></code></pre></td></tr></table></figure><p>接下来，kubelet 要做的操作就取决于Volume 的类型了。下面我们分别讨论。</p><h4 id="1-1-1、远程块存储">1.1.1、远程块存储</h4><p>如果我们的 Volume 类型是远程块存储，比如 Google Cloud 的 Persistent Disk（GCE 提供的远程磁盘服务），那么 kubelet 就需要先调用 Goolge Cloud 的 API，将它所提供的 Persistent Disk 挂载到 Pod 所在的宿主机上。这相当于执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcloud compute instances attach-disk &lt;虚拟机名字&gt; --disk &lt;远程磁盘名字&gt;</span><br></code></pre></td></tr></table></figure><p>这一步挂载远程磁盘的操作，对应的正是“两阶段处理”的第一阶段。在 Kubernetes 中，我们把这个阶段称为 Attach。</p><p>Attach阶段完成后，为了能够使用这个远程磁盘，kubelet 还要进行第二个操作，即：格式化这个磁盘设备，然后将它挂载到宿主机指定的挂载点（Volume 的宿主机目录）上。这一步相当于执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">通过lsblk命令获取磁盘设备ID</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo lsblk</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式化成ext4格式</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo mkfs.ext4 -m 0 -F -E lazy_itable_init=0,lazy_journal_init=0,discard /dev/&lt;磁盘设备ID&gt;</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载到挂载点</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">mkdir</span> -p /var/lib/kubelet/pods/&lt;Pod的ID&gt;/volumes/kubernetes.io~&lt;Volume类型&gt;/&lt;Volume名字&gt;</span><br></code></pre></td></tr></table></figure><p>这个将磁盘设备格式化并挂载到 Volume 宿主机目录的操作，对应的正是“两阶段处理”的第二个阶段，我们一般称为：Mount。这个阶段完成后，这个 Volume 的宿主机目录就是一个“持久化”的目录了，容器在它里面写入的内容，会保存在 Google Cloud 的远程磁盘中。</p><h4 id="1-1-2、远程文件存储">1.1.2、远程文件存储</h4><p>如果我们的 Volume 类型是远程文件存储（比如 NFS）的话，kubelet 的处理过程就会更简单一些。</p><p>在这种场景下，kubelet 可以跳过“第一阶段”（Attach）的操作，这是因为一般来说，远程文件存储并没有一个“存储设备”需要挂载在宿主机上。所以，kubelet 会直接从“第二阶段”（Mount）开始，准备宿主机上的 Volume 目录。在这一步中，kubelet 需要作为 client，将远端 NFS 服务器的目录（比如：“/”目录），挂载到 Volume 的宿主机目录上，即相当于执行如下所示的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mount -t nfs &lt;NFS服务器地址&gt;:/ /var/lib/kubelet/pods/&lt;Pod的ID&gt;/volumes/kubernetes.io~&lt;Volume类型&gt;/&lt;Volume名字&gt;</span><br></code></pre></td></tr></table></figure><p>通过这个挂载操作，Volume 的宿主机目录就成为了一个远程 NFS 目录的挂载点，后面我们在这个目录里写入的所有文件，都会被保存在远程 NFS 服务器上。所以，我们也就完成了对这个 Volume 宿主机目录的“持久化”。</p><h4 id="1-1-3、如何定义和区分两阶段">1.1.3、如何定义和区分两阶段</h4><p>到了这里，我们可能会有这样的疑问：</p><blockquote><p>Kubernetes 又是如何定义和区分这两个阶段的呢？</p></blockquote><p>其实很简单，在具体的 Volume 插件的接口实现上，Kubernetes 分别给这两个阶段提供了两种不同的参数列表：</p><ul><li><p>对于“第一阶段”（Attach），Kubernetes 提供的可用参数是 nodeName，即宿主机的名字。</p></li><li><p>对于“第二阶段”（Mount），Kubernetes 提供的可用参数是 dir，即 Volume 的宿主机目录。</p></li></ul><p>所以，作为一个存储插件，我们只需要根据自己的需求进行选择和实现即可。</p><h3 id="1-2、容器挂载Volume">1.2、容器挂载Volume</h3><p>经过了“两阶段处理”，我们就能得到一个“持久化”的 Volume 宿主机目录。所以，接下来，kubelet 只要把这个 Volume 目录通过 CRI 里的 Mounts 参数，传递给 Docker，然后就可以为 Pod 里的容器挂载这个“持久化”的 Volume 了。其实，这一步相当于执行了如下所示的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -v /var/lib/kubelet/pods/&lt;Pod的ID&gt;/volumes/kubernetes.io~&lt;Volume类型&gt;/&lt;Volume名字&gt;:/&lt;容器内的目标目录&gt; 我的镜像 ...</span><br></code></pre></td></tr></table></figure><p>以上，就是 Kubernetes 创建 PV 的具体原理了。对应地，在删除一个 PV 的时候，Kubernetes 也需要 Unmount 和 Dettach 两个阶段来处理。</p><h3 id="1-3、相关控制循环">1.3、相关控制循环</h3><p>从上面的流程中，我们可以看出，PV 的处理流程似乎跟 Pod 以及容器的启动流程没有太多的耦合，只要 kubelet 在向 Docker 发起 CRI 请求之前，确保“持久化”的宿主机目录已经处理完毕即可。所以，在 Kubernetes 中，上述关于 PV 的“两阶段处理”流程，是靠独立于 kubelet 主控制循环（Kubelet Sync Loop）之外的两个控制循环来实现的。其中：</p><ul><li><p>“第一阶段”的 Attach（以及 Dettach）操作，是由 Volume Controller 负责维护的，这个控制循环的名字叫作：AttachDetachController。而它的作用，就是不断地检查每一个 Pod 对应的 PV，和这个 Pod 所在宿主机之间的挂载情况。从而决定，是否需要对这个 PV 进行 Attach（或者 Dettach）操作。</p><p>需要注意的是，作为一个 Kubernetes 内置的控制器，Volume Controller 自然是 kube-controller-manager 的一部分。所以，AttachDetachController 也一定是运行在 Master 节点上的。当然，Attach 操作只需要调用公有云或者具体存储项目的 API，并不需要在具体的宿主机上执行操作，所以这个设计没有任何问题。</p></li><li><p>“第二阶段”的 Mount（以及 Unmount）操作，必须发生在 Pod 对应的宿主机上，所以它必须是 kubelet 组件的一部分。这个控制循环的名字，叫作：VolumeManagerReconciler，它运行起来之后，是一个独立于 kubelet 主循环的 Goroutine。</p><p>通过将 Volume 的处理同 kubelet 的主循环解耦，Kubernetes 就避免了这些耗时的远程挂载操作拖慢 kubelet 的主控制循环，进而导致 Pod 的创建效率大幅下降的问题。实际上，kubelet 的一个主要设计原则，就是它的主控制循环绝对不可以被 block。</p></li></ul><h3 id="1-4、小结">1.4、小结</h3><p>Kubernetes通过“两阶段”完成持久化宿主机目录。这两个阶段分别是Attach / Detach（远程挂载 / 卸载）和Mount / Unmount（本地挂载 / 卸载）。</p><h3 id="1-5、参考">1.5、参考</h3><p><a href="https://time.geekbang.org/column/intro/100015201">https://time.geekbang.org/column/intro/100015201</a></p>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储管理1：理解PV、PVC对象</title>
    <link href="/2020/10/05/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%861%EF%BC%9A%E7%90%86%E8%A7%A3PV%E3%80%81PVC%E4%BD%93%E7%B3%BB/"/>
    <url>/2020/10/05/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%861%EF%BC%9A%E7%90%86%E8%A7%A3PV%E3%80%81PVC%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>一个优秀的云计算项目自然少不了存储资源的管理。在kubernetes中，为了简化用户使用持久化存储的门槛，引入了一组叫作  Persistent Volume（PV）和Persistent Volume Claim（PVC）的 API 对象。</p><h3 id="1-1、PV对象">1.1、PV对象</h3><p>PV对象用于描述集群中的存储资源。它主要定义了存储服务的访问信息（或实现细节），比如一个NFS服务的共享信息。通常情况下，PV对象是由集群管理员事先创建的，以供集群用户使用。比如，运维人员可以定义一个这样的NFS类型的PV，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">apiVerson:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">meatdata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">nfs:</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-number">10.244</span><span class="hljs-number">.1</span><span class="hljs-number">.4</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;/&quot;</span><br>  <span class="hljs-attr">capacity:</span><br>    <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteMany</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">manual</span><br></code></pre></td></tr></table></figure><p>有关PV对象更多的属性以及其它类型PV的定义方式可参考kubernetes<a href="https://kubernetes.io/zh/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes">官方文档</a>。</p><h3 id="1-2、PVC对象">1.2、PVC对象</h3><p>PVC对象用于描述Pod所需要的持久化存储信息。比如，存储大小、访问权限等。PVC通常由要使用存储资源的用户创建，或者以PVC模板的形式出现在StatefulSet对象中，然后由StatefulSet控制器创建带编号的PVC。比如，开发人员可以声明一个1GB大小的PVC，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteMany</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">manual</span><br></code></pre></td></tr></table></figure><p>有关PVC对象更多的属性可参考kubernetes<a href="https://kubernetes.io/zh/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims">官方文档</a>。</p><h3 id="1-3、Pod使用PVC">1.3、Pod使用PVC</h3><p>PVC资源只有在和某个符合条件的PV绑定后，才能被Pod使用。这里的条件包括：</p><ul><li>它们有相同的storageClassName；</li><li>PV能满足PVC对存储资源的要求。比如，PV的存储大小能满足PVC的需要。</li></ul><p>一旦PVC和PV绑定后，Pod就能像使用hostPath等常规类型的Volume一样，在自己的对象文件里声明它要使用的PVC，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">role:</span> <span class="hljs-string">web-frontend</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>        <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nfs</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">&quot;/usr/share/nginx/html&quot;</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nfs</span><br>    <span class="hljs-attr">persistentVolumeClaim:</span><br>      <span class="hljs-attr">claimName:</span> <span class="hljs-string">nfs</span><br></code></pre></td></tr></table></figure><p>可以看到，我们只需要在Pod对象的volumes字段中声明要使用的PVC的名字。当创建这个Pod时，kubelet就会把这个PVC所对应的PV，也就是一个NFS类型的Volume，挂载到Pod容器内的目录上。</p><h3 id="1-4、PersistentVolumeController">1.4、PersistentVolumeController</h3><p>在 Kubernetes 中，实际上存在着一个专门处理持久化存储的控制器，叫作 Volume Controller。这个 Volume Controller 维护着多个控制循环，其中有一个循环，其作用就是将PVC与某个符合条件的PV进行绑定。它的名字叫作 PersistentVolumeController。</p><p>PersistentVolumeController 会不断地查看当前每一个 PVC是不是已经处于 Bound（已绑定）状态。如果不是，那它就会遍历所有的、可用的 PV，并尝试将其与这个“单身”的 PVC 进行绑定。这样，Kubernetes 就可以保证用户提交的每一个 PVC，只要有合适的 PV 出现，它就能够很快进入绑定状态，从而结束“单身”之旅。</p><p>将一个 PV 与 PVC 进行“绑定”，其实就是将这个 PV 对象的名字，填在了 PVC 对象的 spec.volumeName 字段上。所以， Kubernetes 只要获取到这个 PVC 对象，就一定能够找到它所绑定的 PV。</p><h3 id="1-5、小结">1.5、小结</h3><p>在Kubernetes中PVC和PV的设计，仍然符合“面向对象”的思想。其中，PVC是接口，用于描述用户所需要的存储（存储大小、读写权限等）；PV是实现，用于定义存储服务的访问信息（或实现细节）。PVC和PV之间相互独立，通过PersistentVolumeContronller就能将PVC和符合条件的PV进行绑定。</p><h3 id="1-6、参考">1.6、参考</h3><p><a href="https://time.geekbang.org/column/intro/100015201">https://time.geekbang.org/column/intro/100015201</a></p><p><a href="https://kubernetes.io/zh/docs/concepts/storage/persistent-volumes/">https://kubernetes.io/zh/docs/concepts/storage/persistent-volumes/</a></p>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器编排8：Operator</title>
    <link href="/2020/10/04/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%928%EF%BC%9AOperator/"/>
    <url>/2020/10/04/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%928%EF%BC%9AOperator/</url>
    
    <content type="html"><![CDATA[<p>在 Kubernetes 中，管理“有状态应用”是一个比较复杂的过程，尤其是编写 Pod 模板的时候，总有一种“在 YAML 文件里编程序”的感觉，让人很不舒服。而在 Kubernetes 生态中，还有一个相对更加灵活和编程友好的管理“有状态应用”的解决方案，它就是：Operator。接下来，我们就以 Etcd Operator 为例，讨论一下 Operator 的工作原理和编写方法。</p><h2 id="一、Operator的使用流程">一、Operator的使用流程</h2><p>Etcd Operator 的使用方法非常简单，只需要两步即可完成。</p><h3 id="1-1、获取Operator代码">1.1、获取Operator代码</h3><p>第一步，将这个 Operator 的代码 Clone 到本地：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/coreos/etcd-operator</span><br></code></pre></td></tr></table></figure><h3 id="1-2、部署Operator">1.2、部署Operator</h3><p>第二步，将这个 Etcd Operator 部署在 Kubernetes 集群里。</p><h4 id="1-2-1、创建RBAC规则">1.2.1、创建RBAC规则</h4><p>不过，在部署 Etcd Operator 的 Pod 之前，我们需要先执行这样一个脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">example/rbac/create_role.sh</span><br></code></pre></td></tr></table></figure><p>这个脚本的作用，就是为 Etcd Operator 创建 RBAC 规则。这是因为，Etcd Operator 需要访问 Kubernetes 的 APIServer 来创建对象。更具体地说，上述脚本为 Etcd Operator 定义了如下所示的权限：</p><ul><li>对 Pod、Service、PVC、Deployment、Secret 等 API 对象，有所有权限；</li><li>对 CRD （Custom Resource Definition）对象，有所有权限；</li><li>对属于 <a href="http://etcd.database.coreos.com">etcd.database.coreos.com</a> 这个 API Group 的 CR（Custom Resource）对象，有所有权限。</li></ul><h4 id="1-2-1、创建Operator">1.2.1、创建Operator</h4><p>Etcd Operator 本身，其实就是一个 Deployment，它的 YAML 文件如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">etcd-operator</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">etcd-operator</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">etcd-operator</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">quay.io/coreos/etcd-operator:v0.9.2</span><br>        <span class="hljs-attr">command:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">etcd-operator</span><br>        <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">MY_POD_NAMESPACE</span><br>          <span class="hljs-attr">valueFrom:</span><br>            <span class="hljs-attr">fieldRef:</span><br>              <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.namespace</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">MY_POD_NAME</span><br>          <span class="hljs-attr">valueFrom:</span><br>            <span class="hljs-attr">fieldRef:</span><br>              <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.name</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>所以，我们就可以使用上述的 YAML 文件来创建 Etcd Operator，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f example/deployment.yaml</span><br></code></pre></td></tr></table></figure><h4 id="1-2-3、查看创建的资源">1.2.3、查看创建的资源</h4><p>一旦 Etcd Operator 的 Pod 进入了 Running 状态，我们就会发现，有一个 CRD 被自动创建了出来，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods</span><br>NAME                              READY     STATUS      RESTARTS   AGE<br>etcd-operator-649dbdb5cb-bzfzp    1/1       Running     0          20s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get crd</span><br>NAME                                    CREATED AT<br>etcdclusters.etcd.database.coreos.com   2018-09-18T11:42:55Z<br></code></pre></td></tr></table></figure><p>这个 CRD <a href="http://xn--etcdclusters-4v0uno.etcd.database.coreos.com">名叫etcdclusters.etcd.database.coreos.com</a> 。我们可以通过 kubectl describe 命令看到它的细节，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe crd  etcdclusters.etcd.database.coreos.com</span><br>...<br>Group:   etcd.database.coreos.com<br>  Names:<br>    Kind:       EtcdCluster<br>    List Kind:  EtcdClusterList<br>    Plural:     etcdclusters<br>    Short Names:<br>      etcd<br>    Singular:  etcdcluster<br>  Scope:       Namespaced<br>  Version:     v1beta2<br>  <br>...<br></code></pre></td></tr></table></figure><p>可以看到，这个 CRD 相当于告诉了 Kubernetes：接下来，如果有 API 组（Group）<a href="http://xn--etcd-zi0i.database.coreos.com">是etcd.database.coreos.com</a>、API 资源类型（Kind）是“EtcdCluster”的 YAML 文件被提交上来，你可一定要认识啊。</p><h4 id="1-2-4、小结">1.2.4、小结</h4><p>所以说，通过上述操作，我们实际上是在 Kubernetes 里添加了一个名叫 EtcdCluster 的自定义资源类型。而 Etcd Operator 本身，就是这个自定义资源类型对应的自定义控制器。</p><h3 id="1-3、使用Operator">1.3、使用Operator</h3><p>当 Etcd Operator 部署好之后，接下来在这个 Kubernetes 里创建一个 Etcd 集群的工作就非常简单了。我们只需要编写一个 EtcdCluster 的 YAML 文件，然后把它提交给 Kubernetes 即可，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f example/example-etcd-cluster.yaml</span><br></code></pre></td></tr></table></figure><p>这个 example-etcd-cluster.yaml 文件里描述的，是一个 3 个节点的 Etcd 集群。我们可以看到它被提交给 Kubernetes 之后，就会有三个 Etcd 的 Pod 运行起来，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods</span><br>NAME                            READY     STATUS    RESTARTS   AGE<br>example-etcd-cluster-dp8nqtjznc   1/1       Running     0          1m<br>example-etcd-cluster-mbzlg6sd56   1/1       Running     0          2m<br>example-etcd-cluster-v6v6s6stxd   1/1       Running     0          2m<br></code></pre></td></tr></table></figure><p>那么，究竟发生了什么，让创建一个 Etcd 集群的工作如此简单呢？我们当然还是得从这个 example-etcd-cluster.yaml 文件开始说起。不难想到，这个文件里定义的，正是 EtcdCluster 这个 CRD 的一个具体实例，也就是一个 Custom Resource（CR）。而它的内容非常简单，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">&quot;etcd.database.coreos.com/v1beta2&quot;</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">&quot;EtcdCluster&quot;</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;example-etcd-cluster&quot;</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">size:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.2.13&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到，EtcdCluster 的 spec 字段非常简单。其中，size=3 指定了它所描述的 Etcd 集群的节点个数。而 version=“3.2.13”，则指定了 Etcd 的版本，仅此而已。而真正把这样一个 Etcd 集群创建出来的逻辑，就是 Etcd Operator 要实现的主要工作了。</p><h3 id="1-4、小结">1.4、小结</h3><p>到这里，相信我们应该已经对 Operator 有了一个初步的认知：Operator的工作原理，实际上是利用了Kubernetes的自定义API资源（CRD），来描述我们想要部署的“有状态应用”；然后再自定义控制器里，根据自定义API对象的变化，来完成具体的部署和运维工作。</p><h2 id="二、如何部署一个Etcd集群">二、如何部署一个Etcd集群</h2><p>考虑到我们可能还不太清楚Etcd 集群的组建方式，在这里先简单介绍一下这部分知识。</p><h3 id="2-1、Etcd集群的静态部署过程">2.1、Etcd集群的静态部署过程</h3><p>Etcd Operator 部署 Etcd 集群，采用的是静态集群（Static）的方式。静态集群的好处是，它不必依赖于一个额外的服务发现机制来组建集群，非常适合本地容器化部署。而它的难点，则在于我们必须在部署的时候，就规划好这个集群的拓扑结构，并且能够知道这些节点固定的 IP 地址。比如下面这个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">etcd --name infra0 --initial-advertise-peer-urls http://10.0.1.10:2380 \</span><br><span class="language-bash">  --listen-peer-urls http://10.0.1.10:2380 \</span><br><span class="language-bash">...</span><br>  --initial-cluster-token etcd-cluster-1 \<br>  --initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \<br>  --initial-cluster-state new<br><span class="hljs-meta prompt_">  </span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">etcd --name infra1 --initial-advertise-peer-urls http://10.0.1.11:2380 \</span><br><span class="language-bash">  --listen-peer-urls http://10.0.1.11:2380 \</span><br><span class="language-bash">...</span><br>  --initial-cluster-token etcd-cluster-1 \<br>  --initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \<br>  --initial-cluster-state new<br><span class="hljs-meta prompt_">  </span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">etcd --name infra2 --initial-advertise-peer-urls http://10.0.1.12:2380 \</span><br><span class="language-bash">  --listen-peer-urls http://10.0.1.12:2380 \</span><br><span class="language-bash">...</span><br>  --initial-cluster-token etcd-cluster-1 \<br>  --initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \<br>  --initial-cluster-state new<br></code></pre></td></tr></table></figure><p>在这个例子中，启动了三个 Etcd 进程，组成了一个三节点的 Etcd 集群。其中，这些节点启动参数里的–initial-cluster 参数，非常值得关注。它的含义，正是当前节点启动时集群的拓扑结构。说得更详细一点，就是当前这个节点启动时，需要跟哪些节点通信来组成集群。举个例子，我们可以看一下上述 infra2 节点的–initial-cluster 的值，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">--initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \<br></code></pre></td></tr></table></figure><p>可以看到，–initial-cluster 参数是由“&lt; 节点名字 &gt;=&lt; 节点地址 &gt;”格式组成的一个数组。而上面这个配置的意思就是，当 infra2 节点启动之后，这个 Etcd 集群里就会有 infra0、infra1 和 infra2 三个节点。同时，这些 Etcd 节点，需要通过 2380 端口进行通信以便组成集群，这也正是上述配置中–listen-peer-urls 字段的含义。此外，一个 Etcd 集群还需要用–initial-cluster-token 字段，来声明一个该集群独一无二的 Token 名字。</p><p>像上述这样为每一个 Ectd 节点配置好它对应的启动参数，然后把它们启动起来，一个 Etcd 集群就可以自动组建起来了。而我们要编写的 Etcd Operator，就是要把上述过程自动化。这其实等同于：用代码来生成每个 Etcd 节点 Pod 的启动命令，然后把它们启动起来。接下来，我们一起来实践一下这个流程。</p><h3 id="2-2、如何自动化静态部署过程">2.2、如何自动化静态部署过程</h3><h4 id="2-2-1、从CRD的定义说起">2.2.1、从CRD的定义说起</h4><p>在编写自定义控制器之前，我们首先需要完成 EtcdCluster 这个 CRD 的定义，它对应的 types.go 文件的主要内容，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// +genclient</span><br><span class="hljs-comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span><br><br><span class="hljs-keyword">type</span> EtcdCluster <span class="hljs-keyword">struct</span> &#123;<br>  metav1.TypeMeta   <span class="hljs-string">`json:&quot;,inline&quot;`</span><br>  metav1.ObjectMeta <span class="hljs-string">`json:&quot;metadata,omitempty&quot;`</span><br>  Spec              ClusterSpec   <span class="hljs-string">`json:&quot;spec&quot;`</span><br>  Status            ClusterStatus <span class="hljs-string">`json:&quot;status&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> ClusterSpec <span class="hljs-keyword">struct</span> &#123;<br> <span class="hljs-comment">// Size is the expected size of the etcd cluster.</span><br> <span class="hljs-comment">// The etcd-operator will eventually make the size of the running</span><br> <span class="hljs-comment">// cluster equal to the expected size.</span><br> <span class="hljs-comment">// The vaild range of the size is from 1 to 7.</span><br> Size <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;size&quot;`</span><br> ... <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，EtcdCluster 是一个有 Status 字段的 CRD。在这里，我们可以不必关心 ClusterSpec 里的其他字段，只关注 Size（即：Etcd 集群的大小）字段即可。Size 字段的存在，就意味着将来如果我们想要调整集群大小的话，应该直接修改 YAML 文件里 size 的值，并执行 kubectl apply -f。这样，Operator 就会帮我们完成 Etcd 节点的增删操作。</p><p>上述这种“scale”能力，也是 Etcd Operator 自动化运维 Etcd 集群需要实现的主要功能。而为了能够支持这个功能，我们就不能再像前面那样在–initial-cluster 参数里把拓扑结构固定死。所以，Etcd Operator 的实现，虽然选择的也是静态集群，但这个集群具体的组建过程，是逐个节点动态添加的方式，即：首先，Etcd Operator 会创建一个“种子节点”；然后，Etcd Operator 会不断创建新的 Etcd 节点，然后将它们逐一加入到这个集群当中，直到集群的节点数等于 size。</p><h4 id="2-2-2、动态添加节点的关键">2.2.2、动态添加节点的关键</h4><p>这就意味着，在生成不同角色的 Etcd Pod 时，Operator 需要能够区分种子节点与普通节点。而这两种节点的不同之处，就在于一个名叫–initial-cluster-state 的启动参数：</p><ul><li>当这个参数值设为 new 时，就代表了该节点是种子节点。而我们前面提到过，种子节点还必须通过–initial-cluster-token 声明一个独一无二的 Token。</li><li>而如果这个参数值设为 existing，那就是说明这个节点是一个普通节点，Etcd Operator 需要把它加入到已有集群里。</li></ul><p>那么接下来的问题就是，每个 Etcd 节点的–initial-cluster 字段的值又是怎么生成的呢？</p><p>由于这个方案要求种子节点先启动，所以对于种子节点 infra0 来说，它启动后的集群只有它自己，即：–initial-cluster=infra0=<a href="http://10.0.1.10:2380">http://10.0.1.10:2380</a>。而对于接下来要加入的节点，比如 infra1 来说，它启动后的集群就有两个节点了，所以它的–initial-cluster 参数的值应该是：infra0=<a href="http://10.0.1.10:2380">http://10.0.1.10:2380</a>,infra1=<a href="http://10.0.1.11:2380">http://10.0.1.11:2380</a>。其他节点，都以此类推。</p><h4 id="2-2-3、Etcd-集群自动化部署过程">2.2.3、Etcd 集群自动化部署过程</h4><p>现在，我们就应该能在脑海中构思出上述三节点 Etcd 集群的部署过程了。</p><p>首先，只要用户提交 YAML 文件时声明创建一个 EtcdCluster 对象（一个 Etcd 集群），那么 Etcd Operator 都应该先创建一个单节点的种子集群（Seed Member），并启动这个种子节点。以 infra0 节点为例，它的 IP 地址是 10.0.1.10，那么 Etcd Operator 生成的种子节点的启动命令，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">etcd</span><br>  --data-dir=/var/etcd/data<br>  --name=infra0<br>  --initial-advertise-peer-urls=http://10.0.1.10:2380<br>  --listen-peer-urls=http://0.0.0.0:2380<br>  --listen-client-urls=http://0.0.0.0:2379<br>  --advertise-client-urls=http://10.0.1.10:2379<br>  --initial-cluster=infra0=http://10.0.1.10:2380<br>  --initial-cluster-state=new<br>  --initial-cluster-token=4b5215fa-5401-4a95-a8c6-892317c9bef8<br></code></pre></td></tr></table></figure><p>可以看到，这个种子节点的 initial-cluster-state 是 new，并且指定了唯一的 initial-cluster-token 参数。我们可以把这个创建种子节点（集群）的阶段称为：Bootstrap。接下来，对于其他每一个节点，Operator 只需要执行如下两个操作即可，以 infra1 为例。</p><p>第一步：通过 Etcd 命令行添加一个新成员：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">etcdctl member add infra1 http://10.0.1.11:2380</span><br></code></pre></td></tr></table></figure><p>第二步：为这个成员节点生成对应的启动参数，并启动它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">etcd</span><br>    --data-dir=/var/etcd/data<br>    --name=infra1<br>    --initial-advertise-peer-urls=http://10.0.1.11:2380<br>    --listen-peer-urls=http://0.0.0.0:2380<br>    --listen-client-urls=http://0.0.0.0:2379<br>    --advertise-client-urls=http://10.0.1.11:2379<br>    --initial-cluster=infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380<br>    --initial-cluster-state=existing<br></code></pre></td></tr></table></figure><p>可以看到，对于这个 infra1 成员节点来说，它的 initial-cluster-state 是 existing，也就是要加入已有集群。而它的 initial-cluster 的值，则变成了 infra0 和 infra1 两个节点的 IP 地址。所以，以此类推，不断地将 infra2 等后续成员添加到集群中，直到整个集群的节点数目等于用户指定的 size 之后，部署就完成了。</p><h2 id="三、Etcd-Operator的工作原理">三、Etcd Operator的工作原理</h2><p>在熟悉了上述部署思路之后，再来理解Etcd Operator 的工作原理，就非常简单了。</p><h3 id="3-1、创建资源的CRD">3.1、创建资源的CRD</h3><p>跟所有的自定义控制器一样，Etcd Operator 的启动流程也是围绕着 Informer 展开的，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> Start() <span class="hljs-type">error</span> &#123;<br> <span class="hljs-keyword">for</span> &#123;<br>  err := c.initResource()<br>  ...<br>  time.Sleep(initRetryWaitTime)<br> &#125;<br> c.run()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> run() &#123;<br> ...<br> <br> _, informer := cache.NewIndexerInformer(source, &amp;api.EtcdCluster&#123;&#125;, <span class="hljs-number">0</span>, cache.ResourceEventHandlerFuncs&#123;<br>  AddFunc:    c.onAddEtcdClus,<br>  UpdateFunc: c.onUpdateEtcdClus,<br>  DeleteFunc: c.onDeleteEtcdClus,<br> &#125;, cache.Indexers&#123;&#125;)<br> <br> ctx := context.TODO()<br> <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> use workqueue to avoid blocking</span><br> informer.Run(ctx.Done())<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，Etcd Operator 启动要做的第一件事（ c.initResource），是创建 EtcdCluster 对象所需要的 CRD，即：<a href="http://xn--etcdclusters-l65tvmp55t3s6cz0ug.etcd.database.coreos.com">前面提到的etcdclusters.etcd.database.coreos.com</a>。这样 Kubernetes 就能够“认识”EtcdCluster 这个自定义 API 资源了。</p><h3 id="3-2、定义资源的Informer">3.2、定义资源的Informer</h3><p>接下来，Etcd Operator 会定义一个 EtcdCluster 对象的 Informer。不过，需要注意的是，由于 Etcd Operator 的完成时间相对较早，所以它里面有些代码的编写方式会跟我们使用的最新的编写方式不太一样。比如，在上面的代码最后，会看到有这样一句注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> use workqueue to avoid blocking</span><br>...<br></code></pre></td></tr></table></figure><p>也就是说，Etcd Operator 并没有用工作队列来协调 Informer 和控制循环。具体来讲，我们在控制循环里执行的业务逻辑，往往是比较耗时间的。比如，创建一个真实的 Etcd 集群。而 Informer 的 WATCH 机制对 API 对象变化的响应，则非常迅速。所以，控制器里的业务逻辑就很可能会拖慢 Informer 的执行周期，甚至可能 Block 它。而要协调这样两个快、慢任务的一个典型解决方法，就是引入一个工作队列。</p><p>由于 Etcd Operator 里没有工作队列，那么在它的 EventHandler 部分，就不会有什么入队操作，而直接就是每种事件对应的具体的业务逻辑了。不过，Etcd Operator 在业务逻辑的实现方式上，与常规的自定义控制器略有不同。这一部分的工作原理，见如下流程图：</p><p><img src="/img/image-20201004100845395.png" alt="image-20201004100845395"></p><p>可以看到，Etcd Operator 的特殊之处在于，它为每一个 EtcdCluster 对象，都启动了一个控制循环，“并发”地响应这些对象的变化。显然，这种做法不仅可以简化 Etcd Operator 的代码实现，还有助于提高它的响应速度。</p><p>以文章一开始的 example-etcd-cluster 的 YAML 文件为例。当这个 YAML 文件第一次被提交到 Kubernetes 之后，Etcd Operator 的 Informer，就会立刻“感知”到一个新的 EtcdCluster 对象被创建了出来。所以，EventHandler 里的“添加”事件会被触发。而这个 Handler 要做的操作也很简单，即：在 Etcd Operator 内部创建一个对应的 Cluster 对象（cluster.New），比如流程图里的 Cluster1。这个 Cluster 对象，就是一个 Etcd 集群在 Operator 内部的描述，所以它与真实的 Etcd 集群的生命周期是一致的。</p><h3 id="3-3、Cluster对象的职责">3.3、Cluster对象的职责</h3><p>一个 Cluster 对象需要具体负责的，其实有两个工作。</p><p>其中，第一个工作只在该 Cluster 对象第一次被创建的时候才会执行。这个工作，就是我们前面提到过的 Bootstrap，即：创建一个单节点的种子集群。由于种子集群只有一个节点，所以这一步直接就会生成一个 Etcd 的 Pod 对象。这个 Pod 里有一个 InitContainer，负责检查 Pod 的 DNS 记录是否正常。如果检查通过，用户容器也就是 Etcd 容器就会启动起来。而这个 Etcd 容器最重要的部分，当然就是它的启动命令了。以我们在文章一开始部署的集群为例，它的种子节点的容器启动命令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/local/bin/etcd<br>  --data-dir=/var/etcd/data<br>  --name=example-etcd-cluster-mbzlg6sd56<br>  --initial-advertise-peer-urls=http://example-etcd-cluster-mbzlg6sd56.example-etcd-cluster.default.svc:2380<br>  --listen-peer-urls=http://0.0.0.0:2380<br>  --listen-client-urls=http://0.0.0.0:2379<br>  --advertise-client-urls=http://example-etcd-cluster-mbzlg6sd56.example-etcd-cluster.default.svc:2379<br>  --initial-cluster=example-etcd-cluster-mbzlg6sd56=http://example-etcd-cluster-mbzlg6sd56.example-etcd-cluster.default.svc:2380<br>  --initial-cluster-state=new<br>  --initial-cluster-token=4b5215fa-5401-4a95-a8c6-892317c9bef8<br></code></pre></td></tr></table></figure><p>上述启动命令里的各个参数的含义，我们已经在前面介绍过。可以看到，在这些启动参数（比如：initial-cluster）里，Etcd Operator 只会使用 Pod 的 DNS 记录，而不是它的 IP 地址。这当然是因为，在 Operator 生成上述启动命令的时候，Etcd 的 Pod 还没有被创建出来，它的 IP 地址自然也无从谈起。这也就意味着，每个 Cluster 对象，都会事先创建一个与该 EtcdCluster 同名的 Headless Service。这样，Etcd Operator 在接下来的所有创建 Pod 的步骤里，就都可以使用 Pod 的 DNS 记录来代替它的 IP 地址了。</p><p>Cluster 对象的第二个工作，则是启动该集群所对应的控制循环。这个控制循环每隔一定时间，就会执行一次下面的 Diff 流程。首先，控制循环要获取到所有正在运行的、属于这个 Cluster 的 Pod 数量，也就是该 Etcd 集群的“实际状态”。而这个 Etcd 集群的“期望状态”，正是用户在 EtcdCluster 对象里定义的 size。所以接下来，控制循环会对比这两个状态的差异。如果实际的 Pod 数量不够，那么控制循环就会执行一个添加成员节点的操作（即：上述流程图中的 addOneMember 方法）；反之，就执行删除成员节点的操作（即：上述流程图中的 removeOneMember 方法）。</p><p>以 addOneMember 方法为例，它执行的流程是这样的：生成一个新节点的 Pod 的名字，比如：example-etcd-cluster-v6v6s6stxd；调用 Etcd Client，执行前面提到过的 etcdctl member add example-etcd-cluster-v6v6s6stxd 命令；使用这个 Pod 名字，和已经存在的所有节点列表，组合成一个新的 initial-cluster 字段的值；使用这个 initial-cluster 的值，生成这个 Pod 里 Etcd 容器的启动命令。如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/local/bin/etcd<br>  --data-dir=/var/etcd/data<br>  --name=example-etcd-cluster-v6v6s6stxd<br>  --initial-advertise-peer-urls=http://example-etcd-cluster-v6v6s6stxd.example-etcd-cluster.default.svc:2380<br>  --listen-peer-urls=http://0.0.0.0:2380<br>  --listen-client-urls=http://0.0.0.0:2379<br>  --advertise-client-urls=http://example-etcd-cluster-v6v6s6stxd.example-etcd-cluster.default.svc:2379<br>  --initial-cluster=example-etcd-cluster-mbzlg6sd56=http://example-etcd-cluster-mbzlg6sd56.example-etcd-cluster.default.svc:2380,example-etcd-cluster-v6v6s6stxd=http://example-etcd-cluster-v6v6s6stxd.example-etcd-cluster.default.svc:2380<br>  --initial-cluster-state=existing<br></code></pre></td></tr></table></figure><p>这样，当这个容器启动之后，一个新的 Etcd 成员节点就被加入到了集群当中。控制循环会重复这个过程，直到正在运行的 Pod 数量与 EtcdCluster 指定的 size 一致。在有了这样一个与 EtcdCluster 对象一一对应的控制循环之后，后续对这个 EtcdCluster 的任何修改，比如：修改 size 或者 Etcd 的 version，它们对应的更新事件都会由这个 Cluster 对象的控制循环进行处理。</p><p>以上，就是一个 Etcd Operator 的工作原理了。</p><h2 id="四、Etcd的备份与恢复">四、Etcd的备份与恢复</h2><p>如果对比一下 Etcd Operator 与 MySQL StatefulSet 的话，我们可能会有两个问题。</p><p>第一个问题是，在 StatefulSet 里，它为 Pod 创建的名字是带编号的，这样就把整个集群的拓扑状态固定了下来（比如：一个三节点的集群一定是由名叫 web-0、web-1 和 web-2 的三个 Pod 组成）。可是，在 Etcd Operator 里，为什么我们使用随机名字就可以了呢？这是因为，Etcd Operator 在每次添加 Etcd 节点的时候，都会先执行 etcdctl member add &lt;Pod 名字 &gt;；每次删除节点的时候，则会执行 etcdctl member remove &lt;Pod 名字 &gt;。这些操作，其实就会更新 Etcd 内部维护的拓扑信息，所以 Etcd Operator 无需在集群外部通过编号来固定这个拓扑关系。</p><p>第二个问题是，为什么我没有在 EtcdCluster 对象里声明 Persistent Volume？难道，我们不担心节点宕机之后 Etcd 的数据会丢失吗？我们知道，Etcd 是一个基于 Raft 协议实现的高可用 Key-Value 存储。根据 Raft 协议的设计原则，当 Etcd 集群里只有半数以下（在我们的例子里，小于等于一个）的节点失效时，当前集群依然可以正常工作。此时，Etcd Operator 只需要通过控制循环创建出新的 Pod，然后将它们加入到现有集群里，就完成了“期望状态”与“实际状态”的调谐工作。这个集群，是一直可用的 。</p><p>但是，当这个 Etcd 集群里有半数以上（在我们的例子里，大于等于两个）的节点失效的时候，这个集群就会丧失数据写入的能力，从而进入“不可用”状态。此时，即使 Etcd Operator 创建出新的 Pod 来，Etcd 集群本身也无法自动恢复起来。这个时候，我们就必须使用 Etcd 本身的备份数据来对集群进行恢复操作。</p><h3 id="4-1、Etcd-Backup-Operator">4.1、Etcd Backup Operator</h3><p>在有了 Operator 机制之后，上述 Etcd 的备份操作，是由一个单独的 Etcd Backup Operator 负责完成的。创建和使用这个 Operator 的流程，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">首先，创建etcd-backup-operator</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f example/etcd-backup-operator/deployment.yaml</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">确认etcd-backup-operator已经在正常运行</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pod</span><br>NAME                                    READY     STATUS    RESTARTS   AGE<br>etcd-backup-operator-1102130733-hhgt7   1/1       Running   0          3s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以看到，Backup Operator会创建一个叫etcdbackups的CRD</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get crd</span><br>NAME                                    KIND<br>etcdbackups.etcd.database.coreos.com    CustomResourceDefinition.v1beta1.apiextensions.k8s.io<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">我们这里要使用AWS S3来存储备份，需要将S3的授权信息配置在文件里</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> <span class="hljs-variable">$AWS_DIR</span>/credentials</span><br>[default]<br>aws_access_key_id = XXX<br>aws_secret_access_key = XXX<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> <span class="hljs-variable">$AWS_DIR</span>/config</span><br>[default]<br>region = &lt;region&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后，将上述授权信息制作成一个Secret</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create secret generic aws --from-file=<span class="hljs-variable">$AWS_DIR</span>/credentials --from-file=<span class="hljs-variable">$AWS_DIR</span>/config</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用上述S3的访问信息，创建一个EtcdBackup对象</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sed -e <span class="hljs-string">&#x27;s|&lt;full-s3-path&gt;|mybucket/etcd.backup|g&#x27;</span> \</span><br><span class="language-bash">    -e <span class="hljs-string">&#x27;s|&lt;aws-secret&gt;|aws|g&#x27;</span> \</span><br><span class="language-bash">    -e <span class="hljs-string">&#x27;s|&lt;etcd-cluster-endpoints&gt;|&quot;http://example-etcd-cluster-client:2379&quot;|g&#x27;</span> \</span><br><span class="language-bash">    example/etcd-backup-operator/backup_cr.yaml \</span><br><span class="language-bash">    | kubectl create -f -</span><br></code></pre></td></tr></table></figure><p>需要注意的是，每当我们创建一个 EtcdBackup 对象（backup_cr.yaml），就相当于为它所指定的 Etcd 集群做了一次备份。EtcdBackup 对象的 etcdEndpoints 字段，会指定它要备份的 Etcd 集群的访问地址。所以，在实际的环境里，建议把最后这个备份操作，编写成一个 Kubernetes 的 CronJob 以便定时运行。</p><h3 id="4-2、Etcd-Restore-Operator">4.2、Etcd Restore Operator</h3><p>当 Etcd 集群发生了故障之后，我们就可以通过创建一个 EtcdRestore 对象来完成恢复操作。当然，这就意味着我们也需要事先启动 Etcd Restore Operator。这个流程的完整过程，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建etcd-restore-operator</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f example/etcd-restore-operator/deployment.yaml</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">确认它已经正常运行</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods</span><br>NAME                                     READY     STATUS    RESTARTS   AGE<br>etcd-restore-operator-4203122180-npn3g   1/1       Running   0          7s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建一个EtcdRestore对象，来帮助Etcd Operator恢复数据，记得替换模板里的S3的访问信息</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sed -e <span class="hljs-string">&#x27;s|&lt;full-s3-path&gt;|mybucket/etcd.backup|g&#x27;</span> \</span><br><span class="language-bash">    -e <span class="hljs-string">&#x27;s|&lt;aws-secret&gt;|aws|g&#x27;</span> \</span><br><span class="language-bash">    example/etcd-restore-operator/restore_cr.yaml \</span><br><span class="language-bash">    | kubectl create -f -</span><br></code></pre></td></tr></table></figure><p>上面例子里的 EtcdRestore 对象（restore_cr.yaml），会指定它要恢复的 Etcd 集群的名字和备份数据所在的 S3 存储的访问信息。而当一个 EtcdRestore 对象成功创建后，Etcd Restore Operator 就会通过上述信息，恢复出一个全新的 Etcd 集群。然后，Etcd Operator 会把这个新集群直接接管过来，从而重新进入可用的状态。</p><h2 id="五、小结">五、小结</h2><p>在这篇文章中，我们以etcd operator为例，理解了operator的使用流程和工作原理。我们需要知道的是：在Kubernetes中，每种编排功能都对应着一个具体地资源类型，每种资源类型是由一个或多个控制器组成的，每个控制器会维护一个或多个控制循环。而operator则是一个自定义的资源类型，它也有相对应的资源类型定义、控制器以及控制循环等。</p>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器编排7：Job与CronJob</title>
    <link href="/2020/10/04/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%927%EF%BC%9AJob%E4%B8%8ECronJob/"/>
    <url>/2020/10/04/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%927%EF%BC%9AJob%E4%B8%8ECronJob/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们已经讨论Deployment、StatefulSet以及DaemonSet这三个编排对象。接下来，我们讨论另一种重要的对象：Job</p><h2 id="一、在线业务-vs-离线业务">一、在线业务 vs 离线业务</h2><p>Deployment、StatefulSet，以及 DaemonSet 这三个编排对象，它们主要编排的都是“在线业务”，即：Long Running Task（长作业）。比如，我在前面举例时常用的 Nginx、Tomcat，以及 MySQL 等等。这些应用一旦运行起来，除非出错或者停止，它的容器进程会一直保持在 Running 状态。</p><p>但是，有一类作业显然不满足这样的条件，这就是“离线业务”，或者叫作 Batch Job（计算业务）。这种业务在计算完成后就直接退出了，而此时如果我们依然用 Deployment 来管理这种业务的话，就会发现 Pod 会在计算结束后退出，然后被 Deployment Controller 不断地重启；而像“滚动更新”这样的编排功能，更无从谈起了。</p><p>所以，早在 Borg 项目中，Google 就已经对作业进行了分类处理，提出了 LRS（Long Running Service）和 Batch Jobs 两种作业形态，对它们进行“分别管理”和“混合调度”。</p><p>不过，在 2015 年 Borg 论文刚刚发布的时候，Kubernetes 项目并不支持对 Batch Job 的管理。直到 v1.4 版本之后，社区才逐步设计出了一个用来描述离线业务的 API 对象，它的名字就是：Job。</p><h2 id="二、理解Job对象">二、理解Job对象</h2><h3 id="2-1、从一个Job示例说起">2.1、从一个Job示例说起</h3><p>Job API 对象的定义非常简单，我来举个例子，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pi</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">pi</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">resouer/ubuntu-bc</span> <br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo &#x27;scale=10000; 4*a(1)&#x27; | bc -l &quot;</span>]<br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span><br>  <span class="hljs-attr">backoffLimit:</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>在这个 Pod 模板中，我们定义了一个 Ubuntu 镜像的容器（准确地说，是一个安装了 bc 命令的 Ubuntu 镜像），它运行的程序是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;scale=10000; 4*a(1)&quot; | bc -l<br></code></pre></td></tr></table></figure><p>其中，bc 命令是 Linux 里的“计算器”；-l 表示，我们现在要使用标准数学库；而 a(1)，则是调用数学库中的 arctangent 函数，计算 atan(1)。这是什么意思呢？我们知道：tan(π/4) = 1。所以，4*atan(1)正好就是π，也就是 3.1415926…。所以，这其实就是一个计算π值的容器。而通过 scale=10000，我指定了输出的小数点后的位数是 10000。</p><p>需要注意的是，跟其他控制器不同，Job 对象并不要求我们定义一个 spec.selector 来描述要控制哪些 Pod。</p><h3 id="2-2、创建、并查看Job对象">2.2、创建、并查看Job对象</h3><p>现在，我们就可以创建这个 Job 了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f job.yaml</span><br></code></pre></td></tr></table></figure><p>在成功创建后，我们来查看一下这个 Job 对象，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe <span class="hljs-built_in">jobs</span>/pi</span><br>Name:             pi<br>Namespace:        default<br>Selector:         controller-uid=c2db599a-2c9d-11e6-b324-0209dc45a495<br>Labels:           controller-uid=c2db599a-2c9d-11e6-b324-0209dc45a495<br>                  job-name=pi<br>Annotations:      &lt;none&gt;<br>Parallelism:      1<br>Completions:      1<br>..<br>Pods Statuses:    0 Running / 1 Succeeded / 0 Failed<br>Pod Template:<br>  Labels:       controller-uid=c2db599a-2c9d-11e6-b324-0209dc45a495<br>                job-name=pi<br>  Containers:<br>   ...<br>  Volumes:              &lt;none&gt;<br>Events:<br>  FirstSeen    LastSeen    Count    From            SubobjectPath    Type        Reason            Message<br>  ---------    --------    -----    ----            -------------    --------    ------            -------<br>  1m           1m          1        &#123;job-controller &#125;                Normal      SuccessfulCreate  Created pod: pi-rq5rl<br></code></pre></td></tr></table></figure><p>可以看到，这个 Job 对象在创建后，它的 Pod 模板，被自动加上了一个 controller-uid=&lt; 一个随机字符串 &gt; 这样的 Label。而这个 Job 对象本身，则被自动加上了这个 Label 对应的 Selector，从而 保证了 Job 与它所管理的 Pod 之间的匹配关系。</p><p>而 Job Controller 之所以要使用这种携带了 UID 的 Label，就是为了避免不同 Job 对象所管理的 Pod 发生重合。需要注意的是，这种自动生成的 Label 对用户来说并不友好，所以不太适合推广到 Deployment 等长作业编排对象上。</p><h3 id="2-3、Job对象下的Pod">2.3、Job对象下的Pod</h3><p>接下来，我们可以看到这个 Job 创建的 Pod 进入了 Running 状态，这意味着它正在计算 Pi 的值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods</span><br>NAME                                READY     STATUS    RESTARTS   AGE<br>pi-rq5rl                            1/1       Running   0          10s<br></code></pre></td></tr></table></figure><p>而几分钟后计算结束，这个 Pod 就会进入 Completed 状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods</span><br>NAME                                READY     STATUS      RESTARTS   AGE<br>pi-rq5rl                            0/1       Completed   0          4m<br></code></pre></td></tr></table></figure><p>这也是我们需要在 Pod 模板中定义 restartPolicy=Never 的原因：离线计算的 Pod 永远都不应该被重启，否则它们会再重新计算一遍。事实上，restartPolicy 在 Job 对象里只允许被设置为 Never 和 OnFailure；而在 Deployment 对象里，restartPolicy 则只允许被设置为 Always。</p><p>此时，我们通过 kubectl logs 查看一下这个 Pod 的日志，就可以看到计算得到的 Pi 值已经被打印了出来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl logs pi-rq5rl</span><br>3.141592653589793238462643383279...<br></code></pre></td></tr></table></figure><h3 id="2-4、离线作业失败了该怎么办？">2.4、离线作业失败了该怎么办？</h3><p>这时候，我们一定会想到这样一个问题，如果这个离线作业失败了要怎么办？比如，我们在这个例子中定义了 restartPolicy=Never，那么离线作业失败后 Job Controller 就会不断地尝试创建一个新 Pod，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods</span><br>NAME                                READY     STATUS              RESTARTS   AGE<br>pi-55h89                            0/1       ContainerCreating   0          2s<br>pi-tqbcz                            0/1       Error               0          5s<br></code></pre></td></tr></table></figure><p>可以看到，这时候会不断地有新 Pod 被创建出来。当然，这个尝试肯定不能无限进行下去。所以，我们就在 Job 对象的 spec.backoffLimit 字段里定义了重试次数为 4（即，backoffLimit=4），而这个字段的默认值是 6。</p><p>需要注意的是，Job Controller 重新创建 Pod 的间隔是呈指数增加的，即下一次重新创建 Pod 的动作会分别发生在 10 s、20 s、40 s …后。</p><p>而如果我们定义的 restartPolicy=OnFailure，那么离线作业失败后，Job Controller 就不会去尝试创建新的 Pod。但是，它会不断地尝试重启 Pod 里的容器。</p><h3 id="2-5、Job的最长运行时间">2.5、Job的最长运行时间</h3><p>如前所述，当一个 Job 的 Pod 运行结束后，它会进入 Completed 状态。但是，如果这个 Pod 因为某种原因一直不肯结束呢？在 Job 的 API 对象里，有一个 spec.activeDeadlineSeconds 字段可以设置最长运行时间，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br> <span class="hljs-attr">backoffLimit:</span> <span class="hljs-number">5</span><br> <span class="hljs-attr">activeDeadlineSeconds:</span> <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>一旦运行超过了 100 s，这个 Job 的所有 Pod 都会被终止。并且，我们可以在 Pod 的状态里看到终止的原因是 reason: DeadlineExceeded。</p><h2 id="三、并行作业">三、并行作业</h2><p>以上，就是一个 Job API 对象最主要的概念和用法了。不过，离线业务之所以被称为 Batch Job，当然是因为它们可以以“Batch”，也就是并行的方式去运行。接下来，我们理解一下Job Controller 对并行作业的控制方法。</p><p>在 Job 对象中，负责并行控制的参数有两个：</p><ul><li>spec.parallelism，它定义的是一个Job在任意时间最多可以启动多少个Pod同时运行；</li><li>spec.competions，它定义的是Job至少要完成的Pod数目，即Job的最小完成数。</li></ul><p>这两个参数听起来有点儿抽象，我通过一个具体的例子来理解。</p><h3 id="3-1、定义Job对象">3.1、定义Job对象</h3><p>在之前计算 Pi 值的 Job 里，添加这两个参数：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pi</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">parallelism:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">completions:</span> <span class="hljs-number">4</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">pi</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">resouer/ubuntu-bc</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo &#x27;scale=5000; 4*a(1)&#x27; | bc -l &quot;</span>]<br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span><br>  <span class="hljs-attr">backoffLimit:</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>这样，我们就指定了这个 Job 最大的并行数是 2，而最小的完成数是 4。</p><h3 id="3-2、创建、并查看Job对象">3.2、创建、并查看Job对象</h3><p>接下来，我们来创建这个 Job 对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f job.yaml</span><br></code></pre></td></tr></table></figure><p>可以看到，这个 Job 其实也维护了两个状态字段，即 DESIRED 和 SUCCESSFUL，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get job</span><br>NAME      DESIRED   SUCCESSFUL   AGE<br>pi        4         0            3s<br></code></pre></td></tr></table></figure><p>其中，DESIRED 的值，正是 completions 定义的最小完成数。</p><h3 id="3-3、Job对象下的Pod">3.3、Job对象下的Pod</h3><p>然后，我们可以看到，这个 Job 首先创建了两个并行运行的 Pod 来计算 Pi：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods</span><br>NAME       READY     STATUS    RESTARTS   AGE<br>pi-5mt88   1/1       Running   0          6s<br>pi-gmcq5   1/1       Running   0          6s<br></code></pre></td></tr></table></figure><p>而在 40 s 后，这两个 Pod 相继完成计算。这时我们可以看到，每当有一个 Pod 完成计算进入 Completed 状态时，就会有一个新的 Pod 被自动创建出来，并且快速地从 Pending 状态进入到 ContainerCreating 状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods</span><br>NAME       READY     STATUS    RESTARTS   AGE<br>pi-gmcq5   0/1       Completed   0         40s<br>pi-84ww8   0/1       Pending   0         0s<br>pi-5mt88   0/1       Completed   0         41s<br>pi-62rbt   0/1       Pending   0         0s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods</span><br>NAME       READY     STATUS    RESTARTS   AGE<br>pi-gmcq5   0/1       Completed   0         40s<br>pi-84ww8   0/1       ContainerCreating   0         0s<br>pi-5mt88   0/1       Completed   0         41s<br>pi-62rbt   0/1       ContainerCreating   0         0s<br></code></pre></td></tr></table></figure><p>紧接着，Job Controller 第二次创建出来的两个并行的 Pod 也进入了 Running 状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods</span> <br>NAME       READY     STATUS      RESTARTS   AGE<br>pi-5mt88   0/1       Completed   0          54s<br>pi-62rbt   1/1       Running     0          13s<br>pi-84ww8   1/1       Running     0          14s<br>pi-gmcq5   0/1       Completed   0          54s<br></code></pre></td></tr></table></figure><p>最终，后面创建的这两个 Pod 也完成了计算，进入了 Completed 状态。这时，由于所有的 Pod 均已经成功退出，这个 Job 也就执行完了，所以我们会看到它的 SUCCESSFUL字段的值变成了 4：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods</span> <br>NAME       READY     STATUS      RESTARTS   AGE<br>pi-5mt88   0/1       Completed   0          5m<br>pi-62rbt   0/1       Completed   0          4m<br>pi-84ww8   0/1       Completed   0          4m<br>pi-gmcq5   0/1       Completed   0          5m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get job</span><br>NAME      DESIRED   SUCCESSFUL   AGE<br>pi        4         4            5m<br></code></pre></td></tr></table></figure><h3 id="3-4、小结">3.4、小结</h3><p>通过上述 Job 的 DESIRED 和 SUCCESSFUL 字段的关系，我们就可以很容易地理解Job Controller 的工作原理了。</p><p>首先，Job Controller 控制的对象，直接就是 Pod。</p><p>其次，Job Controller 在控制循环中进行的调谐（Reconcile）操作，是根据实际处于Running 状态 Pod 的数目、已经成功退出的 Pod 的数目，以及 parallelism、completions 参数的值共同计算出，在这个周期里应该创建或者删除的 Pod 数目，然后调用 Kubernetes API 来执行这个操作。</p><p>以创建 Pod 为例。在上面计算 Pi 值的这个例子中，当 Job 一开始创建出来时，实际处于 Running 状态的 Pod 数目 =0，已经成功退出的 Pod 数目 =0，而用户定义的 completions，也就是最终用户需要的 Pod 数目 =4。</p><p>所以，在这个时刻，需要创建的 Pod 数目 = 最终需要的 Pod 数目 - 实际在 Running 状态 Pod 数目 - 已经成功退出的 Pod 数目 = 4 - 0 - 0= 4。也就是说，Job Controller 需要创建 4 个 Pod 来纠正这个不一致状态。</p><p>可是，我们又定义了这个 Job 的 parallelism=2。也就是说，我们规定了每次并发创建的 Pod 个数不能超过 2 个。所以，Job Controller 会对前面的计算结果做一个修正，修正后的期望创建的 Pod 数目应该是：2 个。这时候，Job Controller 就会并发地向 kube-apiserver 发起两个创建 Pod 的请求。</p><p>类似地，如果在这次调谐周期里，Job Controller 发现实际在 Running 状态的 Pod 数目，比 parallelism 还大，那么它就会删除一些 Pod，使两者相等。</p><p>综上所述，Job Controller 实际上控制了，作业执行的并行度，以及总共需要完成的任务数这两个重要参数。而在实际使用时，我们需要根据作业的特性，来决定并行度（parallelism）和任务数（completions）的合理取值。</p><h2 id="四、Job对象三种常用的用法">四、Job对象三种常用的用法</h2><h3 id="4-1、外部管理器-Job模板">4.1、外部管理器 + Job模板</h3><p>第一种用法，也是最简单粗暴的用法：外部管理器 +Job 模板。</p><p>这种模式的特定用法是：把 Job 的 YAML 文件定义为一个“模板”，然后用一个外部工具控制这些“模板”来生成 Job。这时，Job 的定义方式如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">process-item-$ITEM</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">jobgroup:</span> <span class="hljs-string">jobexample</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">jobexample</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">jobgroup:</span> <span class="hljs-string">jobexample</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">c</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo Processing item $ITEM &amp;&amp; sleep 5&quot;</span>]<br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span><br></code></pre></td></tr></table></figure><p>可以看到，我们在这个 Job 的 YAML 里，定义了 $ITEM 这样的“变量”。所以，在控制这种 Job 时，我们只要注意如下两个方面即可：</p><ul><li><p>创建 Job 时，替换掉 $ITEM 这样的变量；</p></li><li><p>所有来自于同一个模板的 Job，都有一个 jobgroup: jobexample 标签，也就是说这一组 Job 使用这样一个相同的标识。</p></li></ul><p>而做到第一点非常简单。比如，我们可以通过这样一句 shell 把 $ITEM 替换掉：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> ./jobs</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> apple banana cherry</span><br>do<br>  cat job-tmpl.yaml | sed &quot;s/\$ITEM/$i/&quot; &gt; ./jobs/job-$i.yaml<br>done<br></code></pre></td></tr></table></figure><p>这样，一组来自于同一个模板的不同 Job 的 yaml 就生成了。接下来，我们就可以通过一句 kubectl create 指令创建这些 Job 了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f ./jobs</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods -l jobgroup=jobexample</span><br>NAME                        READY     STATUS      RESTARTS   AGE<br>process-item-apple-kixwv    0/1       Completed   0          4m<br>process-item-banana-wrsf7   0/1       Completed   0          4m<br>process-item-cherry-dnfu9   0/1       Completed   0          4m<br></code></pre></td></tr></table></figure><p>这个模式看起来虽然很“傻”，但却是 Kubernetes 社区里使用 Job 的一个很普遍的模式。原因很简单：大多数用户在需要管理 Batch Job 的时候，都已经有了一套自己的方案，需要做的往往就是集成工作。这时候，Kubernetes 项目对这些方案来说最有价值的，就是 Job 这个 API 对象。所以，我们只需要编写一个外部工具（等同于我们这里的 for 循环）来管理这些 Job 即可。这种模式最典型的应用，就是 TensorFlow 社区的 KubeFlow 项目。</p><p>很容易理解，在这种模式下使用 Job 对象，completions 和 parallelism 这两个字段都应该使用默认值 1，而不应该由我们自行设置。而作业 Pod 的并行控制，应该完全交由外部工具来进行管理（比如，KubeFlow）。</p><h3 id="4-2、拥有最终任务数的并行Job">4.2、拥有最终任务数的并行Job</h3><p>第二种用法：拥有最终任务数的并行 Job。</p><p>这种模式下，我们只关心最后是否有指定数目（spec.completions）的任务成功退出。至于执行时的并行度是多少，我们并不关心。</p><p>比如，我们这个计算 Pi 值的例子，就是这样一个典型的、拥有最终任务数目（completions=4）的应用场景。 它的 parallelism 值是 2；或者，我们可以干脆不指定 parallelism，直接使用默认的并行度（即：1）。</p><p>此外，我们还可以使用一个工作队列（Work Queue）进行任务分发。这时，Job 的 YAML 文件定义如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">job-wq-1</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">completions:</span> <span class="hljs-number">8</span><br>  <span class="hljs-attr">parallelism:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">job-wq-1</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">c</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">myrepo/job-wq-1</span><br>        <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">BROKER_URL</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">amqp://guest:guest@rabbitmq-service:5672</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">QUEUE</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">job1</span><br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span><br></code></pre></td></tr></table></figure><p>我们可以看到，它的 completions 的值是：8，这意味着我们总共要处理的任务数目是 8 个。也就是说，总共会有 8 个任务会被逐一放入工作队列里（我们可以运行一个外部小程序作为生产者，来提交任务）。</p><p>在这个实例中，我们选择充当工作队列的是一个运行在 Kubernetes 里的 RabbitMQ。所以，我们需要在 Pod 模板里定义 BROKER_URL，来作为消费者。</p><p>所以，一旦我们用 kubectl create 创建了这个 Job，它就会以并发度为 2 的方式，每两个 Pod 一组，创建出 8 个 Pod。每个 Pod 都会去连接 BROKER_URL，从 RabbitMQ 里读取任务，然后各自进行处理。这个 Pod 里的执行逻辑，我们可以用这样一段伪代码来表示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">/* job-wq-1的伪代码 */<br>queue := newQueue($BROKER_URL, $QUEUE)<br>task := queue.Pop()<br>process(task)<br>exit<br></code></pre></td></tr></table></figure><p>可以看到，每个 Pod 只需要将任务信息读取出来，处理完成，然后退出即可。而作为用户，我们只关心最终一共有 8 个计算任务启动并且退出，只要这个目标达到，我们就认为整个 Job 处理完成了。所以说，这种用法，对应的就是“任务总数固定”的场景。</p><h3 id="4-3、指定并行度但不设置固定的completions">4.3、指定并行度但不设置固定的completions</h3><p>第三种用法，也是很常用的一个用法：指定并行度（parallelism），但不设置固定的 completions 的值。</p><p>此时，我们就必须自己想办法，来决定什么时候启动新 Pod，什么时候 Job 才算执行完成。在这种情况下，任务的总数是未知的，所以我们不仅需要一个工作队列来负责任务分发，还需要能够判断工作队列已经为空（即：所有的工作已经结束了）。</p><p>这时候，Job 的定义基本上没变化，只不过是不再需要定义 completions 的值了而已：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">job-wq-2</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">parallelism:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">job-wq-2</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">c</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">gcr.io/myproject/job-wq-2</span><br>        <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">BROKER_URL</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">amqp://guest:guest@rabbitmq-service:5672</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">QUEUE</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">job2</span><br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span><br></code></pre></td></tr></table></figure><p>而对应的 Pod 的逻辑会稍微复杂一些，我们可以用这样一段伪代码来描述：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">/* job-wq-2的伪代码 */<br>for !queue.IsEmpty($BROKER_URL, $QUEUE) &#123;<br>  task := queue.Pop()<br>  process(task)<br>&#125;<br>print(&quot;Queue empty, exiting&quot;)<br>exit<br></code></pre></td></tr></table></figure><p>由于任务数目的总数不固定，所以每一个 Pod 必须能够知道，自己什么时候可以退出。比如，在这个例子中，我们简单地以“队列为空”，作为任务全部完成的标志。所以说，这种用法，对应的是“任务总数不固定”的场景。</p><p>不过，在实际的应用中，我们需要处理的条件往往会非常复杂。比如，任务完成后的输出、每个任务 Pod 之间是不是有资源的竞争和协同等等。</p><h2 id="五、CronJon">五、CronJon</h2><p>最后，我们讨论一个非常有用的 Job 对象，叫作：CronJob。顾名思义，CronJob 描述的，正是定时任务。它的 API 对象，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">CronJob</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hello</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">schedule:</span> <span class="hljs-string">&quot;*/1 * * * *&quot;</span><br>  <span class="hljs-attr">jobTemplate:</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">template:</span><br>        <span class="hljs-attr">spec:</span><br>          <span class="hljs-attr">containers:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hello</span><br>            <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>            <span class="hljs-attr">args:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">/bin/sh</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">-c</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">date;</span> <span class="hljs-string">echo</span> <span class="hljs-string">Hello</span> <span class="hljs-string">from</span> <span class="hljs-string">the</span> <span class="hljs-string">Kubernetes</span> <span class="hljs-string">cluster</span><br>          <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span><br></code></pre></td></tr></table></figure><p>在这个 YAML 文件中，最重要的关键词就是 jobTemplate。看到它，我们一定恍然大悟，原来 CronJob 是一个 Job 对象的控制器（Controller）！</p><p>没错，CronJob 与 Job 的关系，正如同 Deployment 与 Pod 的关系一样。CronJob 是一个专门用来管理 Job 对象的控制器。只不过，它创建和删除 Job 的依据，是 schedule 字段定义的、一个标准的Unix Cron格式的表达式。比如，“*/1 * * * *”。这个 Cron 表达式里 */1 中的 * 表示从 0 开始，/ 表示“每”，1 表示偏移量。所以，它的意思就是：从 0 开始，每 1 个时间单位执行一次。</p><p>那么，时间单位又是什么呢？Cron 表达式中的五个部分分别代表：分钟、小时、日、月、星期。所以，上面这句 Cron 表达式的意思是：从当前开始，每分钟执行一次。而这里要执行的内容，就是 jobTemplate 定义的 Job 了。所以，这个 CronJob 对象在创建 1 分钟后，就会有一个 Job 产生了，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f ./cronjob.yaml</span><br>cronjob &quot;hello&quot; created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">一分钟后</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get <span class="hljs-built_in">jobs</span></span><br>NAME               DESIRED   SUCCESSFUL   AGE<br>hello-4111706356   1         1         2s<br></code></pre></td></tr></table></figure><p>此时，CronJob 对象会记录下这次 Job 执行的时间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get cronjob hello</span><br>NAME      SCHEDULE      SUSPEND   ACTIVE    LAST-SCHEDULE<br>hello     */1 * * * *   False     0         Thu, 6 Sep 2018 14:34:00 -070<br></code></pre></td></tr></table></figure><p>需要注意的是，由于定时任务的特殊性，很可能某个 Job 还没有执行完，另外一个新 Job 就产生了。这时候，我们可以通过 spec.concurrencyPolicy 字段来定义具体的处理策略。比如：</p><ul><li>concurrencyPolicy=Allow，这也是默认情况，这意味着这些 Job 可以同时存在；</li><li>oncurrencyPolicy=Forbid，这意味着不会创建新的 Pod，该创建周期被跳过；</li><li>concurrencyPolicy=Replace，这意味着新产生的 Job 会替换旧的、没有执行完的 Job。</li></ul><p>而如果某一次 Job 创建失败，这次创建就会被标记为“miss”。当在指定的时间窗口内，miss 的数目达到 100 时，那么 CronJob 会停止再创建这个 Job。这个时间窗口，可以由 spec.startingDeadlineSeconds 字段指定。比如 startingDeadlineSeconds=200，意味着在过去 200 s 里，如果 miss 的数目达到了 100 次，那么这个 Job 就不会被创建执行了。</p><h2 id="六、小结">六、小结</h2><p>在这篇文章中，我们主要讨论了如下概念：</p><ul><li>离线业务是Job对象的主要应用场景。比如，在计算业务中，我们可以通过Job对象控制计算业务的并发数（parallelism）和最终完成的业务数（completions）。</li><li>在Job对象中，有一种特殊的Job名叫CronJob。它类似与Uninx系统中的定时任务。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器编排6：DaemonSet</title>
    <link href="/2020/10/04/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%926%EF%BC%9ADaemonSet/"/>
    <url>/2020/10/04/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%926%EF%BC%9ADaemonSet/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们讨论了StatefulSet的工作原理。接下来，我们再看看容器化守护进程的意义，即：DaemonSet。</p><h2 id="一、从滚动更新StatefulSet说起">一、从滚动更新StatefulSet说起</h2><p>StatefulSet 其实就是对现有典型运维业务的容器化抽象。也就是说，我们一定有方法在不使用 Kubernetes、甚至不使用容器的情况下，自己 DIY 一个类似的方案出来。但是，一旦涉及到升级、版本管理等更工程化的能力，Kubernetes 的好处，才会更加凸现。比如，如何对 StatefulSet 进行“滚动更新”（rolling update）？</p><p>很简单。我们只要修改 StatefulSet 的 Pod 模板，就会自动触发“滚动更新”:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl patch statefulset mysql --<span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;json&#x27;</span> -p=<span class="hljs-string">&#x27;[&#123;&quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/spec/template/spec/containers/0/image&quot;, &quot;value&quot;:&quot;mysql:5.7.23&quot;&#125;]&#x27;</span></span><br>statefulset.apps/mysql patched<br></code></pre></td></tr></table></figure><p>在这里，我们使用了 kubectl patch 命令。它的意思是，以“补丁”的方式（JSON 格式的）修改一个 API 对象的指定字段，也就是我在后面指定的“spec/template/spec/containers/0/image”。这样，StatefulSet Controller 就会按照与 Pod 编号相反的顺序，从最后一个 Pod 开始，逐一更新这个 StatefulSet 管理的每个 Pod。而如果更新发生了错误，这次“滚动更新”就会停止。</p><p>此外，StatefulSet 的“滚动更新”还允许我们进行更精细的控制，比如金丝雀发布（Canary Deploy）或者灰度发布，这意味着应用的多个实例中被指定的一部分不会被更新到最新的版本。而这个字段，正是 StatefulSet 的 spec.updateStrategy.rollingUpdate 的 partition 字段。比如，现在我将前面这个 StatefulSet 的 partition 字段设置为 2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl patch statefulset mysql -p <span class="hljs-string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;updateStrategy&quot;:&#123;&quot;type&quot;:&quot;RollingUpdate&quot;,&quot;rollingUpdate&quot;:&#123;&quot;partition&quot;:2&#125;&#125;&#125;&#125;&#x27;</span></span><br>statefulset.apps/mysql patched<br></code></pre></td></tr></table></figure><p>其中，kubectl patch 命令后面的参数（JSON 格式的），就是 partition 字段在 API 对象里的路径。所以，上述操作等同于直接使用 kubectl edit 命令，打开这个对象，把 partition 字段修改为 2。这样，我们就指定了当 Pod 模板发生变化的时候，比如 MySQL 镜像更新到 5.7.23，那么只有序号大于或者等于 2 的 Pod 会被更新到这个版本。并且，如果我们删除或者重启了序号小于 2 的 Pod，等它再次启动后，也会保持原先的 5.7.2 版本，绝不会被升级到 5.7.23 版本。</p><h2 id="二、DaemonSet的作用">二、DaemonSet的作用</h2><p>DaemonSet 的主要作用，是让我们在 Kubernetes 集群里，运行一个 Daemon Pod。 这个 Pod 有如下三个特征：</p><ul><li><p>这个 Pod 运行在 Kubernetes 集群里的每一个节点（Node）上；</p></li><li><p>每个节点上只有一个这样的 Pod 实例；</p></li><li><p>当有新的节点加入 Kubernetes 集群后，该 Pod 会自动地在新节点上被创建出来；</p></li><li><p>当旧节点被删除后，它上面的 Pod 也相应地会被回收掉。</p></li></ul><p>这个机制听起来很简单，但 Daemon Pod 的意义确实是非常重要的。我们随便列举几个例子：</p><ul><li><p>各种网络插件的 Agent 组件，都必须运行在每一个节点上，用来处理这个节点上的容器网络；</p></li><li><p>各种存储插件的 Agent 组件，也必须运行在每一个节点上，用来在这个节点上挂载远程存储目录，操作容器的 Volume 目录；</p></li><li><p>各种监控组件和日志组件，也必须运行在每一个节点上，负责这个节点上的监控信息和日志搜集。</p></li></ul><p>更重要的是，跟其他编排对象不一样，DaemonSet 开始运行的时机，很多时候比整个 Kubernetes 集群出现的时机都要早。这个乍一听起来可能有点儿奇怪。但其实我们来想一下：如果这个 DaemonSet 正是一个网络插件的 Agent 组件呢？</p><p>这个时候，整个 Kubernetes 集群里还没有可用的容器网络，所有 Worker 节点的状态都是 NotReady（NetworkReady=false）。这种情况下，普通的 Pod 肯定不能运行在这个集群上。所以，这也就意味着 DaemonSet 的设计，必须要有某种“过人之处”才行。</p><h2 id="三、DaemonSet的工作原理">三、DaemonSet的工作原理</h2><h3 id="3-1、部署一个DaemonSet对象">3.1、部署一个DaemonSet对象</h3><p>为了弄清楚 DaemonSet 的工作原理，我们还是按照老规矩，先从它的 API 对象的定义说起。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd-elasticsearch</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">fluentd-logging</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd-elasticsearch</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd-elasticsearch</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">tolerations:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">node-role.kubernetes.io/master</span><br>        <span class="hljs-attr">effect:</span> <span class="hljs-string">NoSchedule</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd-elasticsearch</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">k8s.gcr.io/fluentd-elasticsearch:1.20</span><br>        <span class="hljs-attr">resources:</span><br>          <span class="hljs-attr">limits:</span><br>            <span class="hljs-attr">memory:</span> <span class="hljs-string">200Mi</span><br>          <span class="hljs-attr">requests:</span><br>            <span class="hljs-attr">cpu:</span> <span class="hljs-string">100m</span><br>            <span class="hljs-attr">memory:</span> <span class="hljs-string">200Mi</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlog</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/log</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlibdockercontainers</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/lib/docker/containers</span><br>          <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">terminationGracePeriodSeconds:</span> <span class="hljs-number">30</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlog</span><br>        <span class="hljs-attr">hostPath:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">/var/log</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlibdockercontainers</span><br>        <span class="hljs-attr">hostPath:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">/var/lib/docker/containers</span><br></code></pre></td></tr></table></figure><p>这个 DaemonSet，管理的是一个 fluentd-elasticsearch 镜像的 Pod。这个镜像的功能非常实用：通过 fluentd 将 Docker 容器里的日志转发到 ElasticSearch 中。</p><p>可以看到，DaemonSet 跟 Deployment 其实非常相似，只不过是没有 replicas 字段；它也使用 selector 选择管理所有携带了 name=fluentd-elasticsearch 标签的 Pod。而这些 Pod 的模板，也是用 template 字段定义的。在这个字段中，我们定义了一个使用 fluentd-elasticsearch:1.20 镜像的容器，而且这个容器挂载了两个 hostPath 类型的 Volume，分别对应宿主机的 /var/log 目录和 /var/lib/docker/containers 目录。</p><p>显然，fluentd 启动之后，它会从这两个目录里搜集日志信息，并转发给 ElasticSearch 保存。这样，我们通过 ElasticSearch 就可以很方便地检索这些日志了。需要注意的是，Docker 容器里应用的日志，默认会保存在宿主机的 /var/lib/docker/containers/容器 ID/容器 ID-json.log 文件里，所以这个目录正是 fluentd 的搜集目标。</p><h3 id="3-2、DaemonSet-Controller">3.2、DaemonSet Controller</h3><p>那么，DaemonSet 又是如何保证每个 Node 上有且只有一个被管理的 Pod 呢？显然，这是一个典型的“控制器模型”能够处理的问题。</p><p>DaemonSet Controller，首先从 Etcd 里获取所有的 Node 列表，然后遍历所有的 Node。这时，它就可以很容易地去检查，当前这个 Node 上是不是有一个携带了 name=fluentd-elasticsearch 标签的 Pod 在运行。而检查的结果，可能有这么三种情况：</p><ul><li><p>没有这种 Pod，那么就意味着要在这个 Node 上创建这样一个 Pod；</p></li><li><p>有这种 Pod，但是数量大于 1，那就说明要把多余的 Pod 从这个 Node 上删除掉；</p></li><li><p>正好只有一个这种 Pod，那说明这个节点是正常的。</p></li></ul><p>其中，删除节点（Node）上多余的 Pod 非常简单，直接调用 Kubernetes API 就可以了。但是，如何在指定的 Node 上创建新 Pod 呢？</p><h3 id="3-3、nodeSelector-VS-nodeAffinity">3.3、nodeSelector VS nodeAffinity</h3><p>如果我们已经熟悉了 Pod API 对象的话，那一定可以立刻说出答案：用 nodeSelector，选择 Node 的名字即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">nodeSelector:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">&lt;Node名字&gt;</span><br></code></pre></td></tr></table></figure><p>没错。不过，在 Kubernetes 项目里，nodeSelector 其实已经是一个将要被废弃的字段了。因为，现在有了一个新的、功能更完善的字段可以代替它，即：nodeAffinity。举个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">with-node-affinity</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">affinity:</span><br>    <span class="hljs-attr">nodeAffinity:</span><br>      <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span><br>        <span class="hljs-attr">nodeSelectorTerms:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">matchExpressions:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">metadata.name</span><br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>            <span class="hljs-attr">values:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">node-geektime</span><br></code></pre></td></tr></table></figure><p>在这个 Pod 里，我声明了一个 spec.affinity 字段，然后定义了一个 nodeAffinity。其中，spec.affinity 字段，是 Pod 里跟调度相关的一个字段。而在这里，我们定义的 nodeAffinity 的含义是：</p><ul><li>requiredDuringSchedulingIgnoredDuringExecution：它的意思是说，这个 nodeAffinity 必须在每次调度的时候予以考虑。同时，这也意味着我们可以设置在某些情况下不考虑这个 nodeAffinity；</li><li>这个 Pod，将来只允许运行在“<a href="http://metadata.name">metadata.name</a>”是“node-geektime”的节点上。</li></ul><p>在这里，我们应该注意到 nodeAffinity 的定义，可以支持更加丰富的语法，比如 operator: In（即：部分匹配；如果你定义 operator: Equal，就是完全匹配），这也正是 nodeAffinity 会取代 nodeSelector 的原因之一。备注：其实在大多数时候，这些 Operator 语义没啥用处。所以说，在学习开源项目的时候，一定要学会抓住“主线”。不要顾此失彼。</p><p>所以，我们的 DaemonSet Controller 会在创建 Pod 的时候，自动在这个 Pod 的 API 对象里，加上这样一个 nodeAffinity 定义。其中，需要绑定的节点名字，正是当前正在遍历的这个 Node。当然，DaemonSet 并不需要修改用户提交的 YAML 文件里的 Pod 模板，而是在向 Kubernetes 发起请求之前，直接修改根据模板生成的 Pod 对象。</p><h3 id="3-4、tolerations">3.4、tolerations</h3><p>此外，DaemonSet 还会给这个 Pod 自动加上另外一个与调度相关的字段，叫作 tolerations。这个字段意味着这个 Pod，会“容忍”（Toleration）某些 Node 的“污点”（Taint）。而 DaemonSet 自动加上的 tolerations 字段，格式如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">with-toleration</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">tolerations:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">node.kubernetes.io/unschedulable</span><br>    <span class="hljs-attr">operator:</span> <span class="hljs-string">Exists</span><br>    <span class="hljs-attr">effect:</span> <span class="hljs-string">NoSchedule</span><br></code></pre></td></tr></table></figure><p>这个 Toleration 的含义是：“容忍”所有被标记为 unschedulable“污点”的 Node；“容忍”的效果是允许调度。</p><p>而在正常情况下，被标记了 unschedulable“污点”的 Node，是不会有任何 Pod 被调度上去的（effect: NoSchedule）。可是，DaemonSet 自动地给被管理的 Pod 加上了这个特殊的 Toleration，就使得这些 Pod 可以忽略这个限制，继而保证每个节点上都会被调度一个 Pod。当然，如果这个节点有故障的话，这个 Pod 可能会启动失败，而 DaemonSet 则会始终尝试下去，直到 Pod 启动成功。前面介绍到的 DaemonSet 的“过人之处”，其实就是依靠 Toleration 实现的。</p><p>假如当前 DaemonSet 管理的，是一个网络插件的 Agent Pod，那么我们就必须在这个 DaemonSet 的 YAML 文件里，给它的 Pod 模板加上一个能够“容忍”<a href="http://node.kubernetes.io/network-unavailable%E2%80%9C%E6%B1%A1%E7%82%B9%E2%80%9D%E7%9A%84">node.kubernetes.io/network-unavailable“污点”的</a> Toleration。正如下面这个例子所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">...</span><br><span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">network-plugin-agent</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">tolerations:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">node.kubernetes.io/network-unavailable</span><br>        <span class="hljs-attr">operator:</span> <span class="hljs-string">Exists</span><br>        <span class="hljs-attr">effect:</span> <span class="hljs-string">NoSchedule</span><br></code></pre></td></tr></table></figure><p>在 Kubernetes 项目中，当一个节点的网络插件尚未安装时，<a href="http://xn--node-z94frg9d44f7vojcx1tn65ah64dqk9bb4b9x5bu21a.kubernetes.io/network-unavailable%E7%9A%84%E2%80%9C%E6%B1%A1%E7%82%B9%E2%80%9D%E3%80%82%E8%80%8C%E9%80%9A%E8%BF%87%E8%BF%99%E6%A0%B7%E4%B8%80%E4%B8%AA">这个节点就会被自动加上名为node.kubernetes.io/network-unavailable的“污点”。而通过这样一个</a> Toleration，调度器在调度这个 Pod 的时候，就会忽略当前节点上的“污点”，从而成功地将网络插件的 Agent 组件调度到这台机器上启动起来。</p><p>这种机制，正是我们在部署 Kubernetes 集群的时候，能够先部署 Kubernetes 本身、再部署网络插件的根本原因：因为当时我们所创建的 Weave 的 YAML，实际上就是一个 DaemonSet。</p><h3 id="3-5、小结">3.5、小结</h3><p>至此，通过上面这些内容，我们应该能够明白，DaemonSet 其实是一个非常简单的控制器。在它的控制循环中，只需要遍历所有节点，然后根据节点上是否有被管理 Pod 的情况，来决定是否要创建或者删除一个 Pod。只不过，在创建每个 Pod 的时候，DaemonSet 会自动给这个 Pod 加上一个 nodeAffinity，从而保证这个 Pod 只会在指定节点上启动。同时，它还会自动给这个 Pod 加上一个 Toleration，从而忽略节点的 unschedulable“污点”。</p><p>当然，我们也可以在 Pod 模板里加上更多种类的 Toleration，从而利用 DaemonSet 达到自己的目的。比如，在这个 fluentd-elasticsearch DaemonSet 里，可以给它加上了这样的 Toleration：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tolerations:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">node-role.kubernetes.io/master</span><br>  <span class="hljs-attr">effect:</span> <span class="hljs-string">NoSchedule</span><br></code></pre></td></tr></table></figure><p>这是因为在默认情况下，Kubernetes 集群不允许用户在 Master 节点部署 Pod。因为，Master <a href="http://xn--node-role-u75noor9at9e18ylg0bklu1r2cs51dijtbej6e.kubernetes.io/master%E7%9A%84%E2%80%9C%E6%B1%A1%E7%82%B9%E2%80%9D%E3%80%82%E6%89%80%E4%BB%A5%EF%BC%8C%E4%B8%BA%E4%BA%86%E8%83%BD%E5%9C%A8">节点默认携带了一个叫作node-role.kubernetes.io/master的“污点”。所以，为了能在</a> Master 节点上部署 DaemonSet 的 Pod，我们就必须让这个 Pod“容忍”这个“污点”。</p><h2 id="四、实践DeamonSet">四、实践DeamonSet</h2><p>在理解了 DaemonSet 的工作原理之后，接下来我们就通过一个具体的实践来更深入地掌握 DaemonSet 的使用方法。备注：需要注意的是，在 Kubernetes v1.11 之前，由于调度器尚不完善，DaemonSet 是由 DaemonSet Controller 自行调度的，即它会直接设置 Pod 的 spec.nodename 字段，这样就可以跳过调度器了。但是，这样的做法很快就会被废除。</p><h3 id="4-1、创建DaemonSet对象">4.1、创建DaemonSet对象</h3><p>首先，创建这个 DaemonSet 对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f fluentd-elasticsearch.yaml</span><br></code></pre></td></tr></table></figure><p>需要注意的是，在 DaemonSet 上，我们一般都应该加上 resources 字段，来限制它的 CPU 和内存使用，防止它占用过多的宿主机资源。</p><h3 id="4-2、查看Pod对象">4.2、查看Pod对象</h3><p>而创建成功后，我们就能看到，如果有 N 个节点，就会有 N 个 fluentd-elasticsearch Pod 在运行。比如在我们的例子里，会有两个 Pod，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pod -n kube-system -l name=fluentd-elasticsearch</span><br>NAME                          READY     STATUS    RESTARTS   AGE<br>fluentd-elasticsearch-dqfv9   1/1       Running   0          53m<br>fluentd-elasticsearch-pf9z5   1/1       Running   0          53m<br></code></pre></td></tr></table></figure><h3 id="4-3、查看DaemonSet对象">4.3、查看DaemonSet对象</h3><p>而如果此时通过 kubectl get 查看一下 Kubernetes 集群里的 DaemonSet 对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get ds -n kube-system fluentd-elasticsearch</span><br>NAME                    DESIRED   CURRENT   READY     UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE<br>fluentd-elasticsearch   2         2         2         2            2           &lt;none&gt;          1h<br></code></pre></td></tr></table></figure><p>就会发现 DaemonSet 和 Deployment 一样，也有 DESIRED、CURRENT 等多个状态字段。这也就意味着，DaemonSet 可以像 Deployment 那样，进行版本管理。</p><h3 id="4-4、查看DaemonSet对象的版本">4.4、查看DaemonSet对象的版本</h3><p>这个版本，可以使用 kubectl rollout history 看到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout <span class="hljs-built_in">history</span> daemonset fluentd-elasticsearch -n kube-system</span><br>daemonsets &quot;fluentd-elasticsearch&quot;<br>REVISION  CHANGE-CAUSE<br>1         &lt;none&gt;<br></code></pre></td></tr></table></figure><h3 id="4-5、更新DaemonSet的容器镜像">4.5、更新DaemonSet的容器镜像</h3><p>接下来，我们来把这个 DaemonSet 的容器镜像版本更新到 v2.2.0：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">set</span> image ds/fluentd-elasticsearch fluentd-elasticsearch=k8s.gcr.io/fluentd-elasticsearch:v2.2.0 --record -n=kube-system</span><br></code></pre></td></tr></table></figure><p>这个 kubectl set image 命令里，第一个 fluentd-elasticsearch 是 DaemonSet 的名字，第二个 fluentd-elasticsearch 是容器的名字。</p><h3 id="4-6、查看滚动更新的过程">4.6、查看滚动更新的过程</h3><p>这时候，我们可以使用 kubectl rollout status 命令看到这个“滚动更新”的过程，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout status ds/fluentd-elasticsearch -n kube-system</span><br>Waiting for daemon set &quot;fluentd-elasticsearch&quot; rollout to finish: 0 out of 2 new pods have been updated...<br>Waiting for daemon set &quot;fluentd-elasticsearch&quot; rollout to finish: 0 out of 2 new pods have been updated...<br>Waiting for daemon set &quot;fluentd-elasticsearch&quot; rollout to finish: 1 of 2 updated pods are available...<br>daemon set &quot;fluentd-elasticsearch&quot; successfully rolled out<br></code></pre></td></tr></table></figure><p>注意，由于这一次我们在升级命令后面加上了–record 参数，所以这次升级使用到的指令就会自动出现在 DaemonSet 的 rollout history 里面，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout <span class="hljs-built_in">history</span> daemonset fluentd-elasticsearch -n kube-system</span><br>daemonsets &quot;fluentd-elasticsearch&quot;<br>REVISION  CHANGE-CAUSE<br>1         &lt;none&gt;<br>2         kubectl set image ds/fluentd-elasticsearch fluentd-elasticsearch=k8s.gcr.io/fluentd-elasticsearch:v2.2.0 --namespace=kube-system --record=true<br></code></pre></td></tr></table></figure><p>有了版本号，我们也就可以像 Deployment 一样，将 DaemonSet 回滚到某个指定的历史版本了。</p><h2 id="五、ControllerRevision">五、ControllerRevision</h2><p>我们在前面的文章中讲解 Deployment 对象的时候，曾经提到过，Deployment 管理这些版本，靠的是“一个版本对应一个 ReplicaSet 对象”。可是，DaemonSet 控制器操作的直接就是 Pod，不可能有 ReplicaSet 这样的对象参与其中。那么，它的这些版本又是如何维护的呢？</p><p>所谓，一切皆对象！在 Kubernetes 项目中，任何我们觉得需要记录下来的状态，都可以通过 API 对象的方式实现。当然，“版本”也不例外。Kubernetes v1.7 之后添加了一个 API 对象，名叫 ControllerRevision，专门用来记录某种 Controller 对象的版本。比如，我们可以通过如下命令查看 fluentd-elasticsearch 对应的 ControllerRevision：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get controllerrevision -n kube-system -l name=fluentd-elasticsearch</span><br>NAME                               CONTROLLER                             REVISION   AGE<br>fluentd-elasticsearch-64dc6799c9   daemonset.apps/fluentd-elasticsearch   2          1h<br></code></pre></td></tr></table></figure><p>而如果我们使用 kubectl describe 查看这个 ControllerRevision 对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe controllerrevision fluentd-elasticsearch-64dc6799c9 -n kube-system</span><br>Name:         fluentd-elasticsearch-64dc6799c9<br>Namespace:    kube-system<br>Labels:       controller-revision-hash=2087235575<br>              name=fluentd-elasticsearch<br>Annotations:  deprecated.daemonset.template.generation=2<br>              kubernetes.io/change-cause=kubectl set image ds/fluentd-elasticsearch fluentd-elasticsearch=k8s.gcr.io/fluentd-elasticsearch:v2.2.0 --record=true --namespace=kube-system<br>API Version:  apps/v1<br>Data:<br>  Spec:<br>    Template:<br>      $ Patch:  replace<br>      Metadata:<br>        Creation Timestamp:  &lt;nil&gt;<br>        Labels:<br>          Name:  fluentd-elasticsearch<br>      Spec:<br>        Containers:<br>          Image:              k8s.gcr.io/fluentd-elasticsearch:v2.2.0<br>          Image Pull Policy:  IfNotPresent<br>          Name:               fluentd-elasticsearch<br>...<br>Revision:                  2<br>Events:                    &lt;none&gt;<br></code></pre></td></tr></table></figure><p>就会看到，这个 ControllerRevision 对象，实际上是在 Data 字段保存了该版本对应的完整的 DaemonSet 的 API 对象。并且，在 Annotation 字段保存了创建这个对象所使用的 kubectl 命令。接下来，我们可以尝试将这个 DaemonSet 回滚到 Revision=1 时的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout undo daemonset fluentd-elasticsearch --to-revision=1 -n kube-system</span><br>daemonset.extensions/fluentd-elasticsearch rolled back<br></code></pre></td></tr></table></figure><p>这个 kubectl rollout undo 操作，实际上相当于读取到了 Revision=1 的 ControllerRevision 对象保存的 Data 字段。而这个 Data 字段里保存的信息，就是 Revision=1 时这个 DaemonSet 的完整 API 对象。</p><p>所以，现在 DaemonSet Controller 就可以使用这个历史 API 对象，对现有的 DaemonSet 做一次 PATCH 操作（等价于执行一次 kubectl apply -f “旧的 DaemonSet 对象”），从而把这个 DaemonSet“更新”到一个旧版本。这也是为什么，在执行完这次回滚操作后，我们会发现，DaemonSet 的 Revision 并不会从 Revision=2 退回到 1，而是会增加成 Revision=3。这是因为，一个新的 ControllerRevision 被创建了出来。</p><h2 id="六、小结">六、小结</h2><p>在这篇文章中，我们主要讨论了如下概念：</p><ul><li><p>DaemonSet的主要作用是，在每个节点上只运行一个Pod实例。它通常被用于部署监控组件、日志组件、网络组件和存储组件等。</p></li><li><p>DaemonSet控制器的工作原理其实很简单：首先，它会遍历所有的节点，并根据节点的Pod情况决定要执行的调度操作，然后，通过nodeAffinity和toleration机制实现自己的编排能力。其中，nodeAffinity用于将Pod调度到指定的节点；toleration则用于忽略节点的某些“污点”。</p></li><li><p>DaemonSet使用ControllerRevision保存和管理自己的版本。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器编排5：深入理解StatefulSet之部署一个有状态应用</title>
    <link href="/2020/10/03/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%925%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3StatefulSet%E4%B9%8B%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E6%9C%89%E7%8A%B6%E6%80%81%E5%BA%94%E7%94%A8/"/>
    <url>/2020/10/03/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%925%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3StatefulSet%E4%B9%8B%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E6%9C%89%E7%8A%B6%E6%80%81%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们主要讨论了StatefulSet是如何处理拓扑状态和存储状态的，以及StatefulSet的工作原理。接下来，我们通过一个实际例子，熟悉一下部署一个StatefulSet的完整流程。</p><h2 id="一、部署MySQL主从集群的三座大山">一、部署MySQL主从集群的三座大山</h2><p>相比于 Etcd、Cassandra 等“原生”就考虑了分布式需求的项目，MySQL 以及很多其他的数据库项目，在分布式集群的搭建上并不友好，甚至有点“原始”。首先，用自然语言来描述一下我们想要部署的“有状态应用”：</p><ul><li>一个“主从复制”（Maser-Slave Replication）的 MySQL 集群；</li><li>有 1 个主节点（Master）；</li><li>有多个从节点（Slave）；</li><li>从节点需要能水平扩展；</li><li>所有的写操作，只能在主节点上执行；</li><li>读操作可以在所有节点上执行。</li></ul><p>这就是一个非常典型的主从模式的 MySQL 集群了。我们可以把上面描述的“有状态应用”的需求，通过一张图来表示。</p><p><img src="/img/image-20201003204519331.png" alt="image-20201003204519331"></p><p>在常规环境里，部署这样一个主从模式的 MySQL 集群的主要难点在于：如何让从节点能够拥有主节点的数据，即：如何配置主从节点的复制与同步。</p><p>所以，在安装好 MySQL 的 Master 节点之后，我们需要做的第一步工作，就是通过 XtraBackup 将 Master 节点的数据备份到指定目录。这一步会自动在目标目录里生成一个备份信息文件，名叫：xtrabackup_binlog_info。这个文件一般会包含如下两个信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> xtrabackup_binlog_info</span><br>TheMaster-bin.000001     481<br></code></pre></td></tr></table></figure><p>这两个信息会在接下来配置 Slave 节点的时候用到。</p><p>第二步：配置 Slave 节点。Slave 节点在第一次启动前，需要先把 Master 节点的备份数据，连同备份信息文件，一起拷贝到自己的数据目录（/var/lib/mysql）下。然后，我们执行这样一句 SQL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">TheSlave|mysql&gt; CHANGE MASTER TO<br>                MASTER_HOST=&#x27;$masterip&#x27;,<br>                MASTER_USER=&#x27;xxx&#x27;,<br>                MASTER_PASSWORD=&#x27;xxx&#x27;,<br>                MASTER_LOG_FILE=&#x27;TheMaster-bin.000001&#x27;,<br>                MASTER_LOG_POS=481;<br></code></pre></td></tr></table></figure><p>其中，MASTER_LOG_FILE 和 MASTER_LOG_POS，就是备份数据对应的二进制日志（Binary Log）文件名称和开始位置（偏移量），这也正是 xtrabackup_binlog_info 文件里的两部分内容（即：TheMaster-bin.000001 和 481）。</p><p>第三步，启动 Slave 节点。在这一步，我们需要执行这样一句 SQL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">TheSlave|mysql&gt; START SLAVE;<br></code></pre></td></tr></table></figure><p>这样，Slave 节点就启动了。它会使用备份信息文件中的二进制日志文件和偏移量，与主节点进行数据同步。</p><p>接下来，我们还可以在这个集群中添加更多的 Slave 节点。需要注意的是，新添加的 Slave 节点的备份数据，来自于已经存在的 Slave 节点。所以，我们需要将 Slave 节点的数据备份在指定目录。而这个备份操作会自动生成另一种备份信息文件，名叫：xtrabackup_slave_info。同样地，这个文件也包含了 MASTER_LOG_FILE 和 MASTER_LOG_POS 两个字段。然后，我们就可以执行跟前面一样的“CHANGE MASTER TO”和“START SLAVE” 指令，来初始化并启动这个新的 Slave 节点了。</p><p>通过上面的叙述，我们不难看到，将部署 MySQL 集群的流程迁移到 Kubernetes 项目上，需要能够“容器化”地解决下面的“三座大山”：</p><ul><li>Master 节点和 Slave 节点需要有不同的配置文件（即：不同的 my.cnf）；</li><li>Master 节点和 Slave 节点需要能够传输备份数据；</li><li>Slave 节点在第一次启动之前，需要执行一些初始化 SQL 操作；</li></ul><p>由于 MySQL 本身同时拥有拓扑状态（主从节点的区别）和存储状态（MySQL 保存在本地的数据），我们自然要通过 StatefulSet 来解决这“三座大山”的问题。</p><h2 id="二、解决第一座大山">二、解决第一座大山</h2><p>“第一座大山：Master 节点和 Slave 节点需要有不同的配置文件”，这很容易处理：我们只需要给主从节点分别准备两份不同的 MySQL 配置文件，然后根据 Pod 的序号（Index）挂载进去即可。</p><p>而这样的配置文件信息，应该保存在 ConfigMap 里供 Pod 使用。它的定义如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">master.cnf:</span> <span class="hljs-string">|</span><br><span class="hljs-string">    # 主节点MySQL的配置文件</span><br><span class="hljs-string">    [mysqld]</span><br><span class="hljs-string">    log-bin</span><br><span class="hljs-string"></span>  <span class="hljs-attr">slave.cnf:</span> <span class="hljs-string">|</span><br><span class="hljs-string">    # 从节点MySQL的配置文件</span><br><span class="hljs-string">    [mysqld]</span><br><span class="hljs-string">    super-read-only</span><br></code></pre></td></tr></table></figure><p>在这里，我们定义了 master.cnf 和 slave.cnf 两个 MySQL 的配置文件。master.cnf 开启了 log-bin，即：使用二进制日志文件的方式进行主从复制，这是一个标准的设置。slave.cnf 开启了 super-read-only，代表的是从节点会拒绝除了主节点的数据同步操作之外的所有写操作，即：它对用户是只读的。</p><p>而上述 ConfigMap 定义里的 data 部分，是 Key-Value 格式的。比如，master.cnf 就是这份配置数据的 Key，而“|”后面的内容，就是这份配置数据的 Value。这份数据将来挂载进 Master 节点对应的 Pod 后，就会在 Volume 目录里生成一个叫作 master.cnf 的文件。</p><p>在开始定义实际的容器之前，我们还需要创建两个 Service 来供 StatefulSet 以及用户使用。这两个 Service 的定义如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">3306</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-read</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">3306</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span><br></code></pre></td></tr></table></figure><p>可以看到，这两个 Service 都代理了所有携带 app=mysql 标签的 Pod，也就是所有的 MySQL Pod。端口映射都是用 Service 的 3306 端口对应 Pod 的 3306 端口。不同的是:</p><ul><li>第一个名叫“mysql”的 Service 是一个 Headless Service（即：clusterIP= None）。所以它的作用，是通过为 Pod 分配 DNS 记录来固定它的拓扑状态，比如“mysql-0.mysql”和“mysql-1.mysql”这样的 DNS 名字。其中，编号为 0 的节点就是我们的主节点。</li><li>第二个名叫“mysql-read”的 Service，则是一个常规的 Service。并且我们规定，所有用户的读请求，都必须访问第二个 Service 被自动分配的 DNS 记录，即：“mysql-read”（当然，也可以访问这个 Service 的 VIP）。</li></ul><p>这样，读请求就可以被转发到任意一个 MySQL 的主节点或者从节点上。而写请求，则必须直接以 DNS 记录的方式访问到 MySQL 的主节点，也就是：“mysql-0.mysql“这条 DNS 记录。</p><h2 id="三、解决第二座大山">三、解决第二座大山</h2><p>接下来，我们再一起解决“第二座大山：Master 节点和 Slave 节点需要能够传输备份文件”的问题。而翻越这座大山的一个推荐思路是：先搭建框架，再完善细节。其中，Pod 部分如何定义，是完善细节时的重点。</p><h3 id="3-1、搭建框架">3.1、搭建框架</h3><p>首先，我们先为 StatefulSet 对象规划一个大致的框架，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">initContainers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">init-mysql</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">clone-mysql</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">xtrabackup</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">conf</span><br>        <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-map</span><br>        <span class="hljs-attr">configMap:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">volumeClaimTemplates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">data</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">accessModes:</span> [<span class="hljs-string">&quot;ReadWriteOnce&quot;</span>]<br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">requests:</span><br>          <span class="hljs-attr">storage:</span> <span class="hljs-string">10Gi</span><br></code></pre></td></tr></table></figure><p>在这一步，我们可以先为 StatefulSet 定义一些通用的字段。比如：</p><ul><li><p>selector 表示，这个 StatefulSet 要管理的 Pod 必须携带 app=mysql 标签；</p></li><li><p>serviceName表示，这个 StatefulSet 要使用的 Headless Service 的名字是：mysql。</p></li><li><p>replicas表示，这个 StatefulSet 定义了一个由三个节点组成的MySQL 集群：一个 Master 节点，两个 Slave 节点。</p></li></ul><p>此外，还可以看到，StatefulSet 管理的“有状态应用”的多个实例，也都是通过同一份 Pod 模板创建出来的，使用的是同一个 Docker 镜像。这也就意味着：如果我们的应用要求不同节点的镜像不一样，那就不能再使用 StatefulSet 了。对于这种情况，应该考虑使用 Operator。</p><p>除了这些基本的字段外，作为一个有存储状态的 MySQL 集群，StatefulSet 还需要管理存储状态。所以，我们需要通过 volumeClaimTemplate（PVC 模板）来为每个 Pod 定义 PVC。比如，在这里的 PVC 模板中：</p><ul><li>resources.requests.strorage 指定了存储的大小为 10 GiB；</li><li>ReadWriteOnce 指定了该存储的属性为可读写，并且一个 PV 只允许挂载在一个宿主机上。将来，这个 PV 对应的的 Volume 就会充当 MySQL Pod 的数据存储目录。</li></ul><p>接下来，我们来重点设计一下这个 StatefulSet 的 Pod 模板，也就是 template 字段。由于 StatefulSet 所管理的 Pod 都来自于同一个镜像，这就要求我们在编写 Pod 时，一定要保持清醒，用“人格分裂”的方式进行思考：</p><ul><li>如果这个 Pod 是 Master 节点，我们要怎么做；</li><li>如果这个 Pod 是 Slave 节点，我们又要怎么做。</li></ul><p>想清楚了这两个问题，我们就可以按照 Pod 的启动过程来一步步定义它们了。</p><h3 id="3-2、获取配置文件">3.2、获取配置文件</h3><p>第一步：从 ConfigMap 中，获取 MySQL Pod 对应的配置文件。</p><p>为此，我们需要进行一个初始化操作，根据节点的角色是 Master 还是 Slave，为 Pod 分配对应的配置文件。此外，MySQL 还要求集群里的每个节点都有一个唯一的 ID 文件，名叫 server-id.cnf。而根据我们已经掌握的 Pod 知识，这些初始化操作显然适合通过 InitContainer 来完成。所以，我们首先定义了一个 InitContainer，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">...</span><br><span class="hljs-comment"># template.spec</span><br><span class="hljs-attr">initContainers:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">init-mysql</span><br>  <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>  <span class="hljs-attr">command:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">bash</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;-c&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">|</span><br><span class="hljs-string">    set -ex</span><br><span class="hljs-string"></span><br>    <span class="hljs-comment"># 从Pod的序号，生成server-id</span><br>    [[ <span class="hljs-string">`hostname`</span> <span class="hljs-string">=~</span> <span class="hljs-string">-(</span>[<span class="hljs-number">0</span><span class="hljs-number">-9</span>]<span class="hljs-string">+)$</span> ]] <span class="hljs-string">||</span> <span class="hljs-string">exit</span> <span class="hljs-number">1</span><br>    <span class="hljs-string">ordinal=$&#123;BASH_REMATCH[1]&#125;</span><br>    <span class="hljs-string">echo</span> [<span class="hljs-string">mysqld</span>] <span class="hljs-string">&gt;</span> <span class="hljs-string">/mnt/conf.d/server-id.cnf</span><br><br>    <span class="hljs-comment"># 由于server-id=0有特殊含义，我们给ID加一个100来避开它</span><br>    <span class="hljs-string">echo</span> <span class="hljs-string">server-id=$((100</span> <span class="hljs-string">+</span> <span class="hljs-string">$ordinal))</span> <span class="hljs-string">&gt;&gt;</span> <span class="hljs-string">/mnt/conf.d/server-id.cnf</span><br>    <span class="hljs-comment"># 如果Pod序号是0，说明它是Master节点，从ConfigMap里把Master的配置文件拷贝到/mnt/conf.d/目录；</span><br>    <span class="hljs-comment"># 否则，拷贝Slave的配置文件</span><br>    <span class="hljs-string">if</span> [[ <span class="hljs-string">$ordinal</span> <span class="hljs-string">-eq</span> <span class="hljs-number">0</span> ]]<span class="hljs-string">;</span> <span class="hljs-string">then</span><br>      <span class="hljs-string">cp</span> <span class="hljs-string">/mnt/config-map/master.cnf</span> <span class="hljs-string">/mnt/conf.d/</span><br>    <span class="hljs-string">else</span><br>      <span class="hljs-string">cp</span> <span class="hljs-string">/mnt/config-map/slave.cnf</span> <span class="hljs-string">/mnt/conf.d/</span><br>    <span class="hljs-string">fi</span><br>  <span class="hljs-attr">volumeMounts:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">conf</span><br>    <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/mnt/conf.d</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-map</span><br>    <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/mnt/config-map</span><br></code></pre></td></tr></table></figure><p>在这个名叫 init-mysql 的 InitContainer 的配置中，它从 Pod 的 hostname 里，读取到了 Pod 的序号，以此作为 MySQL 节点的 server-id。</p><p>然后，init-mysql 通过这个序号，判断当前 Pod 到底是 Master 节点（即：序号为 0）还是 Slave 节点（即：序号不为 0），从而把对应的配置文件从 /mnt/config-map 目录拷贝到 /mnt/conf.d/ 目录下。</p><p>其中，文件拷贝的源目录 /mnt/config-map，正是 ConfigMap 在这个 Pod 的 Volume，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">...</span><br><span class="hljs-comment"># template.spec</span><br><span class="hljs-attr">volumes:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">conf</span><br>  <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-map</span><br>  <span class="hljs-attr">configMap:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br></code></pre></td></tr></table></figure><p>通过这个定义，init-mysql 在挂载了 config-map 这个 Volume 之后，ConfigMap 里保存的内容，就会以文件的方式出现在它的 /mnt/config-map 目录当中。而文件拷贝的目标目录，即容器里的 /mnt/conf.d/ 目录，对应的则是一个名叫 conf 的、emptyDir 类型的 Volume。基于 Pod Volume 共享的原理，当 InitContainer 复制完配置文件退出后，后面启动的 MySQL 容器只需要直接声明挂载这个名叫 conf 的 Volume，它所需要的.cnf 配置文件已经出现在里面了。这跟我们之前介绍的 Tomcat 和 WAR 包的处理方法是完全一样的。</p><h3 id="3-3、拷贝数据">3.3、拷贝数据</h3><p>第二步：在 Slave Pod 启动前，从 Master 或者其他 Slave Pod 里拷贝数据库数据到自己的目录下。为了实现这个操作，我们就需要再定义第二个 InitContainer，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">...</span><br><span class="hljs-comment"># template.spec.initContainers</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">clone-mysql</span><br>  <span class="hljs-attr">image:</span> <span class="hljs-string">gcr.io/google-samples/xtrabackup:1.0</span><br>  <span class="hljs-attr">command:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">bash</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;-c&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">|</span><br><span class="hljs-string">    set -ex</span><br><span class="hljs-string"></span><br>    <span class="hljs-comment"># 拷贝操作只需要在第一次启动时进行，所以如果数据已经存在，跳过</span><br>    [[ <span class="hljs-string">-d</span> <span class="hljs-string">/var/lib/mysql/mysql</span> ]] <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">exit</span> <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># Master节点(序号为0)不需要做这个操作</span><br>    [[ <span class="hljs-string">`hostname`</span> <span class="hljs-string">=~</span> <span class="hljs-string">-(</span>[<span class="hljs-number">0</span><span class="hljs-number">-9</span>]<span class="hljs-string">+)$</span> ]] <span class="hljs-string">||</span> <span class="hljs-string">exit</span> <span class="hljs-number">1</span><br>    <span class="hljs-string">ordinal=$&#123;BASH_REMATCH[1]&#125;</span><br>    [[ <span class="hljs-string">$ordinal</span> <span class="hljs-string">-eq</span> <span class="hljs-number">0</span> ]] <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">exit</span> <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 使用ncat指令，远程地从前一个节点拷贝数据到本地</span><br>    <span class="hljs-string">ncat</span> <span class="hljs-string">--recv-only</span> <span class="hljs-string">mysql-$(($ordinal-1)).mysql</span> <span class="hljs-number">3307</span> <span class="hljs-string">|</span> <span class="hljs-string">xbstream</span> <span class="hljs-string">-x</span> <span class="hljs-string">-C</span> <span class="hljs-string">/var/lib/mysql</span><br><br>    <span class="hljs-comment"># 执行--prepare，这样拷贝来的数据就可以用作恢复了</span><br>    <span class="hljs-string">xtrabackup</span> <span class="hljs-string">--prepare</span> <span class="hljs-string">--target-dir=/var/lib/mysql</span><br>  <span class="hljs-attr">volumeMounts:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">data</span><br>    <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/lib/mysql</span><br>    <span class="hljs-attr">subPath:</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">conf</span><br>    <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/mysql/conf.d</span><br></code></pre></td></tr></table></figure><p>在这个名叫 clone-mysql 的 InitContainer 里，我们使用的是 xtrabackup 镜像（它里面安装了 xtrabackup 工具）。而在它的启动命令里，我们首先做了一个判断。即：当初始化所需的数据（/var/lib/mysql/mysql 目录）已经存在，或者当前 Pod 是 Master 节点的时候，不需要做拷贝操作。</p><p>接下来，clone-mysql 会使用 Linux 自带的 ncat 指令，向 DNS 记录为“mysql-&lt; 当前序号减一 &gt;.mysql”的 Pod，也就是当前 Pod 的前一个 Pod，发起数据传输请求，并且直接用 xbstream 指令将收到的备份数据保存在 /var/lib/mysql 目录下。</p><blockquote><p>备注：3307 是一个特殊端口，运行着一个专门负责备份 MySQL 数据的辅助进程。</p></blockquote><p>当然，这一步我们可以随意选择用自己喜欢的方法来传输数据。比如，用 scp 或者 rsync，都没问题。</p><p>我们可能已经注意到，这个容器里的 /var/lib/mysql 目录，实际上正是一个名为 data 的 PVC，即：我们在前面声明的持久化存储。</p><p>这就可以保证，哪怕宿主机宕机了，数据库中的数据也不会丢失。更重要的是，由于 Pod Volume 是被 Pod 里的容器共享的，所以当最后 MySQL 容器启动时，就可以把这个 Volume 挂载到自己的 /var/lib/mysql 目录下，直接使用里面的备份数据。</p><p>不过，clone-mysql 容器还要对 /var/lib/mysql 目录，执行一句 xtrabackup --prepare 操作，目的是让拷贝来的数据进入一致性状态，这样，这些数据才能被MySQL容器直接使用。</p><p>至此，我们就通过 InitContainer 完成了对“主、从节点间备份文件传输”操作的处理过程，也就是翻越了“第二座大山”。</p><h2 id="四、解决第三座大山">四、解决第三座大山</h2><p>接下来，我们可以开始定义 MySQL 容器, 启动 MySQL 服务了。由于 StatefulSet 里的所有 Pod 都来自于同一个 Pod 模板，所以我们还要“人格分裂”地去思考：这个 MySQL 容器的启动命令，在 Master 和 Slave 两种情况下有什么不同。</p><p>有了 Docker 镜像，在 Pod 里声明一个 Master 角色的 MySQL 容器并不是什么困难的事情：直接执行 MySQL 启动命令即可。但是，如果这个 Pod 是一个第一次启动的 Slave 节点，在执行 MySQL 启动命令之前，它就需要使用前面 InitContainer 拷贝来的备份数据进行初始化。可是，别忘了，容器是一个单进程模型。所以，一个 Slave 角色的 MySQL 容器启动之前，谁能负责给它执行初始化的 SQL 语句呢？</p><p>这就是我们需要解决的“第三座大山”问题，即：如何在 Slave 节点的 MySQL 容器第一次启动之前，执行初始化 SQL。其实，我们可以为这个 MySQL 容器额外定义一个 sidecar 容器，来完成这个操作，它的定义如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">...</span><br><span class="hljs-comment"># template.spec.containers</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">xtrabackup</span><br>  <span class="hljs-attr">image:</span> <span class="hljs-string">gcr.io/google-samples/xtrabackup:1.0</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">xtrabackup</span><br>    <span class="hljs-attr">containerPort:</span> <span class="hljs-number">3307</span><br>  <span class="hljs-attr">command:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">bash</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;-c&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">|</span><br><span class="hljs-string">    set -ex</span><br><span class="hljs-string">    cd /var/lib/mysql</span><br><span class="hljs-string"></span><br>    <span class="hljs-comment"># 从备份信息文件里读取MASTER_LOG_FILEM和MASTER_LOG_POS这两个字段的值，用来拼装集群初始化SQL</span><br>    <span class="hljs-string">if</span> [[ <span class="hljs-string">-f</span> <span class="hljs-string">xtrabackup_slave_info</span> ]]<span class="hljs-string">;</span> <span class="hljs-string">then</span><br>      <span class="hljs-comment"># 如果xtrabackup_slave_info文件存在，说明这个备份数据来自于另一个Slave节点。这种情况下，XtraBackup工具在备份的时候，就已经在这个文件里自动生成了&quot;CHANGE MASTER TO&quot; SQL语句。所以，我们只需要把这个文件重命名为change_master_to.sql.in，后面直接使用即可</span><br>      <span class="hljs-string">mv</span> <span class="hljs-string">xtrabackup_slave_info</span> <span class="hljs-string">change_master_to.sql.in</span><br>      <span class="hljs-comment"># 所以，也就用不着xtrabackup_binlog_info了</span><br>      <span class="hljs-string">rm</span> <span class="hljs-string">-f</span> <span class="hljs-string">xtrabackup_binlog_info</span><br>    <span class="hljs-string">elif</span> [[ <span class="hljs-string">-f</span> <span class="hljs-string">xtrabackup_binlog_info</span> ]]<span class="hljs-string">;</span> <span class="hljs-string">then</span><br>      <span class="hljs-comment"># 如果只存在xtrabackup_binlog_inf文件，那说明备份来自于Master节点，我们就需要解析这个备份信息文件，读取所需的两个字段的值</span><br>      [[ <span class="hljs-string">`cat</span> <span class="hljs-string">xtrabackup_binlog_info`</span> <span class="hljs-string">=~</span> <span class="hljs-string">^(.*?)</span>[[<span class="hljs-string">:space:</span>]]<span class="hljs-string">+(.*?)$</span> ]] <span class="hljs-string">||</span> <span class="hljs-string">exit</span> <span class="hljs-number">1</span><br>      <span class="hljs-string">rm</span> <span class="hljs-string">xtrabackup_binlog_info</span><br>      <span class="hljs-comment"># 把两个字段的值拼装成SQL，写入change_master_to.sql.in文件</span><br>      <span class="hljs-string">echo</span> <span class="hljs-string">&quot;CHANGE MASTER TO MASTER_LOG_FILE=&#x27;$&#123;BASH_REMATCH[1]&#125;&#x27;,\</span><br><span class="hljs-string">            MASTER_LOG_POS=$&#123;BASH_REMATCH[2]&#125;&quot;</span> <span class="hljs-string">&gt;</span> <span class="hljs-string">change_master_to.sql.in</span><br>    <span class="hljs-string">fi</span><br><br>    <span class="hljs-comment"># 如果change_master_to.sql.in，就意味着需要做集群初始化工作</span><br>    <span class="hljs-string">if</span> [[ <span class="hljs-string">-f</span> <span class="hljs-string">change_master_to.sql.in</span> ]]<span class="hljs-string">;</span> <span class="hljs-string">then</span><br>      <span class="hljs-comment"># 但一定要先等MySQL容器启动之后才能进行下一步连接MySQL的操作</span><br>      <span class="hljs-string">echo</span> <span class="hljs-string">&quot;Waiting for mysqld to be ready (accepting connections)&quot;</span><br>      <span class="hljs-string">until</span> <span class="hljs-string">mysql</span> <span class="hljs-string">-h</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-string">-e</span> <span class="hljs-string">&quot;SELECT 1&quot;</span><span class="hljs-string">;</span> <span class="hljs-string">do</span> <span class="hljs-string">sleep</span> <span class="hljs-number">1</span><span class="hljs-string">;</span> <span class="hljs-string">done</span><br><br>      <span class="hljs-string">echo</span> <span class="hljs-string">&quot;Initializing replication from clone position&quot;</span><br>      <span class="hljs-comment"># 将文件change_master_to.sql.in改个名字，防止这个Container重启的时候，因为又找到了change_master_to.sql.in，从而重复执行一遍这个初始化流程</span><br>      <span class="hljs-string">mv</span> <span class="hljs-string">change_master_to.sql.in</span> <span class="hljs-string">change_master_to.sql.orig</span><br>      <span class="hljs-comment"># 使用change_master_to.sql.orig的内容，也是就是前面拼装的SQL，组成一个完整的初始化和启动Slave的SQL语句</span><br>      <span class="hljs-string">mysql</span> <span class="hljs-string">-h</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-string">&lt;&lt;EOF</span><br>    <span class="hljs-string">$(&lt;change_master_to.sql.orig),</span><br>      <span class="hljs-string">MASTER_HOST=&#x27;mysql-0.mysql&#x27;,</span><br>      <span class="hljs-string">MASTER_USER=&#x27;root&#x27;,</span><br>      <span class="hljs-string">MASTER_PASSWORD=&#x27;&#x27;,</span><br>      <span class="hljs-string">MASTER_CONNECT_RETRY=10;</span><br>    <span class="hljs-string">START</span> <span class="hljs-string">SLAVE;</span><br>    <span class="hljs-string">EOF</span><br>    <span class="hljs-string">fi</span><br><br>    <span class="hljs-comment"># 使用ncat监听3307端口。它的作用是，在收到传输请求的时候，直接执行&quot;xtrabackup --backup&quot;命令，备份MySQL的数据并发送给请求者</span><br>    <span class="hljs-string">exec</span> <span class="hljs-string">ncat</span> <span class="hljs-string">--listen</span> <span class="hljs-string">--keep-open</span> <span class="hljs-string">--send-only</span> <span class="hljs-string">--max-conns=1</span> <span class="hljs-number">3307</span> <span class="hljs-string">-c</span> <span class="hljs-string">\</span><br>      <span class="hljs-string">&quot;xtrabackup --backup --slave-info --stream=xbstream --host=127.0.0.1 --user=root&quot;</span><br>  <span class="hljs-attr">volumeMounts:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">data</span><br>    <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/lib/mysql</span><br>    <span class="hljs-attr">subPath:</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">conf</span><br>    <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/mysql/conf.d</span><br></code></pre></td></tr></table></figure><p>可以看到，在这个名叫 xtrabackup 的 sidecar 容器的启动命令里，其实实现了两部分工作。</p><p>第一部分工作，当然是 MySQL 节点的初始化工作。这个初始化需要使用的 SQL，是 sidecar 容器拼装出来、保存在一个名为 change_master_to.sql.in 的文件里的，具体过程是这样的：</p><ul><li><p>sidecar 容器首先会判断当前 Pod 的 /var/lib/mysql 目录下，是否有 xtrabackup_slave_info 这个备份信息文件。</p></li><li><p>如果有，则说明这个目录下的备份数据是由一个 Slave 节点生成的。这种情况下，XtraBackup 工具在备份的时候，就已经在这个文件里自动生成了&quot;CHANGE MASTER TO&quot; SQL 语句。所以，我们只需要把这个文件重命名为 change_master_to.sql.in，后面直接使用即可。</p></li><li><p>如果没有 xtrabackup_slave_info 文件、但是存在 xtrabackup_binlog_info 文件，那就说明备份数据来自于 Master 节点。这种情况下，sidecar 容器就需要解析这个备份信息文件，读取 MASTER_LOG_FILE 和 MASTER_LOG_POS 这两个字段的值，用它们拼装出初始化 SQL 语句，然后把这句 SQL 写入到 change_master_to.sql.in 文件中。</p></li><li><p>接下来，sidecar 容器就可以执行初始化了。</p></li></ul><p>从上面的叙述中可以看到，只要这个 change_master_to.sql.in 文件存在，那就说明接下来需要进行集群初始化操作。所以，这时候，sidecar 容器只需要读取并执行 change_master_to.sql.in 里面的“CHANGE MASTER TO”指令，再执行一句 START SLAVE 命令，一个 Slave 节点就被成功启动了。</p><p>但需要注意的是：Pod 里的容器并没有先后顺序，所以在执行初始化 SQL 之前，必须先执行一句 SQL（select 1）来检查一下 MySQL 服务是否已经可用。</p><p>当然，上述这些初始化操作完成后，我们还要删除掉前面用到的这些备份信息文件。否则，下次这个容器重启时，就会发现这些文件存在，所以又会重新执行一次集群初始化的操作，这是不对的。因此，change_master_to.sql.in 在使用后要被重命名，以免容器重启时因为发现这个文件存在又执行一遍初始化。</p><p>第二部分工作，是在完成 MySQL 节点的初始化后，启动一个数据传输服务。具体做法是：sidecar 容器会使用 ncat 命令启动一个工作在 3307 端口上的网络发送服务。一旦收到数据传输请求时，sidecar 容器就会调用 xtrabackup --backup 指令备份当前 MySQL 的数据，然后把这些备份数据返回给请求者。这就是为什么我们在 InitContainer 里定义数据拷贝的时候，访问的是“上一个 MySQL 节点”的 3307 端口。</p><p>值得一提的是，由于 sidecar 容器和 MySQL 容器同处于一个 Pod 里，所以它是直接通过 Localhost 来访问和备份 MySQL 容器里的数据的，非常方便。同样地，在这里举例用的只是一种备份方法而已，我们完全可以选择其他的方案。比如，可以使用 innobackupex 命令做数据备份和准备，它的使用方法几乎与本文的备份方法一样。</p><p>至此，我们也就翻越了“第三座大山”，完成了 Slave 节点第一次启动前的初始化工作。</p><h2 id="五、定义MySQL容器">五、定义MySQL容器</h2><p>扳倒了这“三座大山”后，我们终于可以定义 Pod 里的主角，MySQL 容器了。有了前面这些定义和初始化工作，MySQL 容器本身的定义就非常简单了，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">...</span><br><span class="hljs-comment"># template.spec</span><br><span class="hljs-attr">containers:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>  <span class="hljs-attr">env:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">MYSQL_ALLOW_EMPTY_PASSWORD</span><br>    <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;1&quot;</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">containerPort:</span> <span class="hljs-number">3306</span><br>  <span class="hljs-attr">volumeMounts:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">data</span><br>    <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/lib/mysql</span><br>    <span class="hljs-attr">subPath:</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">conf</span><br>    <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/mysql/conf.d</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">cpu:</span> <span class="hljs-string">500m</span><br>      <span class="hljs-attr">memory:</span> <span class="hljs-string">1Gi</span><br>  <span class="hljs-attr">livenessProbe:</span><br>    <span class="hljs-attr">exec:</span><br>      <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;mysqladmin&quot;</span>, <span class="hljs-string">&quot;ping&quot;</span>]<br>    <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">30</span><br>    <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span><br>    <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">5</span><br>  <span class="hljs-attr">readinessProbe:</span><br>    <span class="hljs-attr">exec:</span><br>      <span class="hljs-comment"># 通过TCP连接的方式进行健康检查</span><br>      <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;-e&quot;</span>, <span class="hljs-string">&quot;SELECT 1&quot;</span>]<br>    <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span><br>    <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">2</span><br>    <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>在这个容器的定义里，我们使用了一个标准的 MySQL 5.7 的官方镜像。它的数据目录是 /var/lib/mysql，配置文件目录是 /etc/mysql/conf.d。这时候，我们应该能够明白，如果 MySQL 容器是 Slave 节点的话，它的数据目录里的数据，是 InitContainer 从其他节点拷贝而来的。它的配置文件目录 /etc/mysql/conf.d 里的内容，则来自于 ConfigMap 对应的 Volume。而它的初始化工作，则是由同一个 Pod 里的 sidecar 容器完成的。</p><p>另外，我们为它定义了一个 livenessProbe，通过 mysqladmin ping 命令来检查它是否健康；还定义了一个 readinessProbe，通过查询 SQL（select 1）来检查 MySQL 服务是否可用。当然，凡是 readinessProbe 检查失败的 MySQL Pod，都会从 Service 里被摘除掉。</p><p>至此，一个完整的主从复制模式的 MySQL 集群就定义完了。</p><h2 id="六、创建MySQL集群">六、创建MySQL集群</h2><p>现在，我们就可以使用 kubectl 命令，尝试运行一下这个 StatefulSet 了。</p><p>首先，我们需要在 Kubernetes 集群里创建满足条件的 PV。假设我们的存储集群为Ceph，因此可以按照如下方式使用存储插件 Rook：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">kubectl</span> <span class="hljs-string">create</span> <span class="hljs-string">-f</span> <span class="hljs-string">rook-storage.yaml</span><br><span class="hljs-string">$</span> <span class="hljs-string">cat</span> <span class="hljs-string">rook-storage.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">ceph.rook.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">CephBlockPool</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">replicapool</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">rook-ceph</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">failureDomain:</span> <span class="hljs-string">host</span><br>  <span class="hljs-attr">replicated:</span><br>    <span class="hljs-attr">size:</span> <span class="hljs-number">3</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">storage.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StorageClass</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">rook-ceph-block</span><br><span class="hljs-attr">provisioner:</span> <span class="hljs-string">ceph.rook.io/block</span><br><span class="hljs-attr">parameters:</span><br>  <span class="hljs-attr">pool:</span> <span class="hljs-string">replicapool</span><br>  <span class="hljs-attr">clusterNamespace:</span> <span class="hljs-string">rook-ceph</span><br></code></pre></td></tr></table></figure><p>在这里，我们用到了 StorageClass 来完成这个操作。它的作用是，自动地为集群里存在的每一个 PVC，调用存储插件（Rook）创建对应的 PV，从而省去了我们手动创建 PV 的机械劳动。</p><blockquote><p>备注：在使用 Rook 的情况下，mysql-statefulset.yaml 里的 volumeClaimTemplates 字段需要加上声明 storageClassName=rook-ceph-block，才能使用到这个 Rook 提供的持久化存储。</p></blockquote><p>然后，我们就可以创建这个 StatefulSet 了，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f mysql-statefulset.yaml</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pod -l app=mysql</span><br>NAME      READY     STATUS    RESTARTS   AGE<br>mysql-0   2/2       Running   0          2m<br>mysql-1   2/2       Running   0          1m<br>mysql-2   2/2       Running   0          1m<br></code></pre></td></tr></table></figure><p>可以看到，StatefulSet 启动成功后，会有三个 Pod 运行。接下来，我们可以尝试向这个 MySQL 集群发起请求，执行一些 SQL 操作来验证它是否正常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl run mysql-client --image=mysql:5.7 -i --<span class="hljs-built_in">rm</span> --restart=Never -- \</span><br><span class="language-bash">  mysql -h mysql-0.mysql &lt;&lt;<span class="hljs-string">EOF</span></span><br>CREATE DATABASE test;<br>CREATE TABLE test.messages (message VARCHAR(250));<br>INSERT INTO test.messages VALUES (&#x27;hello&#x27;);<br>EOF<br></code></pre></td></tr></table></figure><p>如上所示，我们通过启动一个容器，使用 MySQL client 执行了创建数据库和表、以及插入数据的操作。需要注意的是，我们连接的 MySQL 的地址必须是 mysql-0.mysql（即：Master 节点的 DNS 记录）。因为，只有 Master 节点才能处理写操作。</p><p>而通过连接 mysql-read 这个 Service，我们就可以用 SQL 进行读操作，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl run mysql-client --image=mysql:5.7 -i -t --<span class="hljs-built_in">rm</span> --restart=Never -- \</span><br><span class="language-bash">  mysql -h mysql-read -e <span class="hljs-string">&quot;SELECT * FROM test.messages&quot;</span></span><br>Waiting for pod default/mysql-client to be running, status is Pending, pod ready: false<br>+---------+<br>| message |<br>+---------+<br>| hello   |<br>+---------+<br>pod &quot;mysql-client&quot; deleted<br></code></pre></td></tr></table></figure><p>在有了 StatefulSet 以后，我们就可以像 Deployment 那样，非常方便地扩展这个 MySQL 集群，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl scale statefulset mysql  --replicas=5</span><br></code></pre></td></tr></table></figure><p>这时候，我们就会发现新的 Slave Pod mysql-3 和 mysql-4 被自动创建了出来。而如果我们像如下所示的这样，直接连接 mysql-3.mysql，即 mysql-3 这个 Pod 的 DNS 名字来进行查询操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl run mysql-client --image=mysql:5.7 -i -t --<span class="hljs-built_in">rm</span> --restart=Never -- \</span><br><span class="language-bash">  mysql -h mysql-3.mysql -e <span class="hljs-string">&quot;SELECT * FROM test.messages&quot;</span></span><br>Waiting for pod default/mysql-client to be running, status is Pending, pod ready: false<br>+---------+<br>| message |<br>+---------+<br>| hello   |<br>+---------+<br>pod &quot;mysql-client&quot; deleted<br></code></pre></td></tr></table></figure><p>就会看到，从 StatefulSet 为我们新创建的 mysql-3 上，同样可以读取到之前插入的记录。也就是说，我们的数据备份和恢复，都是有效的。</p><h2 id="七、小结">七、小结</h2><p>在这篇文章中，我们以MySQL主从集群为例，讨论了一个实际的StatefulSet的编写过程。在这个过程中，有以下几个关键点需要认真体会：</p><ul><li>“人格分裂”：在解决需求的过程中，一定要记得思考，该Pod在扮演不同角色时的不同操作。</li><li>“阅后即焚”：很多“有状态应用”的节点，只是在第一次启动时才需要做额外处理。所以，在编写YAML文件时，一定要考虑“容器重启”的情况，不要让这一次的操作干扰到下一次的容器启动。</li><li>“人人平等”：除了InitContainer之外，一个Pod里的多个容器之间是完全平等的。所以，我们设计的sidecar，绝对不能对容器的顺序做出假设，否则就需要进行前置检查。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器编排4：深入理解StatefulSet之存储状态</title>
    <link href="/2020/10/03/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%924%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3StatefulSet%E4%B9%8B%E5%AD%98%E5%82%A8%E7%8A%B6%E6%80%81/"/>
    <url>/2020/10/03/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%924%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3StatefulSet%E4%B9%8B%E5%AD%98%E5%82%A8%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们讨论了StatefulSet如何保证应用实例的拓扑状态。接下来，我们重点讨论StatefulSet如何保证应用的存储状态。</p><h2 id="一、从PVC和PV说起">一、从PVC和PV说起</h2><p>StatefulSet 对存储状态的管理，主要依赖于一个叫作 Persistent Volume Claim 的功能。</p><h3 id="1-1、没有PVC和PV之前">1.1、没有PVC和PV之前</h3><p>我们知道，在一个 Pod 里声明 Volume，只要在 Pod 里加上 spec.volumes 字段即可。然后，我们就可以在这个字段里定义一个具体类型的 Volume ，比如：hostPath。</p><p>可是，在有些场景中：我们并不知道有哪些具体类型的Volume可以用，此时该怎么办呢？更具体地说，一个应用开发者，可能对持久化存储项目（比如 Ceph、GlusterFS 等）一窍不通，也不知道所使用的 Kubernetes 集群到底是怎么搭建出来的，自然也就不会编写它们对应的 Volume 定义文件。正所谓“术业有专攻”，这些关于 Volume 的管理和远程持久化存储的知识，不仅超越了一个普通开发者的知识储备，还会暴露公司的基础设施。</p><p>比如，下面这个例子，就是一个声明了  Volume类型为Ceph RBD  的 Pod：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">rbd</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">kubernetes/pause</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">rbd-rw</span><br>      <span class="hljs-attr">volumeMounts:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">rbdpd</span><br>        <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/mnt/rbd</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">rbdpd</span><br>      <span class="hljs-attr">rbd:</span><br>        <span class="hljs-attr">monitors:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;10.16.154.78:6789&#x27;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;10.16.154.82:6789&#x27;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;10.16.154.83:6789&#x27;</span><br>        <span class="hljs-attr">pool:</span> <span class="hljs-string">kube</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">foo</span><br>        <span class="hljs-attr">fsType:</span> <span class="hljs-string">ext4</span><br>        <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-attr">user:</span> <span class="hljs-string">admin</span><br>        <span class="hljs-attr">keyring:</span> <span class="hljs-string">/etc/ceph/keyring</span><br>        <span class="hljs-attr">imageformat:</span> <span class="hljs-string">&quot;2&quot;</span><br>        <span class="hljs-attr">imagefeatures:</span> <span class="hljs-string">&quot;layering&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到，这YAML文件存在以下几个问题：</p><ul><li>其一，如果不懂得 Ceph RBD 的使用方法，那么这个 Pod 里 Volumes 字段，我们十有八九也完全看不懂。</li><li>其二，这个 Ceph RBD 对应的存储服务器的地址、用户名、授权文件的位置，也都被轻易地暴露给了全公司的所有开发人员，这就是一个典型的信息被“过度暴露”的例子。</li></ul><h3 id="1-2、有了PVC和PV之后">1.2、有了PVC和PV之后</h3><p>这也是为什么，在后来的演化中，Kubernetes 项目引入了一组叫作 Persistent Volume Claim（PVC）和 Persistent Volume（PV）的 API 对象，它们大大降低了用户声明和使用持久化 Volume 的门槛。举个例子，有了 PVC 之后，一个开发人员想要使用一个 Volume，只需要简单的两步即可。</p><p>第一步：定义一个 PVC，即声明想要的 Volume 的属性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pv-claim</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><br></code></pre></td></tr></table></figure><p>可以看到，在这个 PVC 对象里，不需要任何关于 Volume 细节的字段，只有描述性的属性和定义。比如，storage: 1Gi，表示我想要的 Volume 大小至少是 1 GiB；accessModes: ReadWriteOnce，表示这个 Volume 的挂载方式是可读写，并且只能被挂载在一个节点上而非被多个节点共享。</p><p>第二步：在应用的 Pod 中，声明使用这个 PVC：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pv-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">pv-container</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>      <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;http-server&quot;</span><br>      <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">&quot;/usr/share/nginx/html&quot;</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">pv-storage</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">pv-storage</span><br>      <span class="hljs-attr">persistentVolumeClaim:</span><br>        <span class="hljs-attr">claimName:</span> <span class="hljs-string">pv-claim</span><br></code></pre></td></tr></table></figure><p>可以看到，在这个 Pod 的 Volumes 定义中，我们只需要声明它的类型是 persistentVolumeClaim，然后指定 PVC 的名字，完全不必关心 Volume 本身的定义。</p><h3 id="1-3、PVC和PV的关系">1.3、PVC和PV的关系</h3><p>一旦我们创建了上面的 PVC 对象，Kubernetes 就会自动为它绑定一个符合条件的 Volume。可是，这些符合条件的 Volume 又是从哪里来的呢？答案是，它们来自于运维人员维护的 PV（Persistent Volume）对象。接下来，我们一起看一个常见的 PV 对象的 YAML 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pv-volume</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">local</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">capacity:</span><br>    <span class="hljs-attr">storage:</span> <span class="hljs-string">10Gi</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>  <span class="hljs-attr">rbd:</span><br>    <span class="hljs-attr">monitors:</span><br>    <span class="hljs-comment"># 使用 kubectl get pods -n rook-ceph 查看 rook-ceph-mon- 开头的 POD IP 即可得下面的列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;10.16.154.78:6789&#x27;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;10.16.154.82:6789&#x27;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;10.16.154.83:6789&#x27;</span><br>    <span class="hljs-attr">pool:</span> <span class="hljs-string">kube</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">foo</span><br>    <span class="hljs-attr">fsType:</span> <span class="hljs-string">ext4</span><br>    <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">keyring:</span> <span class="hljs-string">/etc/ceph/keyring</span><br></code></pre></td></tr></table></figure><p>可以看到，这个 PV 对象的 spec.rbd 字段，正是我们前面介绍过的 Ceph RBD Volume 的详细定义。而且，它还声明了这个 PV 的容量是 10 GiB。这样，Kubernetes 就会为我们刚刚创建的 PVC 对象绑定这个 PV。</p><p>所以，Kubernetes 中 PVC 和 PV 的设计，实际上类似于“接口”和“实现”的思想。开发者只要知道并会使用“接口”，即：PVC；而运维人员则负责给“接口”绑定具体的实现，即：PV。这种解耦，就避免了因向开发者暴露过多的存储系统细节而带来的隐患。此外，这种职责的分离，往往也意味着出现事故时可以更容易定位问题和明确责任，从而避免“扯皮”现象的出现。</p><h2 id="二、Pod的存储状态">二、Pod的存储状态</h2><h3 id="2-1、创建StatefulSet">2.1、创建StatefulSet</h3><p>PVC、PV 的设计，使得 StatefulSet 对存储状态的管理成为了可能。我们还是以之前文章中用到的 StatefulSet 为例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">&quot;nginx&quot;</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.9.1</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">www</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>  <span class="hljs-attr">volumeClaimTemplates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">www</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">accessModes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">requests:</span><br>          <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><br></code></pre></td></tr></table></figure><p>这次，我们为这个 StatefulSet 额外添加了一个 volumeClaimTemplates 字段。从名字就可以看出来，它跟 Deployment 中 Pod 模板（PodTemplate）的作用类似。也就是说，凡是被这个 StatefulSet 管理的 Pod，都会声明一个对应的 PVC；而这个 PVC 的定义，就来自于 volumeClaimTemplates 这个模板字段。更重要的是，这个 PVC 的名字，会被分配一个与这个 Pod 完全一致的编号。</p><h3 id="2-2、查看PVC">2.2、查看PVC</h3><p>这个自动创建的 PVC，与 PV 绑定成功后，就会进入 Bound 状态，这就意味着这个 Pod 可以挂载并使用这个 PV 了。当然，PVC 与 PV 的绑定得以实现的前提是，运维人员已经在系统里创建好了符合条件的 PV（比如，我们在前面用到的 pv-volume）；或者，当Kubernetes 集群运行在公有云上时，Kubernetes 就可以通过 Dynamic Provisioning 的方式，自动创建与 PVC 匹配的 PV。</p><p>所以，我们在使用 kubectl create 创建了 StatefulSet 之后，就会看到 Kubernetes 集群里出现了两个 PVC：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f statefulset.yaml</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pvc -l app=nginx</span><br>NAME        STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE<br>www-web-0   Bound     pvc-15c268c7-b507-11e6-932f-42010a800002   1Gi        RWO           48s<br>www-web-1   Bound     pvc-15c79307-b507-11e6-932f-42010a800002   1Gi        RWO           48s<br></code></pre></td></tr></table></figure><p>可以看到，这些 PVC，都以“&lt;PVC 名字 &gt;-&lt;StatefulSet 名字 &gt;-&lt; 编号 &gt;”的方式命名，并且处于 Bound 状态。</p><h3 id="2-3、验证Volume的分配情况">2.3、验证Volume的分配情况</h3><p>我们前面已经提到过，这个 StatefulSet 创建出来的所有 Pod，都会声明使用相应编号的 PVC。比如，在名叫 web-0 的 Pod 的 volumes 字段，它会声明使用名叫 www-web-0 的 PVC，从而挂载到这个 PVC 所绑定的 PV。所以，我们就可以使用如下所示的指令，在 Pod 的 Volume 目录里写入一个文件，来验证一下上述 Volume 的分配情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> 0 1; <span class="hljs-keyword">do</span> kubectl <span class="hljs-built_in">exec</span> web-<span class="hljs-variable">$i</span> -- sh -c <span class="hljs-string">&#x27;echo hello $(hostname) &gt; /usr/share/nginx/html/index.html&#x27;</span>; <span class="hljs-keyword">done</span></span><br></code></pre></td></tr></table></figure><p>此时，如果在这个 Pod 容器里访问“<a href="http://localhost">http://localhost</a>”，我们实际访问到的就是 Pod 里 Nginx 服务器进程，而它会为我们返回 /usr/share/nginx/html/index.html 里的内容。这个操作的执行方法如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> 0 1; <span class="hljs-keyword">do</span> kubectl <span class="hljs-built_in">exec</span> -it web-<span class="hljs-variable">$i</span> -- curl localhost; <span class="hljs-keyword">done</span></span><br>hello web-0<br>hello web-1<br></code></pre></td></tr></table></figure><h3 id="2-4、验证Volument的持久性">2.4、验证Volument的持久性</h3><p>如果我们使用 kubectl delete 命令删除这两个 Pod，这些 Volume 里的文件会不会丢失呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete pod -l app=nginx</span><br>pod &quot;web-0&quot; deleted<br>pod &quot;web-1&quot; deleted<br></code></pre></td></tr></table></figure><p>可以看到，正如我们前面介绍过的，在被删除之后，这两个 Pod 会被按照编号的顺序被重新创建出来。而这时候，如果我们在新创建的容器里通过访问“<a href="http://localhost">http://localhost</a>”的方式去访问 web-0 里的 Nginx 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在被重新创建出来的Pod容器里访问http://localhost</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it web-0 -- curl localhost</span><br>hello web-0<br></code></pre></td></tr></table></figure><p>就会发现，这个请求依然会返回：hello web-0。也就是说，原先与名叫 web-0 的 Pod 绑定的 PV，在这个 Pod 被重新创建之后，依然同新的名叫 web-0 的 Pod 绑定在了一起。对于 Pod web-1 来说，也是完全一样的情况。</p><blockquote><p>这是怎么做到的呢？</p></blockquote><p>其实，分析一下 StatefulSet 控制器恢复这个 Pod 的过程，我们就可以很容易理解了。</p><p>首先，当我们把一个 Pod，比如 web-0，删除之后，这个 Pod 对应的 PVC 和 PV，并不会被删除，而这个 Volume 里已经写入的数据，也依然会保存在远程存储服务里（比如，我们在这个例子里用到的 Ceph 服务器）。</p><p>此时，StatefulSet 控制器发现，一个名叫 web-0 的 Pod 消失了。所以，控制器就会重新创建一个新的、名字还是叫作 web-0 的 Pod 来，“纠正”这个不一致的情况。</p><p>需要注意的是，在这个新的 Pod 对象的定义里，它声明使用的 PVC 的名字，还是叫作：www-web-0。这个 PVC 的定义，还是来自于 PVC 模板（volumeClaimTemplates），这是 StatefulSet 创建 Pod 的标准流程。</p><p>所以，在这个新的 web-0 Pod 被创建出来之后，Kubernetes 为它查找名叫 www-web-0 的 PVC 时，就会直接找到旧 Pod 遗留下来的同名的 PVC，进而找到跟这个 PVC 绑定在一起的 PV。这样，新的 Pod 就可以挂载到旧 Pod 对应的那个 Volume，并且获取到保存在 Volume 里的数据。</p><p>通过这种方式，Kubernetes 的 StatefulSet 就实现了对应用存储状态的管理。</p><h2 id="三、SatefulSet的工作原理">三、SatefulSet的工作原理</h2><p>看到这里，是不是已经大致理解了 StatefulSet 的工作原理呢？现在，我们来详细梳理一下吧。</p><p>首先，StatefulSet 控制器所管理的对象就是 Pod。StatefulSet 中不同的 Pod 实例，不再像 ReplicaSet 中那样都是完全一样的，而是有了细微区别。比如，每个 Pod 的 hostname、名字等都是不同的、携带了编号的。而 StatefulSet 区分这些实例的方式，就是通过在 Pod 的名字里加上事先约定好的编号。</p><p>其次，Kubernetes 通过 Headless Service，为这些带有编号的 Pod，在 DNS 服务器中生成了带有同样编号的 DNS 记录。只要 StatefulSet 能够保证这些 Pod 名字里的编号不变，那么 Service 里类似于 web-0.nginx.default.svc.cluster.local 这样的 DNS 记录也就不会变，而这条记录解析出来的 Pod 的 IP 地址，则会随着后端 Pod 的删除和再创建而自动更新。这当然也是 Service 机制本身的能力，不需要 StatefulSet 操心。</p><p>最后，StatefulSet 还为每一个 Pod 分配并创建一个同样编号的 PVC。这样，Kubernetes 就可以通过 Persistent Volume 机制为这个 PVC 绑定上对应的 PV，从而保证了每一个 Pod 都拥有一个独立的 Volume。</p><p>在这种情况下，即使 Pod 被删除，它所对应的 PVC 和 PV 依然会保留下来。所以当这个 Pod 被重新创建出来之后，Kubernetes 会为它找到同样编号的 PVC，挂载这个 PVC 对应的 Volume，从而获取到以前保存在 Volume 里的数据。</p><h2 id="四、小结">四、小结</h2><p>在这篇文章中，我们主要讨论了如下概念：</p><ul><li>StatefulSet对存储状态的管理主要用到了Persistent Volume Claim。</li><li>PVC和PV的设计，类似与编程中的“接口”和”具体实现“。对于使用者而言，只需关注接口（PVC）如何使用，而无需关心具体的实现（PV）。</li><li>StatefulSet的工作原理大致是这样的：首先，StatefulSet控制器会对每个Pod进行编号，并会维护这些编号信息，以保证顺序关系；其次，通过Headless Service为每个Pod维护一份相应的DNS记录，来保证固定的访问入口；最后，借助Persistent Volume机制，StatefulSet会为每个Pod创建同样编号的PVC，从而保证数据的“一致性”。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器编排3：深入理解StatefulSet之拓扑状态</title>
    <link href="/2020/10/03/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%923%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3StatefulSet%E4%B9%8B%E6%8B%93%E6%89%91%E7%8A%B6%E6%80%81/"/>
    <url>/2020/10/03/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%923%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3StatefulSet%E4%B9%8B%E6%8B%93%E6%89%91%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们讨论了Deployment控制器的工作原理，但Deployment控制器并不足以覆盖所有的应用编排问题。接下来，我们重点讨论Kubernetes提供的另一种重要的编排能力：StatefulSet。</p><h2 id="一、从有状态应用说起">一、从有状态应用说起</h2><p>Deployment 对应用做了一个简单化假设：一个应用的所有 Pod，是完全一样的。所以，它们互相之间没有顺序，也无所谓运行在哪台宿主机上。需要的时候，Deployment 就可以通过 Pod 模板创建新的 Pod；不需要的时候，Deployment 就可以“杀掉”任意一个 Pod。</p><p>但是，在实际的场景中，并不是所有的应用都可以满足这样的要求。尤其是分布式应用，它的多个实例之间，往往有依赖关系，比如：主从关系、主备关系。还有就是数据存储类应用，它的多个实例，往往都会在本地磁盘上保存一份数据。而这些实例一旦被杀掉，即便重建出来，实例与数据之间的对应关系也已经丢失，从而导致应用失败。</p><p>所以，这种实例之间有不对等关系，以及实例对外部数据有依赖关系的应用，就被称为“有状态应用”（Stateful Application）。</p><p>我们知道，使用容器封装“无状态应用”（Stateless Application），尤其是 Web 服务，非常好用。但是，一旦我们想要用容器运行“有状态应用”，其困难程度就会直线上升。而且，这个问题解决起来，单纯依靠容器技术本身已经无能为力，这也就导致了很长一段时间内，“有状态应用”几乎成了容器技术圈子的“忌讳”，大家一听到这个词，就纷纷摇头。</p><h2 id="二、StatefulSet">二、StatefulSet</h2><p>得益于“控制器模式”的设计思想，Kubernetes 项目很早就在 Deployment 的基础上，扩展出了对“有状态应用”的初步支持。这个编排功能，就是：StatefulSet。</p><p>StatefulSet 的设计其实非常容易理解。它把真实世界里的应用状态，抽象为了两种情况：拓扑状态和存储状态。</p><ul><li><p>拓扑状态。这种情况意味着，应用的多个实例之间不是完全对等的关系。这些应用实例，必须按照某些顺序启动，比如应用的主节点A要先于从节点B启动。而如果我们把A和B两个Pod删除掉，它们再次被创建出来时也必须严格按照这个顺序才行。并且，新创建出来的Pod，必须和原来Pod的网络标识一样，这样原先的访问者才能使用同样的方法，访问到这个新Pod。</p></li><li><p>存储状态。这种情况意味着，应用的多个实例分别绑定了不同的存储数据。对于这些应用实例来说，Pod A第一次读取的数据，和隔了十分钟之后再次读取到的数据，应该是同一份，哪怕在此期间Pod A被重新创建过。这种情况最典型的例子，就是一个数据库应用的多个存储实例。</p></li></ul><p>因此，StatefulSet 的核心功能，就是通过某种方式记录这些状态，然后在 Pod 被重新创建时，能够为新 Pod 恢复这些状态。而想要理解 StatefulSet 的工作原理，我们必须先了解 Kubernetes 项目中一个非常实用的概念：Headless Service。</p><h2 id="三、Service">三、Service</h2><p>Service是Kubernetes项目中一种用来将一组Pod暴露给外界访问的机制。比如，一个 Deployment 有 3 个 Pod，那么我们就可以定义一个 Service。然后，用户只要能访问到这个 Service，它就能访问到某个具体的 Pod。那么，这个 Service 又是如何被访问的呢？</p><ul><li><p>第一种方式，是以 Service 的 VIP（Virtual IP，即：虚拟 IP）方式。比如：当我们访问 10.0.23.1 这个 Service 的 IP 地址时，10.0.23.1 其实就是一个 VIP，它会把请求转发到该 Service 所代理的某一个 Pod 上。</p></li><li><p>第二种方式，是以 Service 的 DNS 方式。比如：当我们访问“my-svc.my-namespace.svc.cluster.local”这条 DNS 记录，就可以访问到一个名叫 my-svc 的 Service 所代理的某一个 Pod。</p></li></ul><p>而在 Service DNS 的方式下，具体还可以分为两种处理方法：</p><ul><li><p>第一种处理方法，是 Normal Service。这种情况下，当我们访问“my-svc.my-namespace.svc.cluster.local”时，解析到的正是 my-svc 这个 Service 的 VIP，后面的流程就跟 VIP 方式一致了</p></li><li><p>第二种处理方法，是 Headless Service。这种情况下，当我们访问“my-svc.my-namespace.svc.cluster.local”时，解析到的直接就是 my-svc 代理的某一个 Pod 的 IP 地址。可以看到，这里的区别在于，Headless Service 不需要分配一个 VIP，而是可以直接以 DNS 记录的方式解析出被代理 Pod 的 IP 地址。</p></li></ul><blockquote><p>那么，Headless Service有什么作用呢？</p></blockquote><p>想要回答这个问题，我们需要从 Headless Service 的定义方式看起。下面是一个标准的 Headless Service 对应的 YAML 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure><p>可以看到，所谓的 Headless Service，其实仍是一个标准 Service 的 YAML 文件。只不过，它的 clusterIP 字段的值是：None，即：这个 Service，没有一个 VIP 作为“头”。这也就是 Headless 的含义。所以，这个 Service 被创建后并不会被分配一个 VIP，而是会以 DNS 记录的方式暴露出它所代理的 Pod。而它所代理的 Pod，依然是采用 Label Selector 机制选择出来的，即：所有携带了 app=nginx 标签的 Pod，都会被这个 Service 代理。而当我们按照这样的方式创建了一个 Headless Service 之后，它所代理的所有 Pod 的 IP 地址，都会被绑定成一个这样格式的 DNS 记录，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;pod-name&gt;.&lt;svc-name&gt;.&lt;namespace&gt;.svc.cluster.local<br></code></pre></td></tr></table></figure><p>这个 DNS 记录，正是 Kubernetes 项目为 Pod 分配的唯一的“可解析身份”（Resolvable Identity）。有了这个“可解析身份”，只要知道了一个 Pod 的名字，以及它对应的 Service 的名字，我们就可以非常确定地通过这条 DNS 记录访问到 Pod 的 IP 地址。</p><h2 id="四、理解Pod的拓扑状态">四、理解Pod的拓扑状态</h2><blockquote><p>那么，StatefulSet 又是如何使用这个 DNS 记录来维持 Pod 的拓扑状态的呢？</p></blockquote><p>为了回答这个问题，现在我们就来编写一个 StatefulSet 的 YAML 文件，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">&quot;nginx&quot;</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.9.1</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br></code></pre></td></tr></table></figure><p>这个 YAML 文件，和我们在前面用到的 nginx-deployment 的唯一区别，就是多了一个 serviceName=nginx 字段。这个字段的作用，就是告诉 StatefulSet 控制器，在执行控制循环（Control Loop）的时候，请使用 nginx 这个 Headless Service 来保证 Pod 的“可解析身份”。所以，当我们通过 kubectl create 创建了上面这个 Service 和 StatefulSet 之后，就会看到如下两个对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f svc.yaml</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get service nginx</span><br>NAME      TYPE         CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE<br>nginx     ClusterIP    None         &lt;none&gt;        80/TCP    10s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f statefulset.yaml</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get statefulset web</span><br>NAME      DESIRED   CURRENT   AGE<br>web       2         1         19s<br></code></pre></td></tr></table></figure><p>这时候，如果我们手比较快的话，还可以通过 kubectl 的 -w 参数，即：Watch 功能，实时查看 StatefulSet 创建两个有状态实例的过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">注：如果手不够快的话，Pod 很快就创建完了。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">不过，我们依然可以通过这个 StatefulSet 的 Events 看到这些信息。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods -w -l app=nginx</span><br>NAME      READY     STATUS    RESTARTS   AGE<br>web-0     0/1       Pending   0          0s<br>web-0     0/1       Pending   0         0s<br>web-0     0/1       ContainerCreating   0         0s<br>web-0     1/1       Running   0         19s<br>web-1     0/1       Pending   0         0s<br>web-1     0/1       Pending   0         0s<br>web-1     0/1       ContainerCreating   0         0s<br>web-1     1/1       Running   0         20s<br></code></pre></td></tr></table></figure><p>通过上面这个 Pod 的创建过程，我们不难看到，StatefulSet 给它所管理的所有 Pod 的名字，进行了编号。而且这些编号都是从 0 开始累加，与 StatefulSet 的每个 Pod 实例一一对应，绝不重复。</p><p>更重要的是，这些 Pod 的创建，也是严格按照编号顺序进行的。比如，在 web-0 进入到 Running 状态、并且细分状态（Conditions）成为 Ready 之前，web-1 会一直处于 Pending 状态。</p><p>当这两个 Pod 都进入了 Running 状态之后，我们就可以查看到它们各自唯一的“网络身份”了。我们使用 kubectl exec 命令进入到容器中查看它们的 hostname：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> web-0 -- sh -c <span class="hljs-string">&#x27;hostname&#x27;</span></span><br>web-0<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> web-1 -- sh -c <span class="hljs-string">&#x27;hostname&#x27;</span></span><br>web-1<br></code></pre></td></tr></table></figure><p>可以看到，这两个 Pod 的 hostname 与 Pod 名字是一致的，都被分配了对应的编号。接下来，我们再试着以 DNS 的方式，访问一下这个 Headless Service：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl run -i --<span class="hljs-built_in">tty</span> --image busybox:1.28.4 dns-test --restart=Never --<span class="hljs-built_in">rm</span> /bin/sh</span><br></code></pre></td></tr></table></figure><p>通过这条命令，我们启动了一个一次性的 Pod，因为–rm 意味着 Pod 退出后就会被删除掉。然后，在这个 Pod 的容器里面，我们尝试用 nslookup 命令，解析一下 Pod 对应的 Headless Service：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">nslookup web-0.nginx</span><br>Server:    10.0.0.10<br>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local<br><br>Name:      web-0.nginx<br>Address 1: 10.244.1.7<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">nslookup web-1.nginx</span><br>Server:    10.0.0.10<br>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local<br><br>Name:      web-1.nginx<br>Address 1: 10.244.2.7<br></code></pre></td></tr></table></figure><p>从 nslookup 命令的输出结果中，我们可以看到，在访问 web-0.nginx 的时候，最后解析到的，正是 web-0 这个 Pod 的 IP 地址；而当访问 web-1.nginx 的时候，解析到的则是 web-1 的 IP 地址。这时候，如果我们在另外一个 Terminal 里把这两个“有状态应用”的 Pod 删掉：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete pod -l app=nginx</span><br>pod &quot;web-0&quot; deleted<br>pod &quot;web-1&quot; deleted<br></code></pre></td></tr></table></figure><p>然后，再在当前 Terminal 里 Watch 一下这两个 Pod 的状态变化，就会发现一个有趣的现象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pod -w -l app=nginx</span><br>NAME      READY     STATUS              RESTARTS   AGE<br>web-0     0/1       ContainerCreating   0          0s<br>NAME      READY     STATUS    RESTARTS   AGE<br>web-0     1/1       Running   0          2s<br>web-1     0/1       Pending   0         0s<br>web-1     0/1       ContainerCreating   0         0s<br>web-1     1/1       Running   0         32s<br></code></pre></td></tr></table></figure><p>可以看到，当我们把这两个 Pod 删除之后，Kubernetes 会按照原先编号的顺序，创建出了两个新的 Pod。并且，Kubernetes 依然为它们分配了与原来相同的“网络身份”：web-0.nginx 和 web-1.nginx。</p><p>通过这种严格的对应规则，StatefulSet 就保证了 Pod 网络标识的稳定性。比如，如果 web-0 是一个需要先启动的主节点，web-1 是一个后启动的从节点，那么只要这个 StatefulSet 不被删除，我们访问 web-0.nginx 时始终都会落在主节点上，访问 web-1.nginx 时，则始终都会落在从节点上，这个关系绝对不会发生任何变化。所以，如果我们再用 nslookup 命令，查看一下这个新 Pod 对应的 Headless Service 的话：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl run -i --<span class="hljs-built_in">tty</span> --image busybox dns-test --restart=Never --<span class="hljs-built_in">rm</span> /bin/sh</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">nslookup web-0.nginx</span><br>Server:    10.0.0.10<br>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local<br><br>Name:      web-0.nginx<br>Address 1: 10.244.1.8<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">nslookup web-1.nginx</span><br>Server:    10.0.0.10<br>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local<br><br>Name:      web-1.nginx<br>Address 1: 10.244.2.8<br></code></pre></td></tr></table></figure><p>我们可以看到，在这个 StatefulSet 中，这两个新 Pod 的“网络标识”（比如：web-0.nginx 和 web-1.nginx），再次解析到了正确的 IP 地址（比如：web-0 Pod 的 IP 地址 10.244.1.8）。</p><p>通过这种方法，Kubernetes 就成功地将 Pod 的拓扑状态（比如：哪个节点先启动，哪个节点后启动），按照 Pod 的“名字 + 编号”的方式固定了下来。此外，Kubernetes 还为每一个 Pod 提供了一个固定并且唯一的访问入口，即：这个 Pod 对应的 DNS 记录。这些状态，在 StatefulSet 的整个生命周期里都会保持不变，绝不会因为对应 Pod 的删除或者重新创建而失效。</p><p>尽管 web-0.nginx 这条记录本身不会变，但它解析到的 Pod 的 IP 地址，并不是固定的。这就意味着，对于“有状态应用”实例的访问，我们必须使用 DNS 记录或者 hostname 的方式，而绝不应该直接访问这些 Pod 的 IP 地址。</p><h2 id="五、小结">五、小结</h2><p>在这篇文章中，我们主要讨论了如下概念：</p><ul><li>有状态应用是指应用的多个实例之间不是完全对等的关系（比如，主从、主备等）或者应用对外部数据有依赖关系（比如，数据库需要持久化存储）</li><li>StatefulSet的核心功能是记录应用的状态，并在重建时恢复这个状态。StatefulSet将真实世界中的应用抽象成了拓扑状态和存储状态两种情况。其中：<ul><li>拓扑状态是指应用的多个实例之间不是完全对等的关系，它们必须按照某种顺序先后启动，即使它们被重建也依然会按照这个顺序先后启动，并且从始至终它们的网络标识保持不变；</li><li>存储状态是指应用对外部数据有依赖关系，应用的多个实例会绑定不同的存储数据，即使它们被重建这些存储数据也依然是一致的。</li></ul></li><li>StatefulSet在创建Pod时，会对它们进行编号，并且会按照编号顺序逐一完成创建工作。在StatefulSet控制器发现Pod的“实际状态”与“期望状态”不一致时，也会严格按照Pod的编号顺序，逐一完成新建或删除操作。</li><li>StatefulSet对拓扑状态的管理依赖于Headless Service。而Headless Service的主要作用是为Pod生成从主机名到IP的DNS记录。按编号顺序的名字加上DNS记录就能将Pod的拓扑状态固定下来。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器编排2：副本与水平扩展</title>
    <link href="/2020/10/02/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%922%EF%BC%9A%E5%89%AF%E6%9C%AC%E4%B8%8E%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%B1%95/"/>
    <url>/2020/10/02/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%922%EF%BC%9A%E5%89%AF%E6%9C%AC%E4%B8%8E%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<p>在前面讨论控制器模式的文章中，我们提到了Deployment这个控制器，接下来，我们重点讨论一下这个控制器的工作原理。</p><h2 id="一、从ReplicaSet说起">一、从ReplicaSet说起</h2><p>Deployment 看似简单，但实际上，它实现了 Kubernetes 项目中两个非常重要的功能：Pod 的“水平扩展 / 收缩”（horizontal scaling out/in）和“滚动更新”（rolling update）。举个例子，如果我们更新了 Deployment 的 Pod 模板（比如，修改了容器的镜像），那么 Deployment 就会遵循一种叫作“滚动更新”的方式，来升级现有的容器。而这个能力的实现，依赖于 Kubernetes 项目中的一个非常重要的概念（API 对象）：ReplicaSet。ReplicaSet 的结构非常简单，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-set</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.7.9</span><br></code></pre></td></tr></table></figure><p>可以看到，一个 ReplicaSet 对象，是由副本数和一个 Pod 模板组成。同时，也不难发现，它的定义其实和Deployment 是相同。但在这里我们需要知道的是：Deployment 控制器实际操纵的，是 ReplicaSet 对象，而不是 Pod 对象。</p><h2 id="二、理解Deployment">二、理解Deployment</h2><p>我们再来分析一个 Deployment对象，示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.7.9</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>可以看到，它定义的 Pod 副本数是 3（spec.replicas=3）。那么，在具体的实现上，这个 Deployment与 ReplicaSet以及 Pod 的关系是怎样的呢？我们可以用一张图把它描述出来：</p><p><img src="/img/image-20201002173911781.png" alt="image-20201002173911781"></p><p>通过这张图，我们可以很清楚地看到，一个定义了 replicas=3 的 Deployment，与它的 ReplicaSet以及 Pod 的之间，实际上是一种“层层控制”的关系。其中，ReplicaSet 负责通过“控制器模式”，保证系统中 Pod 的个数永远等于指定的个数（比如，3 个）。这也正是 Deployment 只允许容器的 restartPolicy=Always 的主要原因：只有在容器能保证自己始终是 Running 状态的前提下，ReplicaSet 调整 Pod 的个数才有意义。而在此基础上，Deployment 同样通过“控制器模式”，来操作 ReplicaSet 的个数和属性，进而实现“水平扩展 / 收缩”和“滚动更新”这两个编排动作。</p><h3 id="2-1、水平扩展-收缩">2.1、水平扩展/收缩</h3><p>“水平扩展 / 收缩”其实非常容易实现，只需要修改Deployment 控制器所控制的 ReplicaSet 的 Pod 副本数就可以了。比如，把这个值从 3 改成 4，那么 Deployment 所对应的 ReplicaSet，就会根据修改后的值自动创建一个新的 Pod。这就是“水平扩展”了；“水平收缩”则反之。执行这个操作的指令也非常简单，就是 kubectl scale，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl scale deployment nginx-deployment --replicas=4</span><br>deployment.apps/nginx-deployment scaled<br></code></pre></td></tr></table></figure><h3 id="2-2、滚动更新">2.2、滚动更新</h3><p>那么，“滚动更新”又是什么意思，是如何实现的呢？接下来，我们还以这个 Deployment 为例，理解“滚动更新”的过程。</p><h4 id="2-2-1、创建deployment">2.2.1、创建deployment</h4><p>首先，我们来创建这个 nginx-deployment：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">注意，在这里，我们额外加了一个–record 参数。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">它的作用，是记录下我们每次操作所执行的命令，以方便后面查看。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f nginx-deployment.yaml --record</span><br></code></pre></td></tr></table></figure><h4 id="2-2-2、查看deployment的状态信息">2.2.2、查看deployment的状态信息</h4><p>然后，我们来检查一下 nginx-deployment 创建后的状态信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get deployments</span><br>NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br>nginx-deployment   3         0         0            0           1s<br></code></pre></td></tr></table></figure><p>在返回结果中，我们可以看到四个状态字段，它们的含义如下所示：</p><ul><li>DESIRED，用户期望的Pod副本数（spec.replicas的值）；</li><li>CURRENT，当前处于Running状态的Pod数；</li><li>UP-TO-DATE，当前处于最新版本的Pod数，所谓最新版本指的是Pod的Spec部分与Deployment里Pod模板定义的完全一致；</li><li>AVAILABLE，当前已经可用的Pod数，即，即是Runing状态，又是最新版本，并且已经处于Ready状态的Pod数。</li></ul><p>可以看到，只有这个 AVAILABLE 字段，描述的才是用户所期望的最终状态。</p><h4 id="2-2-3、实时查看deployment的状态变化">2.2.3、实时查看deployment的状态变化</h4><p>Kubernetes 项目还为我们提供了一条指令，让我们可以实时查看 Deployment 对象的状态变化。这个指令就是 kubectl rollout status：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout status deployment/nginx-deployment</span><br>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...<br>deployment.apps/nginx-deployment successfully rolled out<br></code></pre></td></tr></table></figure><p>在这个返回结果中，“2 out of 3 new replicas have been updated”意味着已经有 2 个 Pod 进入了 UP-TO-DATE 状态。继续等待一会儿，我们就能看到这个 Deployment 的 3 个 Pod，就进入到了 AVAILABLE 状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br>nginx-deployment   3         3         3            3           20s<br></code></pre></td></tr></table></figure><h4 id="2-2-4、查看replicaset">2.2.4、查看replicaset</h4><p>此时，我们可以尝试查看一下这个 Deployment 所控制的 ReplicaSet：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rs</span><br>NAME                          DESIRED   CURRENT   READY   AGE<br>nginx-deployment-3167673210   3         3         3       20s<br></code></pre></td></tr></table></figure><p>如上所示，在我们提交了一个 Deployment 对象后，Deployment Controller 就会立即创建一个 Pod 副本个数为 3 的 ReplicaSet。这个 ReplicaSet 的名字，则是由 Deployment 的名字和一个随机字符串共同组成。</p><p>这个随机字符串叫作 pod-template-hash，在我们这个例子里就是：3167673210。ReplicaSet 会把这个随机字符串加在它所控制的所有 Pod 的标签里，从而保证这些 Pod 不会与集群里的其他 Pod 混淆。</p><p>而 ReplicaSet 的 DESIRED、CURRENT 和 READY 字段的含义，和 Deployment 中是一致的。所以，相比之下，Deployment 只是在 ReplicaSet 的基础上，添加了 UP-TO-DATE 这个跟版本有关的状态字段。</p><h4 id="2-2-5、编辑Pod模板">2.2.5、编辑Pod模板</h4><p>这个时候，如果我们修改了 Deployment 的 Pod 模板，“滚动更新”就会被自动触发。修改 Deployment 有很多方法。比如，我可以直接使用 kubectl edit 指令编辑 Etcd 里的 API 对象。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">备注：kubectl edit 并不神秘，它不过是把 API 对象的内容下载到了本地文件，让你修改完成后再提交上去。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl edit deployment/nginx-deployment</span><br>... <br>    spec:<br>      containers:<br>      - name: nginx<br>        image: nginx:1.9.1 # 1.7.9 -&gt; 1.9.1<br>        ports:<br>        - containerPort: 80<br>...<br>deployment.extensions/nginx-deployment edited<br></code></pre></td></tr></table></figure><p>这个 kubectl edit 指令，会帮我们直接打开 nginx-deployment 的 API 对象。然后，我们就可以修改这里的 Pod 模板部分了。比如，在这里，我将 nginx 镜像的版本升级到了 1.9.1。</p><p>kubectl edit 指令编辑完成后，保存退出，Kubernetes 就会立刻触发“滚动更新”的过程。我们还可以通过 kubectl rollout status 指令查看 nginx-deployment 的状态变化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout status deployment/nginx-deployment</span><br>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...<br>deployment.extensions/nginx-deployment successfully rolled out<br></code></pre></td></tr></table></figure><h4 id="2-2-6、查看滚动更新流程">2.2.6、查看滚动更新流程</h4><p>这时，我们可以通过查看 Deployment 的 Events，看到这个“滚动更新”的流程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe deployment nginx-deployment</span><br>...<br>Events:<br>  Type    Reason             Age   From                   Message<br>  ----    ------             ----  ----                   -------<br>...<br>  Normal  ScalingReplicaSet  24s   deployment-controller  Scaled up replica set nginx-deployment-1764197365 to 1<br>  Normal  ScalingReplicaSet  22s   deployment-controller  Scaled down replica set nginx-deployment-3167673210 to 2<br>  Normal  ScalingReplicaSet  22s   deployment-controller  Scaled up replica set nginx-deployment-1764197365 to 2<br>  Normal  ScalingReplicaSet  19s   deployment-controller  Scaled down replica set nginx-deployment-3167673210 to 1<br>  Normal  ScalingReplicaSet  19s   deployment-controller  Scaled up replica set nginx-deployment-1764197365 to 3<br>  Normal  ScalingReplicaSet  14s   deployment-controller  Scaled down replica set nginx-deployment-3167673210 to 0<br></code></pre></td></tr></table></figure><p>可以看到，首先，当我们修改了 Deployment 里的 Pod 定义之后，Deployment Controller 会使用这个修改后的 Pod 模板，创建一个新的 ReplicaSet（hash=1764197365），这个新的 ReplicaSet 的初始 Pod 副本数是：0。</p><p>然后，在 Age=24 s 的位置，Deployment Controller 开始将这个新的 ReplicaSet 所控制的 Pod 副本数从 0 个变成 1 个，即：“水平扩展”出一个副本。</p><p>紧接着，在 Age=22 s 的位置，Deployment Controller 又将旧的 ReplicaSet（hash=3167673210）所控制的旧 Pod 副本数减少一个，即：“水平收缩”成了两个副本。</p><p>如此交替进行，新 ReplicaSet 管理的 Pod 副本数，从 0 个变成 1 个，再变成 2 个，最后变成 3 个。而旧的 ReplicaSet 管理的 Pod 副本数则从 3 个变成 2 个，再变成 1 个，最后变成 0 个。这样，就完成了这一组 Pod 的版本升级过程。像这样，将一个集群中正在运行的多个 Pod 版本，交替地逐一升级的过程，就是“滚动更新”。</p><h4 id="2-2-7、查看replicaset的最终状态">2.2.7、查看replicaset的最终状态</h4><p>在这个“滚动更新”过程完成之后，我们可以查看一下新、旧两个 ReplicaSet 的最终状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rs</span><br>NAME                          DESIRED   CURRENT   READY   AGE<br>nginx-deployment-1764197365   3         3         3       6s<br>nginx-deployment-3167673210   0         0         0       30s<br></code></pre></td></tr></table></figure><p>其中，旧 ReplicaSet（hash=3167673210）已经被“水平收缩”成了 0 个副本。</p><h4 id="2-2-8、小结">2.2.8、小结</h4><p>这种“滚动更新”的好处是显而易见的。比如，在升级刚开始的时候，集群里只有 1 个新版本的 Pod。如果这时，新版本 Pod 有问题启动不起来，那么“滚动更新”就会停止，从而允许开发和运维人员介入。而在这个过程中，由于应用本身还有两个旧版本的 Pod 在线，所以服务并不会受到太大的影响。</p><p>当然，这也就要求你一定要使用 Pod 的 Health Check 机制检查应用的运行状态，而不是简单地依赖于容器的 Running 状态。要不然的话，虽然容器已经变成 Running 了，但服务很有可能尚未启动，“滚动更新”的效果也就达不到了。</p><h3 id="2-3、RollingUpdateStrategy">2.3、RollingUpdateStrategy</h3><p>为了保证服务的连续性，Deployment Controller 会确保，在任何时间窗口内，只有指定比例的 Pod 处于离线状态；同时，它也会确保，在任何时间窗口内，只有指定比例的新 Pod 被创建出来。这两个比例的值都是可以配置的，默认都是 DESIRED 值的 25%。</p><p>所以，在上面这个 Deployment 的例子中，它有 3 个 Pod 副本，那么控制器在“滚动更新”的过程中永远都会确保至少有 2 个 Pod 处于可用状态，至多只有 4 个 Pod 同时存在于集群中。这个策略，是 Deployment 对象的一个字段，名叫 RollingUpdateStrategy，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br><span class="hljs-string">...</span><br>  <span class="hljs-attr">strategy:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">RollingUpdate</span><br>    <span class="hljs-attr">rollingUpdate:</span><br>      <span class="hljs-attr">maxSurge:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>在上面这个 RollingUpdateStrategy 的配置中，maxSurge 指定的是除了 DESIRED 数量之外，在一次“滚动”中，Deployment 控制器还可以创建多少个新 Pod；而 maxUnavailable 指的是，在一次“滚动”中，Deployment 控制器可以删除多少个旧 Pod。同时，这两个配置还可以用前面我们介绍的百分比形式来表示，比如：maxUnavailable=50%，指的是我们最多可以一次删除“50%*DESIRED 数量”个 Pod。</p><h2 id="三、再看Deployment">三、再看Deployment</h2><p>结合以上讲述，现在我们可以扩展一下 Deployment、ReplicaSet 和 Pod 的关系图了。</p><p><img src="/img/image-20201002175648709.png" alt="image-20201002175648709"></p><p>如上所示，Deployment 的控制器，实际上控制的是 ReplicaSet 的数目，以及每个 ReplicaSet 的属性。而一个应用的版本，对应的正是一个 ReplicaSet；这个版本应用的 Pod 数量，则由 ReplicaSet 通过它自己的控制器（ReplicaSet Controller）来保证。</p><p>通过这样的多个 ReplicaSet 对象，Kubernetes 项目就实现了对多个“应用版本”的描述。而明白了“应用版本和 ReplicaSet 一一对应”的设计思想之后，我们就可以了解一下Deployment 对应用进行版本控制的具体原理了。</p><h3 id="3-1、修改deployment">3.1、修改deployment</h3><p>我们可以使用一个叫 kubectl set image 的指令，直接修改 nginx-deployment 所使用的镜像。这个命令的好处就是，我们可以不用像 kubectl edit 那样需要打开编辑器。不过这一次，我们把这个镜像名字修改成为了一个错误的名字，比如：nginx:1.91。这样，这个 Deployment 就会出现一个升级失败的版本。我们一起来实践一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">set</span> image deployment/nginx-deployment nginx=nginx:1.91</span><br>deployment.extensions/nginx-deployment image updated<br></code></pre></td></tr></table></figure><p>由于这个 nginx:1.91 镜像在 Docker Hub 中并不存在，所以这个 Deployment 的“滚动更新”被触发后，会立刻报错并停止。这时，我们来检查一下 ReplicaSet 的状态，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rs</span><br>NAME                          DESIRED   CURRENT   READY   AGE<br>nginx-deployment-1764197365   2         2         2       24s<br>nginx-deployment-2156724341   2         2         0       7s<br></code></pre></td></tr></table></figure><p>通过这个返回结果，我们可以看到，新版本的 ReplicaSet（hash=2156724341）的“水平扩展”已经停止。而且此时，它已经创建了两个 Pod，但是它们都没有进入 READY 状态。这当然是因为这两个 Pod 都拉取不到有效的镜像。与此同时，旧版本的 ReplicaSet（hash=1764197365）的“水平收缩”，也自动停止了。此时，已经有一个旧 Pod 被删除，还剩下两个旧 Pod。</p><h3 id="3-2、回滚deployment">3.2、回滚deployment</h3><p>那么问题来了， 我们如何让这个 Deployment 的 3 个 Pod，都回滚到以前的旧版本呢？我们只需要执行一条 kubectl rollout undo 命令，就能把整个 Deployment 回滚到上一个版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout undo deployment/nginx-deployment</span><br>deployment.extensions/nginx-deployment<br></code></pre></td></tr></table></figure><p>很容易想到，在具体操作上，Deployment 的控制器，其实就是让这个旧 ReplicaSet（hash=1764197365）再次“扩展”成 3 个 Pod，而让新的 ReplicaSet（hash=2156724341）重新“收缩”到 0 个 Pod。</p><h3 id="3-3、查看deployment历史版本">3.3、查看deployment历史版本</h3><p>更进一步地，如果我们想回滚到更早之前的版本，要怎么办呢？</p><p>首先，我们需要使用 kubectl rollout history 命令，查看每次 Deployment 变更对应的版本。而由于我们在创建这个 Deployment 的时候，指定了–record 参数，所以我们创建这些版本时执行的 kubectl 命令，都会被记录下来。这个操作的输出如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout <span class="hljs-built_in">history</span> deployment/nginx-deployment</span><br>deployments &quot;nginx-deployment&quot;<br>REVISION    CHANGE-CAUSE<br>1           kubectl create -f nginx-deployment.yaml --record<br>2           kubectl edit deployment/nginx-deployment<br>3           kubectl set image deployment/nginx-deployment nginx=nginx:1.91<br></code></pre></td></tr></table></figure><p>可以看到，我们前面执行的创建和更新操作，分别对应了版本 1 和版本 2，而那次失败的更新操作，则对应的是版本 3。当然，我们还可以通过这个 kubectl rollout history 指令，看到每个版本对应的 Deployment 的 API 对象的细节，具体命令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout <span class="hljs-built_in">history</span> deployment/nginx-deployment --revision=2</span><br></code></pre></td></tr></table></figure><h3 id="3-4、回滚deployment到指定版本">3.4、回滚deployment到指定版本</h3><p>然后，我们就可以在 kubectl rollout undo 命令行最后，加上要回滚到的指定版本的版本号，就可以回滚到指定版本了。这个指令的用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout undo deployment/nginx-deployment --to-revision=2</span><br>deployment.extensions/nginx-deployment<br></code></pre></td></tr></table></figure><p>这样，Deployment Controller 还会按照“滚动更新”的方式，完成对 Deployment 的降级操作。</p><h3 id="3-5、暂停deployment">3.5、暂停deployment</h3><p>此时，我们可能已经想到了一个问题：对 Deployment 进行的每一次更新操作，都会生成一个新的 ReplicaSet 对象，是不是有些多余，甚至浪费资源呢？</p><p>答案是肯定的。为此，Kubernetes项目还提供了一个指令，使得我们对 Deployment 的多次更新操作，最后只生成一个 ReplicaSet。具体的做法是，在更新 Deployment 前，我们要先执行一条 kubectl rollout pause 指令。它的用法如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout pause deployment/nginx-deployment</span><br>deployment.extensions/nginx-deployment paused<br></code></pre></td></tr></table></figure><p>这个 kubectl rollout pause 的作用，是让这个 Deployment 进入了一个“暂停”状态。所以接下来，我们就可以随意使用 kubectl edit 或者 kubectl set image 指令，修改这个 Deployment 的内容了。由于此时 Deployment 正处于“暂停”状态，所以我们对 Deployment 的所有修改，都不会触发新的“滚动更新”，也不会创建新的 ReplicaSet。</p><h3 id="3-6、恢复deployment">3.6、恢复deployment</h3><p>等到我们对 Deployment 修改操作都完成之后，只需要再执行一条 kubectl rollout resume 指令，就可以把这个 Deployment“恢复”回来，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout resume deploy/nginx-deployment</span><br>deployment.extensions/nginx-deployment resumed<br></code></pre></td></tr></table></figure><p>而在这个 kubectl rollout resume 指令执行之前，在 kubectl rollout pause 指令之后的这段时间里，我们对 Deployment 进行的所有修改，最后只会触发一次“滚动更新”。</p><h3 id="3-7、检查replicaset的状态">3.7、检查replicaset的状态</h3><p>当然，我们可以通过检查 ReplicaSet 状态的变化，来验证一下 kubectl rollout pause 和 kubectl rollout resume 指令的执行效果，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rs</span><br>NAME               DESIRED   CURRENT   READY     AGE<br>nginx-1764197365   0         0         0         2m<br>nginx-3196763511   3         3         3         28s<br></code></pre></td></tr></table></figure><p>通过返回结果，我们可以看到，只有一个 hash=3196763511 的 ReplicaSet 被创建了出来。</p><h3 id="3-8、设置历史replicaset的数量">3.8、设置历史replicaset的数量</h3><p>不过，即使我们像上面这样小心翼翼地控制了 ReplicaSet 的生成数量，随着应用版本的不断增加，Kubernetes 中还是会为同一个 Deployment 保存很多很多不同的 ReplicaSet。那么，我们又该如何控制这些“历史”ReplicaSet 的数量呢？</p><p>很简单，Deployment 对象有一个字段，叫作 spec.revisionHistoryLimit，就是 Kubernetes 为 Deployment 保留的“历史版本”个数。所以，如果把它设置为 0，我们就再也不能做回滚操作了。</p><h2 id="四、小结">四、小结</h2><p>在这篇文章中，我们主要讨论了Deployment控制器的工作原理和使用方法。我们需要知道的是：</p><ul><li>Deployment控制器最核心的能力是：Pod的水平扩展/收缩以及滚动更新。</li><li>Deployment依赖于ReplicaSet。Deployment控制器操控的对象并不是Pod，而是ReplicaSet。</li><li>Deployment、ReplicaSet和Pod之间是一种层层控制关系，Deployment控制ReplicaSet的版本，ReplicaSet控制Pod的个数。</li><li>Deployment控制器的滚动更新策略是可以设置的。默认情况下，在任何时间窗口内，只能有“期望副本数 * 25%”个Pod处于离线状态，也只能有“期望副本数 * （1+25%）”个Pod处于在线状态。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器编排1：理解控制器模型</title>
    <link href="/2020/10/02/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%921%EF%BC%9A%E7%90%86%E8%A7%A3%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/10/02/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%921%EF%BC%9A%E7%90%86%E8%A7%A3%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们已经对Pod对象进行了深入地讨论。接下来，我们一起来看Kubernetes项目最核心的功能，编排。</p><h2 id="一、从一个例子说起">一、从一个例子说起</h2><p>在前面讨论Pod对象时，我们做出了一个这样的总结：“容器，是进程；Pod，是操作系统”。由于容器描述应用时过于简单，因此kubernetes将容器进一步抽象、封装成了Pod。在kubernetes的世界中，通常不会直接操作Pod对象，而是由控制器完成。比如，下面这个名叫nginx-deployment 的例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.7.9</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>在这个例子中，Deployment控制器会确保携带了 app=nginx 标签的 Pod 的个数，永远等于 spec.replicas 指定的个数，即 2 个。这意味着，如果在这个集群中，携带 app=nginx 标签的 Pod 的个数大于 2 的时候，就会有旧的 Pod 被删除；反之，就会有新的 Pod 被创建。</p><h2 id="二、控制器">二、控制器</h2><p>在Kubernetes架构中，有一个名叫kube-controller-manager的组件。这个组件，就是一系列控制器的集合。我们可以查看一下 Kubernetes 项目的 pkg/controller 目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> kubernetes/pkg/controller/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -d */</span>              <br>deployment/             job/                    podautoscaler/          <br>cloud/                  disruption/             namespace/              <br>replicaset/             serviceaccount/         volume/<br>cronjob/                garbagecollector/       nodelifecycle/          replication/            statefulset/            daemon/<br>...<br></code></pre></td></tr></table></figure><p>这个目录下面的每一个控制器，都会以独有的方式负责某种编排功能。而我们的 Deployment，正是这些控制器中的一种。</p><h3 id="2-1、控制循环">2.1、控制循环</h3><p>我们需要知道的是，上面这些控制器之所以被统一放在 pkg/controller 目录下，是因为它们都遵循 Kubernetes 项目中的一个通用编排模式，即：控制循环（control loop）。比如，现在有一个待编排对象 X，它有一个对应的控制器。那么，我就可以用一段 Go 语言风格的伪代码，来描述这个控制循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;<br>    实际状态 := 获取集群中对象X的实际状态（Actual State）<br>    期望状态 := 获取集群中对象x的期望状态（Desired state）<br>    <span class="hljs-keyword">if</span> 实际状态 == 期望状态 &#123;<br>        什么都不做<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        执行编排动作，将实际状态调整为期望状态<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在具体的实现中，实际状态往往来自于 Kubernetes 集群本身。比如，kubelet 通过心跳汇报的容器状态和节点状态，或者监控系统中保存的应用监控数据，再或者控制器主动收集的它自己感兴趣的信息，这些都是常见的实际状态的来源。而期望状态，一般来自于用户提交的 YAML 文件。比如，Deployment 对象中 Replicas 字段的值。很明显，这些信息往往都保存在 Etcd 中。</p><h3 id="2-2、调谐循环">2.2、调谐循环</h3><p>我们可以以上面的 Deployment 对象为例，简单描述一下控制器模型的实现：</p><ul><li>Deployment控制器从Etcd中获取到所有携带了“app:ningx”标签的Pod，然后统计它们的数量，这就是实际状态；</li><li>YAML文件中Deployment对象的Replicas字段的值就是期望状态；</li><li>Deployment控制器将两个状态做比较，然后根据比较结果，确定是创建Pod，还是删除已有的Pod。</li></ul><p>可以看到，一个 Kubernetes 对象的主要编排逻辑，实际上是在第三步的“对比”阶段完成的。这个操作，通常被叫作调谐（Reconcile）。这个调谐的过程，则被称作“Reconcile Loop”（调谐循环）或者“Sync Loop”（同步循环）。而调谐的最终结果，往往都是对被控制对象的某种写操作。比如，增加 Pod，删除已有的 Pod，或者更新 Pod 的某个字段。</p><h3 id="2-3、对象模板">2.3、对象模板</h3><p>控制器，主要负责定义被控制对象的期望状态。比如，Deployment 里的 replicas=2 这个字段。而被控制对象，则来自于一个“模板”。比如，Deployment 里的 template 字段。可以看到，Deployment 这个 template 字段里的内容，跟一个标准的 Pod 对象的 API 定义，丝毫不差。而所有被这个 Deployment 管理的 Pod 实例，其实都是根据这个 template 字段的内容创建出来的。</p><p>像 Deployment 定义的 template 字段，在 Kubernetes 项目中有一个专有的名字，叫作 PodTemplate（Pod 模板）。Kubernetes中的大多数控制器，都会使用 PodTemplate 来统一定义它所要管理的 Pod。此外，我们还会看到其他类型的对象模板，比如 Volume 的模板。</p><p>在这里，我们可以对 Deployment 以及其他类似的控制器，做一个简单总结：</p><p><img src="/img/image-20201002165418796.png" alt="image-20201002165418796"></p><p>如上图所示，类似于 Deployment 这样的控制器，实际上都是由上半部分的控制器定义（包括期望状态），加上下半部分的被控制对象的模板组成的。</p><h2 id="三、小结">三、小结</h2><p>在这篇文章中，我们以Deployment为例，讨论了Kubernetes如何通过“控制器”，实现对各种不同对象或资源的编排：</p><ul><li>Kubernetes支持多种容器编排功能，比如ReplicaSet、Deployment、StatefulSet、DaemonSet、CronJob等</li><li>每一种编排功能都是由一个或多个控制器实现的，每个控制器通过控制循环完成各自的编排逻辑。</li><li>在控制循环的作用下，最后的执行结果都和Deployment类似，即要么创建、更新一些Pod，要么删除一些已经存在的Pod（或者其他的API对象、资源）。</li><li>当我们描述一个对象时，主要会涉及到两个核心内容：控制器定义（对象所使用的控制器）和被控制对象（即对象本身）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入解析Pod对象3：使用进阶</title>
    <link href="/2020/10/02/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Pod%E5%AF%B9%E8%B1%A13%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6/"/>
    <url>/2020/10/02/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Pod%E5%AF%B9%E8%B1%A13%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们已经深入讨论了Pod的API对象，以及Pod和Container的关系。接下来，我们先从一种特殊的Volume开始，更加深入地理解Pod对象各个重要字段的含义。</p><h2 id="一、Projected-Volume">一、Projected Volume</h2><p>在 Kubernetes 中，有几种特殊的 Volume，它们存在的意义不是为了存放容器里的数据，也不是用来进行容器和宿主机之间的数据交换。这些特殊 Volume 的作用，是为容器提供预先定义好的数据。所以，从容器的角度来看，这些 Volume 中的信息仿佛就是被 Kubernetes“投射”（Project）进入容器当中的。这正是 Projected Volume 的含义。到目前为止，Kubernetes 支持的 Projected Volume 一共有四种：</p><ul><li>Secret，存放Pod中容器要访问的加密数据。比如，数据库连接用户的用户名和密码</li><li>ConfigMap，存放Pod中容器要访问的配置信息。比如，一个 Java 应用所需的配置文件（.properties 文件）</li><li>Downward API，让Pod中的容器能够直接获取到当前Pod对象本身的信息。</li><li>ServiceAccountToken，保存ServiceAccount对象的授权信息。</li></ul><h3 id="1-1、Secret">1.1、Secret</h3><p>我们先讨论Secret。它的作用，是帮我们把 Pod 想要访问的加密数据，存放到 Etcd 中。然后，我们就可以通过在 Pod 的容器里以挂载 Volume 的方式，访问到这些 Secret 里保存的信息了。</p><p>Secret 最典型的使用场景，莫过于存放数据库的 Credential 信息了，比如下面这个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-projected-volume</span> <br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">test-secret-volume</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">args:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">sleep</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;86400&quot;</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-cred</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">&quot;/projected-volume&quot;</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-cred</span><br>    <span class="hljs-attr">projected:</span><br>      <span class="hljs-attr">sources:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">secret:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">user</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">secret:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">pass</span><br></code></pre></td></tr></table></figure><p>在这个 Pod 中，我们定义了一个简单的容器。它声明挂载的 Volume，并不是常见的 emptyDir 或者 hostPath 类型，而是 projected 类型。而这个 Volume 的数据来源（sources），则是名为 user 和 pass 的两个 Secret 对象，它们分别对应的是数据库的用户名和密码。</p><p>这里用到的数据库用户名、密码，正是以 Secret 对象的方式提交给 Kubernetes 保存的。完成这个操作的指令，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> ./username.txt</span><br>admin<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> ./password.txt</span><br>c1oudc0w!<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create secret generic user --from-file=./username.txt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create secret generic pass --from-file=./password.txt</span><br></code></pre></td></tr></table></figure><p>其中，username.txt 和 password.txt 文件里，存放的就是用户名和密码；而 user 和 pass，则是我们为 Secret 对象指定的名字。而我想要查看这些 Secret 对象的话，只要执行一条 kubectl get 命令就可以了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get secrets</span><br>NAME           TYPE                                DATA      AGE<br>user          Opaque                                1         51s<br>pass          Opaque                                1         51s<br></code></pre></td></tr></table></figure><p>当然，除了使用 kubectl create secret 指令外，我们也可以直接通过编写 YAML 文件的方式来创建这个 Secret 对象，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">Opaque</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">user:</span> <span class="hljs-string">YWRtaW4=</span><br>  <span class="hljs-attr">pass:</span> <span class="hljs-string">MWYyZDFlMmU2N2Rm</span><br></code></pre></td></tr></table></figure><p>可以看到，通过编写 YAML 文件创建出来的 Secret 对象只有一个。但它的 data 字段，却以 Key-Value 的格式保存了两份 Secret 数据。其中，“user”就是第一份数据的 Key，“pass”则是第二份数据的 Key。需要注意的是，Secret 对象要求这些数据必须是经过 Base64 转码的，以免出现明文密码的安全隐患。这个转码操作也很简单，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&#x27;admin&#x27;</span> | <span class="hljs-built_in">base64</span></span><br>YWRtaW4=<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&#x27;1f2d1e2e67df&#x27;</span> | <span class="hljs-built_in">base64</span></span><br>MWYyZDFlMmU2N2Rm<br></code></pre></td></tr></table></figure><p>这里需要注意的是，像这样创建的 Secret 对象，它里面的内容仅仅是经过了转码，而并没有被加密。在真正的生产环境中，我们需要在 Kubernetes 中开启 Secret 的加密插件，增强数据的安全性。</p><p>接下来，我们尝试一下创建这个 Pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f test-projected-volume.yaml</span><br></code></pre></td></tr></table></figure><p>当 Pod 变成 Running 状态之后，我们再验证一下这些 Secret 对象是不是已经在容器里了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it test-projected-volume -- /bin/sh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /projected-volume/</span><br>user<br>pass<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /projected-volume/user</span><br>root<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /projected-volume/pass</span><br>1f2d1e2e67df<br></code></pre></td></tr></table></figure><p>从返回结果中，我们可以看到，保存在 Etcd 里的用户名和密码信息，已经以文件的形式出现在了容器的 Volume 目录里。而这个文件的名字，就是 kubectl create secret 指定的 Key，或者说是 Secret 对象的 data 字段指定的 Key。</p><p>更重要的是，像这样通过挂载方式进入到容器里的 Secret，一旦其对应的 Etcd 里的数据被更新，这些 Volume 里的文件内容，同样也会被更新。其实，这是 kubelet 组件在定时维护这些 Volume。需要注意的是，这个更新可能会有一定的延时。所以在编写应用程序时，在发起数据库连接的代码处写好重试和超时的逻辑，绝对是个好习惯。</p><h3 id="1-2、ConfigMap">1.2、ConfigMap</h3><p>与 Secret 类似的是 ConfigMap，它与 Secret 的区别在于，ConfigMap 保存的是不需要加密的、应用所需的配置信息。ConfigMap 的用法几乎与 Secret 完全相同：我们可以使用 kubectl create configmap 从文件或者目录创建 ConfigMap 对象，也可以直接编写 ConfigMap 对象的 YAML 文件。</p><p>比如，一个 Java 应用所需的配置文件（.properties 文件），就可以通过下面这样的方式保存在 ConfigMap 里：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">.properties文件的内容</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> example/ui.properties</span><br>color.good=purple<br>color.bad=yellow<br>allow.textmode=true<br>how.nice.to.look=fairlyNice<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从.properties文件创建ConfigMap</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create configmap ui-config --from-file=example/ui.properties</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看这个ConfigMap里保存的信息(data)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get configmaps ui-config -o yaml</span><br>apiVersion: v1<br>data:<br>  ui.properties: |<br>    color.good=purple<br>    color.bad=yellow<br>    allow.textmode=true<br>    how.nice.to.look=fairlyNice<br>kind: ConfigMap<br>metadata:<br>  name: ui-config<br>  ...<br></code></pre></td></tr></table></figure><p>备注：kubectl get -o yaml 这样的参数，会将指定的 Pod API 对象以 YAML 的方式展示出来。</p><h3 id="1-3、Downward-API">1.3、Downward API</h3><p>接下来是 Downward API，它的作用是：让 Pod 里的容器能够直接获取到这个 Pod API 对象本身的信息。如下示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-downwardapi-volume</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">zone:</span> <span class="hljs-string">us-est-coast</span><br>    <span class="hljs-attr">cluster:</span> <span class="hljs-string">test-cluster1</span><br>    <span class="hljs-attr">rack:</span> <span class="hljs-string">rack-22</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">client-container</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">k8s.gcr.io/busybox</span><br>      <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>]<br>      <span class="hljs-attr">args:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">while</span> <span class="hljs-literal">true</span><span class="hljs-string">;</span> <span class="hljs-string">do</span><br>          <span class="hljs-string">if</span> [[ <span class="hljs-string">-e</span> <span class="hljs-string">/etc/podinfo/labels</span> ]]<span class="hljs-string">;</span> <span class="hljs-string">then</span><br>            <span class="hljs-string">echo</span> <span class="hljs-string">-en</span> <span class="hljs-string">&#x27;\n\n&#x27;</span><span class="hljs-string">;</span> <span class="hljs-string">cat</span> <span class="hljs-string">/etc/podinfo/labels;</span> <span class="hljs-string">fi;</span><br>          <span class="hljs-string">sleep</span> <span class="hljs-number">5</span><span class="hljs-string">;</span><br>        <span class="hljs-string">done;</span><br>      <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">podinfo</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/podinfo</span><br>          <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">podinfo</span><br>      <span class="hljs-attr">projected:</span><br>        <span class="hljs-attr">sources:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">downwardAPI:</span><br>            <span class="hljs-attr">items:</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;labels&quot;</span><br>                <span class="hljs-attr">fieldRef:</span><br>                  <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.labels</span><br></code></pre></td></tr></table></figure><p>在这个 Pod 的 YAML 文件中，我们定义了一个简单的容器，声明了一个 projected 类型的 Volume。只不过这次 Volume 的数据来源，变成了 Downward API。而这个 Downward API Volume，则声明要暴露 Pod 的 metadata.labels 信息给容器。</p><p>通过这样的声明方式，当前 Pod 的 Labels 字段的值，就会被 Kubernetes 自动挂载成为容器里的 /etc/podinfo/labels 文件。而这个容器的启动命令，则是不断打印出 /etc/podinfo/labels 里的内容。所以，当我们创建了这个 Pod 之后，就可以通过 kubectl logs 指令，查看到这些 Labels 字段被打印出来，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f dapi-volume.yaml</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl logs test-downwardapi-volume</span><br>cluster=&quot;test-cluster1&quot;<br>rack=&quot;rack-22&quot;<br>zone=&quot;us-est-coast&quot;<br></code></pre></td></tr></table></figure><p>目前，Downward API 支持的字段已经非常丰富了，比如：</p><ul><li>使用fieldRef可以声明使用：<ul><li>spec.nodeName - 宿主机名字</li><li>status.hostIP - 宿主机IP</li><li><a href="http://metadata.name">metadata.name</a> - Pod的名字</li><li>metadata.namespace - Pod的Namespace</li><li>status.podIP - Pod的IP</li><li>spec.serviceAccountName - Pod的Service Account的名字</li><li>metadata.uid - Pod的UID</li><li>metadata.labels[‘&lt;KEY&gt;’] - 指定&lt;KEY&gt;的Label值</li><li>metadata.annotations[‘&lt;KEY&gt;’] - 指定&lt;KEY&gt;的Annotation值</li><li>metadata.labels - Pod的所有Label</li><li>metadata.annotations - Pod的所有Annotation</li></ul></li><li>使用resourceFieldRef可以声明使用：<ul><li>容器的CPU limit</li><li>容器的CPU request</li><li>容器的memory limit</li><li>容器的memory request</li></ul></li></ul><p>上面这个列表的内容，随着 Kubernetes 项目的发展肯定还会不断增加。不过，需要注意的是，Downward API 能够获取到的信息，一定是 Pod 里的容器进程启动之前就能够确定下来的信息。而如果我们想要获取 Pod 容器运行后才会出现的信息，比如，容器进程的 PID，那就肯定不能使用 Downward API 了，而应该考虑在 Pod 里定义一个 sidecar 容器。</p><h3 id="1-4、ServiceAccountToken">1.4、ServiceAccountToken</h3><p>假设我们现在有一个这样的需求：</p><blockquote><p>现在有了一个 Pod，我们能不能在这个 Pod 里安装一个 Kubernetes 的 Client，这样就可以从容器里直接访问并且操作这个 Kubernetes 的 API 了呢？</p></blockquote><p>这当然是可以的。不过，我们首先要解决 API Server 的授权问题。</p><p>Service Account对象，就是Kubernetes系统内置的一种“服务账户”，它是Kubernetes进行权限分配的对象。比如，Service Account A，可以只被允许对Kubernetes API进行GET操作，而Service Account B，则可以有Kubernetes API的所有操作权限。</p><p>这样的 Service Account 的授权信息和文件，实际上保存在它所绑定的一个特殊的 Secret 对象里。而这个特殊的 Secret 对象，就叫作 ServiceAccountToken。任何运行在 Kubernetes 集群上的应用，都必须使用 ServiceAccountToken 里保存的授权信息，也就是 Token，才可以合法地访问 API Server。</p><p>所以说，Kubernetes 项目的 Projected Volume 其实只有三种，因为第四种 ServiceAccountToken，只是一种特殊的 Secret 而已。另外，为了方便使用，Kubernetes 已经为我们提供了一个默认“服务账户”（default Service Account）。并且，任何一个运行在 Kubernetes 里的 Pod，都可以直接使用这个默认的 Service Account，而无需显示地声明挂载它。</p><blockquote><p>这是如何做到的呢？</p></blockquote><p>当然还是靠 Projected Volume 机制。如果查看一下任意一个运行在 Kubernetes 集群里的 Pod，就会发现，每一个 Pod，都已经自动声明了一个类型是 Secret、名为 default-token-xxx 的 Volume，然后 自动挂载在每个容器的一个固定目录上。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe pod nginx-deployment-5c678cfb6d-lg9lw</span><br>Containers:<br>...<br>  Mounts:<br>    /var/run/secrets/kubernetes.io/serviceaccount from default-token-s8rbq (ro)<br>Volumes:<br>  default-token-s8rbq:<br>  Type:       Secret (a volume populated by a Secret)<br>  SecretName:  default-token-s8rbq<br>  Optional:    false<br></code></pre></td></tr></table></figure><p>这个 Secret 类型的 Volume，正是默认“服务账户”对应的 ServiceAccountToken。所以说，Kubernetes 其实在创建每个 Pod 的时候，自动在它的 spec.volumes 部分添加上了默认 ServiceAccountToken 的定义，然后自动给每个容器加上了对应的 volumeMounts 字段。这个过程对于用户来说是完全透明的。</p><p>这样，一旦 Pod 创建完成，容器里的应用就可以直接从这个挂载了 ServiceAccountToken 的目录里访问到授权信息和文件。这个目录的的路径在容器中是固定的，即：/var/run/secrets/kubernetes.io/serviceaccount ，而这个 Secret 类型的 Volume 里面的内容如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /var/run/secrets/kubernetes.io/serviceaccount</span> <br>ca.crt namespace  token<br></code></pre></td></tr></table></figure><p>所以，我们的应用程序只要直接加载这些授权文件，就可以访问并操作 Kubernetes API 了。而且，如果我们使用的是 Kubernetes 官方的 Client 包（<a href="http://k8s.io/client-go%EF%BC%89%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%AE%83%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E8%BF%99%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E6%88%91%E4%BB%AC%E5%81%9A%E4%BB%BB%E4%BD%95%E9%85%8D%E7%BD%AE%E6%88%96%E8%80%85%E7%BC%96%E7%A0%81%E6%93%8D%E4%BD%9C%E3%80%82">k8s.io/client-go）的话，它会自动加载这个目录下的文件，不需要我们做任何配置或者编码操作。</a></p><p>这种把 Kubernetes 客户端以容器的方式运行在集群里，然后使用 default Service Account 自动授权的方式，被称作“InClusterConfig”，它也是最推荐的进行 Kubernetes API 编程的授权方式。</p><p>当然，考虑到自动挂载默认 ServiceAccountToken 的潜在风险，Kubernetes 允许我们设置默认不为 Pod 里的容器自动挂载这个 Volume。</p><p>除了这个默认的 Service Account 外，我们很多时候还需要创建一些我们自己定义的 Service Account，来对应不同的权限设置。这样，Pod 里的容器就可以通过挂载这些 Service Account 对应的 ServiceAccountToken，来使用这些自定义的授权信息。</p><h3 id="1-5、补充">1.5、补充</h3><p>其实，Secret、ConfigMap，以及 Downward API 这三种 Projected Volume 定义的信息，大多还可以通过环境变量的方式出现在容器里。但是，通过环境变量获取这些信息的方式，不具备自动更新的能力。所以，一般情况下，建议使用 Volume 文件的方式获取这些信息。</p><h2 id="二、容器健康检查和恢复机制">二、容器健康检查和恢复机制</h2><p>接下来，我们再来看 Pod 另一个重要的配置：容器健康检查和恢复机制。</p><h3 id="2-1、从官方示例说起">2.1、从官方示例说起</h3><p>在 Kubernetes 中，我们可以为 Pod 里的容器定义一个健康检查“探针”（Probe）。这样，kubelet 就会根据这个 Probe 的返回值决定这个容器的状态，而不是直接以容器进程是否运行（来自 Docker 返回的信息）作为依据。这种机制，是生产环境中保证应用健康存活的重要手段。如下是 Kubernetes 文档中的一个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">test:</span> <span class="hljs-string">liveness</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-liveness-exec</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">liveness</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">args:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">/bin/sh</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">-c</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">touch</span> <span class="hljs-string">/tmp/healthy;</span> <span class="hljs-string">sleep</span> <span class="hljs-number">30</span><span class="hljs-string">;</span> <span class="hljs-string">rm</span> <span class="hljs-string">-rf</span> <span class="hljs-string">/tmp/healthy;</span> <span class="hljs-string">sleep</span> <span class="hljs-number">600</span><br>    <span class="hljs-attr">livenessProbe:</span><br>      <span class="hljs-attr">exec:</span><br>        <span class="hljs-attr">command:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">cat</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">/tmp/healthy</span><br>      <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span><br>      <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>在这个 Pod 中，定义了一个有趣的容器。它在启动之后做的第一件事，就是在 /tmp 目录下创建了一个 healthy 文件，以此作为自己已经正常运行的标志。而 30 s 过后，它会把这个文件删除掉。</p><p>与此同时，定义了一个 livenessProbe（健康检查）。它的类型是 exec，这意味着，它会在容器启动后，在容器里面执行一条我们指定的命令，比如：“cat /tmp/healthy”。这时，如果这个文件存在，这条命令的返回值就是 0，Pod 就会认为这个容器不仅已经启动，而且是健康的。这个健康检查，在容器启动 5 s 后开始执行（initialDelaySeconds: 5），并且每隔 5 s 再执行一次（periodSeconds: 5）。</p><h3 id="2-2、理解官方示例">2.2、理解官方示例</h3><p>现在，让我们来具体实践一下这个过程。首先，创建这个 Pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f test-liveness-exec.yaml</span><br></code></pre></td></tr></table></figure><p>然后，查看这个 Pod 的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pod</span><br>NAME                READY     STATUS    RESTARTS   AGE<br>test-liveness-exec   1/1       Running   0          10s<br></code></pre></td></tr></table></figure><p>可以看到，由于已经通过了健康检查，这个 Pod 就进入了 Running 状态。而 30 s 之后，我们再查看一下 Pod 的 Events：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe pod test-liveness-exec</span><br></code></pre></td></tr></table></figure><p>我们会发现，这个 Pod 在 Events 报告了一个异常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">FirstSeen LastSeen    Count   From            SubobjectPath           Type        Reason      Message<br>--------- --------    -----   ----            -------------           --------    ------      -------<br>2s        2s      1   &#123;kubelet worker0&#125;   spec.containers&#123;liveness&#125;   Warning     Unhealthy   Liveness probe failed: cat: can&#x27;t open &#x27;/tmp/healthy&#x27;: No such file or directory<br></code></pre></td></tr></table></figure><p>显然，这个健康检查探查到 /tmp/healthy 已经不存在了，所以它报告容器是不健康的。那么接下来会发生什么呢？我们不妨再次查看一下这个 Pod 的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pod test-liveness-exec</span><br>NAME           READY     STATUS    RESTARTS   AGE<br>liveness-exec   1/1       Running   1          1m<br></code></pre></td></tr></table></figure><p>这时我们发现，Pod 并没有进入 Failed 状态，而是保持了 Running 状态。这是为什么呢？</p><p>其实，如果我们注意到 RESTARTS 字段从 0 到 1 的变化，就明白原因了：这个异常的容器已经被 Kubernetes 重启了。在这个过程中，Pod 保持 Running 状态不变。需要注意的是：Kubernetes 中并没有 Docker 的 Stop 语义。所以虽然是 Restart（重启），但实际却是重新创建了容器。而这个功能就是 Kubernetes 里的 Pod 恢复机制，也叫 restartPolicy。它是 Pod 的 Spec 部分的一个标准字段（pod.spec.restartPolicy），默认值是 Always，即：任何时候这个容器发生了异常，它一定会被重新创建。</p><p>但一定要强调的是，对Pod这样的“控制器”来说，Pod 的恢复过程，永远发生在当前节点上，而不会跑到别的节点上去。事实上，一旦一个 Pod 与一个节点（Node）绑定，除非这个绑定发生了变化（pod.spec.node 字段被修改），否则它永远都不会离开这个节点。这也就意味着，如果这个宿主机宕机了，这个 Pod 也不会主动迁移到其他节点上去。而如果我们想让 Pod 出现在其他的可用节点上，就必须使用 Deployment 这样的“控制器”来管理 Pod，哪怕我们只需要一个 Pod 副本。</p><h3 id="2-3、Pod-的三种恢复策略">2.3、Pod 的三种恢复策略</h3><p>作为用户，我们还可以通过设置 restartPolicy，改变 Pod 的恢复策略。除了 Always，它还有 OnFailure 和 Never 两种情况：</p><ul><li>Always，只要容器不是运行状态，就自动重启容器；</li><li>OnFailure，只在容器异常时，才自动重启容器；</li><li>Never，永远不重启容器。</li></ul><p>在实际使用时，我们需要根据应用运行的特性，合理设置这三种恢复策略。比如，一个 Pod，它只计算 1+1=2，计算完成输出结果后退出，变成 Succeeded 状态。这时，我们如果再用 restartPolicy=Always 强制重启这个 Pod 的容器，就没有任何意义了。而如果我们关心这个容器退出后的上下文环境，比如容器退出后的日志、文件和目录，就需要将 restartPolicy 设置为 Never。因为一旦容器被自动重新创建，这些内容就有可能丢失掉了（被垃圾回收了）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pod test-liveness-exec</span><br>NAME           READY     STATUS    RESTARTS   AGE<br>liveness-exec   0/1       Running   1          1m<br></code></pre></td></tr></table></figure><p>值得一提的是，Kubernetes 的官方文档，把 restartPolicy 和 Pod 里容器的状态，以及 Pod 状态的对应关系，总结了非常复杂的一大堆情况。实际上，我们根本不需要死记硬背这些对应关系，只要记住如下两个基本的设计原理即可：</p><ul><li>只要Pod的restartPolicy指定的策略允许重启异常的容器（比如，Always），那么这个Pod就会保持Running状态，并进行容器重启。否则，Pod就会进入Failed状态。</li><li>对于包含多个容器的Pod，只有它里面所有的容器都进入异常状态后，Pod才会进入Failed状态。在此之前，Pod都是Running状态。此时，Pod的READY字段会显示正常容器的个数。</li></ul><p>所以，假如一个 Pod 里只有一个容器，然后这个容器异常退出了。那么，只有当 restartPolicy=Never 时，这个 Pod 才会进入 Failed 状态。而其他情况下，由于 Kubernetes 都可以重启这个容器，所以 Pod 的状态保持 Running 不变。而如果这个 Pod 里有多个容器，仅有一个容器异常退出，它就始终保持 Running 状态，哪怕即使 restartPolicy=Never。只有当所有容器也异常退出之后，这个 Pod 才会进入 Failed 状态。至于其他情况，都可以以此类推出来。</p><h3 id="2-4、再看livenessProbe">2.4、再看livenessProbe</h3><p>现在，我们一起回到前面提到的 livenessProbe 上来。除了在容器中执行命令外，livenessProbe还可以被定义为发起 HTTP 或者 TCP 请求的方式，定义格式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># HTTP</span><br><span class="hljs-string">...</span><br><span class="hljs-attr">livenessProbe:</span><br>     <span class="hljs-attr">httpGet:</span><br>       <span class="hljs-attr">path:</span> <span class="hljs-string">/healthz</span><br>       <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>       <span class="hljs-attr">httpHeaders:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">X-Custom-Header</span><br>         <span class="hljs-attr">value:</span> <span class="hljs-string">Awesome</span><br>       <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">3</span><br>       <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">3</span><br><br><span class="hljs-comment"># TCP</span><br>    <span class="hljs-string">...</span><br>    <span class="hljs-attr">livenessProbe:</span><br>      <span class="hljs-attr">tcpSocket:</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>      <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">15</span><br>      <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>所以，我们的 Pod 其实可以暴露一个健康检查 URL（比如 /healthz），或者直接让健康检查去检测应用的监听端口。这两种配置方法，在 Web 服务类的应用中非常常用。除此之外，在 Kubernetes 的 Pod 中，还有一个叫 readinessProbe 的字段。虽然它的用法与 livenessProbe 类似，但作用却大不一样。readinessProbe 检查结果的成功与否，决定这个 Pod 是不是能通过 Service 的方式访问到，而并不影响 Pod 的生命周期。</p><h2 id="三、-PodPreset">三、 PodPreset</h2><p>在讨论了这么多字段之后，想必我们对 Pod 对象的语义和描述能力，已经有了一个初步的感觉。此时，我们有没有产生这样一个想法：</p><blockquote><p>Pod 的字段这么多，我们又不可能全记住，Kubernetes 能不能自动给 Pod 填充某些字段呢？</p></blockquote><p>这个需求实际上非常实用。比如，开发人员只需要提交一个基本的、非常简单的 Pod YAML，Kubernetes 就可以自动给对应的 Pod 对象加上其他必要的信息，比如， labels、annotations、volumes 等等。而这些信息，可以是运维人员事先定义好的。这么一来，开发人员编写 Pod YAML 的门槛，就被大大降低了。所以，一个叫作 PodPreset（Pod 预设置）的功能就出现在了 v1.11 版本的 Kubernetes 中。举个例子，现在开发人员编写了如下一个 pod.yaml 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">website</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">website</span><br>    <span class="hljs-attr">role:</span> <span class="hljs-string">frontend</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">website</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>      <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>作为 Kubernetes 的初学者，肯定会眼前一亮：这不就是我最擅长编写的、最简单的 Pod 嘛。没错，这个 YAML 文件里的字段，想必我们现在闭着眼睛也能写出来。可是，如果运维人员看到了这个 Pod，他一定会连连摇头：这种 Pod 在生产环境里根本不能用啊！</p><p>所以，这个时候，运维人员就可以定义一个 PodPreset 对象。在这个对象中，凡是他想在开发人员编写的 Pod 里追加的字段，都可以预先定义好。比如这个 preset.yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">settings.k8s.io/v1alpha1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PodPreset</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">allow-database</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">role:</span> <span class="hljs-string">frontend</span><br>  <span class="hljs-attr">env:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">DB_PORT</span><br>      <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;6379&quot;</span><br>  <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/cache</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">cache-volume</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">cache-volume</span><br>      <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>在这个 PodPreset 的定义中，首先是一个 selector。这就意味着后面这些追加的定义，只会作用于 selector 所定义的、带有“role: frontend”标签的 Pod 对象，这就可以防止“误伤”。</p><p>然后，我们定义了一组 Pod 的 Spec 里的标准字段，以及对应的值。比如，env 里定义了 DB_PORT 这个环境变量，volumeMounts 定义了容器 Volume 的挂载目录，volumes 定义了一个 emptyDir 类型的 Volume。</p><p>接下来，我们假定运维人员先创建了这个 PodPreset，然后开发人员才创建 Pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f preset.yaml</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f pod.yaml</span><br></code></pre></td></tr></table></figure><p>这时，Pod 运行起来之后，我们查看一下这个 Pod 的 API 对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pod website -o yaml</span><br>apiVersion: v1<br>kind: Pod<br>metadata:<br>  name: website<br>  labels:<br>    app: website<br>    role: frontend<br>  annotations:<br>    podpreset.admission.kubernetes.io/podpreset-allow-database: &quot;resource version&quot;<br>spec:<br>  containers:<br>    - name: website<br>      image: nginx<br>      volumeMounts:<br>        - mountPath: /cache<br>          name: cache-volume<br>      ports:<br>        - containerPort: 80<br>      env:<br>        - name: DB_PORT<br>          value: &quot;6379&quot;<br>  volumes:<br>    - name: cache-volume<br>      emptyDir: &#123;&#125;<br></code></pre></td></tr></table></figure><p>这个时候，我们就可以清楚地看到，这个 Pod 里多了新添加的 labels、env、volumes 和 volumeMount 的定义，它们的配置跟 PodPreset 的内容一样。此外，这个 Pod 还被自动加上了一个 annotation 表示这个 Pod 对象被 PodPreset 改动过。</p><p>需要说明的是，PodPreset 里定义的内容，只会在 Pod API 对象被创建之前追加在这个对象本身上，而不会影响任何 Pod 的控制器定义。比如，我们现在提交的是一个 nginx-deployment，那么这个 Deployment 对象本身是永远不会被 PodPreset 改变的，被修改的只是这个 Deployment 创建出来的所有 Pod。这一点请务必区分清楚。</p><p>这里有一个问题：如果我们定义了同时作用于一个 Pod 对象的多个 PodPreset，会发生什么呢？</p><p>实际上，Kubernetes 项目会帮我们合并（Merge）这些 PodPreset 要做的修改。而如果它们要做的修改有冲突的话，这些冲突字段就不会被修改。</p><h2 id="四、小结">四、小结</h2><p>在这篇文章中，我们主要讨论了Pod对象更高阶的使用方法，内容如下：</p><ul><li>Projected Volume，用于为容器提供预先设定好的数据。比如，Secret保存的是加密数据；ConfigMap保存的是配置文件，Downward API保存的是Pod本身的信息；ServiceAccountToken保存的是ServiceAccount对象的授权信息。</li><li>Kubernetes支持对容器进行两种类型的健康检查：livenessProbe和readinessProbe。其中，livenessProbe的检查结果用于确定容器运行是否正常（默认情况下，以容器进程的返回值为依据），readinessProbe的检查结果用于确定Pod能否通过Service的方式被访问到。</li><li>当容器运行异常时，Kubernetes就会按照restartPolicy所设置的恢复策略对容器进行相应的处理。restartPolicy的默认值为Always即只要容器不是运行状态就重启容器，当然，我们还可以将其设置OnFailure即在容器异常时才重启容器或者Never即永远不重启容器。</li><li>Pod的状态与Pod中所有容器的运行状态密切相关。READY字段表示Pod中正常运行的容器数量；STATUS字段表示Pod当前的状态；RESTARTS字段表示重启Pod的次数。</li><li>通过PodPreset对象，我们可以在Pod对象的配置文件中追加一些预先定义的字段。比如，可以将一些固定不变的字段定义成一个PodPreset对象，这样在之后描述Pod对象时我们只需填写Pod的“个性”字段就可以了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入解析Pod对象2：基本概念</title>
    <link href="/2020/10/02/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Pod%E5%AF%B9%E8%B1%A12%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2020/10/02/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Pod%E5%AF%B9%E8%B1%A12%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们详细讨论了Pod的实现原理和容器设计模式。接下来，我们来看看有关Pod对象的更多细节。</p><h2 id="一、Pod-VS-虚拟机">一、Pod VS 虚拟机</h2><p>在 Kubernetes 项目中，最小的编排单位是Pod。将这个设计落实到 API 对象上后，容器（Container）就成了 Pod 属性里的一个普通的字段。此时，一个很自然的问题就是：</p><blockquote><p>到底哪些字段属于 Pod 对象，而又有哪些字段属于 Container ？</p></blockquote><p>要彻底理解这个问题，我们就一定要牢记这样一个结论：Pod 扮演的是传统部署环境里“虚拟机”的角色。这样的设计，是为了使用户从传统环境（虚拟机环境）向 Kubernetes（容器环境）的迁移，更加平滑。</p><p>如果我们能把 Pod 看成传统环境里的“机器”、把容器看作是运行在这个“机器”里的“用户程序”，那么很多关于 Pod 对象的设计就非常容易理解了。比如，凡是调度、网络、存储，以及安全相关的属性，基本上是 Pod 级别的。这些属性的共同特征是，它们描述的是“机器”这个整体，而不是里面运行的“程序”。比如：</p><ul><li>配置这个“机器”的网卡（即：Pod 的网络定义），</li><li>配置这个“机器”的磁盘（即：Pod 的存储定义），</li><li>配置这个“机器”的防火墙（即：Pod 的安全定义），</li><li>这台“机器”运行在哪个服务器之上（即：Pod 的调度）。</li></ul><h2 id="二、Pod级的重要字段">二、Pod级的重要字段</h2><p>下面，我们一起来讨论一下Pod 中几个重要字段的含义和用法。</p><h3 id="2-1、NodeSelector">2.1、NodeSelector</h3><p>NodeSelector：是一个供用户将 Pod 与 Node 进行绑定的字段，用法如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-string">...</span><br><span class="hljs-attr">spec:</span><br> <span class="hljs-attr">nodeSelector:</span><br>   <span class="hljs-attr">disktype:</span> <span class="hljs-string">ssd</span><br></code></pre></td></tr></table></figure><p>这样的一个配置，意味着这个 Pod 永远只能运行在携带了“disktype: ssd”标签（Label）的节点上；否则，它将调度失败。</p><h3 id="2-2、NodeName">2.2、NodeName</h3><p>NodeName：一旦 Pod 的这个字段被赋值，Kubernetes 项目就会认为这个 Pod 已经被调度过了，调度的结果就是赋值的节点名字。所以，这个字段一般由调度器负责设置，但我们可以通过设置它来“骗过”调度器，当然这个做法一般是在测试或者调试的时候才会用到。其用法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-string">...</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">nodeName:</span> <span class="hljs-string">node1</span><br></code></pre></td></tr></table></figure><p>在这里，我们指定将Pod调度到node1上。</p><h3 id="2-3、HostAliases">2.3、HostAliases</h3><p>HostAliases：定义了 Pod 的 hosts 文件（比如 /etc/hosts）里的内容，用法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-string">...</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">hostAliases:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-string">&quot;10.1.2.3&quot;</span><br>    <span class="hljs-attr">hostnames:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;foo.remote&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;bar.remote&quot;</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>在这个 Pod 的 YAML 文件中，我们设置了一组 IP 和 hostname 数据。这样，这个 Pod 启动后，/etc/hosts 文件的内容将如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/hosts<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Kubernetes-managed hosts file.</span><br>127.0.0.1 localhost<br>...<br>10.244.135.10 hostaliases-pod<br>10.1.2.3 foo.remote<br>10.1.2.3 bar.remote<br></code></pre></td></tr></table></figure><p>其中，最下面的两行记录，就是我们通过 HostAliases 字段为 Pod 设置的。需要指出的是，在 Kubernetes 项目中，如果要设置 hosts 文件里的内容，一定要通过这种方法。否则，如果直接修改 hosts 文件，在 Pod 被删除重建之后，kubelet 会自动覆盖掉被修改的内容。</p><h3 id="2-4、与Namespace相关的字段">2.4、与Namespace相关的字段</h3><p>除了上述跟“机器”相关的配置外，我们可能也会发现，凡是跟容器的 Linux Namespace 相关的属性，也一定是 Pod 级别的。这个原因也很容易理解：Pod 的设计，就是要让它里面的容器尽可能多地共享 Linux Namespace，仅保留必要的隔离和限制能力。这样，Pod 模拟出的效果，就跟虚拟机里程序间的关系非常类似了。</p><p>举个例子，在下面这个 Pod 的 YAML 文件中，我们定义了 shareProcessNamespace=true：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">shareProcessNamespace:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">shell</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">stdin:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">tty:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>这就意味着这个 Pod 里的容器要共享 PID Namespace。而在这个 YAML 文件中，我们还定义了两个容器：一个是 nginx 容器，一个是开启了 tty 和 stdin 的 shell 容器。当这个 Pod 被创建后，我们就可以使用 shell 容器的 tty 跟这个容器进行交互了。我们一起实践一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f nginx.yaml</span><br></code></pre></td></tr></table></figure><p>接下来，我们使用 kubectl attach 命令，连接到 shell 容器的 tty 上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl attach -it nginx -c shell</span><br></code></pre></td></tr></table></figure><p>这样，我们就可以在 shell 容器里执行 ps 指令，查看所有正在运行的进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl attach -it nginx -c shell</span><br>/ # ps ax<br>PID   USER     TIME  COMMAND<br>    1 root      0:00 /pause<br>    8 root      0:00 nginx: master process nginx -g daemon off;<br>   14 101       0:00 nginx: worker process<br>   15 root      0:00 sh<br>   21 root      0:00 ps ax<br></code></pre></td></tr></table></figure><p>可以看到，在这个容器里，我们不仅可以看到它本身的 ps ax 指令，还可以看到 nginx 容器的进程，以及 Infra 容器的 /pause 进程。这就意味着，这个 Pod 里的每个容器中的进程，对于所有容器来说都是可见的，因为它们共享了同一个 PID Namespace。</p><p>类似地，凡是 Pod 中的容器要共享宿主机的 Namespace，也一定是 Pod 级别的定义，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">hostIPC:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">hostPID:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">shell</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">stdin:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">tty:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>在这个 Pod 中，我定义了共享宿主机的 Network、IPC 和 PID Namespace。这就意味着，这个 Pod 里的所有容器，会直接使用宿主机的网络、直接与宿主机进行 IPC 通信、看到宿主机里正在运行的所有进程。</p><h2 id="三、Container级的重要字段">三、Container级的重要字段</h2><p>除了上面这些属性外，Pod 里最重要的字段当属“Containers”了。而在之前的文章中，我们还介绍过“Init Containers”。其实，这两个字段都属于 Pod 对容器的定义，内容也完全相同，只是 Init Containers 的生命周期，会先于所有的 Containers，并且严格按照定义的顺序执行。</p><p>在Kubernetes 项目中对 Container 的定义，和 Docker 相比并没有什么太大区别。容器技术中的概念，比如，Image（镜像）、Command（启动命令）、workingDir（容器的工作目录）、Ports（容器要开放的端口），以及 volumeMounts（容器要挂载的 Volume）都是构成 Kubernetes 项目中 Container 的主要字段。不过在这里，还有这么几个属性值得我们额外关注。</p><h3 id="3-1、ImagePullPolicy">3.1、ImagePullPolicy</h3><p>首先，是 ImagePullPolicy 字段。它定义了镜像拉取策略。而它之所以是一个 Container 级别的属性，是因为容器镜像本来就是 Container 定义中的一部分。</p><p>ImagePullPolicy 的值默认是 Always，即每次创建 Pod 都重新拉取一次镜像。另外，当容器的镜像是类似于 nginx 或者 nginx:latest 这样的名字时，ImagePullPolicy 也会被认为是Always。而如果它的值被定义为 Never 或者 IfNotPresent，就意味着 Pod 永远不会主动拉取这个镜像，或者只在宿主机上不存在这个镜像时才拉取。</p><h3 id="3-2、Lifecycle">3.2、Lifecycle</h3><p>其次，是 Lifecycle 字段。它定义的是 Container Lifecycle Hooks。顾名思义，它是在容器状态发生变化时触发的一系列“钩子”。我们来看这样一个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">lifecycle-demo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">lifecycle-demo-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">lifecycle:</span><br>      <span class="hljs-attr">postStart:</span><br>        <span class="hljs-attr">exec:</span><br>          <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo Hello from the postStart handler &gt; /usr/share/message&quot;</span>]<br>      <span class="hljs-attr">preStop:</span><br>        <span class="hljs-attr">exec:</span><br>          <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/usr/sbin/nginx&quot;</span>,<span class="hljs-string">&quot;-s&quot;</span>,<span class="hljs-string">&quot;quit&quot;</span>]<br></code></pre></td></tr></table></figure><p>这是一个来自与 Kubernetes 官方文档中的 Pod YAML 文件。它其实非常简单，只是定义了一个 nginx 镜像的容器。不过，在这个 YAML 文件的容器（Containers）部分，我们可以看到这个容器分别设置了一个 postStart 和 preStop 参数。这是什么意思呢？</p><ul><li><p>先说 postStart 吧。它指的是，在容器启动后，立刻执行一个指定的操作。需要注意的是，postStart 定义的操作，虽然是在容器 ENTRYPOINT 执行之后，但它并不严格保证顺序。也就是说，在 postStart 启动时，ENTRYPOINT 有可能还没有结束。当然，如果 postStart 执行超时或者错误，会导致 Pod 也处于失败的状态，同时 Kubernetes 会在该 Pod 的 Events 中报出该容器启动失败的错误信息。</p></li><li><p>而类似地，preStop 发生的时机，则是容器被杀死之前（比如，收到了 SIGKILL 信号）。但需要注意的是，preStop 操作的执行，是同步的。即，它会阻塞当前容器的杀死流程，直到这个 Hook 定义操作完成之后，才允许容器被杀死，这跟 postStart 完全不一样。</p></li></ul><p>所以，在这个例子中，我们在容器成功启动之后，在 /usr/share/message 里写入了一句“欢迎信息”（即 postStart 定义的操作）。而在这个容器被删除之前，我们则先调用了 nginx 的退出指令（即 preStop 定义的操作），从而实现了容器的“优雅退出”。</p><h2 id="四、Pod的生命周期">四、Pod的生命周期</h2><p>在熟悉了 Pod 以及它的 Container 部分的主要字段之后，我们在来看一下Pod 对象在 Kubernetes 中的生命周期。</p><p>Pod 生命周期的变化，主要体现在 Pod API 对象的 Status 部分，这是它除了 Metadata 和 Spec 之外的第三个重要字段。其中，pod.status.phase，就是 Pod 的当前状态，它有如下几种可能的情况：</p><ul><li>Pending。这个状态意味着，Pod的YAML文件已经提交给了kubernetes，API对象已经被创建并保存在Etcd中。但是，这个Pod里有些容器因为某种原因而不能被顺利创建。比如，调度不成功。</li><li>Running。这个状态下，Pod已经调度成功，并跟一个具体的节点绑定。它所包含的容器都已经创建成功，并且至少有一个正在运行中。</li><li>Succeeded。这个状态意味着，Pod里有所有容器都正常运行完毕，并且已经退出了。这种情况在运行一次性任务时最为常见。</li><li>Failed。这个状态下，Pod里至少有一个容器以不正常的状态（非0的返回码）退出。这个状态的出现，意味着我们得想办法Debug这个Pod中的容器，比如查看Pod的Events和日志。</li><li>Unknown。这是一个异常状态，意味着Pod的状态不能持续地被kubelet汇报给kube-apiserver，这很有可能是主从节点（Master和Kubelet）间的通信出现了问题。</li></ul><p>更进一步地，Pod 对象的 Status 字段，还可以再细分出一组 Conditions。这些细分状态的值包括：PodScheduled、Ready、Initialized，以及 Unschedulable。它们主要用于描述造成当前 Status 的具体原因是什么。比如，Pod 当前的 Status 是 Pending，对应的 Condition 是 Unschedulable，这就意味着它的调度出现了问题。而其中，Ready 这个细分状态非常值得我们关注：它意味着 Pod 不仅已经正常启动（Running 状态），而且已经可以对外提供服务（Ready状态）了。这两者之间（Running 和 Ready）是有区别的。</p><p>Pod 的这些状态信息，是我们判断应用运行情况的重要标准，尤其是 Pod 进入了非“Running”状态后，我们一定要能迅速做出反应，根据它所代表的异常情况开始跟踪和定位，而不是去手忙脚乱地查阅文档。</p><h2 id="五、小结">五、小结</h2><p>在这篇文章中，我们主要讨论了如下内容：</p><ul><li><p>在Kubernetes中，当我们描述一个应用时，可以把Pod看作虚拟机，把容器看作应用程序。因此，凡是与“机器”有关的字段（比如，调度、存储、网络等）都属于Pod级，凡是与“进程”相关的字段（比如，镜像、启动命令、工作目录等）都属于Container级。</p></li><li><p>Pod级的重要字段有NodeSelector、NodeName、HostAliases等</p></li><li><p>Container级的重要字段有ImagePullPolicy、Lifecycle等</p></li><li><p>在Kubernetes中，Pod对象是有生命周期的，每个Pod都有一个名为pod.status.phase的字段，它反映了Pod的当前状态，这个字段的值可能是：</p><ul><li>Pending：已经在etcd中创建了API对象，但Pod还未被成功调度。</li><li>Running：Pod已经调度成功，并与某个节点绑定。它所包含的容器都已经创建成功，并且至少有一个正在运行中。</li><li>Succeeded：一般出现在一次性任务中。表示Pod中的所有容器都已正常运行完毕，并且退出了。</li><li>Failed：Pod中至少有一个容器以不正常的状态（非0的返回码）退出。</li><li>Unknown：Pod的状态不能持续地被kubelet汇报给kube-apiserver。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入解析Pod对象1：我们为什么需要Pod</title>
    <link href="/2020/10/02/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Pod%E5%AF%B9%E8%B1%A11%EF%BC%9A%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Pod/"/>
    <url>/2020/10/02/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Pod%E5%AF%B9%E8%B1%A11%EF%BC%9A%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Pod/</url>
    
    <content type="html"><![CDATA[<p>接触过kubernetes的同学，对Pod这个概念一定不陌生。它是Kubernetes项目中最小的API对象。用更专业的术语来描述：Pod，是Kubernetes项目的原子调度单位。但我们是否思考过：我们为什么需要Pod？接下来，我们就来讨论一下这个问题。</p><h2 id="一、从进程组说起">一、从进程组说起</h2><p>首先，我们登录到一台 Linux 机器里，执行一条如下所示的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pstree -gt</span><br></code></pre></td></tr></table></figure><p>这条命令的作用，是展示当前系统中正在运行的进程的树状结构。它的返回结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemd(1)-+-accounts-daemon(1984)-+-&#123;gdbus&#125;(1984)<br>           | `-&#123;gmain&#125;(1984)<br>           |-acpid(2044)<br>          ...      <br>           |-lxcfs(1936)-+-&#123;lxcfs&#125;(1936)<br>           | `-&#123;lxcfs&#125;(1936)<br>           |-mdadm(2135)<br>           |-ntpd(2358)<br>           |-polkitd(2128)-+-&#123;gdbus&#125;(2128)<br>           | `-&#123;gmain&#125;(2128)<br>           |-rsyslogd(1632)-+-&#123;in:imklog&#125;(1632)<br>           |  |-&#123;in:imuxsock) S 1(1632)<br>           | `-&#123;rs:main Q:Reg&#125;(1632)<br>           |-snapd(1942)-+-&#123;snapd&#125;(1942)<br>           |  |-&#123;snapd&#125;(1942)<br>           |  |-&#123;snapd&#125;(1942)<br>           |  |-&#123;snapd&#125;(1942)<br>           |  |-&#123;snapd&#125;(1942)<br></code></pre></td></tr></table></figure><p>不难发现，在一个真正的操作系统里，进程并不是“孤零零”地独自运行，而是以进程组的方式，“有原则地”组织在一起。比如，这里有一个叫作 rsyslogd 的程序，它负责的是 Linux 操作系统里的日志处理。可以看到，rsyslogd 的主程序 main，和它要用到的内核日志模块 imklog 等，同属于 1632 进程组。这些进程相互协作，共同完成 rsyslogd 程序的职责。而 Kubernetes 项目所做的，其实就是将“进程组”的概念映射到了容器技术中。</p><p>Kubernetes 项目之所以要这么做的原因是：在 Borg 项目的开发和实践过程中，Google 公司的工程师们发现，他们部署的应用，往往都存在着类似于“进程和进程组”的关系。更具体地说，就是这些应用之间有着密切的协作关系，使得它们必须部署在同一台机器上。</p><p>如果事先没有“组”的概念，像这样的运维关系就会非常难以处理。我们还是以前面的 rsyslogd 为例子。已知 rsyslogd 由三个进程组成：一个 imklog 模块，一个 imuxsock 模块，一个 rsyslogd 自己的 main 函数主进程。这三个进程一定要运行在同一台机器上，否则，它们之间基于 Socket 的通信和文件交换，都会出现问题。</p><p>现在，我们要把 rsyslogd 这个应用给容器化，由于受限于容器的“单进程模型”，这三个模块必须被分别制作成三个不同的容器。而在这三个容器运行的时候，它们设置的内存配额都是 1 GB。</p><blockquote><p>我们需要注意的是，容器的“单进程模型”，并不是指容器里只能运行“一个”进程，而是指容器没有管理多个进程的能力。这是因为容器里PID=1的进程就是应用本身，其他的进程都是这个PID=1的进程的子进程。</p></blockquote><p>现假设我们的 Kubernetes 集群上有两个节点：node-1 上有 3 GB 可用内存，node-2 有 2.5 GB 可用内存。</p><p>这时，假设我要用 Docker Swarm 来运行这个 rsyslogd 程序。为了能够让这三个容器都运行在同一台机器上，我就必须在另外两个容器上设置一个 affinity=main（与 main 容器有亲密性）的约束，即：它们俩必须和 main 容器运行在同一台机器上。</p><p>然后，我顺序执行：“docker run main”“docker run imklog”和“docker run imuxsock”，创建这三个容器。这样，这三个容器都会进入 Swarm 的待调度队列。</p><p>然后，main 容器和 imklog 容器都先后出队并被调度到了 node-2 上（这个情况是完全有可能的）。可是，当 imuxsock 容器出队开始被调度时，Swarm 就有点懵了：node-2 上的可用资源只有 0.5 GB 了，并不足以运行 imuxsock 容器；可是，根据 affinity=main 的约束，imuxsock 容器又只能运行在 node-2 上。</p><p>这就是一个典型的成组调度（gang scheduling）没有被妥善处理的例子。</p><h2 id="二、如何处理“成组调度”">二、如何处理“成组调度”</h2><p>在工业界和学术界，关于这个问题的讨论可谓旷日持久，也产生了很多可供选择的解决方案。比如，Mesos 中就有一个资源囤积（resource hoarding）的机制，会在所有设置了 Affinity 约束的任务都达到时，才开始对它们统一进行调度。而在 Google Omega 论文中，则提出了使用乐观调度处理冲突的方法，即：先不管这些冲突，而是通过精心设计的回滚机制在出现了冲突之后解决问题。可是这些方法都谈不上完美。资源囤积带来了不可避免的调度效率损失和死锁的可能性；而乐观调度的复杂程度，则不是常规技术团队所能驾驭的。</p><p>但是，到了 Kubernetes 项目里，这样的问题就迎刃而解了：Pod 是 Kubernetes 里的原子调度单位。这就意味着，Kubernetes 项目的调度器，是统一按照 Pod 而非容器的资源需求进行计算的。所以，像 imklog、imuxsock 和 main 函数主进程这样的三个容器，正是一个典型的由三个容器组成的 Pod。Kubernetes 项目在调度时，自然就会去选择可用内存等于 3 GB 的 node-1 节点进行绑定，而根本不会考虑 node-2。</p><p>像这样容器间的紧密协作，我们可以称为”超亲密关系“。这些具有”超亲密关系“容器的典型特征包括但不限于：互相之间会发生直接的文件交换、使用localhost或者Socket文件进行本地通信、会发生非常频繁的远程调用、需要共享某些Linux Namespace（比如，一个容器要加入另一个容器的Network Namepsace）等。这也就意味着，并不是所有有“关系”的容器都属于同一个 Pod。比如，PHP 应用容器和 MySQL 虽然会发生访问关系，但并没有必要、也不应该部署在同一台机器上，它们更适合做成两个 Pod。</p><p>不过，此时我们可能会有这样疑问：对于一个初学者来说，一般都是先学会了用Docker这种单容器的工具，才会开始接触Pod。而如果 Pod 的设计只是出于调度上的考虑，那么 Kubernetes 项目似乎完全没有必要非得把 Pod 作为“一等公民”吧？这不是故意增加用户的学习门槛吗？没错，如果只是处理“超亲密关系”这样的调度问题，有 Borg 和 Omega 论文珠玉在前，Kubernetes 项目肯定可以在调度器层面给它解决掉。不过，Pod 在 Kubernetes 项目里还有更重要的意义，那就是：容器设计模式。</p><p>为了理解这一层含义，我们就必须先了解一下Pod 的实现原理。</p><h2 id="三、Pod的实现原理">三、Pod的实现原理</h2><p>首先，关于 Pod 最重要的一个事实是：它只是一个逻辑概念。也就是说，Kubernetes 真正处理的，还是宿主机操作系统上 Linux 容器的 Namespace 和 Cgroups，并不存在一个所谓的 Pod 边界或者隔离环境。</p><blockquote><p>那么，Pod 又是怎么被“创建”出来的呢？</p></blockquote><p>答案是：Pod，其实是一组共享了某些资源的容器。具体来说，Pod 里的所有容器，共享的是同一个 Network Namespace，并且可以声明共享同一个 Volume。</p><p>这么来看的话，一个有 A、B 两个容器的 Pod，不就是等同于一个容器（容器 A）共享另外一个容器（容器 B）的网络和 Volume 的玩儿法么？这好像通过 docker run --net --volumes-from 这样的命令就能实现嘛，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --net=B --volumes-from=B --name=A image-A ...</span><br></code></pre></td></tr></table></figure><p>但是，我们有没有考虑过，如果真这样做的话，容器 B 就必须比容器 A 先启动，这样一个 Pod 里的多个容器就不是对等关系，而是拓扑关系了。</p><p>所以，在 Kubernetes 项目里，Pod 的实现需要使用一个中间容器，这个容器叫作 Infra 容器。在这个 Pod 中，Infra 容器永远都是第一个被创建的容器，而其他用户定义的容器，则通过 Join Network Namespace 的方式，与 Infra 容器关联在一起。这样的组织关系，可以用下面这样一个示意图来表达：</p><p><img src="/img/image-20201002093427616.png" alt="image-20201002093427616"></p><p>如上图所示，这个 Pod 里有两个用户容器 A 和 B，还有一个 Infra 容器。很容易理解，在 Kubernetes 项目里，Infra 容器一定要占用极少的资源，所以它使用的是一个非常特殊的镜像，叫作：<a href="http://k8s.gcr.io/pause%E3%80%82%E8%BF%99%E4%B8%AA%E9%95%9C%E5%83%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E7%9A%84%E3%80%81%E6%B0%B8%E8%BF%9C%E5%A4%84%E4%BA%8E%E2%80%9C%E6%9A%82%E5%81%9C%E2%80%9D%E7%8A%B6%E6%80%81%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%8C%E8%A7%A3%E5%8E%8B%E5%90%8E%E7%9A%84%E5%A4%A7%E5%B0%8F%E4%B9%9F%E5%8F%AA%E6%9C%89">k8s.gcr.io/pause。这个镜像是一个用汇编语言编写的、永远处于“暂停”状态的容器，解压后的大小也只有</a> 100~200 KB 左右。而在 Infra 容器“Hold 住”Network Namespace 后，用户容器就可以加入到 Infra 容器的 Network Namespace 当中了。</p><p>所以，如果我们查看这些容器在宿主机上的 Namespace 文件，它们指向的值一定是完全一样的。这也就意味着，对于 Pod 里的容器 A 和容器 B 来说：</p><ul><li>它们可以直接使用localhost进行通信；</li><li>它们看到的网络设备跟Infra容器看到的完全一样；</li><li>它们使用同一个IP地址，也就是这个Pod的Network Namespace对应的IP地址；当然，其他的所有网络资源，都是一个Pod一份，并且被该Pod中的所有容器共享；</li><li>Pod的生命周期只跟Infra容器一致，而与容器A和B无关</li></ul><p>对于同一个 Pod 里面的所有用户容器来说，它们的进出流量，也可以认为都是通过 Infra 容器完成的。这一点很重要，因为将来如果我们要为 Kubernetes 开发一个网络插件时，应该重点考虑的是如何配置这个 Pod 的 Network Namespace，而不是每一个用户容器如何使用我们的网络配置，这是没有意义的。</p><p>这就意味着，如果我们的网络插件需要在容器里安装某些包或者进行一些配置才能完成的话，是不可取的：Infra 容器镜像的 rootfs 里几乎什么都没有，没有随意发挥的空间。当然，这同时也意味着我们的网络插件完全不必关心用户容器的启动与否，而只需要关注如何配置 Pod，也就是 Infra 容器的 Network Namespace 即可。</p><p>有了这个设计之后，共享 Volume 就简单多了：Kubernetes 项目只要把所有 Volume 的定义都设计在 Pod 层级即可。这样，一个 Volume 对应的宿主机目录对于 Pod 来说就只有一个，Pod 里的容器只要声明挂载这个 Volume，就一定可以共享这个 Volume 对应的宿主机目录。比如下面这个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">two-containers</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">shared-data</span><br>    <span class="hljs-attr">hostPath:</span>      <br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/data</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">shared-data</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">debian-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">debian</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">shared-data</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/pod-data</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/sh&quot;</span>]<br>    <span class="hljs-attr">args:</span> [<span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo Hello from the debian container &gt; /pod-data/index.html&quot;</span>]<br></code></pre></td></tr></table></figure><p>在这个例子中，debian-container 和 nginx-container 都声明挂载了 shared-data 这个 Volume。而 shared-data 是 hostPath 类型。所以，它对应在宿主机上的目录就是：/data。而这个目录，其实就被同时绑定挂载进了上述两个容器当中。这就是为什么，nginx-container 可以从它的 /usr/share/nginx/html 目录中，读取到 debian-container 生成的 index.html 文件的原因。</p><h2 id="四、理解sidecar设计模式">四、理解sidecar设计模式</h2><p>Pod 这种“超亲密关系”容器的设计思想，实际上就是希望，当用户想在一个容器里跑多个功能并不相关的应用时，应该优先考虑它们是不是更应该被描述成一个 Pod 里的多个容器。</p><p>为了能够掌握这种思考方式，我们应该尽量尝试使用它来描述一些用单个容器难以解决的问题。下面我们来看两例子：</p><h3 id="4-1、示例1：WAR包-Web服务器">4.1、示例1：WAR包 &amp; Web服务器</h3><p>第一个最典型的例子是：WAR 包与 Web 服务器。假设，我们现在有一个 Java Web 应用的 WAR 包，它需要被放在 Tomcat 的 webapps 目录下运行起来。此时，该如何实现呢？</p><ul><li><p>一种方法是，把 WAR 包直接放在 Tomcat 镜像的 webapps 目录下，做成一个新的镜像运行起来。可是，这时候，如果我们要更新 WAR 包的内容，或者要升级 Tomcat 镜像，就要重新制作一个新的镜像，这样非常麻烦。</p></li><li><p>另一种方法是，我们压根儿不管 WAR 包，永远只发布一个 Tomcat 容器。不过，这个容器的 webapps 目录，就必须声明一个 hostPath 类型的 Volume，从而把宿主机上的 WAR 包挂载进 Tomcat 容器当中。不过，这样我们就必须要解决一个问题，即：如何让每一台宿主机，都预先准备好这个存储有 WAR 包的目录呢？这样来看，我们只能独立维护一套分布式存储系统了。</p></li></ul><p>实际上，有了 Pod 之后，这样的问题就很容易解决了。我们可以把 WAR 包和 Tomcat 分别做成镜像，然后把它们作为一个 Pod 里的两个容器“组合”在一起。这个 Pod 的配置文件如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">javaweb-2</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">app-volume</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br>  <span class="hljs-attr">initContainers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">geektime/sample:v2</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">war</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;cp&quot;</span>, <span class="hljs-string">&quot;/sample.war&quot;</span>, <span class="hljs-string">&quot;/app&quot;</span>]<br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/app</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">app-volume</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">geektime/tomcat:7.0</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">tomcat</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;/root/apache-tomcat-7.0.42-v2/bin/start.sh&quot;</span>]<br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/root/apache-tomcat-7.0.42-v2/webapps</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">app-volume</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br>      <span class="hljs-attr">hostPort:</span> <span class="hljs-number">8001</span> <br></code></pre></td></tr></table></figure><p>在这个 Pod 中，我们定义了两个容器，第一个容器使用的镜像是 geektime/sample:v2，这个镜像里只有一个 WAR 包（sample.war）放在根目录下。而第二个容器则使用的是一个标准的 Tomcat 镜像。</p><p>不过，我们可能已经注意到，WAR 包容器的类型不再是一个普通容器，而是一个 Init Container 类型的容器。在 Pod 中，所有 Init Container 定义的容器，都会比 containers 定义的用户容器先启动。并且，Init Container 容器会按顺序逐一启动，直到它们都启动并且退出了， containers 定义的用户容器才会启动。</p><p>所以，这个 Init Container 类型的 WAR 包容器启动后，我们执行了一句&quot;cp /sample.war /app&quot;，把应用的 WAR 包拷贝到 /app 目录下，然后退出。而后这个 /app 目录，就挂载了一个名叫 app-volume 的 Volume。此外，Tomcat 容器，同样声明了挂载 app-volume 到自己的 webapps 目录下。所以，等 Tomcat 容器启动时，它的 webapps 目录下就一定会存在 sample.war 文件，而这个文件正是 WAR 包容器启动时拷贝到这个 Volume 里面的，而这个 Volume 是被这两个容器共享的。</p><p>像这样，我们就用一种“组合”方式，解决了 WAR 包与 Tomcat 容器之间耦合关系的问题。实际上，这个所谓的“组合”操作，正是容器设计模式里最常用的一种模式，它的名字叫：sidecar。顾名思义，sidecar 指的就是我们可以在一个 Pod 中，启动一个辅助容器，来完成一些独立于主进程（主容器）之外的工作。比如，在上面的这个Pod 中，Tomcat 容器是我们要使用的主容器，而 WAR 包容器的存在，只是为了给它提供一个 WAR 包而已。所以，我们用 Init Container 的方式优先运行 WAR 包容器，扮演了一个 sidecar 的角色。</p><h3 id="4-2、示例2：容器的日志收集">4.2、示例2：容器的日志收集</h3><p>第二个例子，则是容器的日志收集。比如，我们现在有一个应用，需要不断地把日志文件输出到容器的 /var/log 目录中。</p><p>这时，我就可以把 Pod 里的一个 Volume 挂载到应用容器的 /var/log 目录上。然后，我们在这个 Pod 里同时运行一个 sidecar 容器，它也声明挂载同一个 Volume 到自己的 /var/log 目录上。接下来 sidecar 容器就只需要做一件事儿，那就是不断地从自己的 /var/log 目录里读取日志文件，转发到 MongoDB 或者 Elasticsearch 中存储起来。这样，一个最基本的日志收集工作就完成了。</p><p>跟第一个例子一样，这个例子中的 sidecar 的主要工作也是使用共享的 Volume 来完成对文件的操作。</p><p>此外，不要忘记Pod 的另一个重要特性是，它的所有容器都共享同一个 Network Namespace。这就使得很多与 Pod 网络相关的配置和管理，也都可以交给 sidecar 完成，而完全无须干涉用户容器。这里最典型的例子莫过于 Istio 这个微服务治理项目了。</p><h2 id="五、小结">五、小结</h2><p>在这篇文章中，我们主要讨论了如下内容：</p><ul><li>容器实际上是一种单进程模型，但操作系统中的进程往往不是“孤零零”地独自运行，而是以进程组的方式有原则的组织在一起。</li><li>Pod不仅是一种处理“超亲密关系（成组）”调度问题的解决方案，而且是一种容器设计模式。sidecar就是一种典型容器设计模式。它的主要应用场景是，容器环境的初始化（比如，配置网络、准备WAF包等）；容器日志的收集等。</li><li>Pod就是一组共享了某些资源的容器。每个Pod中都存在一个Infra容器，所有的用户容器都共享Infra容器的资源。比如，同一个Pod中的所有容器都共享了Infra容器的 Network Namespace。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器基础4：重新认识Docker</title>
    <link href="/2020/10/02/%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%804%EF%BC%9A%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86Docker/"/>
    <url>/2020/10/02/%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%804%EF%BC%9A%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86Docker/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们围绕“Namespace做隔离、Cgroups做限制、Rootfs做文件系统”对Linux容器的核心实现原理展开了详细的讨论。接下来，我们通过一个实际案例对前面的内容做一次深入的总结和扩展。</p><h2 id="一、从一个Python应用说起">一、从一个Python应用说起</h2><p>在开始实践之前，我们需要准备一台 Linux 机器，并安装 Docker。这个流程可以参考<a href="https://docs.docker.com/engine/install/">Docker官网</a>，就不在此赘述了。</p><p>这一次，我们用 Docker 部署一个用 Python 编写的 Web 应用。这个应用的代码部分（<a href="http://app.py">app.py</a>）非常简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> os<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():<br>    html = <span class="hljs-string">&quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot;</span> \<br>           <span class="hljs-string">&quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot;</span>           <br>    <span class="hljs-keyword">return</span> html.<span class="hljs-built_in">format</span>(name=os.getenv(<span class="hljs-string">&quot;NAME&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>), hostname=socket.gethostname())<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app.run(host=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, port=<span class="hljs-number">80</span>)<br></code></pre></td></tr></table></figure><p>在这段代码中，我们使用 Flask 框架启动了一个 Web 服务器，而它唯一的功能是：如果当前环境中有“NAME”这个环境变量，就把它打印在“Hello”之后，否则就打印“Hello world”，最后再打印出当前环境的 hostname。</p><p>这个应用的依赖，则被定义在了同目录下的 requirements.txt 文件里，内容如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> requirements.txt</span><br>Flask<br></code></pre></td></tr></table></figure><p>而将这样一个应用容器化的第一步，是制作容器镜像。</p><h2 id="二、Dockerfile">二、Dockerfile</h2><p>相较于我们之前介绍的制作 rootfs 的过程，Docker 为我们提供了一种更便捷的方式，叫作 Dockerfile，如下所示。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 使用官方提供的Python开发镜像作为基础镜像</span><br><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">2.7</span>-slim<br><br><span class="hljs-comment"># 将工作目录切换为/app</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-comment"># 将当前目录下的所有内容复制到/app下</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> . /app</span><br><br><span class="hljs-comment"># 使用pip命令安装这个应用所需要的依赖</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install --trusted-host pypi.python.org -r requirements.txt</span><br><br><span class="hljs-comment"># 允许外界访问容器的80端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br><br><span class="hljs-comment"># 设置环境变量</span><br><span class="hljs-keyword">ENV</span> NAME World<br><br><span class="hljs-comment"># 设置容器进程为：python app.py，即：这个Python应用的启动命令</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;app.py&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>通过这个文件的内容，我们可以看到 Dockerfile 的设计思想，是使用一些标准的原语（即大写高亮的词语），描述我们所要构建的 Docker 镜像。并且这些原语，都是按顺序处理的。</p><p>比如 FROM 原语，指定了“python:2.7-slim”这个官方维护的基础镜像，从而免去了安装 Python 等语言环境的操作。否则，这一段我们就得这么写了：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:latest<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update -yRUN apt-get install -y python-pip python-dev build-essential</span><br>...<br></code></pre></td></tr></table></figure><p>其中，RUN 原语就是在容器里执行 shell 命令的意思。</p><p>而 WORKDIR，意思是在这一句之后，Dockerfile 后面的操作都以这一句指定的 /app 目录作为当前目录。</p><p>最后的 CMD，意思是 Dockerfile 指定 python <a href="http://app.py">app.py</a> 为这个容器的进程。这里，<a href="http://app.py">app.py</a> 的实际路径是 /app/app.py。所以，CMD [“python”, “<a href="http://app.py">app.py</a>”]等价于&quot;docker run &lt;image&gt; python <a href="http://app.py">app.py</a>&quot;。</p><p>另外，在使用 Dockerfile 时，我们可能还会看到一个叫作 ENTRYPOINT 的原语。实际上，它和 CMD 都是 Docker 容器进程启动所必需的参数，完整执行格式是：“ENTRYPOINT CMD”。</p><p>但是，默认情况下，Docker 会为我们提供一个隐含的 ENTRYPOINT，即：/bin/sh -c。所以，在不指定 ENTRYPOINT 时，比如在我们这个例子里，实际上运行在容器里的完整进程是：/bin/sh -c “python <a href="http://app.py">app.py</a>”，即 CMD 的内容就是 ENTRYPOINT 的参数。备注：基于以上原因，我们后面会统一称 Docker 容器的启动进程为 ENTRYPOINT，而不是 CMD。</p><p>需要注意的是，Dockerfile 里的原语并不都是指对容器内部的操作。就比如 ADD，它指的是把当前目录（即 Dockerfile 所在的目录）里的文件，复制到指定容器内的目录当中。</p><p>读懂这个 Dockerfile 之后，我们再把上述内容，保存到当前目录下一个名叫“Dockerfile”的文件中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span></span><br>Dockerfile  app.py   requirements.txt<br></code></pre></td></tr></table></figure><h2 id="三、docker-build">三、docker build</h2><p>接下来，我就可以让 Docker 制作这个镜像了，在当前目录执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t helloworld .<br></code></pre></td></tr></table></figure><p>其中，-t 的作用是给这个镜像加一个 Tag，即：起一个好听的名字。docker build 会自动加载当前目录下的 Dockerfile 文件，然后按照顺序，执行文件中的原语。而这个过程，实际上可以等同于 Docker 使用基础镜像启动了一个容器，然后在容器中依次执行 Dockerfile 中的原语。</p><p>需要注意的是，Dockerfile 中的每个原语执行后，都会生成一个对应的镜像层。即使原语本身并没有明显地修改文件的操作（比如，ENV 原语），它对应的层也会存在。只不过在外界看来，这个层是空的。</p><h2 id="四、docker-images">四、docker images</h2><p>docker build 操作完成后，我可以通过 docker images 命令查看结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker image <span class="hljs-built_in">ls</span></span><br><br>REPOSITORY            TAG                 IMAGE ID<br>helloworld         latest              653287cdf998<br></code></pre></td></tr></table></figure><p>通过这个镜像 ID，我们就可以使用之前讲过的方法，查看这些新增的层在 AuFS 路径下对应的文件和目录了。</p><h2 id="五、docker-run">五、docker run</h2><p>接下来，我们使用这个镜像，通过 docker run 命令启动容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -p 4000:80 helloworld<br></code></pre></td></tr></table></figure><p>在这一句命令中，镜像名 helloworld 后面，我们什么都不用写，因为在 Dockerfile 中已经指定了 CMD。否则，我就得把进程的启动命令加在后面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -p 4000:80 helloworld python app.py</span><br></code></pre></td></tr></table></figure><h2 id="六、docker-ps">六、docker ps</h2><p>容器启动之后，我可以使用 docker ps 命令看到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps</span><br>CONTAINER ID        IMAGE               COMMAND             CREATED<br>4ddf4638572d        helloworld       &quot;python app.py&quot;     10 seconds ago<br></code></pre></td></tr></table></figure><p>同时，我们已经通过 -p 4000:80 告诉了 Docker，请把容器内的 80 端口映射在宿主机的 4000 端口上。这样做的目的是，只要访问宿主机的 4000 端口，我们就可以看到容器里应用返回的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl http://localhost:4000</span><br>&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; 4ddf4638572d&lt;br/&gt;<br></code></pre></td></tr></table></figure><p>否则，我们就得先用 docker inspect 命令查看容器的 IP 地址，然后访问“http://&lt; 容器 IP 地址 &gt;:80”才可以看到容器内应用的返回。</p><h2 id="七、docker-tag">七、docker tag</h2><p>至此，我们已经使用容器完成了一个应用的开发与测试，如果现在想要把这个容器的镜像上传到 DockerHub 上分享给更多的人，我要怎么做呢？</p><p>为了能够上传镜像，我首先需要注册一个 Docker Hub 账号，然后使用 docker login 命令登录。</p><p>接下来，我们要用 docker tag 命令给容器镜像起一个完整的名字：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag helloworld zhangsan/helloworld:v1</span><br></code></pre></td></tr></table></figure><p>注意：做实验时，请将&quot;zhangsan&quot;替换成你自己的 Docker Hub 账户名称。</p><p>其中，zhangsan就是我们在 Docker Hub 上的用户名，它的“学名”叫镜像仓库（Repository）；“/”后面的 helloworld 是这个镜像的名字，而“v1”则是我给这个镜像分配的版本号。</p><h2 id="八、docker-push">八、docker push</h2><p>然后，我们执行 docker push：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker push zhangsan/helloworld:v1</span><br></code></pre></td></tr></table></figure><p>这样，我们就可以把这个镜像上传到 Docker Hub 上了。</p><h2 id="九、docker-commit">九、docker commit</h2><p>此外，我们还可以使用 docker commit 指令，把一个正在运行的容器，直接提交为一个镜像。一般来说，需要这么操作原因是：这个容器运行起来后，我们又在里面做了一些操作，并且要把操作结果保存到镜像里，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it 4ddf4638572d /bin/sh</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在容器内部新建了一个文件</span><br>root@4ddf4638572d:/app# touch test.txt<br>root@4ddf4638572d:/app# exit<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">将这个新建的文件提交到镜像中保存</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker commit 4ddf4638572d zhangsan/helloworld:v2</span><br></code></pre></td></tr></table></figure><p>docker commit，实际上就是在容器运行起来后，把最上层的“可读写层”，加上原先容器镜像的只读层，打包组成了一个新的镜像。当然，下面这些只读层在宿主机上是共享的，不会占用额外的空间。</p><p>而由于使用了联合文件系统，我们在容器里对镜像 rootfs 所做的任何修改，都会被操作系统先复制到这个可读写层，然后再修改。这就是所谓的：Copy-on-Write。</p><p>而正如前所说，Init 层的存在，就是为了避免我们执行 docker commit 时，把 Docker 自己对 /etc/hosts 等文件做的修改，也一起提交掉。</p><p>这里，我们还使用到了 docker exec 命令进入到了容器当中。在了解了 Linux Namespace 的隔离机制后，我们应该会很自然地想到一个问题：docker exec 是怎么做到进入容器里的呢？</p><h2 id="十、docker-exec">十、docker exec</h2><p>实际上，Linux Namespace 创建的隔离空间虽然看不见摸不着，但一个进程的 Namespace 信息在宿主机上是确确实实存在的，并且是以一个文件的方式存在。</p><p>比如，通过如下指令，我们可以看到当前正在运行的 Docker 容器的进程号（PID）是 25686：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker inspect --format <span class="hljs-string">&#x27;&#123;&#123; .State.Pid &#125;&#125;&#x27;</span>  4ddf4638572d</span><br>25686<br></code></pre></td></tr></table></figure><p>这时，我们可以通过查看宿主机的 proc 文件，看到这个 25686 进程的所有 Namespace 对应的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l  /proc/25686/ns</span><br>total 0<br>lrwxrwxrwx 1 root root 0 Aug 13 14:05 cgroup -&gt; cgroup:[4026531835]<br>lrwxrwxrwx 1 root root 0 Aug 13 14:05 ipc -&gt; ipc:[4026532278]<br>lrwxrwxrwx 1 root root 0 Aug 13 14:05 mnt -&gt; mnt:[4026532276]<br>lrwxrwxrwx 1 root root 0 Aug 13 14:05 net -&gt; net:[4026532281]<br>lrwxrwxrwx 1 root root 0 Aug 13 14:05 pid -&gt; pid:[4026532279]<br>lrwxrwxrwx 1 root root 0 Aug 13 14:05 pid_for_children -&gt; pid:[4026532279]<br>lrwxrwxrwx 1 root root 0 Aug 13 14:05 user -&gt; user:[4026531837]<br>lrwxrwxrwx 1 root root 0 Aug 13 14:05 uts -&gt; uts:[4026532277]<br></code></pre></td></tr></table></figure><p>可以看到，一个进程的每种 Linux Namespace，都在它对应的 /proc/[进程号]/ns 下有一个对应的虚拟文件，并且链接到一个真实的 Namespace 文件上。</p><p>有了这样一个可以“hold 住”所有 Linux Namespace 的文件，我们就可以对 Namespace 做一些很有意义事情了，比如：加入到一个已经存在的 Namespace 当中。这也就意味着：一个进程，可以选择加入到某个进程已有的 Namespace 当中，从而达到“进入”这个进程所在容器的目的，这正是 docker exec 的实现原理。</p><p>而这个操作所依赖的，乃是一个名叫 setns() 的 Linux 系统调用。它的调用方法，我们可以用如下一段小程序来理解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> errExit(msg) do &#123; perror(msg); exit(EXIT_FAILURE);&#125; while (0)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">int</span> fd;<br>    <br>    fd = open(argv[<span class="hljs-number">1</span>], O_RDONLY);<br>    <span class="hljs-keyword">if</span> (setns(fd, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;setns&quot;</span>);<br>    &#125;<br>    execvp(argv[<span class="hljs-number">2</span>], &amp;argv[<span class="hljs-number">2</span>]); <br>    errExit(<span class="hljs-string">&quot;execvp&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码功能非常简单：它一共接收两个参数，第一个参数是 argv[1]，即当前进程要加入的 Namespace 文件的路径，比如 /proc/25686/ns/net；而第二个参数，则是我们要在这个 Namespace 里运行的进程，比如 /bin/bash。</p><p>这段代码的核心操作，则是通过 open() 系统调用打开了指定的 Namespace 文件，并把这个文件的描述符 fd 交给 setns() 使用。在 setns() 执行后，当前进程就加入了这个文件对应的 Linux Namespace 当中了。</p><p>现在，我们可以编译执行一下这个程序，加入到容器进程（PID=25686）的 Network Namespace 中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -o set_ns set_ns.c</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./set_ns /proc/25686/ns/net /bin/bash</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ifconfig</span><br>eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:00:02  <br>          inet addr:172.17.0.2  Bcast:0.0.0.0  Mask:255.255.0.0<br>          inet6 addr: fe80::42:acff:fe11:2/64 Scope:Link<br>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br>          RX packets:12 errors:0 dropped:0 overruns:0 frame:0<br>          TX packets:10 errors:0 dropped:0 overruns:0 carrier:0<br>     collisions:0 txqueuelen:0 <br>          RX bytes:976 (976.0 B)  TX bytes:796 (796.0 B)<br><br>lo        Link encap:Local Loopback  <br>          inet addr:127.0.0.1  Mask:255.0.0.0<br>          inet6 addr: ::1/128 Scope:Host<br>          UP LOOPBACK RUNNING  MTU:65536  Metric:1<br>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0<br>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0<br>    collisions:0 txqueuelen:1000 <br>          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)<br></code></pre></td></tr></table></figure><p>正如上所示，当我们执行 ifconfig 命令查看网络设备时，会发现能看到的网卡“变少”了：只有两个。而我们的宿主机则至少有四个网卡。这是怎么回事呢？</p><p>实际上，在 setns() 之后看到的这两个网卡，正是我们在前面启动的 Docker 容器里的网卡。也就是说，新创建的这个 /bin/bash 进程，由于加入了该容器进程（PID=25686）的 Network Namepace，它所看到的网络设备与这个容器里是一样的，即：/bin/bash 进程的网络设备视图，也被修改了。</p><p>而一旦一个进程加入到了另一个 Namespace 当中，在宿主机的 Namespace 文件上，也会有所体现。在宿主机上，我们可以用 ps 指令找到这个 set_ns 程序执行的 /bin/bash 进程，其真实的 PID 是 28499：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在宿主机上</span><br>ps aux | grep /bin/bash<br>root     28499  0.0  0.0 19944  3612 pts/0    S    14:15   0:00 /bin/bash<br></code></pre></td></tr></table></figure><p>这时，如果按照前面介绍过的方法，查看一下这个 PID=28499 的进程的 Namespace，我们就会发现这样一个事实：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l /proc/28499/ns/net</span><br>lrwxrwxrwx 1 root root 0 Aug 13 14:18 /proc/28499/ns/net -&gt; net:[4026532281]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l  /proc/25686/ns/net</span><br>lrwxrwxrwx 1 root root 0 Aug 13 14:05 /proc/25686/ns/net -&gt; net:[4026532281]<br></code></pre></td></tr></table></figure><p>在 /proc/[PID]/ns/net 目录下，这个 PID=28499 进程，与我们前面的 Docker 容器进程（PID=25686）指向的 Network Namespace 文件完全一样。这说明这两个进程，共享了这个名叫 net:[4026532281]的 Network Namespace。</p><p>此外，Docker 还专门提供了一个参数，可以让我们启动一个容器并“加入”到另一个容器的 Network Namespace 里，这个参数就是 -net，比如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it --net container:4ddf4638572d busybox ifconfig<br></code></pre></td></tr></table></figure><p>这样，我们新启动的这个容器，就会直接加入到 ID=4ddf4638572d 的容器，也就是我们前面的创建的 Python 应用容器（PID=25686）的 Network Namespace 中。所以，执行 ifconfig 返回的网卡信息，跟我们前面那个小程序返回的结果一模一样。</p><p>而如果我们指定–net=host，就意味着这个容器不会为进程启用 Network Namespace。这就意味着，这个容器拆除了 Network Namespace 的“隔离墙”，所以，它会和宿主机上的其他普通进程一样，直接共享宿主机的网络栈。这就为容器直接操作和使用宿主机网络提供了一个渠道。</p><h2 id="十一、docker-push">十一、docker push</h2><p>有了新的镜像，我们就可以把它推送到 Docker Hub 上了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker push zhangsan/helloworld:v2</span><br></code></pre></td></tr></table></figure><p>我们可能还会有这样的问题：在企业内部，能不能也搭建一个跟 Docker Hub 类似的镜像上传系统呢？</p><p>当然可以，这个统一存放镜像的系统，就叫作 Docker Registry。感兴趣的话，可以查看<a href="https://docs.docker.com/registry/">Docker 的官方文档</a>，以及VMware 的 <a href="https://github.com/goharbor/harbor">Harbor 项目</a>。</p><h2 id="十二、Volume">十二、Volume</h2><p>最后，我们再来讨论一下 Docker 项目另一个重要的内容：Volume（数据卷）。</p><p>我们知道，容器技术使用了 rootfs 机制和 Mount Namespace，构建出了一个同宿主机完全隔离开的文件系统环境。这时候，我们就需要考虑这样两个问题：</p><ul><li><p>容器里进程新建的文件，怎么才能让宿主机获取到？</p></li><li><p>宿主机上的文件和目录，怎么才能让容器里的进程访问到？</p></li></ul><p>这正是 Docker Volume 要解决的问题，Volume 机制允许我们将宿主机上指定的目录或者文件，挂载到容器里面进行读取和修改操作。</p><h3 id="12-1、声明Volume的两种方式">12.1、声明Volume的两种方式</h3><p>在 Docker 项目里，有两种 Volume 声明方式，可以把宿主机目录挂载进容器的 /test 目录当中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -v /test ...</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -v /home:/test ...</span><br></code></pre></td></tr></table></figure><p>这两种声明方式的本质，实际上是相同的：都是把一个宿主机的目录挂载进容器的 /test 目录。</p><p>只不过，在第一种情况下，由于我们并没有显示声明宿主机目录，那么 Docker 就会默认在宿主机上创建一个临时目录 /var/lib/docker/volumes/[VOLUME_ID]/_data，然后把它挂载到容器的 /test 目录上。而在第二种情况下，Docker 就直接把宿主机的 /home 目录挂载到容器的 /test 目录上。</p><h3 id="12-2、Volume的工作机制">12.2、Volume的工作机制</h3><blockquote><p>那么，Docker 又是如何做到把一个宿主机上的目录或者文件，挂载到容器里面去呢？难道又是 Mount Namespace 的黑科技吗？</p></blockquote><p>我们知道，当容器进程被创建之后，尽管开启了 Mount Namespace，但是在它执行 chroot（或者 pivot_root）之前，容器进程一直可以看到宿主机上的整个文件系统。</p><p>而在宿主机上的文件系统中，自然也包括了我们要使用的容器镜像。这个镜像的各个层，保存在 /var/lib/docker/aufs/diff 目录下，在容器进程启动后，它们会被联合挂载在 /var/lib/docker/aufs/mnt/ 目录中，这样容器所需的 rootfs 就准备好了。</p><p>所以，我们只需要在准备好 rootfs 之后，在执行 chroot 之前，把 Volume 指定的宿主机目录（比如 /home 目录），挂载到指定的容器目录（比如 /test 目录）在宿主机上对应的目录（即 /var/lib/docker/aufs/mnt/[可读写层 ID]/test）上，这个 Volume 的挂载工作就完成了。</p><p>更重要的是，由于执行这个挂载操作时，“容器进程”已经创建了，也就意味着此时 Mount Namespace 已经开启了。所以，这个挂载事件只在这个容器里可见。我们在宿主机上，是看不见容器内部的这个挂载点的。这就保证了容器的隔离性不会被 Volume 打破。</p><p>需要注意的是，这里提到的&quot;容器进程&quot;，是 Docker 创建的一个容器初始化进程 (dockerinit)，而不是应用进程 (ENTRYPOINT + CMD)。dockerinit 会负责完成根目录的准备、挂载设备和目录、配置 hostname 等一系列需要在容器内进行的初始化操作。最后，它通过 execv() 系统调用，让应用进程取代自己，成为容器里的 PID=1 的进程。</p><h3 id="12-3、绑定挂载">12.3、绑定挂载</h3><p>在执行实际的挂载操作时，使用到的挂载技术，是 Linux 的绑定挂载（bind mount）机制。它的主要作用就是，允许我们将一个目录或者文件，而不是整个设备，挂载到一个指定的目录上。并且，我们在这个挂载点上进行的任何操作，只发生在被挂载的目录或者文件上，而原挂载点的内容则会被隐藏起来且不受影响。</p><p>绑定挂载实际上是一个 inode 替换的过程。在 Linux 操作系统中，inode 可以理解为存放文件内容的“对象”，而 dentry也叫目录项，就是访问这个 inode 所使用的“指针”。</p><p><img src="/img/image-20201012083735928.png" alt="image-20201012083735928"></p><p>如上图所示，mount --bind /home /test，会将 /home 挂载到 /test 上。其实相当于将 /test 的 dentry，重定向到了 /home 的 inode。这样当我们修改 /test 目录时，实际修改的是 /home 目录的 inode。这也就是为何，一旦执行 umount 命令，/test 目录原先的内容就会恢复：因为修改真正发生在 /home 目录里。</p><p>因此，只要在一个正确的时机，进行一次绑定挂载，Docker 就可以成功地将一个宿主机上的目录或文件，不动声色地挂载到容器中。这样，进程在容器里对这个 /test 目录进行的所有操作，实际都发生在宿主机的对应目录（比如，/home，或者 /var/lib/docker/volumes/[VOLUME_ID]/_data）里，而不会影响容器镜像的内容。</p><h3 id="12-4、docker-commit-Volume">12.4、docker commit &amp; Volume</h3><blockquote><p>既然宿主机目录被挂载到容器rootfs的可读可写层，那么它里面的内容会不会被docker commit提交掉呢？</p></blockquote><p>不会。因为容器的镜像操作（比如 docker commit），发生在宿主机空间。而由于 Mount Namespace 的隔离作用，宿主机并不知道这个绑定挂载的存在（此时的dentry指向原来的inode）。所以，在宿主机看来，容器中可读写层的 /test 目录（/var/lib/docker/aufs/mnt/[可读写层 ID]/test），始终是空的。</p><p>不过，由于 Docker 一开始还是要创建 /test 这个目录作为挂载点，所以执行了 docker commit 之后，你会发现新产生的镜像里，会多出来一个空的 /test 目录。毕竟，新建目录操作，又不是挂载操作，Mount Namespace 对它可起不到“障眼法”的作用。</p><h3 id="12-5、实践Volume">12.5、实践Volume</h3><p>结合以上的讲解，我们现在来亲自验证一下：</p><p>首先，启动一个 helloworld 容器，给它声明一个 Volume，挂载在容器里的 /test 目录上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -v /test helloworld</span><br>cf53b766fa6f<br></code></pre></td></tr></table></figure><p>容器启动之后，我们来查看一下这个 Volume 的 ID：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume <span class="hljs-built_in">ls</span></span><br>DRIVER              VOLUME NAME<br>local               cb1c2f7221fa9b0971cc35f68aa1034824755ac44a034c0c0a1dd318838d3a6d<br></code></pre></td></tr></table></figure><p>然后，使用这个 ID，可以找到它在 Docker 工作目录下的 volumes 路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /var/lib/docker/volumes/cb1c2f7221fa/_data/</span><br></code></pre></td></tr></table></figure><p>这个 _data 文件夹，就是这个容器的 Volume 在宿主机上对应的临时目录了。接下来，我们在容器的 Volume 里，添加一个文件 text.txt：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it cf53b766fa6f /bin/sh</span><br>cd test/<br>touch text.txt<br></code></pre></td></tr></table></figure><p>这时，我们再回到宿主机，就会发现 text.txt 已经出现在了宿主机上对应的临时目录里：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /var/lib/docker/volumes/cb1c2f7221fa/_data/</span><br>text.txt<br></code></pre></td></tr></table></figure><p>可是，如果我们在宿主机上查看该容器的可读写层，虽然可以看到这个 /test 目录，但其内容是空的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /var/lib/docker/aufs/mnt/6780d0778b8a/test</span><br></code></pre></td></tr></table></figure><p>可以确认，容器 Volume 里的信息，并不会被 docker commit 提交掉；但这个挂载点目录 /test 本身，则会出现在新的镜像当中。</p>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器基础3：理解容器镜像</title>
    <link href="/2020/10/01/%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%803%EF%BC%9A%E7%90%86%E8%A7%A3%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/"/>
    <url>/2020/10/01/%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%803%EF%BC%9A%E7%90%86%E8%A7%A3%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<p>todo</p><h2 id="一、理解Mount-Namespace">一、理解Mount Namespace</h2><p>如下，是一个小程序，它的作用是在创建子进程时开启指定的Namespace。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mount.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_SIZE (1024 * 1024)</span><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> container_stack[STACK_SIZE];<br><span class="hljs-type">char</span>* <span class="hljs-type">const</span> container_args[] = &#123;<br>  <span class="hljs-string">&quot;/bin/bash&quot;</span>,<br>  <span class="hljs-literal">NULL</span><br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">container_main</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span><br>&#123;  <br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Container - inside the container!\n&quot;</span>);<br>  execv(container_args[<span class="hljs-number">0</span>], container_args);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Something&#x27;s wrong!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent - start a container!\n&quot;</span>);<br>  <span class="hljs-type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWNS | SIGCHLD , <span class="hljs-literal">NULL</span>);<br>  waitpid(container_pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent - container stopped!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码的功能非常简单：在main函数里，我们通过clone()系统调用创建了一个新的子进程container_main，并且声明要为它启用Mount Namespace（即：CLONE_NEWNS标志）。而子进程container_main是一个“/bin/bash”程序，也就是一个shell。所以，这个shell就运行在Mount Namespace的隔离环境中。下面，我们编译一下这个程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -o ns ns.c</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./ns</span><br>Parent - start a container!<br>Container - inside the container!<br></code></pre></td></tr></table></figure><p>这样，我们就进入到了这个“容器”当中。此时，如果我们执行ls命令的话，会发现这个容器中的内容跟宿主机是一样的。也就是说，即时开启了Mount Namespace，容器进程看到的文件系统也跟宿主机完全一样。而这又是为什么呢？</p><p>其实，Mount Namespace修改的是容器进程对文件系统“挂载点”的认知。这也就意味着，只有在“挂载”这个操作发生之后，进程的视图才会被改变。而在此之前，新创建的容器会直接继承宿主机的各个挂载点。</p><p>因此，在创建新进程时，除了声明要启用Mount Namespace之外，我们还可以告诉容器进程，有哪些目录需要重新挂载，比如/tmp目录。于是，我们可以在容器进程执行前添加一步重新挂载/tmp目录的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">container_main</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Container - inside the container!\n&quot;</span>);<br>  <span class="hljs-comment">// 如果你的机器的根目录的挂载类型是shared，那必须先重新挂载根目录</span><br>  <span class="hljs-comment">// mount(&quot;&quot;, &quot;/&quot;, NULL, MS_PRIVATE, &quot;&quot;);</span><br>  mount(<span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-string">&quot;/tmp&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>);<br>  execv(container_args[<span class="hljs-number">0</span>], container_args);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Something&#x27;s wrong!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在修改后的代码里，在启动容器进程之前，加上了一句mount(“none”, “/tmp”, “tmpfs”, 0, “”)语句。它的作用就是，告诉容器以tmpfs（内存盘）格式，重新挂载/tmp目录。再次编译后程序的执行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -o ns ns.c</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./ns</span><br>Parent - start a container!<br>Container - inside the container!<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /tmp</span><br></code></pre></td></tr></table></figure><p>可以看到，这次/tmp变成了一个空目录，这就意味着重新挂载生效了。我们可以用mount -l检查一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mount -l | grep tmpfs</span><br>none on /tmp type tmpfs (rw,relatime)<br></code></pre></td></tr></table></figure><p>这就是Mount Namespace跟其他Namespace在使用时的不同：它对容器进程视图的改变，一定要伴随着挂载操作（mount）才能生效。</p><p>但是，作为一个普通用户，我们希望的是一个更友好的情况：每当创建一个新容器时，容器进程看到的文件系统就是一个独立的隔离环境，而不是继承自宿主机的文件系统。可是要怎样才能做到这一点呢？</p><p>其实，我们可以在容器进程启动之前重新挂载它的整个根目录“/”。而由于Mount Namespace的存在，这个挂载对宿主机是不可见的，所以容器进程就可以在里面随便折腾了。</p><h2 id="二、理解chroot机制">二、理解chroot机制</h2><p>在Linux操作系统中，有一个名为chroot的命令可以帮助我们完成对整个根目录的挂载。顾名思义，它的作用就是帮助我们“change root file system”，即改变进程的根目录。现假设，有一个$HOME/test目录，我们想把它作为一个/bin/bash进程的根目录。操作如下：</p><p>首先，创建test目录和几个lib目录，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p $HOME/test<br>mkdir -p $HOME/test/&#123;bin,lib64,lib&#125;<br></code></pre></td></tr></table></figure><p>然后，把bash命令拷贝到test目录对应的bin目录下，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp -v /bin/&#123;bash,ls&#125; $HOME/test/bin<br></code></pre></td></tr></table></figure><p>接下来，把运行bash和ls所需的so文件也拷贝到test目录对应的lib目录下，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">T=$HOME/test<br>mkdir -p $T/lib/x86_64-linux-gnu<br>list=&quot;$(ldd /bin/bash | egrep -o &#x27;/lib.*\.[0-9]&#x27;)&quot;<br>for i in $list; do cp -v &quot;$i&quot; &quot;$&#123;T&#125;$&#123;i&#125;&quot;; done<br>list=&quot;$(ldd /bin/ls | egrep -o &#x27;/lib.*\.[0-9]&#x27;)&quot;<br>for i in $list; do cp -v &quot;$i&quot; &quot;$&#123;T&#125;$&#123;i&#125;&quot;; done<br></code></pre></td></tr></table></figure><p>最后，执行chroot命令，告诉操作系统，我们将使用$HOME/test目录作为/bin/bash进程的根目录，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chroot $HOME/test /bin/bash<br></code></pre></td></tr></table></figure><p>这时，如果执行<code>ls /</code>，就会看到，它返回的都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>O</mi><mi>M</mi><mi>E</mi><mi mathvariant="normal">/</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi><mtext>目录下的内容，而不是宿主机的内容。更重要的是，对于被</mtext><mi>c</mi><mi>h</mi><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mtext>的进程来说，它并不会感受到自己的根目录已经被“修改”成了</mtext></mrow><annotation encoding="application/x-tex">HOME/test目录下的内容，而不是宿主机的内容。更重要的是，对于被chroot的进程来说，它并不会感受到自己的根目录已经被“修改”成了</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.05764em;">OME</span><span class="mord">/</span><span class="mord mathnormal">t</span><span class="mord mathnormal">es</span><span class="mord mathnormal">t</span><span class="mord cjk_fallback">目录下的内容，而不是宿主机的内容。更重要的是，对于被</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">roo</span><span class="mord mathnormal">t</span><span class="mord cjk_fallback">的进程来说，它并不会感受到自己的根目录已经被</span><span class="mord">“</span><span class="mord cjk_fallback">修改</span><span class="mord">”</span><span class="mord cjk_fallback">成了</span></span></span></span>HOME/test。</p><p>可以看到，这种视图被修改的原理和Linux Namespace很类似。实际上，Mount Namespace正是基于对chroot的不断改良才被发明出来的，它也是Linux操作系统中的第一个Namespace。</p><h2 id="三、容器镜像">三、容器镜像</h2><h3 id="3-1、什么是容器镜像">3.1、什么是容器镜像</h3><p>为了能够让容器的根目录看起来更“真实”，我们一般会在这个容器的根目录下挂载一个操作系统完整的文件系统，比如，Ubuntu 16.04的ISO。这样，在容器启动之后，我们在容器中通过执行<code>ls /</code>查看根目录的下的内容，就是Ubuntu 16.04的所有目录和文件。</p><p>这个挂载在容器根目录上、用来为容器进程提供隔离后的执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作rootfs（即根文件系统）。</p><p>通常，一个最常见的rootfs，或者说容器镜像，会包括如下所示的一些目录和文件，比如/bin，/etc，/proc等：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /</span><br>bin dev etc home lib lib64 mnt opt proc root run sbin sys tmp usr var<br></code></pre></td></tr></table></figure><p>而当我们进入容器之后执行的<code>/bin/bash</code>，就是容器进项的/bin目录下的可执行文件，它与宿主机的/bin/bash完全不同。</p><p>现在，我们应该可以理解，对Docker项目来说，它最核心的原理实际上就是为待创建的用户进程：</p><ul><li>启用Linux Namespace配置；</li><li>设置指定的Cgroups参数；</li><li>切换进程的根目录。</li></ul><p>这样，一个完成的容器就诞生了。不过，Docker项目在最后一步的切换上会优先使用pivot_root系统调用，如果系统不支持，才会使用chroot。这两个系统调用虽然功能类似，但是也有细微的区别。</p><p>此外，我们需要知道的是，rootfs只是一个操作系统所包含的文件、目录和配置，并不包括操作系统内核。在Linux操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。所以说，rootfs只包括了操作系统的”躯壳“，并没有包括操作系统的”灵魂“。那么，对于容器来说，这个操作系统的”灵魂“又在哪里呢？</p><p>实际上，同一台机器上的所有容器，都共享宿主机操作系统的内核。这就意味着，如果我们的应用程序需要配置内核参数、加载额外的内核模块以及跟内核进行直接的交互，那么此时就需要特别注意了：这些操作和依赖的对象，就是宿主机操作系统的内核，它对于该机器上的所有容器来说是一个“全局变量”，牵一发而动全身。</p><p>这也是容器相比于虚拟机的主要缺陷之一：毕竟后者不仅有模拟出来的硬件机器充当沙盒，而且每个沙盒里还运行着一个完整的 Guest OS 给应用随便折腾。</p><h3 id="3-2、理解容器镜像的一致性">3.2、理解容器镜像的一致性</h3><p>我们知道，容器有一个被反复宣传的重要特性：一致性。由于rootfs里打包的不仅仅是应用，而且包括整个操作系统的文件和目录，也就意味着，应用以及它运行所需要的所有依赖，都被封装在了一起。</p><p>事实上，对于大多数开发者而言，他们对应用依赖的理解，一直局限在编程语言层面。比如Golang的Godeps.jsonm。但实际上，一个一直以来很容易被忽视的事实是，对一个应用来说，操作系统本身才是它运行所需要的最完整的“依赖库”。</p><p>有了容器镜像“打包操作系统”的能力，这个最基础的依赖环境也终于变成了应用沙盒的一部分。这就赋予了容器所谓的一致性：无论在本地、云端，还是在一台任何地方的机器上，用户只需要解压打包好的容器镜像，那么这个应用运行所需要的完整的执行环境就会被重现出现。</p><p>而正是这种深入到操作系统级别的运行环境一致性，才打通了应用在本地开发和远端执行环境之间难以逾越的鸿沟。</p><h2 id="四、联合文件系统">四、联合文件系统</h2><h3 id="4-1、早期rootfs存在的问题">4.1、早期rootfs存在的问题</h3><p>这时我们可能已经发现了另一个棘手的问题：难道每次开发一个应用，或升级一下现用的应用，都要重复制作一次rootfs吗？比如，我们现在用Ubuntu操作系统的ISO做了一个rootfs，然后又在里面安装了Java环境，用来部署我的Java应用。那么，其他人在发布他的Java应用时，显然是可以直接使用我们已经安装过Java环境的rootfs，而不用重复这个流程。</p><p>一种比较直观地解决办法就是，我们在制作rootfs的时候，每做一步“有意义”的操作，就保存一个rootfs出来，这样其他人就可以按需求去用他需要的rootfs了。但是，这个解决方法并不具备推广性。原因在于，一旦其他人修改了这个rootfs，新旧两个rootfs之间就没有任何关系了。这样做的结果就是极度的碎片化。</p><p>那么，既然这些修改都是基于一个旧的rootfs，我们能不能以增量的方式去做这些修改呢？这样做的好处就是，所有人都只需要维护相对于base rootfs修改的增量内容，而不是每次修改都制造一个“fork”。</p><p>答案当然是肯定的。Docker公司在实现Docker镜像时并没有沿用以前制作rootfs的流程，而是做了一个小小的创新：Docker在镜像的设计中，引入了层（layer）的概念。也就是说，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量rootfs。而这种创新的想法用到了一种叫作联合文件系统（Union File System）的能力。</p><h3 id="4-2、什么是联合文件系统">4.2、什么是联合文件系统</h3><p>Union File System也叫UnionFS，它最主要的功能就是将多个不同位置的目录联合挂载（union mount）到同一个目录下。比如，我们现在有两个目录A和B，它们分别有两个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir &#123;A,B&#125;<br>touch A/a<br>touch B/b<br>echo a &gt; A/x<br>echo b &gt; B/x<br>tree<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">.<br>├── A<br>│  ├── a<br>│  └── x<br>└── B<br>  ├── b<br>  └── x<br></code></pre></td></tr></table></figure><p>然后，我们使用联合挂载的方式，将这两个目录挂载到一个公共的目录C上：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">mkdir C<br>mount -t aufs -o dirs=<span class="hljs-string">./A</span><span class="hljs-function">:.</span><span class="hljs-string">/B</span> none <span class="hljs-string">./C</span><br></code></pre></td></tr></table></figure><p>这时，我们再查看目录C的内容，就能看到目录A和B下的文件被合并到了一起：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree ./C</span><br>./C<br>├── a<br>├── b<br>└── x<br></code></pre></td></tr></table></figure><p>可以看到，在这个合并后的目录C中，有a、b、x三个文件，并且x文件只有一份。这就是“合并”的含义。此外，如果我们在目录C里对a、b、x文件做修改，这些修改也会在对应的目录A、B中生效。</p><h3 id="4-3、AuFS联合文件系统">4.3、AuFS联合文件系统</h3><blockquote><p>那么，在Docker项目中，又是如何使用这种Union File System的呢？</p></blockquote><p>在Ubuntu 16.04和Docker CE 18.05中，默认使用的是AuFS这个联合文件系统的实现。我们可以通过docker info命令，查看到这个信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker info | grep Storage</span><br>Storage Driver: aufs<br></code></pre></td></tr></table></figure><p>AuFS 的全称是 Another UnionFS，后改名为 Alternative UnionFS，再后来干脆改名叫作 Advance UnionFS。对于 AuFS 来说，它最关键的目录结构在 /var/lib/docker 路径下的 diff 目录中：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/docker/</span>aufs<span class="hljs-regexp">/diff/</span>&lt;layer_id&gt;<br></code></pre></td></tr></table></figure><p>下面，我们通过一个具体的例子来理解这个目录的作用。</p><p>首先，我们启动一个容器，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d ubuntu:latest sleep 3600<br></code></pre></td></tr></table></figure><p>这时，Docker就会从Docker Hub上拉取一个Ubuntu镜像到本地。而这个所谓的“镜像”，实际上就是一个Ubuntu操作系统的rootfs，它的内容是Ubuntu操作系统的所有文件和目录。不过，与之前我们讨论的rootfs不同的是，Docker镜像使用的rootfs，往往也是多个“层”组成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker image inspect ubuntu:latest</span><br>...<br>     &quot;RootFS&quot;: &#123;<br>      &quot;Type&quot;: &quot;layers&quot;,<br>      &quot;Layers&quot;: [<br>        &quot;sha256:f49017d4d5ce9c0f544c...&quot;,<br>        &quot;sha256:8f2b771487e9d6354080...&quot;,<br>        &quot;sha256:ccd4d61916aaa2159429...&quot;,<br>        &quot;sha256:c01d74f99de40e097c73...&quot;,<br>        &quot;sha256:268a067217b5fe78e000...&quot;<br>      ]<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到，这个Ubuntu镜像，实际上由五个层组成。这五个层就是五个增量rootfs，每一层都是Ubuntu操作系统文件与目录的一部分；而在使用镜像时，Docker会把这些增量联合挂载在一个统一的挂载点上（等价于前面例子中的<code>/C</code>目录）。这个挂载点就是/var/lib/docker/aufs/mnt/，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/var/lib/docker/aufs/mnt/6e3be5d2ecccae7cc0fcfa2a2f5c89dc21ee30e166be823ceaeba15dce645b3e<br></code></pre></td></tr></table></figure><p>不出意外，这个目录里面就是一个完成的Ubuntu操作系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /var/lib/docker/aufs/mnt/6e3be5d2ecccae7cc0fcfa2a2f5c89dc21ee30e166be823ceaeba15dce645b3e</span><br>bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var<br></code></pre></td></tr></table></figure><p>那么，前面提到的五个镜像层，又是如何被联合挂载成这样一个完整的Ubuntu文件系统的呢？</p><p>这个信息就记录在AuFS的系统目录/sys/fs/aufs下面。首先，通过查看AuFS的挂载信息，我们可以找到这个目录对应的AuFS的内部ID（也叫：si）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /proc/mounts| grep aufs</span><br>none /var/lib/docker/aufs/mnt/6e3be5d2ecccae7cc0fc... aufs rw,relatime,si=972c6d361e6b32ba,dio,dirperm1 0 0<br></code></pre></td></tr></table></figure><p>即，si=972c6d361e6b32ba。然后，使用这个ID，就可以在/sys/fs/aufs下查看被联合挂载在一起的各个层的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /sys/fs/aufs/si_972c6d361e6b32ba/br[0-9]*</span><br>/var/lib/docker/aufs/diff/6e3be5d2ecccae7cc...=rw<br>/var/lib/docker/aufs/diff/6e3be5d2ecccae7cc...-init=ro+wh<br>/var/lib/docker/aufs/diff/32e8e20064858c0f2...=ro+wh<br>/var/lib/docker/aufs/diff/2b8858809bce62e62...=ro+wh<br>/var/lib/docker/aufs/diff/20707dce8efc0d267...=ro+wh<br>/var/lib/docker/aufs/diff/72b0744e06247c7d0...=ro+wh<br>/var/lib/docker/aufs/diff/a524a729adadedb90...=ro+wh<br></code></pre></td></tr></table></figure><p>从这些信息里，我们可以看到，镜像的层都放置在/var/lib/docker/aufs/diff目录下，然后被联合挂载在/var/lib/docker/aufs/mnt下。</p><h3 id="4-4、理解镜像分层">4.4、理解镜像分层</h3><p>从上面的结构中，我们可以看出，这个容器的rootfs由如下所示的三部分组成：</p><h4 id="4-4-1、只读层">4.4.1、只读层</h4><p>第一部分，只读层。它是这个容器的rootfs最下面的五层，对应的正是ubuntu:latest镜像的五层。可以看到，它们的挂载方式都是只读的（ro+wh，即readonly+witeout）。这时，我们可以分别查看一下这些层的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /var/lib/docker/aufs/diff/72b0744e06247c7d0...</span><br>etc sbin usr var<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /var/lib/docker/aufs/diff/32e8e20064858c0f2...</span><br>run<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /var/lib/docker/aufs/diff/a524a729adadedb900...</span><br>bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var<br></code></pre></td></tr></table></figure><p>可以看到，这些层都以增量的方式分别包含了Ubuntu操作系统的一部分。</p><h4 id="4-4-2、可读写层">4.4.2、可读写层</h4><p>第二部分，可读写层。它是这个容器的roots最上面的一层，它的挂载方式为读写（rw，即read write）。在没有写入文件之前，这个目录是空的。而一旦在容器里做了写操作，修改产生的内容就会以增量的方式出现在这个层中。</p><blockquote><p>如果我们要做的是，删除只读层中的一个文件，这时会发生什么呢？</p></blockquote><p>为了实现删除操作，AuFS会在可读写层创建一个whieout文件，把只读层里的文件“遮挡”起来。比如，我们要删除只读层里一个名为foo的文件，那么这个删除操作实际上是在可读写层创建了一个名叫.wh.foo的文件。这样，当着两个层被联合挂载只有，foo文件就会被.wh.foo文件“遮挡”起来，从而就“消失”了。这个功能，就是“ro+wh”的挂载方式，即read only+whiteout的含义。</p><p>所以，最上面的这个可读写层的作用，就是专门用来存放我们修改rootfs后产生的增量，增、删、改操作都发生在这里。而当我们使用完了这个被修改过的容器之后，还可以使用docker commit和push指令，保存这个被修改过的可读写层，并上传到Docker Hub上，供其他人使用；与此同时，原先的只读层里的内容则不会有任何变化。而这就是增量rootfs的好处。</p><h4 id="4-4-3、init层">4.4.3、init层</h4><p>第三部分，init层。它是一个以“-init”结尾的层，夹在只读层和读写层之间。init层是Docker项目单独生成的一个内部层，专门用来存放/etc/hosts、/etc/resolv.conf等信息。</p><p>之所以需要这样的一层，是因为这些文件本属于只读的ubuntu镜像的一部分，但是用户往往需要在启动容器时，写入一些指定的值比如hostname，所以就需要在可读写层对它们进行修改。可是，这些修改往往只对当前的容器有效，我们并不希望执行docker commit时，把这些信息连同可读写层一起提交。</p><p>所以，Docker的做法是，在修改了这些文件之后，以一个单独的层挂载出来。而用户执行docker commit只会提交可读写层，所以是不包含这些内容的。</p><p>最终，这7个层都被联合挂载到/var/lib/docker/aufs/mnt目录下，表现为一个完成的Ubuntu操作系统供容器使用。</p><h2 id="五、小结">五、小结</h2><p>在这篇文章中，我们主要讨论了如下内容：</p><ul><li>mount namespace不同与其它namespace，它只有在挂载操作发生后才会生效。</li><li>现行的Mount Namespace是对chroot的改良。</li><li>容器镜像就是挂载在容器根目录上、用来为容器进程提供隔离后的执行环境的文件系统。</li><li>容器镜像的一致性是指容器不仅打包了应用运行所需的依赖程序，而且打包了整个文件系统。这样就实现了“一处构建，到处运行”。</li><li>联合文件系统就是将多个不同位置的目录联合挂载到同一个目录下。而容器镜像的分层特性就是借助联合文件系统实现的。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>容器基础2：隔离与限制</title>
    <link href="/2020/10/01/%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%802%EF%BC%9A%E9%9A%94%E7%A6%BB%E4%B8%8E%E9%99%90%E5%88%B6/"/>
    <url>/2020/10/01/%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%802%EF%BC%9A%E9%9A%94%E7%A6%BB%E4%B8%8E%E9%99%90%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>在我们真的了解容器吗这文章中，我们讨论了Linux容器中用来实现“隔离”的技术手段：Namespace。接下来，我们一起来了解一下容器的限制机制。</p><h2 id="一、再谈隔离">一、再谈隔离</h2><p>我们知道，Namespace技术实际上修改了进程能够看到的计算机“视图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定的内容。但对于宿主机来说，这些被“隔离”的进程跟其他进程并没有太大区别。</p><p>此外，我们需要知道的是，Docker Engine或者其他任何容器管理工具，并不会像虚拟化技术中的Hypervisor那样对应用进程的隔离环境负责，也不会创建任何实体的“容器”，真正对隔离环境负责的是宿主机操作系统本身。这也就是说，用户运行在容器里的应用进程，跟宿主机上的其他进程一样，都由宿主机操作系统统一管理，只不过这些被隔离的进程拥有额外设置过的Namespace参数。而Docker项目在里扮演的角色，更多的是旁路式的辅助和管理工作。当然，像Docker这样的角色其实也是可以去掉的。</p><p>现在我们应该能理解为什么Docker项目比虚拟机更受欢迎。这是因为，使用虚拟化技术作为应用沙盒，就必须要由Hypervisor来负责创建虚拟机，这个虚拟机是真实存在的，并且它里面必须运行一个完成的Guest OS才能执行用户的应用进程。这就不可避免地带来了额外的资源消耗和占用。而相比之下，容器化后的用户应用，却依然还是一个宿主机上的普通进程，这就意味着这些因为虚拟化而带来的性能损耗都是不存在的；而另一方面，使用Namespace作为隔离手段的容器并不需要单独的Guest OS，这就使得容器额外的资源占用几乎可以忽略不计。</p><p>不过，有利就有弊，基于Linux Namespace的隔离机制相比于虚拟化技术也有很多不足之处，其中最主要的问题就是：隔离得不彻底。</p><p>首先，既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核。尽管我们可以在容器中通过Mount Namespace单独挂载其他不同版本的操作系统文件，比如CentOS或者Ubuntu，但这并不能改变其共享宿主机内核的事实。这意味着，如果我们要在Windows宿主机上运行Linux容器，或者在低版本的Linux宿主机上运行高版本的Linux容器，都是行不通的。而相比之下，拥有硬件虚拟化技术和独立Guest OS的虚拟机就要方便得多了。</p><p>其次，在Linux内核中，有很多资源和对象是不能被Namespace化的，最典型的例子就是时间。当我们在容器中使用系统调用settimeofday(2)修改时间后，整个宿主机的时间都会被随之修改，这显然是不符合预期的。而在虚拟机中我们是可以随便折腾的。</p><p>由于上述问题，尤其是共享宿主机内核这一事实，容器暴露出来的攻击面是相当大的，应用“越狱”的难度比虚拟机低很多。尽管在实践中我们确实可以使用Seccomp等技术，对容器内部发起的所有系统调用进行过滤和甄别来进行安全加固，但这种方法因为多了一层对系统调用的过滤，必然会拖累容器的性能。更何况，默认情况下，谁也不知道到底该开启哪些系统调用，又该禁止哪些系统调用。所以，在生产环境中，没有人敢把运行在物理机上的Linux容器直接暴露到公网上。</p><h2 id="二、理解Cgroups机制">二、理解Cgroups机制</h2><p>在明白了隔离机制后，我们再来讨论一下容器的“限制”问题。</p><p>我们还是以PID Namespace为例。虽然容器内的第1号进程在“障眼法”的干扰下，只能看到容器里的情况，但是在宿主机上，它作为第100号进程与其他进程之间依然是平等的竞争关系。这就意味着，虽然第100号进程表面上被隔离起来了，但是它所能够使用到资源（比如CPU、内存），却是可以随时被宿主机上的其他进程（或者其他容器）占用的；当然，这个第100号进程自己也可能把所有资源吃光。这些情况，显示都不是一个“沙盒”应该变现出来的合理行为。</p><p>Linux Cgroups就是Linux内核中用来为进程设置资源限制的一个重要功能。Linux Cgroups的全称是Linux Control Group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括CPU、内存、磁盘、网络带宽等。此外，Cgroups还能对进程进行优先级设置和审计，以及将进程挂起和恢复等操作。接下来，我们重点讨论它的“限制”能力。</p><h3 id="2-1、Cgroups的操作接口">2.1、Cgroups的操作接口</h3><p>在Linux中，Cgroups给用户暴露出来的操作接口是文件系统，即它以文件和目录的形式组织在操作系统的/sys/fs/cgroup目录下。我们可以用mount指令把它们展示出来，如下是Ubuntu 18.04的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mount -t cgroup</span><br>cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)<br>cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)<br>cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)<br>cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)<br>cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio)<br>cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)<br>cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)<br>cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)<br>cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)<br>cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)<br>cgroup on /sys/fs/cgroup/rdma type cgroup (rw,nosuid,nodev,noexec,relatime,rdma)<br>cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)<br></code></pre></td></tr></table></figure><p>可以看到，它的输出结果，是一系列文件系统目录。</p><h3 id="2-2、Ggroups的子系统">2.2、Ggroups的子系统</h3><p>在/sys/fs/cgroup下面有很多诸如cpuset、cpu、memory这样的子目录，它们也被称为子系统。这些都是可以被Cgroups用来进行限制的资源种类。在子系统对应的资源目录下，我们可以看到该类资源具体用来进行限制的方法。比如，对CPU子系统来说，我们就可以看到如下几个配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l /sys/fs/cgroup/cpu/</span><br>total 0<br>-rw-r--r--  1 root root 0 Oct  1 11:15 cgroup.clone_children<br>-rw-r--r--  1 root root 0 Oct  1 11:15 cgroup.procs<br>-r--r--r--  1 root root 0 Oct  1 11:15 cgroup.sane_behavior<br>-r--r--r--  1 root root 0 Oct  1 11:15 cpuacct.stat<br>-rw-r--r--  1 root root 0 Oct  1 11:15 cpuacct.usage<br>-r--r--r--  1 root root 0 Oct  1 11:15 cpuacct.usage_all<br>-r--r--r--  1 root root 0 Oct  1 11:15 cpuacct.usage_percpu<br>-r--r--r--  1 root root 0 Oct  1 11:15 cpuacct.usage_percpu_sys<br>-r--r--r--  1 root root 0 Oct  1 11:15 cpuacct.usage_percpu_user<br>-r--r--r--  1 root root 0 Oct  1 11:15 cpuacct.usage_sys<br>-r--r--r--  1 root root 0 Oct  1 11:15 cpuacct.usage_user<br>-rw-r--r--  1 root root 0 Oct  1 11:15 cpu.cfs_period_us<br>-rw-r--r--  1 root root 0 Oct  1 11:15 cpu.cfs_quota_us<br>-rw-r--r--  1 root root 0 Oct  1 11:15 cpu.shares<br>-r--r--r--  1 root root 0 Oct  1 11:15 cpu.stat<br>-rw-r--r--  1 root root 0 Oct  1 11:15 notify_on_release<br>-rw-r--r--  1 root root 0 Oct  1 11:15 release_agent<br>-rw-r--r--  1 root root 0 Oct  1 11:15 tasks<br></code></pre></td></tr></table></figure><p>在输出中，我们可以看到有cfs_period和cfs_quota这样的关键词。这两个参数需要组合使用，可以用来限制进程在长度为cfs_period的一段时间内，只能被分配到总量为cfs_quota的CPU时间。</p><p>那我们该如何使用这些配置文件呢？接下来，我们通过一个案例，实践一下这些配置文件的使用。</p><h3 id="2-3、实践：使用Cgroups限制进程">2.3、实践：使用Cgroups限制进程</h3><h4 id="2-3-1、生成控制组">2.3.1、生成控制组</h4><p>首先，我们需要在相应的子系统下创建一个目录，比如，在CPU子系统对应的目录下创建一个container目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cd</span> /sys/fs/cgroup/cpu</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> container</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l container/</span><br>total 0<br>-rw-r--r-- 1 root root 0 Oct  1 11:31 cgroup.clone_children<br>-rw-r--r-- 1 root root 0 Oct  1 11:31 cgroup.procs<br>-r--r--r-- 1 root root 0 Oct  1 11:31 cpuacct.stat<br>-rw-r--r-- 1 root root 0 Oct  1 11:31 cpuacct.usage<br>-r--r--r-- 1 root root 0 Oct  1 11:31 cpuacct.usage_all<br>-r--r--r-- 1 root root 0 Oct  1 11:31 cpuacct.usage_percpu<br>-r--r--r-- 1 root root 0 Oct  1 11:31 cpuacct.usage_percpu_sys<br>-r--r--r-- 1 root root 0 Oct  1 11:31 cpuacct.usage_percpu_user<br>-r--r--r-- 1 root root 0 Oct  1 11:31 cpuacct.usage_sys<br>-r--r--r-- 1 root root 0 Oct  1 11:31 cpuacct.usage_user<br>-rw-r--r-- 1 root root 0 Oct  1 11:31 cpu.cfs_period_us<br>-rw-r--r-- 1 root root 0 Oct  1 11:31 cpu.cfs_quota_us<br>-rw-r--r-- 1 root root 0 Oct  1 11:31 cpu.shares<br>-r--r--r-- 1 root root 0 Oct  1 11:31 cpu.stat<br>-rw-r--r-- 1 root root 0 Oct  1 11:31 notify_on_release<br>-rw-r--r-- 1 root root 0 Oct  1 11:31 tasks<br><br></code></pre></td></tr></table></figure><p>这个目录就是一个“控制组”。可以看到，操作系统在我们创建的container目录下，自动生成了该子系统对应的资源限制文件。</p><h4 id="2-3-2、启动进程">2.3.2、启动进程</h4><p>现在，我们在命令行执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">while</span> :; <span class="hljs-keyword">do</span> :; <span class="hljs-keyword">done</span> &amp;</span><br>[1] 59599<br></code></pre></td></tr></table></figure><p>在这里，我们执行了一个死循环，它可以它计算机的CPU吃到100%，根据它的输出，我们可以看到这条命令在后台的进程号（PID）是59599。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">top</span><br><span class="hljs-meta prompt_">%</span><span class="language-bash">Cpu(s):100.0 us,  0.0 sy,  0.0 ni,  0.0 <span class="hljs-built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br></code></pre></td></tr></table></figure><p>通过top命令，我们可以看到，CPU的使用率已经是100%了。</p><h4 id="2-3-3、设置限制">2.3.3、设置限制</h4><p>通过查看container目录下的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cat</span> /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us</span> <br>-1<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cat</span> /sys/fs/cgroup/cpu/container/cpu.cfs_period_us</span> <br>100000<br></code></pre></td></tr></table></figure><p>我们可以看到，container控制组里的CPU quota还没有任何限制（即：-1），CPU period则是默认的100ms（100000us）。</p><p>接下来，我们通过修改这些文件的内容来设置限制。比如，向container组里的cfs_quota文件写入20ms（20000us）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">echo</span> 20000 &gt; /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us</span><br></code></pre></td></tr></table></figure><p>这个操作的含义是，在每100ms的时间里，被该控制组限制的进程只能使用20ms的CPU时间，也就是说这个进程最多只能使用20%的CPU带宽。</p><h4 id="2-3-4、限制进程">2.3.4、限制进程</h4><p>最后，我们把要限制的进程的PID写入container组里的tasks文件中，上面的设置就会对该进程生效了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">echo</span> 59599 &gt; /sys/fs/cgroup/cpu/container/tasks</span><br></code></pre></td></tr></table></figure><p>此时，我们再用top命令查看CPU的使用情况：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"># top<br>%Cpu(s): <span class="hljs-number">20.4</span> us,  <span class="hljs-number">0.3</span> <span class="hljs-keyword">sy</span>,  <span class="hljs-number">0.0</span> ni, <span class="hljs-number">79.3</span> id,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">wa</span>,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">hi</span>,  <span class="hljs-number">0.0</span> si,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">st</span><br></code></pre></td></tr></table></figure><p>可以看到，计算机的CPU使用率立刻降到了20%。</p><h3 id="2-4、小结">2.4、小结</h3><p>除了CPU子系统外，Cgroups的每一个子系统都有其独有的资源限制能力，比如：</p><ul><li>blkio，为块设备设定IO限制，一般用于磁盘等设备；</li><li>cpuset，为进程分配单独的CPU核和对应的内存节点；</li><li>memory，为进程设定内存使用限制。</li></ul><p>Linux Cgroups的设计还是比较简单易用的，它就是一个子系统目录加上一组资源限制文件的组合。而对于Docker等Linux容器项目来说，它们只需要在每个子系统下面，为每个容器创建一个控制组（即创建一个新目录），然后再启动容器进程之后，把这个进程的PID填写到对应控制组的tasks文件中就可以了。</p><p>至于要在这些控制组下的资源文件中填上什么值，就靠用户执行docker run时指定的参数了。比如，下面这条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">docker run -it --cpu-period=100000 --cpu-quota=20000 ubuntu /bin/bash</span><br></code></pre></td></tr></table></figure><p>在启动这个容器后，我们可以通过查看Cgroups文件系统下，CPU子系统中的“docker”这个控制组里的资源限制文件来确认：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cat</span> /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_period_us</span> <br>100000<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cat</span> /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_quota_us</span> <br>20000<br></code></pre></td></tr></table></figure><p>这就意味着这个Docker容器，只能使用到20%的CPU带宽。</p><h2 id="三、小结">三、小结</h2><p>在这篇文章中，我们重点讨论了如下内容：</p><ul><li>容器的本质就是一个特殊的进程。它几乎没有额外的资源开销，但隔离不彻底是其最大问题，尤其是共享宿主机内核这一事实。</li><li>Linux Cgroups是Docker实现资源限制的主要方法。</li><li>Linux Cgroups的全称是Linux Control Group，它实际上就是一些子系统目录加上一组相应的资源文件的组合。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器基础1：我们真的了解容器吗？</title>
    <link href="/2020/09/28/%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%801%EF%BC%9A%E6%88%91%E4%BB%AC%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8%E5%90%97%EF%BC%9F/"/>
    <url>/2020/09/28/%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%801%EF%BC%9A%E6%88%91%E4%BB%AC%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>我相信但凡接触过Docker的同学，一定看到过下面这张虚拟机和容器的对比图：</p><p>在这幅图的左边，画出了虚拟机的工作原理。其中，名为Hypervisor的软件是虚拟机最主要的部分。它通过硬件虚拟化功能，模拟出运行一个操作系统所需的各种硬件，比如，CPU、内存、I/O设备等；然后，它在这些虚拟的硬件上安装一个新的操作系统，即Guest OS。这样，我们的应用程序就可以运行在这个虚拟的机器中，而它所能看到的范围自然也就只有Guest OS的文件和目录，以及这个虚拟的机器中的虚拟设备。这就是为什么虚拟机也能起到将不同的应用程序互相隔离的作用。</p><p>而在这幅图的右边，用一个名为Docker Engine的软件替换了Hypervisor。这也是为什么，很多人会把Docker项目称为“轻量级”虚拟化技术的原因，实际上就是把虚拟机的概念套在了容器上。然而，这就是Docker的真面目吗？</p><h2 id="一、什么是容器">一、什么是容器</h2><p>在详细说明容器的本质之前，我们先来回答第一个问题：容器，到底是什么？</p><p>容器其实是一种沙盒技术。顾名思义，它就是一种能够像集装箱一样把我们的应用”装“起来的技术。这样，应用与应用之间，因为有了边界而不至于互相干扰；而被装进集装箱的应用，也可以很方便地搬来搬去。</p><p>嗯，说起来好像很简单，那么这个边界是如何实现的呢？</p><h2 id="二、容器技术的核心功能">二、容器技术的核心功能</h2><p>假设，我们现在要写这样的一个计算加法的小程序，这个程序需要的输入来自于一个文件，它计算完成后的结果会输出到另一个文件中。</p><p>我们知道，由于计算机只认识0和1，所以无论用哪种语言编写这段代码，最后都需要通过某种方式翻译成二进制文件，才能在计算操作系统中运行这些代码。而为了让这些代码能够正常运行，我们往往还要给它提供数据，比如我们这个加法程序所需要的输入文件。有了这些数据和代码本身的二进制文件（就是我们平常所说的“程序”，也叫代码的可执行镜像，放在的磁盘上）后，我们就可以在计算机上运行这个“程序”了。</p><p>首先，操作系统从“程序”中发现要输入的数据就保存在一个文件中，所以这些数据会被加载到内存中待命。同时，操作系统又读取到了计算加法的指令，这时它就需要指示CPU完成加法操作。而当CPU与内存协作进行加法计算时，又会使用寄存器存放数值、内存堆栈保存执行的命令和变量。此外，计算机里还有被打开的文件，以及各种各样的I/O设备在不断地调用中修改自己的状态。</p><p>就这样，一旦“程序”被执行起来，它就从磁盘上的二进制文件，变成了计算机内存中的数据、寄存器里的值、堆栈中的指令、被打开的文件，以及各种设备的状态信息的一个集合。而像这样的一个程序运行起来后的计算机执行环境的总和，就是我们所说进程。</p><p>所以，对于进程来说，它的静态表现就是程序，平常都安安静静地待在磁盘上；而一旦运行起来，它就变成了计算机里的数据和状态的总和，而这就是进程的动态表现。</p><p>容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。而对于Docker等大多数Linux容器来说，Groups技术是用来制造约束的主要手段，Namespace技术则是用来修改进程视图的主要方法。</p><h2 id="三、理解Namespace机制">三、理解Namespace机制</h2><p>假设我们现在有一个已经运行了Docker项目的Linux操作系统，接下来，我们在命令行执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it busybox /bin/sh</span><br>/ #<br></code></pre></td></tr></table></figure><p>在这个命令中，docker run的作用就是启动一个容器，而参数-it则告诉Docker项目在启动容器后，给我们分配一个文本输入/输出环境（也就是TTY），跟容器的标准输入相关联，这样我们就可以和这个Docker容器进行交互了。而/bin/sh就是我们要在Docker容器中运行的程序。</p><p>所以，上面这条命令翻译成人类语言就是：请帮我启动一个容器，在容器里执行/bin/sh，并且给我们分配一个命令行终端跟这个容器进行交互。而在这个环境中，我们的Linux操作系统就是一个宿主机，而这个运行着/bin/sh的容器，就跑在我们的宿主机中。</p><p>但凡玩过Docker的同学，对上面这个例子和其原理，一定不会感到陌生。此时，如果我们在容器里执行一下ps指令，就会发现一些更有趣的事情：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">/ # ps<br>PID  USER   TIME COMMAND<br>  1 root   0:00 /bin/sh<br>  10 root   0:00 ps<br></code></pre></td></tr></table></figure><p>可以看到，我们在最开始启动容器时执行的/bin/sh，就是这个容器内部的第1号进程，而在这个容器里一共只有两个进程在运行。这也就意味着，前面执行的/bin/sh，以及我们刚刚执行的ps，已经被Docker隔离在一个跟宿主机完全不同的世界当中。</p><blockquote><p>问题是这究竟是怎么做到的呢？</p></blockquote><p>本来，每当我们在宿主机上运行一个/bin/sh程序时，操作系统都会给它分配一个进程编号，比如PID=100。这个编号就进程的唯一标识。而现在，我们通过Docker把这个/bin/sh程序运行在一个容器当中，此时，Docker会给这个第100号进程施一个“障眼法”，让它永远看不到前面的其他99个进程，更看到不第1号进程，这样它就会错误地以为自己就是操作系统中的第1号进程。</p><p>而这种机制，其实就是对被隔离程序的进程空间做了手脚，使得进程只能看到重新计算过的进程编号，比如PID=1。可实际上，它们在宿主机的操作系统中，还是原来的第100号进程。</p><p>这种技术，就是Linux系统中的Namespace机制。而Namespace的使用方式也很简单：它其实只是Linux创建进程时的一个可参数。我们知道，在Linux系统中创建线程的系统调用是clone()，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> pid = clone(main_function, statick_size, SIGCHLD, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><p>这个系统调用就会为我们创建一个新的进程，并且返回它的PID。而在我们用clone()系统调用创建一个进程时，可以在参数中指定CLONE_NEWPID参数，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> pid = clone(main_function, statck_size, CLONE_NEWPID | SIGCHLD, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><p>此时，这个新创建的进程将会“看到”一个全新的进程空间，在这个进程空间中，它的PID是1。这里之所以用“看到”一词，是因为这只是一个“障眼法”，在宿主机真实的进程空间中，这个进程的PID还是真实的数值，比如100。当然，我们还可以多次执行上面的clone()调用，这样就会创建多个PID Namespace，而每个Namespace中的进程，都会认为自己是当前容器里的第1号进程，它们即看不到宿主机里真正的进程空间，也看不到其他PID Namespace里的具体情况。</p><p>而除了我们刚刚用到的PID Namespace，Linux操作系统还提供了Mount、UTS、IPC、Network和User这些Namespace，用来对各种不同的进程上下文进行“障眼法”操作。比如，Mount Namespace，用于让被隔离进程只看到当前Namespace里的挂载点信息；Network Namespace，用于让被隔离进程看到当前Namespace里的网络设备和配置。而这就是Linux容器最基本的实现原理了。</p><p>我们要知道的是，Docker容器实际上就是在创建容器进程时，指定这个进程所需要启用的一组Namespace参数。这样，容器就只能“看到”当前Namespace所限定的资源、设备、文件、状态和配置等。而对于宿主机以及其他不相关的进程，它就完全看不到了。所以说，容器，其实就是一种特殊的进程而已。</p><h2 id="四、小结">四、小结</h2><p>在这篇文章中，我们主要讨论了如下内容：</p><ul><li>容器是一种沙盒技术，它的主要作用是将应用打包起来。这样既便于搬运，又做到了应用之间的隔离。</li><li>容器技术的核心功能，就是通过约束和限制进程的动态表现，从而为其创造出一个“边界”。</li><li>容器本质上就是一个特殊的进程。在创建容器进程时，Docker会为这个进程启动一组Namespace参数。</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM垃圾回收调优策略</title>
    <link href="/2020/09/26/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5/"/>
    <url>/2020/09/26/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p>对于不同的业务场景，垃圾回收调优策略是不一样的。比如，在对内存要求苛刻的情况下，需要提高对象回收效率；在CPU使用率高的情况下，需要降低高并发时垃圾回收的频率。那么面对不同的场景，我们该如何进行调优呢？</p><h2 id="一、GC性能衡量指标">一、GC性能衡量指标</h2><p>在进行实际的GC调优前，我们需要根据一些GC性能指标，确定具体的调优方向。常用的GC性能指标如下：</p><ul><li>吞吐量，这里的吞吐量是指应用程序所花费的时间和系统总运行时间的比值。我们可以按照这个公式来计算GC的吞吐量：<code>系统总运行时间 = 应用程序耗时 + GC耗时</code>。如果系统运行了100分钟，GC耗时1分钟，则系统吞吐量为99%。系统的吞吐量一般不能低于95%。</li><li>停顿时间，指垃圾回收器正在运行时，应用程序的暂停时间。对于串行回收器而言，停顿时间可能会比较长；而使用并发回收器时，由于垃圾回收器和应用程序交替运行，程序的停顿时间就会变短，但其效率很可能不如独占回收器，系统的的吞吐量也很可能会降低。</li><li>GC频率，指多久发生一次垃圾回收。通常垃圾回收的频率越低越好，增大堆内存空间可以有效降低垃圾回收的频率；但同时也意味着堆积的回收对象越多，最终也会增加回收时的停顿时间。所以，我们要适当的增大堆内存空间，以保证正常的垃圾回收频率。</li></ul><h2 id="二、查看-分析GC日志">二、查看 &amp; 分析GC日志</h2><p>在了解了性能衡量指标后，我们需要通过工具分析GC日志，统计各项指标的信息。</p><p>首先，我们需要通过JVM参数预先设置GC日志，通常有以下几种JVM参数设置：</p><ul><li>-XX:+PrintGC，输出GC日志</li><li>-XX:+PrintGCDetails，输出GC的详细日志</li><li>-XX:+PrintGCTimeStamps，输出GC的时间戳（以基准时间的形式）</li><li>-XX:+PrintGCDateStamps，输出GC的时间戳（以日志的形式，比如2013-05-04T21:53:59.234+0800）</li><li>-XX:+PrintHeapAtGC，在进行GC的前后打印出堆的信息</li><li>-Xloggc:…/logs/gc.log，日志文件的输出路径</li></ul><p>一般我们使用如下参数来输出日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:./gclogs<br></code></pre></td></tr></table></figure><p>对于运行很短时间的GC日志，我们可直接查看日志文件。但如果是长时间的GC日志，我们很难通过文本形式去查看整体的GC性能。</p><p>此时，我们可以使用GCViewer工具打开日志文件，通过图形化界面查看整体的GC性能。通过工具，我们可以得到吞吐量、停顿时间以及GC频率等指标数据，从而可以非常直观地了解到GC的性能情况。</p><p>其实，还有一个比较好用的GC日志分析工具，GCeasy是一款非常直观地GC日志分析工具，我们可以将日志文件压缩之后，上传到GCeasy官网即可看到非常清楚的GC日志分析结果。</p><h2 id="三、GC调优策略">三、GC调优策略</h2><h3 id="3-1、选择合适的垃圾回收器">3.1、选择合适的垃圾回收器</h3><p>假设我们有这样一个需求，要求每次GC操作的响应时间必须在500ms以内。这时，我们一般会选择响应速度比较快的垃圾回收器，比如，CMS回收器和G1回收器。</p><p>而当我们的需求对系统吞吐量有要求时，就可以选择Parallel Scavenge回收器来提高系统的吞吐量。</p><h3 id="3-2、降低Minor-GC频率">3.2、降低Minor GC频率</h3><p>通常情况下，由于新生代空间比较小，Eden区很快就会被填满，此时就会导致频率的Minor GC。因此，我们可以通过增大新生代空间来降低Minor GC的频率。此时，我们可能会有这样的疑问：</p><blockquote><p>扩容Eden区虽然可以减少Minor GC的次数，但不会增加单次Minor GC的时间吗？如果单次Minor GC的时间增加，那也很难达到我们期待的优化效果呀。</p></blockquote><p>我们需要知道的是，单次Minor GC的时间是由两部分组成的：T1（扫描新生代）和T2（复制存活对象）。假设一个对象在Eden区的存活时间为500ms，Minor GC的时间间隔是300ms，那么正常情况下，Minor GC的时间为：T1+T2。</p><p>当我们增大新生代空间，Minor GC的时间间隔可能会扩大到600ms，此时一个存活500ms的对象就会在Eden区中被回收，也就不存在复制存活对象了。所以，再发生Minor GC的时间为：两次扫描新生代，即2T1。</p><p>可见，扩容后，Minor GC时增加了T1，但省去T2。通常在虚拟机中，复制对象的成本要远高于扫面成本。</p><p>需要注意的是，如果在堆内存中存在比较多的长期存活对象，此时增加新生代空间，反而会增加Minor GC的时间。如果堆中的短期对象很多，那么扩容新生代，单次Minor GC的时间不会显著增加。因此，单次Minor GC的时间更多取决于GC后存活对象的数量，而非Eden区的大小。</p><h3 id="3-3、降低Full-GC频率">3.3、降低Full GC频率</h3><p>通常情况下，在堆内存空间不足或老年代对象太多时，会触发Full GC，频繁的Full GC会带来上下文切换，增加系统的性能开销。那我们可以使用哪些方法来降低Full GC的频率呢？</p><ul><li>减少创建大对象。在平常的业务场景中，我们习惯一次性从数据库中查询出一个大对象用于Web端显示。例如，一次性查询出60个字段的业务操作，这种大对象如果超过新生代最大对象阈值，会被直接创建在老年代；即时被创建在了新生代，由于新生代的内存空间有限，通过Minor GC之后也会进入到老年代。这种大对象很容易产生较多的Full GC。我们可以将这种大对象拆解出来，首次只查询一些比较重要的字段，如果还需要其它字段辅助查看，则再通过第二次查询显示剩余的字段。</li><li>增大堆内存空间。在堆内存不足的情况下，增大堆内存空间，且设置初始化堆内存为最大堆内存，也可以降低Full GC的频率。</li></ul><h2 id="四、小结">四、小结</h2><p>在这篇文章中，我主要讨论了如下概念：</p><ul><li>吞吐量、停顿时间和GC频率是衡量GC性能的常用指标。</li><li>通过分析GC日志可以获取到GC性能指标数据。而常用的GC日志分析工具有GCViewer和GCeasy。</li><li>选择合适的垃圾回收器、降低Minor GC频率、降低Full GC频率是常用的GC调优策略。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM堆内存分配的调优过程</title>
    <link href="/2020/09/26/JVM%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E8%B0%83%E4%BC%98%E8%BF%87%E7%A8%8B/"/>
    <url>/2020/09/26/JVM%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E8%B0%83%E4%BC%98%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>在JVM内存分配中，我们提出了一个问题，当遇到JVM内存性能问题时，应该如何调优？接下来我们通过一个案例来回答这个问题。</p><h2 id="一、案例场景">一、案例场景</h2><p>现模拟一个抢购接口，假设需要满足5W的并发请求，且每次请求会产生20KB对象。这里，我们可以通过千级并发创建一个1MB对象的接口来模拟万级并发请求产生大量对象的场景，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &#x27;/test1&#x27;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test1</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>    List&lt;Byte[]&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Byte[]&gt;();<br>    Byte[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br>    temp.add(b);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：这里我们先使用JVM的默认配置</p><h2 id="二、AB压测">二、AB压测</h2><p>分别对应用服务进行压力测试，以下是请求接口的吞吐量和响应时间在不同并发用户数下的变化情况：</p><p>可以看到，当并发数量到了一定值时，吞吐量就上不去了，响应时间也迅速增加。那么，在 JVM 内部运行又是怎样的呢？</p><h2 id="三、分析GC日志">三、分析GC日志</h2><p>此时我们可以通过GC日志查看具体的回收日志。我们可以通过设置JVM参数，将运行期间的GC日志dump下来，具体配置参数如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:/log/heapTest.log<br></code></pre></td></tr></table></figure><p>以下是各个配置项的说明：</p><ul><li>-XX:PrintGCTimeStamps，打印GC具体时间；</li><li>-XX:PrintGCDetails，打印出GC详细日志；</li><li>-Xloggc:path，GC日志的输出路径。</li></ul><p>收集到GC日志后，我们就可以通过GCViewer工具打开它，进而查看到具体的GC日志如下：</p><p>主页面显示FullGC发生了13次，右下角显示新生代和老年代的内存使用率几乎达到了100%。而FullGC会导致stop-the-world的发生，从而严重影响到应用服务的性能。此时，我们需要调整堆内存的大小来减少FullGC的发生。</p><h2 id="四、参考指标">四、参考指标</h2><p>我们可以将某些指标的预期值作为参考指标，常用的参考指标如下：</p><ul><li>GC频率，高频的FullGC会给系统带来非常大的性能消耗，虽然MinorGC相对FullGC来说会好许多，但过多的MinorGC仍会给系统带来压力。</li><li>内存，这里的内存指的是堆内存大小。堆内存又分为新生代和老年代内存。首先，我们要分析堆内存大小是否合适，其次是分析新生代和老年代的比例是否合适。如果内存不足或分配不均匀，会增加FullGC，严重的情况将导致CPU持续爆满，影响系统性能。</li><li>吞吐量，频繁的FullGC将会引起线程的上下文切换，增加系统的性能开销，从而影响每次处理的线程请求，最终导致系统的吞吐量下降。</li><li>延时，JVM的GC持续时间也会影响到每次请求的响应时间。</li></ul><h2 id="五、具体调优方法">五、具体调优方法</h2><h3 id="5-1、调整堆内存空间">5.1、调整堆内存空间</h3><p>调整堆内存空间减少FullGC。通过日志分析，堆内存基本被用完了，而且存在量FullGC，这意味着我们的堆内存严重不足。这时，我们需要调大堆内存的空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar -Xms4g -Xmx4g heapTest-0.0.1-SNAPSHOT.jar<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>-Xms，堆初始大小</li><li>-Xmx，堆最大值</li></ul><h3 id="5-2、调整新生代大小">5.2、调整新生代大小</h3><p>除了调整堆内存大小外，我们还可以将新生代设置得大一些，从而减少一些MinorGC：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar -Xms4g -Xmx4g -Xmn3g heapTest-0.0.1-SNAPSHOT.jar<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>-Xmn，新生代大小</li></ul><h3 id="5-3、设置Eden、Survivor区比例">5.3、设置Eden、Survivor区比例</h3><p>在JVM中，如果开启AdaptiveSizePolicy，则每次GC后都会重新计算Eden、From Survivor和To Survivor区的大小，计算的依据是GC过程中统计的GC时间、内存占用量和吞吐量。这时，SurvivorRatio默认设置的比例会失效。</p><p>在JDK1.8中，默认是开启AdaptiveSizePolicy的，我们可以通过-XX:-UseAdaptiveSizePolicy关闭该项配置，或显示运行-XX:SurvivorRatio=8将Eden、Survivor的比例设置为8:2。大部分新对象都是在Eden区创建的，我们可以固定Eden区的占用比例，来调优JVM的内存分配性能。</p><h2 id="六、小结">六、小结</h2><p>在这篇文章中，我们通过一个案例熟悉了JVM堆内存分配的调优过程。涉及到的核心概念是：</p><ul><li>GC日志分析是进行调优的前提。</li><li>GC频率、堆内存大小、吞吐量、延时是确定调优方向的重要性能指标。</li><li>调整堆内存空间、调整新生代大小和设置Eden、Survivor区比例是调优的常用方法</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>class文件结构</title>
    <link href="/2020/09/26/%E4%BA%86%E8%A7%A3class%E6%96%87%E4%BB%B6/"/>
    <url>/2020/09/26/%E4%BA%86%E8%A7%A3class%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>前面讨论JVM内存模型和JVM运行原理时，我们多次提及到了class文件，当时为了行为内容的简洁，并没有展开描述，今天我们就来认识一下这个文件。</p><p>我们知道，JVM在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。</p><p>在加载类的时候，JVM会先加载class文件，而在class文件有类的版本、字段、方法和常量池（Constant Pool Table）等信息。通过javap反编译一个class文件，就能查看到class文件的内容，其结构如下：</p><p><img src="/img/image-20220428175158549.png" alt="image-20220428175158549"></p><p>在这里，我们要知道的是，前期编译的过程其实是非常复杂的，包括词法分析、符号表填充、注解处理，语义分析以及生成class文件，但这个过程我们并不用过多关注。只要知道，编译后的字节码文件主要包括常量池和方法表集合就够了。</p><ul><li><p>常量池，用于存放编译期间生成的各种字面量和符号引用。字面量包括字符串常量（例如 String str=“abc”，其中“abc”就是常量）、声明为final的属性以及一些基本类型（例如，范围在-127 ~ 128之间的整型）的属性。符号引用则包括类和接口的全限定名、类引用、方法引用以及成员变量引用（例如 String str=“abc”，其中str就是成员变量引用）等。</p></li><li><p>方法表集合中主要包含方法字节码、方法访问权限（public、protect、private等）、方法名索引（与常量池中的方法引用对应）、描述符索引、JVM执行指令以及属性集合等。</p></li></ul><p>当类加载到内存后，JVM就会将class文件常量池中的内容放到运行时常量池中；在解析阶段，JVM会把符号引用替换为直接引用（对象的索引值）。</p><p>例如，类中的一个字符串常量在class文件中时，存放在class文件的常用池中，而在JVM加载完类之后，这个字符串常量就被放到了运行时常量池中，并在解析阶段，指定该字符串对象的索引值。</p><p>注：运行时常量池是全局共享的，多个类共用一个运行时常量池，class文件常量池中多个相同的字符串在运行时常量池只会存在一份。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM内存分配</title>
    <link href="/2020/09/26/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <url>/2020/09/26/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<p>我们知道，在大多数情况下，我们基本不用去调整JVM内存分配，因为一些初始化的参数已经可以保证应用服务正常稳定地工作了。但这并不意味着我们不需要理解JVM内存分配，尤其是在遇到一些性能问题时。</p><p>那么，当出现JVM内存性能问题时，我们该如何调优呢？在回答这个问题之前，我们先来了解一下JVM的内存分配。</p><h2 id="一、JVM的内存性能问题">一、JVM的内存性能问题</h2><p>谈到JVM表现出的内存性能问题时，我们可能会想到一些线上的JVM内存溢出事故。但这方面的事故往往是应用程序创建对象导致的内存回收对象难，一般属于代码编程问题。</p><p>很多时候，在一些特定场景下，应用服务的JVM内存分配不合理带来的性能表现并不会像内存溢出问题这么突出。如果没有深入到各项性能指标中去，很难发现其中隐藏的性能损耗。</p><p>JVM内存分配不合理最直接的表现就是频繁GC，这会导致上下文切换等性能问题，增加系统的响应时间，从而降低系统的吞吐量。因此，如果在线程环境或性能测试时，发现频繁GC，且是正常的对象创建和回收，这时就需要考虑调整JVM内存分配，从而减少GC所带来的性能开销。</p><h2 id="二、对象在对堆的生存周期">二、对象在对堆的生存周期</h2><p>我们知道，在JVM内存模型中，堆被划分为新生代和老年代，新生代又被进一步划分为Eden区和Survivor区，而Survivor又是由From Survivor和To Survivor组成的。</p><p>当我们创建一个对象时，对象会被优先分配到新生代的Eden区中，这时虚拟机会给对象定义一个对象年龄计数器（通过参数-XX:MaxTenuringThreshold设置）。</p><p>此外，还有另外一种情况，当Eden空间不足时，虚拟机会执行一个新生代的垃圾回收（Minor GC）。这时，JVM会把存活的对象转移到Survivor中，并给对象的年龄+1。对象在Survivor中同样也会经历Minor GC，每经过一次Minor GC，对象的年龄就会+1。</p><p>当然，通过-XX:PetenureSizeThreshold参数可以设置直接将大对象分配到老年代。这时，如果分配的对象超过了设置的阈值，对象就会直接被分配到老年代，这样做的好处就是可以减少新生代的垃圾回收（Minor GC）。</p><h2 id="三、查看JVM堆内存大小">三、查看JVM堆内存大小</h2><p>在默认不配置JVM堆内存大小的情况下，JVM根据默认值来配置当前内存大小。我们可以通过以下命令，查看堆内存的配置值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">java -XX:+PrintFlagsFinal -version | grep HeapSize</span><br>    uintx ErgoHeapSizeLimit                         = 0                                   &#123;product&#125;<br>    uintx HeapSizePerGCThread                       = 87241520                            &#123;product&#125;<br>    uintx InitialHeapSize                          := 1585446912                          &#123;product&#125;<br>    uintx LargePageHeapSizeThreshold                = 134217728                           &#123;product&#125;<br>    uintx MaxHeapSize                              := 25341984768                         &#123;product&#125;<br>java version &quot;1.8.0_281&quot;<br>Java(TM) SE Runtime Environment (build 1.8.0_281-b09)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.281-b09, mixed mode)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">jmap -heap 11200</span><br>Attaching to process ID 11200, please wait...<br>Debugger attached successfully.<br>Server compiler detected.<br>JVM version is 25.281-b09<br><br>using thread-local object allocation.<br>Garbage-First (G1) GC with 13 thread(s)<br><br>Heap Configuration:<br>   MinHeapFreeRatio         = 40<br>   MaxHeapFreeRatio         = 70<br>   MaxHeapSize              = 1073741824 (1024.0MB)<br>   NewSize                  = 1363144 (1.2999954223632812MB)<br>   MaxNewSize               = 643825664 (614.0MB)<br>   OldSize                  = 5452592 (5.1999969482421875MB)<br>   NewRatio                 = 2<br>   SurvivorRatio            = 8<br>   MetaspaceSize            = 21807104 (20.796875MB)<br>   CompressedClassSpaceSize = 260046848 (248.0MB)<br>   MaxMetaspaceSize         = 268435456 (256.0MB)<br>   G1HeapRegionSize         = 1048576 (1.0MB)<br><br>Heap Usage:<br>G1 Heap:<br>   regions  = 1024<br>   capacity = 1073741824 (1024.0MB)<br>   used     = 17378344 (16.573280334472656MB)<br>   free     = 1056363480 (1007.4267196655273MB)<br>   1.6184844076633453% used<br>G1 Young Generation:<br>Eden Space:<br>   regions  = 10<br>   capacity = 49283072 (47.0MB)<br>   used     = 10485760 (10.0MB)<br>   free     = 38797312 (37.0MB)<br>   21.27659574468085% used<br>Survivor Space:<br>   regions  = 7<br>   capacity = 7340032 (7.0MB)<br>   used     = 7340032 (7.0MB)<br>   free     = 0 (0.0MB)<br>   100.0% used<br>G1 Old Generation:<br>   regions  = 0<br>   capacity = 1017118720 (970.0MB)<br>   used     = 0 (0.0MB)<br>   free     = 1017118720 (970.0MB)<br>   0.0% used<br><br>6274 interned Strings occupying 451800 bytes.<br></code></pre></td></tr></table></figure><p>我们可以看到，在这台机器上启动的JVM默认最大堆内存为1956MB，初始化大小为124MB。</p><h2 id="四、JVM堆内存分配">四、JVM堆内存分配</h2><p>我们知道了一个对象从创建至回收的过程，接下来我们再来看看JVM堆内存是如何分配的。</p><p>在JDK1.7中，默认情况下新生代和老年代的比例是1:2，可以通过-XX:NewRatio重置该配置项。新生代中的Eden和To Survivor、From Survivor的比例是8:1:1，可以通过-XX:SurvivorRatio重置该配置项。需要注意的是，如果开启了-XX:+UseAdaptiveSizePolicy参数，JVM将会动态调整Java堆中各个区域的大小以及进入老年代的年龄。此时，-XX:NewRatio和-XX:SurvivorRatio将会失效。</p><p>在JDK1.8中，-XX:+UseAdaptiveSizePolicy参数默认是开启的，不要随便关闭该参数，除非已经对初始化堆内存/最大堆内存、新生代/老年代以及Eden区/Survivor区有非常明确的规划了。在默认情况下，JVM将会分配最小堆内存，新生代/老年代按1:2进行分配，Eden区和Survivor区则按8:2进行分配。</p><p>我们需要知道的是，默认分配策略未必是应用服务的最佳配置，因此可能会给应用服务带来严重的性能问题。</p><h2 id="五、小结">五、小结</h2><p>在这篇文章中，我们主要讨论了如下概念：</p><ul><li>频繁GC是JVM内存分配不合理的主要表现。这会导致上下文切换等性能问题，增加系统响应时间，从而降低系统吞吐量。</li><li>一个对象会经历从Eden区到Survivor区再到老年代的过程，在这个过程中会发生多次Minor GC。</li><li>通过设置-XX:PetenureSizeThreshold参数，可以将较大对象，直接分配到老年代内存中，这样可以减少Minor GC</li><li>默认情况下，JVM堆内存是按照新生代/老年代1:2、Eden/From Survivor/To Survivor8:1:1的比例分配的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM垃圾回收机制</title>
    <link href="/2020/09/26/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/09/26/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>JVM具备自动内存管理机制，这个机制虽然可以减轻很多工作量，但是完全交由JVM处理，也会增加回收性能的不确定性。尤其是在一些特殊的业务场景下，不合适的垃圾回收算法以及策略，都有可能导致系统性能下降。因此，我们有必要了解一下JVM的垃圾回收机制。</p><h2 id="一、GC机制">一、GC机制</h2><p>在认识GC算法之前，我们需要先弄清楚3个问题。第一，回收发生在哪里？第二，对象在什么时候可以被回收？第三，如何回收这些对象？</p><h3 id="1-1、回收发生在哪里？-Where">1.1、回收发生在哪里？ - Where</h3><blockquote><p>JVM垃圾回收发生在哪一块内存中？</p></blockquote><p>在JVM的内存模型中，程序计数器、虚拟机栈和本地方法栈这3个区域是线程私有的，随着线程的创建而创建，销毁而销毁。因此，这三个区域的内存分配和回收都具有确定性。</p><p>垃圾回收的重点是堆和方法区中的数据，堆中被回收的主要是对象，方法区中被回收的主要是废弃常量和无用的类。</p><h3 id="1-2、对象在什么时候可以被回收？-When">1.2、对象在什么时候可以被回收？ - When</h3><blockquote><p>JVM如何判断一个对象是可以被回收的呢？</p></blockquote><p>一般一个对象不再被引用，就代表该对象可以被回收。目前有以下两种算法可以判断一个对象是否可以被回收。</p><ul><li>引用计数算法，这种算法是通过每个对象的引用计算器来判断对象是否被引用。每当对象被引用，引用计数器就会加1；每当引用失效，计数器就会减1。当对象的引用计数器的值为0时，就说明该对象不再被引用，可以被回收了。这里需要注意的是，引用计数算法虽然实现简单、判断效率也很高，但是存在着对象之间互相循环引用的问题。</li><li>可达性分析算法，该算法的基础是GC Roots。GC Roots是所有对象的根对象，在JVM加载时，会创建一些普通对象作为正常对象的引用。这些普通对象作为正常对象的起始点，在垃圾回收时，会从GC Roots开始向下搜索，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。目前，HotSpot虚拟机采用的就是这种算法。</li></ul><p>以上两种算法都是通过引用来判断对象是否可以被回收的。在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为了以下四种：</p><ul><li>强引用（Strong Reference），被强引用关联的对象，永远不会被回收</li><li>弱引用（Weak Reference），只被弱引用关联的对象，只要发生垃圾回收事件就会被回收</li><li>软引用（Soft Reference），被软引用关联的对象，只用当系统将要发生内存溢出时才会被回收</li><li>虚引用（Phantom Reference），被虚引用关联的对象，其唯一的作用是在对象被回收时能收到一个系统通知</li></ul><h3 id="1-3、如何回收这些对象？-How">1.3、如何回收这些对象？ - How</h3><blockquote><p>垃圾回收线程是如何回收对象的？</p></blockquote><p>JVM垃圾回收遵循以下两个特性：</p><ul><li>自动性，Java提供了一个系统级的线程来跟踪每一块被分配出去的内存空间，当JVM处于空闲循环时，垃圾回收线程就会自动检查每一块被分配出去的内存空间，然后自动回收空闲的内存块。</li><li>不可预期性，即使一个对象没有被引用，JVM也不一定会回收它。我们很难确定一个没有被引用的对象，是不是会被立刻回收掉，因为有可能当程序结束后，这个对象仍在内存中。</li></ul><p>垃圾回收线程在JVM中是自动执行的，Java程序无法强制执行。我们唯一能做的就是通过调用System.gc方法来“建议”执行垃圾回收，但是否可执行，什么时候执行？仍然是不可预期的。</p><h2 id="二、GC算法">二、GC算法</h2><p>JVM提供了几种不同的回收算法来实现其回收机制。垃圾收集器实现的回收算法可以分为以下几种：</p><table><thead><tr><th>回收算法类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>标记 - 清除算法（Mark - Sweep）</td><td>不需要移动对象，简单高效</td><td>标记 - 清除过程效率低，容易产生内存碎片</td></tr><tr><td>复制算法（Copying）</td><td>不会产生内存碎片，简单高效</td><td>内存使用率低，且有可能产生频繁复制问题</td></tr><tr><td>标记 - 整理算法（Mark - Compact）</td><td>综合了前两种算法的优点</td><td>仍需要移动局部对象</td></tr><tr><td>分代收集算法（Generational Collection）</td><td>分区回收</td><td>对于有长时间存活对象的场景，回收效果不明显，甚至起到反作用</td></tr></tbody></table><h2 id="三、垃圾回收器">三、垃圾回收器</h2><p>如果说收集算法是内存回收的方法论，那么垃圾回收器就是内存回收的具体实现，JDK1.7 update14之后HotSpot虚拟机支持的所有回收器如下（注：以下均为服务端回收器）：</p><table><thead><tr><th>回收器类型</th><th>回收算法</th><th>特点</th><th>设置参数</th></tr></thead><tbody><tr><td>Serial New / Serial Old回收器</td><td>复制算法 / 标记 - 整理算法</td><td>单线程复制回收，简单高效，但会暂停程序导致停顿</td><td>-XX:+UseSerialGC（年轻代、老年代回收器分别为：Serial New、Serial Old）</td></tr><tr><td>ParNew New / ParNew Old回收器</td><td>复制算法 / 标记 - 整理算法</td><td>多线程复制回收，降低了停顿时间，但容易增加上下文切换</td><td>-XX:+UseParNewGC（年轻代、老年代回收器分别为：ParNew New、Serial Old，JDK1.8中无效）                               -XX:+UseParallelOldGC（年轻代、老年代回收器分别为：Parallel Scavenge、Parallel Old）</td></tr><tr><td>Parallel Scavenge回收器</td><td>复制算法</td><td>并行回收器，追求高吞吐量，高效利用CPU</td><td>-XX:+UseParallelGC（年轻代、老年代回收器分别为：Parallel Scavenge、Serial Old）                                                           -XX:ParallelGCThreads=4（设置并发线程）</td></tr><tr><td>CMS回收器</td><td>标记 - 清除算法</td><td>老年代回收器，高并发、低停顿，追求最短GC回收停顿时间，CPU占用比较高，响应时间快，停顿时间短</td><td>-XX:+UseConcMarkSweepGC（年轻代、老年代回收器分别为：ParNew New、CMS（Serial Old作为备用））</td></tr><tr><td>G1回收器</td><td>标记 - 整理 &amp; 复制算法</td><td>高并发、低停顿，可预测停顿时间</td><td>-XX:+UseG1GC（年轻代、老年代回收器分别为：G1、G1）                                   -XX:MaxGCPauseMillis=200（设置最大暂停时间）</td></tr></tbody></table><p>注：在JVM规范中并没有明确GC的运作方式，各个厂商可以采用不同的方式实际垃圾回收器。</p><p>我们可以通过JVM工具查询当前JVM使用的垃圾回收器类型，首先通过ps命令查询出进程ID，再通过<code>jmap -heap 进程ID</code>查询出JVM的配置信息，其中就包括垃圾回收器的设置类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">jmap -heap 11200</span><br>Attaching to process ID 11200, please wait...<br>Debugger attached successfully.<br>Server compiler detected.<br>JVM version is 25.281-b09<br><br>using thread-local object allocation.<br>Garbage-First (G1) GC with 13 thread(s)<br><br>Heap Configuration:<br>   MinHeapFreeRatio         = 40<br>   MaxHeapFreeRatio         = 70<br>   MaxHeapSize              = 1073741824 (1024.0MB)<br>   NewSize                  = 1363144 (1.2999954223632812MB)<br>   MaxNewSize               = 643825664 (614.0MB)<br>   OldSize                  = 5452592 (5.1999969482421875MB)<br>   NewRatio                 = 2<br>   SurvivorRatio            = 8<br>   MetaspaceSize            = 21807104 (20.796875MB)<br>   CompressedClassSpaceSize = 260046848 (248.0MB)<br>   MaxMetaspaceSize         = 268435456 (256.0MB)<br>   G1HeapRegionSize         = 1048576 (1.0MB)<br><br>Heap Usage:<br>G1 Heap:<br>   regions  = 1024<br>   capacity = 1073741824 (1024.0MB)<br>   used     = 16329768 (15.573280334472656MB)<br>   free     = 1057412056 (1008.4267196655273MB)<br>   1.5208281576633453% used<br>G1 Young Generation:<br>Eden Space:<br>   regions  = 9<br>   capacity = 49283072 (47.0MB)<br>   used     = 9437184 (9.0MB)<br>   free     = 39845888 (38.0MB)<br>   19.148936170212767% used<br>Survivor Space:<br>   regions  = 7<br>   capacity = 7340032 (7.0MB)<br>   used     = 7340032 (7.0MB)<br>   free     = 0 (0.0MB)<br>   100.0% used<br>G1 Old Generation:<br>   regions  = 0<br>   capacity = 1017118720 (970.0MB)<br>   used     = 0 (0.0MB)<br>   free     = 1017118720 (970.0MB)<br>   0.0% used<br><br><br>6273 interned Strings occupying 451720 bytes.<br></code></pre></td></tr></table></figure><h2 id="四、小结">四、小结</h2><p>在这篇文章中，我们主要提到了如下概念：</p><ul><li>GC一般发生在堆和方法区中。当一个对象没有被引用时，该对象就可以被回收。而在回收时，JVM会遵循自动性和不可预测性的原则。</li><li>常用的GC算法有四种，分别是标记-清除算法、复制算法、标记-整理算法和分代收集算法。</li><li>垃圾回收器是GC算法的具体实现。HotSpot虚拟机支持的回收器有Seria回收器、ParNew回收器、Parallel回收器、CMS回收器和G1回收器。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM即时编译</title>
    <link href="/2020/09/20/JVM%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/"/>
    <url>/2020/09/20/JVM%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<p>在讨论java类编译加载执行过程时，我们提到了编译这个概念。一说到编译，我们一定会想到将.java文件编译成.class文件的过程，这个编译我们一般称为前端编译。Java的编译和运行过程非常复杂，除了前端编译外，还有运行时编译。</p><h2 id="一、什么是即时编译">一、什么是即时编译</h2><p>即时编译，也被称为运行时编译。由于操作系统无法直接运行java生成的字节码，因此，在运行时，JIT或解释器会将字节码转换成机器码，这个转换过程就叫运行时编译。</p><p>类文件在运行时会被进一步编译，它们可以变成高度优化的机器代码。由于C/C++编译器的所有优化都是在编译期间完成的，运行期间以性能监控为基础的优化措施则无法进行，例如，调用频率预测、分支频率预测、裁剪未被选择的分支等；而Java在运行时的再次编译，就可以进行基础的优化操作。</p><p>因此，JIT编译器可以说是JVM中运行时编译最重要的部分之一。</p><h2 id="二、即时编译器的类型">二、即时编译器的类型</h2><p>在HotSpot虚拟机中，内置了两个JIT，分别为C1编译器和C2编译器，这两个编译器的编译过程是不一样的。</p><ul><li><p>C1编译器，是一个简单快速的编译器，主要的关注点在于局部性的优化，适用于执行时间较短或对启动性能有要求的程序，例如，GUI应用对界面启动速度就有一定的要求。</p></li><li><p>C2编译器，是为长期运行的服务器应用程序做性能调优的编译器，适用于执行时间较长或对峰值性能有要求的程序。</p></li></ul><p>根据各自的适配性，这两种即时编译分别被称为Client Compiler和Server Compiler。</p><h3 id="2-1-、-Java7">2.1 、- Java7</h3><p>在Java7之前，需要根据程序的特性选择对应的JIT，虚拟机默认采用解释器和其中一个编译器配合工作。</p><h3 id="2-2、Java7">2.2、Java7</h3><p>在Java7中，引入了分层编译，这种编译方式综合了C1的启动性能优势和C2的峰值性能优势，我们可以通过参数&quot;-client&quot;和&quot;-server&quot;强制指定虚拟机的即时编译模式。分层编译将JVM的执行状态分为了5个层次：</p><ul><li>第0层，程序解释执行，默认开启性能监控功能（Profiling）。如果不开启，可触发第二层编译；</li><li>第1层，可称为C1编译，不开启Profiling，将字节码编译为本地代码，进行简单、可靠的优化；</li><li>第2层，也称为C1编译，开启Profiling，仅执行带方法调用次数和循环回边执行次数的C1编译；</li><li>第3层，也称为C1编译，执行所有带Profiling的C1编译；</li><li>第4层，可称为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</li></ul><h3 id="2-3、Java8">2.3、Java8</h3><p>在Java8中，默认开启分层编译，-client和-server的设置是无效的。如果只想开启C2，可以使用参数-XX:-TieredCompilation关闭分层编译；如果只想开启C1，可以在打开分层编译的同时，使用参数-XX:TieredStopAtLevel=1。</p><p>除了这种默认的混合编译模式外，我们还可以使用“-Xint”参数强制虚拟机运行于只有解析器的编译模式下，这时JIT完全不介入工作；此外，我们还可以使用参数“-Xcomp”强制虚拟机运行于只有JIT的编译模式下。</p><p>通过在命令行执行<code>java -version</code>命令，可以查看到当前系统使用的编译模式，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubxy@server:~$ java -version<br>java version &quot;1.8.0_181&quot;<br>Java(TM) SE Runtime Environment (build 1.8.0_181-b13)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)<br>kubxy@server:~$ java -Xint -version<br>java version &quot;1.8.0_181&quot;<br>Java(TM) SE Runtime Environment (build 1.8.0_181-b13)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, interpreted mode)<br>kubxy@server:~$ java -Xcomp -version<br>java version &quot;1.8.0_181&quot;<br>Java(TM) SE Runtime Environment (build 1.8.0_181-b13)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, compiled mode)<br></code></pre></td></tr></table></figure><h2 id="三、热点探测">三、热点探测</h2><p>在HotSpot虚拟机中，热点探测是JIT优化的前提。</p><p>热点探测是基于计数器的热点探测，采用这种方法的虚拟机会为每个方法建立计数器，来统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”。</p><p>虚拟机为每个方法准备了两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过了阈值，就会触发JIT编译。</p><ul><li>方法调用计数器，用于统计方法被调用的次数。方法调用计数器的默认阈值在C1模式下是1500次，在C2模式下是10000次，可通过-XX:CompileThreshold参数来设定；而在分层编译的情况下，-XX:CompileThreshold制定的阈值将失效，此时将会根据当前编译的方法数以及编译线程数来动态调整。当方法计数器和回边计数器之和超过方法计数器阈值时，就会触发JIT编译。</li><li>回边计数器，用于统计一个方法中循环体代码执行的次数。在字节码中遇到控制流向后跳转的指令称为“回边”，该值用于计算是否触发C1编译的阈值，在不开启分层编译的情况下，C1默认为13995，C2默认为10700，可通过-XX:OnStackReplacePercentage=N来设置；而在分层编译的情况下，-XX:OnStackReplacePercentage指定的阈值同样会失效，此时将根据当前待编译的方法数以及编译线程数来动态调整。</li></ul><p>建立回边计数器的主要目的是为了触发OSR（On StackReplacement）编译，即栈上编译。在一些循环周期比较长的代码中，当循环次数达到回边计数器阈值时，JVM会认为这段是热点代码，JIT编译器就会将这段代码编译成机器语言并缓存，在该循环时间内，会直接将执行代码替换，执行缓存的机器语言。</p><h2 id="四、编译优化技术">四、编译优化技术</h2><p>JIT编译运用了一些经典的编译优化技术来实现代码的优化，即通过一些例行检查优化，可以智能地编译出运行时的最优性能代码。下面我们主要讨论两种优化手段。</p><h3 id="5-1、-方法内联">5.1、 方法内联</h3><p>当我们调用一个方法时，通常要经历入栈和出栈。调用方法就是将程序执行顺序转移到存储该方法的内存地址，将方法的内容执行完后，再返回到执行该方法前的位置。</p><p>这种执行操作要求在执行前保护现场并记忆执行的地址，执行后要恢复现场，并按原来保存的地址继续执行。因此，方法调用会产生一定的时间和空间方面的开销。</p><p>对于那些方法体代码不是很大，又频繁调用的方法来说，这个时间和空间的消耗会很大。方法内联的优化行为就是把目标方法的代码复制到发起调用的方法之中，避免发生真实的方法调用。例如以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add1</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> x3, <span class="hljs-type">int</span> x4)</span> &#123;<br>    <span class="hljs-keyword">return</span> add2(x1, x2) + add2(x3, x4);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add2</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> x2)</span> &#123;<br>    <span class="hljs-keyword">return</span> x1 + x2;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终会被优化为：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">private</span> int <span class="hljs-keyword">add</span><span class="hljs-number">1</span>(int<span class="hljs-number">1</span> <span class="hljs-keyword">x</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> int <span class="hljs-keyword">x</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span> int <span class="hljs-keyword">x</span><span class="hljs-number">3</span><span class="hljs-punctuation">,</span> int <span class="hljs-keyword">x</span><span class="hljs-number">4</span>) &#123;<br>    return <span class="hljs-keyword">x</span><span class="hljs-number">1</span> + <span class="hljs-keyword">x</span><span class="hljs-number">2</span> + <span class="hljs-keyword">x</span><span class="hljs-number">3</span> + <span class="hljs-keyword">x</span><span class="hljs-number">4</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>JVM会自动识别热点方法，并对它们使用方法内联进行优化。我们可以通过-XX:CompileThreshold来设置热点方法的阈值。但要强调一点，热点方法不一定会被JVM做内联优化，如果这个方法体太大了，JVM将不执行内联操作。而方法体的大小阈值，我们也可以通过参数来优化：</p><ul><li>经常执行的方法，默认情况下，方法大小小于325字节的都会进行内联，我们可以通过-XX:MaxFreqInlineSize=N来设置大小值；</li><li>不是经常执行的方法，默认情况下，方法大小小于35字节才会进行内联，我们也可以通过-XX:MaxInlinxSize=N来重置大小值。</li></ul><p>之后我们就可以通过配置JVM参数来查看到方法被内联的情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+PrintCompilation  //在控制台打印编译过程信息<br>-XX:+UnlockDiagnosticVMOptions  //解锁对JVM进行诊断的选项参数。默认是关闭的，开启后支持一些特定参数对JVM进行诊断<br>-XX:+PrintInlining  //将内联方法打印出来<br></code></pre></td></tr></table></figure><p>当我们设置VM参数：-XX:PrintCompilation -XX:+PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining之后，运行以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">1000000</span>; i++) &#123;  <span class="hljs-comment">//方法调用计数器的默认阈值在C1模式下是1500次，在C2模式下是10000次，我们循环遍历的次数需要超过阈值</span><br>        add1(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到运行结果中，显示了方法内联的日志：</p><p>热点方法的优化可以有效提高系统性能，一般我们可以通过以下几种方式来提高方法内联：</p><ul><li>通过设置JVM参数来减小热点阈值或增加方法体阈值，以便更多的方法可以进行内联，但这种方法意味着需要占用更多地内存；</li><li>在编程中，避免在一个方法中写大量代码，习惯使用小方法体；</li><li>尽量使用final、private、static关键字修饰方法，编码方法因为继承，会需要额外的类型检查。</li></ul><h3 id="5-2、逃逸分析">5.2、逃逸分析</h3><p>逃逸分析（Escape Analysis）是判断一个对象是否被外部方法引用或外部线程访问的分析技术，编译器会根据逃逸分析的结果对代码进行优化。</p><h4 id="5-2-1、栈上分配">5.2.1、栈上分配</h4><p>我们知道，在Java中默认创建一个对象是在堆中分配内存的，而当堆内存中的对象不再使用时，则需要通过垃圾回收机制回收，这个过程相对于分配在栈中的对象的创建和销毁来说，更消耗时间和性能。这个时候，逃逸分析如果发现一个对象只在方法中使用，就会将对象分配在栈上。</p><p>但是，因为HotSpot虚拟机目前的实现导致栈上分配实现比较复杂，可以说，在HotSpot中暂时没有实现这项优化。随着即时编译器的发展与逃逸分析技术的成熟，相信不久的将来HotSpot也会实现这项优化功能。</p><h4 id="5-2-2、锁消除">5.2.2、锁消除</h4><p>在非线程安全的情况下，尽量不要使用线程安全容器，比如StringBuffer。由于StringBuffer中的append方法被Synchronized关键字修饰，会使用到锁，从而导致性能下降。</p><p>但实际上，在以下代码测试中，StringBuffer和StringBuilder的性能基本没什么区别。这是因为在局部方法中创建的对象只能被当前线程访问，无法被其它线程访问，这个变量的读写肯定不会有竞争，这个时候JIT编译会对这个对象的方法锁进行锁消除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getString</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    sb.append(s1);<br>    sb.append(s2);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-5-3、标量替换">5.5.3、标量替换</h4><p>逃逸分析证明一个对象不会被外部访问，如果这个对象可以被拆分的话，当程序真正执行的时候可能不创建这个对象，而直接创建它的成员变量来代替。将对象拆分后，可以分配对象的成员变量在栈或寄存器上，原本的对象就无需分配内存空间了。这种编译优化就叫做标量替换。</p><p>我们用以下代码验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">TestInfo</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestInfo</span>();<br>     info.id = <span class="hljs-number">1</span>;<br>     info.count = <span class="hljs-number">99</span>;<br>       ...<span class="hljs-comment">//to do something</span><br> &#125; <br></code></pre></td></tr></table></figure><p>逃逸分析后，代码会被优化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>     id = <span class="hljs-number">1</span>;<br>     count = <span class="hljs-number">99</span>;<br>     ...<span class="hljs-comment">//to do something</span><br> &#125;<br></code></pre></td></tr></table></figure><p>我们可以通过设置 JVM 参数来开关逃逸分析，还可以单独开关同步消除和标量替换，在 JDK1.8 中 JVM 是默认开启这些操作的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+DoEscapeAnalysis开启逃逸分析（jdk1.8默认开启，其它版本未测试）<br>-XX:-DoEscapeAnalysis 关闭逃逸分析<br><br>-XX:+EliminateLocks开启锁消除（jdk1.8默认开启，其它版本未测试）<br>-XX:-EliminateLocks 关闭锁消除<br><br>-XX:+EliminateAllocations开启标量替换（jdk1.8默认开启，其它版本未测试）<br>-XX:-EliminateAllocations 关闭就可以了<br></code></pre></td></tr></table></figure><h2 id="六、小结">六、小结</h2><p>在本篇文章中，我们主要讨论了JVM的即时编译，我们要知道的是：</p><ul><li><p>即时编译，就是将java字节码编译成机器可识别的机器码</p></li><li><p>在HotSpot虚拟机中，主要有两种编译器：C1和C2</p></li><li><p>热点探测技术是JIT优化的前提。</p></li><li><p>JIT优化的主要方法为：方法内联和逃逸分析</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java代码是如何在JVM中运行的</title>
    <link href="/2020/09/20/Java%E4%BB%A3%E7%A0%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A8JVM%E4%B8%AD%E8%BF%90%E8%A1%8C%E7%9A%84/"/>
    <url>/2020/09/20/Java%E4%BB%A3%E7%A0%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A8JVM%E4%B8%AD%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>在前面我们讨论了JVM内存模型和Java类的编译加载执行过程。接下来我，我们通过一个案例进一步加深对JVM的认识。源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JVMcase</span> &#123;<br>    <span class="hljs-comment">// final修饰的常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">MAN_SEX_TYPE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;man&quot;</span>;<br><br>    <span class="hljs-comment">// 静态变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">WOMAN_SEX_TYPE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;woman&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        stu.setName(<span class="hljs-string">&quot;nick&quot;</span>);<br>        stu.setSexType(MAN_SEX_TYPE);<br>        stu.setAgen(<span class="hljs-number">20</span>);<br><br>        <span class="hljs-type">JVMCase</span> <span class="hljs-variable">jvmcase</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JVMCase</span>();<br><br>        <span class="hljs-comment">// 调用静态方法</span><br>        print(stu);<br>        <span class="hljs-comment">// 调用非静态方法</span><br>        jvmcase.sayHello(stu);<br>    &#125;<br><br>    <span class="hljs-comment">// 常规静态方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(Student stu)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;name: &quot;</span> + stu.getName() + <span class="hljs-string">&quot;; sex: &quot;</span> + stu.getSexType() + <span class="hljs-string">&quot;; age: &quot;</span> + stu.getAge());<br>    &#125;<br><br>    <span class="hljs-comment">// 非静态方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Student stu)</span> &#123;<br>        System.out.println(stu.getName() + <span class="hljs-string">&quot;sya: hello&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    String name;<br>    String sexType;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSexType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sexType;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSexType</span><span class="hljs-params">(String sexType)</span> &#123;<br>        hits.sexType = sexType;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAget</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们通过Java运行以上代码时，JVM的整个处理过程如下：</p><h2 id="一、申请内存">一、申请内存</h2><p>JVM第一步是通过配置参数或者默认配置参数向操作系统申请内存空间，操作系统会根据申请的内存大小找到具体的内存分配表，然后把内存段的起始地址和终止地址分配给JVM。接下来JVM就会进行内部分配。</p><h2 id="二、内部分配">二、内部分配</h2><p>在获得内存空间后，JVM就会根据配置参数分配堆、方法区以及栈的内存大小。</p><h2 id="三、加载、链接">三、加载、链接</h2><p>完成内部分配后，JVM会将class文件加载到内存中，并进行验证、准备、解析等操作。其中，在准备阶段会为类的静态变量分配内存，初始化为系统的初始值。</p><p><img src="/img/image-20200920163103371.png" alt="image-20200920163103371"></p><h2 id="四、初始化">四、初始化</h2><p>完成链接操作后，JVM会进行最后一个初始化阶段。在这个阶段中，JVM首先会执行构造器方法。此时，静态变量的初始值（null）会被初始化为用户自定义的值。</p><p><img src="/img/image-20200920163907881.png" alt="image-20200920163907881"></p><h2 id="五、执行方法">五、执行方法</h2><p>初始化完成后，JVM就会启动main线程，执行main方法，开始第一行代码的执行。此时，首先会在堆内存中创建一个Student对象，Student对象的引用就存放在栈中。</p><p><img src="/img/image-20200920164529917.png" alt="image-20200920164529917"></p><p>接着会创建一个JVMCase对象，调用sayHello非静态方法，sayHello方法属于对象JVMCase，此时sayHello方法入栈，并通过栈中的Student引用调用堆中的Student对象；</p><p><img src="/img/image-20200920165305309.png" alt="image-20200920165305309"></p><p>最后，调用静态方法print，print静态方法属于JVMCase类，是从静态方法中获取，之后放入到栈中，也是通过栈中的student引用调用堆中student对象。</p><p><img src="/img/image-20200920165445131.png" alt="image-20200920165445131"></p><h2 id="六、小结">六、小结</h2><p>在这篇文章中，我们主要讨论了Java代码是如何在JVM中运行的，这个过程包括：</p><ul><li>申请内存</li><li>内部分配</li><li>加载、连接</li><li>初始化</li><li>执行方法</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java类编译加载执行过程</title>
    <link href="/2020/09/20/Java%E7%B1%BB%E7%BC%96%E8%AF%91%E5%8A%A0%E8%BD%BD%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
    <url>/2020/09/20/Java%E7%B1%BB%E7%BC%96%E8%AF%91%E5%8A%A0%E8%BD%BD%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>JVM在执行某个类的时候，需要经过编译、加载、链接、初始化和运行时编译等过程。整个过程如下图所示：</p><p><img src="/img/image-20200920122012583.png" alt="image-20200920122012583"></p><p>接下来，我们详细了解一下Java类从编译到运行的整个过程。</p><h2 id="一、类编译">一、类编译</h2><p>在我们编写好java源代码后，需要将.java源代码文件编译成.class字节码文件，这样代码才能在JVM虚拟机上正常运行。.java文件的编译通常是由JDK中自带的javac工具完成的，对于一个简单的.java文件，我们可以通过javac命令生成.class文件。</p><h2 id="二、类加载">二、类加载</h2><p>当一个类被创建实例或者被其它对象引用时，如果虚拟机没有加载过这个类，那么就会通过类加载器将字节码文件（.java文件）加载到内存中。</p><p>不同的实现类是由不同的类加载器进行加载的。JDK中的本地方法类一般由根加载器（Bootstrap loader）加载，JDK中内部实现的扩展类一般由扩展加载器（ExtClassLoader）加载，而程序中的类文件则由系统加载器（AppClassLoader）加载。</p><p>在类加载后，class类文件中的常量池信息以及其它数据都会被保存到JVM内存的方法区中。</p><h2 id="三、类连接">三、类连接</h2><p>当类被加载到JVM内存中后，会进行连接操作，这个过程又包括验证、准备和解析三个部分：</p><ul><li><p>验证，验证类是否符合Java规范和JVM规范，在保证符合规范的前提下，避免危害虚拟机安全。</p></li><li><p>准备，为类的静态变量分配内存，初始化为系统的初始值。对于final static修饰的变量，则会直接赋值为用户的定义值。</p><p>例如，<code>private final static int valut = 123</code>，会在准备阶段分配内存，并初始化值为123；而如果是<code>private static int value = 123</code>，在准备阶段value的值仍然为0。</p></li><li><p>解析，将符号引用转为直接引用。在编译时，java类并不知道所引用类的实际地址，因此只能使用符号引用来代替。class文件的常量池中存储了符号引用，包括类和接口的全限定名、类引用、方法引用以及成员变量引用等。如果要使用这些类和方法，就需要把它们转化为JVM可以直接获取的内存地址或指针，即直接引用。</p></li></ul><h2 id="四、类初始化">四、类初始化</h2><p>在完成连接操作后，还要进行类初始化工作，在这个阶段中，JVM首先会执行构造器方法（即<code>&lt;clinit&gt;</code>方法）。编译器在将.java文件编译成.class文件时，会将所有的类初始化代码，包括静态变量赋值语句、静态代码块、静态方法，收集在一起组成为<code>&lt;clinet&gt;</code>方法。</p><blockquote><p>注：JVM会保证构造器方法的线程安全，即同一时间只有一个线程执行。</p></blockquote><p>类初始化时，会将类的静态变量和静态代码块初始化为用户自定义的值，初始化的顺序和java源码从上到下的顺序一致。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">static</span> &#123;<br>    i=<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span>&#123;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>此时的运行结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0<br></code></pre></td></tr></table></figure><p>而如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    i=<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span>&#123;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><p>子类初始化时，首先会调用父类的构造器方法，然后再执行子类的构造器方法，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">parentStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;parent static string&quot;</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;parent static fields&quot;</span>);<br>        System.out.println(parentStr);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Parent</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;parent instance initialization&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">subStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sub static string&quot;</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;sub static fields&quot;</span>);<br>        System.out.println(subStr);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Sub</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;sub instance initialization&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;sub main&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs smali">parent<span class="hljs-keyword"> static</span> fields<br>parent<span class="hljs-keyword"> static</span> string<span class="hljs-built_in"></span><br><span class="hljs-built_in">sub </span>static fields<span class="hljs-built_in"></span><br><span class="hljs-built_in">sub </span>static string<span class="hljs-built_in"></span><br><span class="hljs-built_in">sub </span>main<br>parent<span class="hljs-built_in"> instance </span>initialization<span class="hljs-built_in"></span><br><span class="hljs-built_in">sub </span>instance initialization<br></code></pre></td></tr></table></figure><p>初始化代码时，如果实例化一个新对象，则会调用<code>&lt;init&gt;</code>方法对实例变量进行初始化，并会执行对应的构造方法内的代码。</p><h2 id="五、运行时编译">五、运行时编译</h2><p>完成初始化后，类在调用执行过程中，执行引擎会把类的字节码转化为机器码，然后才会在操作系统中执行类。这里将在将字节码转化为机器码的过程，就是运行时编译。</p><h2 id="六、小结">六、小结</h2><p>在本篇文章中，我们主要讨论了java类的编译加载执行过程，这个过程包括：</p><ul><li>类编译，将源码文件（.java文件）编译成字节码文件（.class文件）</li><li>类加载，将字节码文件加载到内存中</li><li>类链接，对内存中的类进行验证、准备、解析等一系列操作</li><li>类初始化，执行类的构造器方法</li><li>运行时编译，将类的字节码转为化机器</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM内存模型</title>
    <link href="/2020/09/20/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/09/20/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>JVM不仅承担了Java字节码的分析（JIT compiler）和执行（Runtime），而且还内置了自动内存管理机制，负责内存的分配与回收。</p><p>JVM自动内存管理机制虽然有诸多好处，但其实是把双刃剑，它在提升Java开发效率的同时，也容易使开发人员过度依赖于这个机制，从而弱化对内存的管理能力。这样系统就很容易发生JVM堆内存异常、垃圾回收（GC）方式不合适以及GC次数过于频繁等问题，这些都将直接影响到应用服务器的性能。因此，在进行JVM调优前，需要深入了解JVM内存原理。</p><p>在深入了解JVM内原理前，我们先来看看JVM的内存模型。JVM内存主要被划分为了堆、方法区、程序计数器、虚拟机栈和本地方法栈。</p><p><img src="/img/image-20200920083402508.png" alt="image-20200920083402508"></p><h2 id="一、堆（Heap）">一、堆（Heap）</h2><p>堆，是JVM内存中最大的一块空间，该空间被所有线程共享，几乎所有的对象和数组都被分配到了堆中。堆被划分为新生代和老年代，新生代又被进一步划分为Eden区和Survivor区，而Survivor又是由From Survivor和To Survivor组成的。</p><p>在Java6中，永久代在非堆内存区：</p><p><img src="/img/image-20200920113631544.png" alt="image-20200920113631544"></p><p>在Java7中，永久代的静态变量和运行时常量池被合并到了堆中：</p><p><img src="/img/image-20200920113709761.png" alt="image-20200920113709761"></p><p>在java8中，永久代则被元空间所取代：</p><p><img src="/img/image-20200920090352851.png" alt="image-20200920090352851"></p><h2 id="二、方法区">二、方法区</h2><p>方法区，主要用来存放已经被虚拟机加载的类相关信息，这些信息源自class文件，其中主要包含类信息和常量池。</p><p>方法区也是一个共享内存区，被所有线程共享，当两个线程试图访问方法区中的同一个类信息时，如果这个类还没有装入JVM，那么此时就只允许一个线程去加载它，另一个线程必须等待。</p><blockquote><p>注：很多开发者习惯将方法区称为“永久代”，其实这两者并不是等价。</p></blockquote><p>在HotSpot虚拟机中使用了永久代来实现方法区，但在其它类型的虚拟机中，例如，Oracle的JRockit、IBM的J9就不存在永久代一说。需要知道的是，方法区只是JVM规范中的一部分，可以说，在HotSpot虚拟机中，设计人员使用了永久代实现了JVM规范的方法区。</p><p>HotSpot虚拟机，在Java7中已经将永久代中的静态变量和运行时常量池转移到了堆中，其余部分则存储在JVM的非堆内存中；而在Java8中已经将永久代去掉了，并用元空间（class metadata）代替了之前的永久代，并且元空间的存储位置位于本地内存。之前永久代中类的元数据存放在了元空间，永久代中的静态变量（class static variables）以及运行时常量池（runtime constant pool）则转移到了堆中。</p><blockquote><p>此时，我们可能会有这样的疑问，Java8为什么要使用元空间替代永久代？</p></blockquote><p>官方给出的解释是：</p><ul><li>为了融合HotSpot JVM与JRockit VM而做出的努力。因为JRockit没有永久代，所以不需要配置永久代。</li><li>永久代存在诸多问题。永久代经常因内存不够用或发生内存溢出，而引发java.lang.OutOfMemoryError: PermGen异常。因为在JDK1.7版本中，指定的PermGen区大小为8M，由于PermGen中的元数据信息在每次FullGC时都可能被收集，回收率都偏低，效率很难令人满意；还有，为PermGen分配多大的空间也很难确定，PermSize的大小依赖于很多因素，比如，JVM加载的class总数、常量池的大小和方法的大小等。</li></ul><h2 id="三、程序计数器">三、程序计数器</h2><p>程序计数器，是一块很小的内存空间，该空间由线程独占，主要用来记录线程执行的字节码地址。分支、循环、跳转、异常、线程恢复等都依赖于程序计数器。</p><p>这里，我们需要知道的是，由于Java是多线程语言，当同时执行的线程数超过CPU核数时，线程之间就会根据CPU时间片轮询争夺CPU资源。如果一个线程的时间片用完了，或者因其它原因导致这个线程的CPU资源被提前抢夺，那么这个退出的线程就需要一个单独的程序计数器，来记录下一条运行的指令。</p><h2 id="四、虚拟机栈">四、虚拟机栈</h2><p>虚拟机栈，是线程私有的内存空间，和Java线程一起被创建，主要用于管理Java函数的调用。当创建一个线程时，会在虚拟机栈中为这个线程申请一个线程栈，用来保存方法的局部变量、操作数栈、动态链接方法和返回地址等信息，并参与方法的调用和返回。每个方法的调用都伴随着栈帧的入栈操作，方法的返回则是栈帧的出栈操作。</p><h2 id="五、本地方法栈">五、本地方法栈</h2><p>本地方法栈，也是线程私有的内存空间，主要用于管理本地方法的调用。需要注意的是，本地方法并不是用Java实现的，而是由C语言实现的。</p><h2 id="六、小结">六、小结</h2><p>在这篇文章中，我们主要熟悉了JVM的内存模型，JVM的内存空间被划分为了堆、方法区、程序计数器、虚拟机栈和本地方法栈。其中：</p><ul><li>堆，用于存放所有的对象和数组</li><li>方法区，用于存放已经被虚拟机加载的类相关信息</li><li>程序计数器，用于保存下一条执行指令的地址</li><li>虚拟机栈，用于管理Java函数的调用</li><li>本地方法栈：用于管理本地方法的调用</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
