

<!DOCTYPE html>
<html lang="zh-CN" >



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="一个好的算法是建立在一个好的数据结构基础之上的。可以说，数据结构是算法设计的基础。根据数据元素之间逻辑关系和操作运算的不同，可以划分出多种数据结构，常用的数据结构如下图所示：  在这些数据结构中，线性表是最基本和最常用的一种数据结构，同时也是其它数据结构的基础，尤其是链表，它会贯穿整个数据结构课程的始终。本篇文章将重点讨论线性表这个最基础的数据结构。 一、线性表 1.1、定义和特点 线性表，是由n">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构：线性表">
<meta property="og:url" content="https://kuberxy.github.io/2023/12/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一个好的算法是建立在一个好的数据结构基础之上的。可以说，数据结构是算法设计的基础。根据数据元素之间逻辑关系和操作运算的不同，可以划分出多种数据结构，常用的数据结构如下图所示：  在这些数据结构中，线性表是最基本和最常用的一种数据结构，同时也是其它数据结构的基础，尤其是链表，它会贯穿整个数据结构课程的始终。本篇文章将重点讨论线性表这个最基础的数据结构。 一、线性表 1.1、定义和特点 线性表，是由n">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kuberxy.github.io/img/image-20231209111631626.png">
<meta property="og:image" content="https://kuberxy.github.io/img/image-20231209113140075.png">
<meta property="og:image" content="https://kuberxy.github.io/img/image-20231209113422454.png">
<meta property="og:image" content="https://kuberxy.github.io/img/image-20231209113613036.png">
<meta property="og:image" content="https://kuberxy.github.io/img/image-20231209170722757.png">
<meta property="og:image" content="https://kuberxy.github.io/img/image-20231209171141352.png">
<meta property="og:image" content="https://kuberxy.github.io/img/image-20231209151644489.png">
<meta property="og:image" content="https://kuberxy.github.io/img/image-20231209154415756.png">
<meta property="og:image" content="https://kuberxy.github.io/img/image-20231209175741080.png">
<meta property="og:image" content="https://kuberxy.github.io/img/image-20231209180949369.png">
<meta property="og:image" content="https://kuberxy.github.io/img/image-20231210144242367.png">
<meta property="og:image" content="https://kuberxy.github.io/img/image-20231210145028960.png">
<meta property="og:image" content="https://kuberxy.github.io/img/image-20231209163315032.png">
<meta property="og:image" content="https://kuberxy.github.io/img/e3e64278595946c9c5e5d4278b62944e.jpg">
<meta property="og:image" content="https://kuberxy.github.io/img/image-20231209203952780.png">
<meta property="og:image" content="https://kuberxy.github.io/img/image-20231209210832745.png">
<meta property="og:image" content="https://kuberxy.github.io/img/image-20231214090952590.png">
<meta property="og:image" content="https://kuberxy.github.io/img/image-20231214091059956.png">
<meta property="og:image" content="https://kuberxy.github.io/img/image-20231210113147496.png">
<meta property="og:image" content="https://kuberxy.github.io/img/image-20231210125028700.png">
<meta property="article:published_time" content="2023-12-02T05:47:11.000Z">
<meta property="article:modified_time" content="2023-12-23T08:06:21.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://kuberxy.github.io/img/image-20231209111631626.png">
  
  
  
  <title>数据结构：线性表 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"kuberxy.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Kubxy</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="数据结构：线性表"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-12-02 13:47" pubdate>
          2023年12月2日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          8.9k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          75 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">数据结构：线性表</h1>
            
            
              <div class="markdown-body">
                
                <p>一个好的算法是建立在一个好的数据结构基础之上的。可以说，数据结构是算法设计的基础。根据数据元素之间逻辑关系和操作运算的不同，可以划分出多种数据结构，常用的数据结构如下图所示：</p>
<p><img src="/img/image-20231209111631626.png" srcset="/img/loading.gif" lazyload alt="image-20231209111631626"></p>
<p>在这些数据结构中，线性表是最基本和最常用的一种数据结构，同时也是其它数据结构的基础，尤其是链表，它会贯穿整个数据结构课程的始终。本篇文章将重点讨论线性表这个最基础的数据结构。</p>
<h2 id="一、线性表">一、线性表</h2>
<h3 id="1-1、定义和特点">1.1、定义和特点</h3>
<p>线性表，是由n个具有相同特性的数据元素构成的有限序列。其中，数据元素的个数n是线性表的长度，当n为零时称为空表。</p>
<p>对于一个非空的线性表（或线性结构）来说，其特点如下：</p>
<ul>
<li>仅有一个被称作“第一个”的数据元素；</li>
<li>仅有一个被称作”最后一个“的数据元素；</li>
<li>除第一个元素之外，表中的每个数据元素均只有一个直接前驱；</li>
<li>除最后一个元素之外，表中的每个数据元素均只有一个直接后继。</li>
</ul>
<p>在日常生活中，线性表的例子比比皆是。例如，26个英文字母的字母表就是一个线性表，表中的数据元素是单个字母。在稍复杂的线性表中，一个数据元素可以包含若干个数据项。例如，在一张学生基本信息表中，每个学生的基本信息为一个数据元素，包括学号、姓名、性别、籍贯、专业等数据项。</p>
<h3 id="1-2、存储结构">1.2、存储结构</h3>
<p>存储结构，也称物理结构，指的是数据对象在计算机中的存储表示。把数据对象存储到计算机时，不仅要存储各数据元素的数据，还要存储数据元素之间的逻辑关系。数据元素在计算机中有两种基本的存储结构，分别是顺序存储结构和链式存储结构。</p>
<h4 id="1-2-1、顺序存储">1.2.1、顺序存储</h4>
<p>顺序存储，是指用一组地址连续的存储单元存放数据元素。其特点是，逻辑上相邻的数据元素，其物理位置也是相邻的。采用这种存储方法的线性表被称为顺序表（Sequential List）。</p>
<p><img src="/img/image-20231209113140075.png" srcset="/img/loading.gif" lazyload alt="image-20231209113140075"></p>
<p>顺序存储借助数据元素在存储器中的相对位置来表示数据元素之间的逻辑关系。在顺序表中，每个数据元素的存储地址是该数据元素在表中位置的线性函数。假设，在一个线性表中，第一个数据元素的存储地址是LOC(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)，每个数据元素的大小是s，那么第i个数据元素的存储地址LOC(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)就为：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mi>O</mi><mi>C</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mi>O</mi><mi>C</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">LOC(a_i) = LOC(a_1) + (i-1)*s
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">OC</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">OC</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span></span></p>
<p>这也就是说，只要知道了第一个数据元素的存储地址（也称基地址）和每个数据元素的大小，就能求出任一数据元素的存储地址，所以顺序表是一种支持随机存取的数据结构。</p>
<h4 id="1-2-2、链式存储">1.2.2、链式存储</h4>
<p>链式存储，是指用一组地址任意的存储单元存放数据元素。其特点是，逻辑上相邻的两个元素，其物理位置可以是连续的，也可以是不连续的。采用这种存储方法的线性表被称为链表。</p>
<p><img src="/img/image-20231209113422454.png" srcset="/img/loading.gif" lazyload alt="image-20231209113422454"></p>
<p>在链式存储结构中，为了表示数据元素之间的逻辑关系，在存储数据时，不仅要存储数据元素本身，还要存储其直接前驱（或后继）的位置等信息。所以，链表中的每个数据元素（通常称为结点）由数据域和指针域这两部分信息共同构成。其中，数据域用于存储数据元素本身的信息；指针域用于存储直接前驱（或后继）的位置等信息。</p>
<p><img src="/img/image-20231209113613036.png" srcset="/img/loading.gif" lazyload alt="image-20231209113613036"></p>
<p>链表中各个元素的存储位置都是随意的。也就是说，链表是非随机存取的存储结构，要取得第i个数据元素必须顺链进行寻找，因此，链表也被称为顺序存取的存储结构。</p>
<h2 id="二、顺序表">二、顺序表</h2>
<p>在高级程序设计语言中，数组具有随机访问的特性。因此，通常用数组来描述顺序表。在C语言中，可用动态分配的一维数组表示顺序表，相应的描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 顺序表的最大长度（应该根据实际需要来定，这里假设为100）</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><br><span class="hljs-comment">// 表中数据元素的类型（应根据实际情况而定，这里假设为int）</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-comment">// 定义顺序表类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-comment">// 存储空间的基地址</span><br>  ElemType* elem;<br>  <span class="hljs-comment">// 表的当前长度（即实际存储的数据元素个数）</span><br>  <span class="hljs-type">int</span> length;<br>&#125;SeqList;<br></code></pre></td></tr></table></figure>
<p>有了该定义，顺序表的一些操作就可轻松实现。因为表的长度是顺序表的一个”属性“，所以可通过返回length的值实现求表长的操作，也可通过length的值是否为0判断表是否为空，实现这些操作的算法的时间复杂度都是O(1)。下面重点讨论顺序表其他几个主要操作的实现。</p>
<h3 id="3-1、初始化">3.1、初始化</h3>
<p>初始化，就是构造一个空的顺序表。该算法步骤为：</p>
<ul>
<li>
<p>为顺序表L动态分配一个预定义大小的数组空间，使elem指向这段空间的基地址。</p>
</li>
<li>
<p>将表的当前长度设为0。</p>
</li>
</ul>
<p>相应的算法描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 构造一个空的顺序表</span><br>Status <span class="hljs-title function_">InitList</span><span class="hljs-params">(SeqList &amp;L)</span> &#123;<br>    <span class="hljs-comment">// 为顺序表分配一个大小为MAXSIZE的数组空间</span><br>    L.elem=(ElemType *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ElemType) * MAXSIZE);<br>    <span class="hljs-comment">// 空间分配失败，退出</span><br>    <span class="hljs-keyword">if</span>(!L.elem) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    <span class="hljs-comment">// 空表的长度为0</span><br>    L.length=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-2、取值">3.2、取值</h3>
<p>取值，是指根据指定的位置序号i，获取顺序表中第i个数据元素的值。由于顺序存储结构具有随机存取的特点，因此可以直接通过数组下标定位第i个数据元素，即第i个数据元素可通过elem[i-1]获取。该算法步骤为：</p>
<ul>
<li>判断位置序号i值是否合理（i值的合法范围是1&lt;=i&lt;=L.length），若不合理，则返回ERROR。</li>
<li>若i值合理，则将第i个数据元素L.elem[i-1]赋给参数e，通过e返回第i个数据元素的值。</li>
</ul>
<p>相应的算法描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取顺序表L的第i个数据元素的值</span><br>Status <span class="hljs-title function_">GetElem</span><span class="hljs-params">(SeqList L, ini i, ElemType &amp;e)</span> &#123;<br>    <span class="hljs-comment">// 判断i值是否合理，若不合理，返回ERROR</span><br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length)<span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-comment">// 获取第i个数据元素</span><br>    e=E.elem[i<span class="hljs-number">-1</span>];<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>显然，顺序表取值算法的时间复杂度为O(1)。</p>
<h3 id="3-3、查找">3.3、查找</h3>
<p>查找，是指根据指定的元素值e，查找顺序表中第1个值与e相等的元素。若查找成功，则返回该元素在表中的位置序号；若查找失败，则返回0。该算法步骤为：</p>
<ul>
<li>从第一个元素起，依次和e相比较，若找到与e相等的元素L.elem[i]，则查找成功，返回该元素的序号i+1。</li>
<li>若查遍整个顺序表都没有找到，则查找失败，返回0。</li>
</ul>
<p>相应的算法描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在顺序表L中查找值为e的数据元素，返回其序号</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">LocateElem</span><span class="hljs-params">(SeqList L, ElemType e)</span> &#123;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;L.length;i++) &#123;<br>        <span class="hljs-comment">// 查找成功，返回该元素的序号i+1</span><br>        <span class="hljs-keyword">if</span>(L.elem[i]==e) <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 查找失败，返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在顺序表中查找一个数据元素时，其时间主要耗费在数据的比较上，而比较的次数取决于被查元素在线性表中的位置。显然，该算法要分析其平均时间复杂度，在等概率情况下，其平均复杂度为O(n)。</p>
<h3 id="3-4、插入">3.4、插入</h3>
<p>插入，是指在表的第i个位置上插入一个新的数据元素e，使线性表的长度由n变为n+1。</p>
<p><img src="/img/image-20231209170722757.png" srcset="/img/loading.gif" lazyload alt="image-20231209170722757"></p>
<p>由于在顺序表中逻辑上相邻的数据元素在物理位置上也是相邻的，因此，除非i=n+1，否则必须移动数据元素。一般情况下，在第i（1≤i≤n）个位置插入一个元素时，需从最后一个元素即第n个元素开始，将每个元素向后移动一个位置，直至第i个元素。该算法步骤为：</p>
<ul>
<li>判断插入位置i是否合法（i值的合法范围是1≤i≤n+1），若不合法则返回ERROR。</li>
<li>判断顺序表的存储空间是否已满，若满则返回ERROR。</li>
<li>将最后一个元素至第i个位置的元素依次向后移动一个位置，空出第i个位置（i=n+1时无需移动）。</li>
<li>将要插入的新元素e放入第i个位置。</li>
<li>表长加1。</li>
</ul>
<p>相应的算法描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将新元素e插入到顺序表L的第i个位置</span><br>Status <span class="hljs-title function_">ListInsert</span><span class="hljs-params">(SeqList &amp;L, <span class="hljs-type">int</span> i, ElemType e)</span> &#123;<br>    <span class="hljs-comment">// i值不合法</span><br>    <span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L.length+<span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">// 当前存储空间已满</span><br>    <span class="hljs-keyword">if</span>(L.length==MAXSiZE) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">// 从最后一个元素开始，依次将每个元素向后移动一个位置，直到第i元素为止</span><br>    <span class="hljs-keyword">for</span>(j=L.length<span class="hljs-number">-1</span>; j&gt;=i<span class="hljs-number">-1</span>; j--) &#123;<br>        L.elem[j+<span class="hljs-number">1</span>]=L.elem[j];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 将新元素e插入到第i个位置</span><br>    L.elem[i<span class="hljs-number">-1</span>]=e;<br>    <br>    <span class="hljs-comment">// 表长加1</span><br>    ++L.length;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在顺序表中某个位置上插入一个数据元素时，其时间主要耗费在移动元素上，而移动元素的个数取决于插入元素的位置。显然，该算法要分析其平均时间复杂度，在等概率情况下，其平均复杂度为O(n)。</p>
<h3 id="3-5、删除">3.5、删除</h3>
<p>删除，是指将表的第i个元素删去，使线性表的长度由n变为n-1。</p>
<p><img src="/img/image-20231209171141352.png" srcset="/img/loading.gif" lazyload alt="image-20231209171141352"></p>
<p>与插入操作类似，除非i=n，否则必须移动数据元素。一般情况下，删除第i（1≤i≤n）个元素时，需将第i+1个至第n个元素依次向前移动一个位置（i=n时无需移动）。该算法步骤为：</p>
<ul>
<li>判断删除位置i是否合法（合法值为1≤i≤n），若不合法则返回ERROR。</li>
<li>将第i+1个至最后一个元素依次向前移动一个位置（i=n时无需移动）。</li>
<li>表长减1。</li>
</ul>
<p>相应的算法描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在顺序表L中删除第i个元素</span><br>Status <span class="hljs-title function_">ListDelete</span><span class="hljs-params">(SeqList &amp;L, <span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-comment">// i值不合法</span><br>    <span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L.length)) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">// 从第i+1个元素开始，依次将每个元素向前移动一个位置，直到最后一个元素为止</span><br>    <span class="hljs-keyword">for</span>(j=i;j&lt;=L.length<span class="hljs-number">-1</span>;j++) &#123;<br>        L.elem[j<span class="hljs-number">-1</span>]=L.elem[j];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 表长减1</span><br>    --L.length;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当在顺序表中某个位置上删除一个数据元素时，其时间主要耗费在移动元素上，而移动元素的个数取决于删除元素的位置。显然，该算法也要分析其平均时间复杂度，在等概率情况下，其平均复杂度为O(n)。</p>
<h3 id="3-6、小结">3.6、小结</h3>
<p>顺序表可以随机存取表中任一元素，其存储位置可用一个线性函数来表示。然而，从另一方面来看，这个特点也造成了这种存储结构的缺点：在进行插入或删除操作时，需移动大量元素。另外，由于数组长度是固定的，当表中数据元素个数较多且变化较大时，不仅会使操作变复杂，还会导致存储空间的浪费。而所有这些问题，都可以通过链表来解决。</p>
<h2 id="三、链表">三、链表</h2>
<p>根据结点指针域的不同，可将链表分为单链表、循环链表、双向链表、二叉链表、十字链表、邻接表、邻接多重表等。其中，单链表、循环链表和双向链表用于实现线性表的链式存储结构，其他形式多用于实现树和图等非线性结构。接下来，我们重点讨论前者。</p>
<h3 id="3-1、单链表">3.1、单链表</h3>
<p>单链表，是指链表中每个节点的指针域只包含一个指向其直接后继结点的指针。</p>
<p><img src="/img/image-20231209151644489.png" srcset="/img/loading.gif" lazyload alt="image-20231209151644489"></p>
<p>在单链表中，由于第一个结点无直接前趋，所以通常会设立头指针指向链表中第一个结点。又由于最后一个结点无直接后继，所以最后一个结点的指针域为空，即NULL。如果单链表中一个数据元素也没有，则为空表，即L==NULL。</p>
<p>在C语言中，可用”结构体指针“来描述单链表，相应的描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 表中元素的类型应根据实际情况而定，这里假设为int</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-comment">// 定义单链表的节点类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    <span class="hljs-comment">// 结点的数据域</span><br>    ElemType data;<br>    <span class="hljs-comment">// 结点的指针域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125;LNoe,*LinkList;<br></code></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>
<p>在单链表中，每个结点的存结构由两部分组成：存储数据的数据域data，其类型用通用类型标识符ElemType表示；存储后继结点位置的指针域next，其类型为指向结点的指针类型LNode*。</p>
</li>
<li>
<p>LinkList和LNode *，两者在本质上是等价的。它们是不同名字的同一结构体指针类型，取名不同是为了在概念上更明确。通常，习惯上用LinkList定义单链表，强调定义的是某个单链表的头指针；用LNode *定义指向单链表中任意结点的指针变量。比如，若定义LinkList L，则L为单链表的头指针，若定义LNode *p，则p为指向单链表中某个结点的指针。</p>
</li>
<li>
<p>单链表是由头指针唯一确定的，因此单链表可以用头指针的名字来命名。若头指针名是L，则简称该链表为表L。</p>
</li>
</ul>
<p>一般情况下，为了处理方便，会在单链表的第一个结点之前附设一个结点（称之为头结点），并使头指针指向该结点。增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针。</p>
<p><img src="/img/image-20231209154415756.png" srcset="/img/loading.gif" lazyload alt="image-20231209154415756"></p>
<p>在带头结点的单链表中，有3个容易混淆的概念，它们分别是：</p>
<ul>
<li>
<p>首元结点，指链表中存储第一个数据元素的结点。</p>
</li>
<li>
<p>头指针，指向链表中的第一个结点。若链表设有头结点，则头指针所指结点为线性表的头结点；若链表不设头结点，则头指针所指结点为线性表的首元结点。</p>
</li>
<li>
<p>头结点，是在首元结点之前附设的一个结点，其指针域指向首元结点。头结点的数据域可以不存储任何信息，也可存储与数据元素类型相同的其他附加信息。例如，当数据元素为整数型时，头结点的数据域中可存放该线性表的长度。</p>
</li>
</ul>
<h4 id="3-1-1、初始化">3.1.1、初始化</h4>
<p>初始化，就是构造一个空的单链表。该算法步骤为：</p>
<ul>
<li>生成新结点作为头结点，用头指针L指向头结点。</li>
<li>头结点的指针域置空。</li>
</ul>
<p>相应的算法描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 构造一个空的单链表</span><br>Status <span class="hljs-title function_">InitList</span><span class="hljs-params">(LinkList &amp;L)</span> &#123;<br>    <span class="hljs-comment">// 生成新结点作为头结点，并用头指针L指向头结点</span><br>    L=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    <span class="hljs-comment">// 头结点的指针域置空</span><br>    L-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-1-2、取值">3.1.2、取值</h4>
<p>和顺序表不同，链表中逻辑相邻的结点，在物理存储上并不相邻。这样，根据给定的结点位置序号i，在链表中获取该结点的值不能像顺序表那样随机访问，而只能从链表的首元结点出发，顺着链域next逐个结点向后访问。该算法步骤为：</p>
<ul>
<li>用指针p指向首元结点，用j做计数器初值赋为1。</li>
<li>从首元结点开始依次顺着链域next向下访问，只要指向当前结点的指针p不为空（NULL），并且没有到达序号为i的结点，则循环执行以下操作：
<ul>
<li>p指向下一个结点；</li>
<li>计数器j加1。</li>
</ul>
</li>
<li>退出循环时，如果指针p为空，或者计数器j大于i，说明指定的序号i值不合法（i大于表长n或i小于等于0），取值失败返回ERROR；否则取值成功，此时j=i时，p所指的结点就是要找的第i个结点，用参数e保存当前结点的数据域，返回OK。</li>
</ul>
<p>相应的算法描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在带头结点的单链表L中根据序号i获取元素的值，用e返回L中第i个数据元素的值</span><br>Status <span class="hljs-title function_">GetElem</span><span class="hljs-params">(LinkList L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span> &#123;<br>    <span class="hljs-comment">// p指向首元结点，计数器j初值赋为1</span><br>    p=L-&gt;next;j=<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// 顺链域向后扫描，直到p为空或p指向第i个元素</span><br>    <span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;i) &#123;<br>        <span class="hljs-comment">// p指向下一个结点</span><br>        p=p-&gt;next;<br>        <span class="hljs-comment">// p指向下一个结点</span><br>        ++j;<br>    &#125;<br>    <br>    <span class="hljs-comment">// i值不合法i&gt;n或i≤0</span><br>    <span class="hljs-keyword">if</span>(!p || j&gt;i) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">// 取第i个结点的数据域</span><br>    e=p-&gt;data;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该算法的基本操作是比较j和i并后移指针p，while循环体中的语句频度与位置i有关。显然，该算法要分析其平均时间复杂度，在等概率情况下，其平均复杂度为O(n)。</p>
<h4 id="3-1-3、查找">3.1.3、查找</h4>
<p>链表的按值查找过程和顺序表类似，从链表的首元结点出发，依次将结点值和给定值e进行比较，返回查找结果。该算法步骤为：</p>
<ul>
<li>用指针p指向首元结点。</li>
<li>从首元结点开始依次顺着链域next向下查找，只要指向当前结点的指针p不为空，并且p所指结点的数据域不等于给定值e，则循环执行以下操作：
<ul>
<li>p指向下一个结点。</li>
</ul>
</li>
<li>返回p。若查找成功，p此时即为结点的地址值，若查找失败，p的值即为NULL。</li>
</ul>
<p>相应的算法描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在带头结点的单链表L中查找值为e的元素</span><br>LNode *<span class="hljs-title function_">LocateElem</span><span class="hljs-params">(LinkList L, ElemType e)</span> &#123;<br>    <span class="hljs-comment">// p指向首元结点</span><br>    p=L-&gt;next;<br>    <br>    <span class="hljs-comment">// 顺链域向后扫描，直到p为空或p所指结点的数据域等于e</span><br>    <span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;data!=e) &#123;<br>        <span class="hljs-comment">// p指向下一个结点</span><br>        p=p-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 查找成功返回值为e的结点地址p，查找失败p为NULL</span><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该算法的执行时间与待查找的值e的位置有关，需要分析其平均时间复杂度，在等概率情况下，其平均复杂度为O(n)。</p>
<h4 id="3-1-4、插入">3.1.4、插入</h4>
<p>插入，是指将值为e的新结点插入到表的第i个结点的位置上，即插入到结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>与结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之间。</p>
<p><img src="/img/image-20231209175741080.png" srcset="/img/loading.gif" lazyload alt="image-20231209175741080"></p>
<p>其算法步骤为：</p>
<ul>
<li>查找结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>并由指针p指向该结点。</li>
<li>生成一个新结点*s。</li>
<li>将新结点*s的数据域置为e。</li>
<li>将新结点*s的指针域指向结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li>
<li>将结点*p的指针域指向新结点*s。</li>
</ul>
<p>相应的算法描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在带头结点的单链表L中第i个位置插入值为e的新结点</span><br>Status <span class="hljs-title function_">ListInsert</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i, ElemType e)</span> &#123;<br>    p=L;j=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 查找第i−1个结点，p指向该结点</span><br>    <span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;i<span class="hljs-number">-1</span>) &#123;<br>        p=p-&gt;next;<br>        ++j;<br>    &#125;<br>    <br>    <span class="hljs-comment">// i值不合法（i&gt;n+1或者i&lt;1）</span><br>    <span class="hljs-keyword">if</span>(!p || j&gt;i<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">// 生成新结点*s</span><br>    s=new LNode;<br>    <span class="hljs-comment">// 将结点*s的数据域置为e</span><br>    s-&gt;data=e;<br>    <span class="hljs-comment">// 将结点*s的指针域指向结点ai</span><br>    s-&gt;next=p-&gt;next;<br>    <span class="hljs-comment">// 将结点*p的指针域指向结点*s</span><br>    p-&gt;next=s;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>单链表的插入操作虽然不需要像顺序表的插入操作那样需要移动元素，但其平均时间复杂度仍为O(n)。这是因为，为了在第i个结点之前插入一个新结点，必须首先找到第i−1个结点，在等概率情况下，该操作的平均复杂度为O(n)。</p>
<h4 id="3-1-5、删除">3.1.5、删除</h4>
<p>删除，是指将第i个结点从链表中删去，即将链表第i-1个结点的指针指向第i+1个结点。</p>
<p><img src="/img/image-20231209180949369.png" srcset="/img/loading.gif" lazyload alt="image-20231209180949369"></p>
<p>其步骤为：</p>
<ul>
<li>查找结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>并由指针p指向该结点。</li>
<li>临时保存待删除结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的地址在q中，以备释放。</li>
<li>将结点*p的指针域指向<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的直接后继结点。</li>
<li>释放结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的空间。</li>
</ul>
<p>相应的算法描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在带头结点的单链表L中，删除第i个元素</span><br>Status <span class="hljs-title function_">ListDelete</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i)</span> &#123;<br>    p=L;j=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(p&gt;next &amp;&amp; j&lt;i<span class="hljs-number">-1</span>) &#123;<br>        p=p-&gt;next;<br>        ++j;<br>    &#125;<br>    <br>    <span class="hljs-comment">// i值不合法（i&gt;n或者i&lt;1）</span><br>    <span class="hljs-keyword">if</span>(!(p-&gt;next) || (j&gt;i<span class="hljs-number">-1</span>)) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-comment">// 临时保存被删结点的地址以备释放</span><br>    q=p-&gt;next;<br>    <span class="hljs-comment">// 改变删除结点前驱结点的指针域</span><br>    p-&gt;next=q-&gt;next;<br>    <span class="hljs-comment">// 释放删除结点的空间</span><br>    <span class="hljs-built_in">free</span>(q);<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>类似于插入算法，删除算法的平均时间复杂度亦为O(n)。</p>
<h4 id="3-1-6、创建单链表">3.1.6、创建单链表</h4>
<p>初始化操作是创建一个只有头结点的空链表，而前面的一些算法都是假定链表已经存在多个结点。那么，该如何建立一个包括若干个结点的链表呢？</p>
<p>链表和顺序表不同，它是一种动态结构。整个可用存储空间可为多个链表共同享用，每个链表占用的空间不需预先分配划定，而是由系统按需即时生成。因此，建立线性表的链式存储结构的过程就是一个动态生成链表的过程。即从初始的空表状态起，依次生成各元素结点，并逐个插入链表。</p>
<p>根据结点插入位置的不同，链表的创建方法可分为前插法和后插法。</p>
<h5 id="3-1-6-1、前插法">3.1.6.1、前插法</h5>
<p>前插法，是指通过将新结点逐个插入到链表的头部（头结点之后）来创建链表。每次申请一个新结点，读入相应的数据元素值，然后将新结点插入到头结点之后。如下图，是采用前插法创建线性表(a,b,c,d,e)的过程。因为每次是在链表的头部插入，所以应该逆位序输入数据，即应该依次输入e、d、c、b、a。</p>
<p><img src="/img/image-20231210144242367.png" srcset="/img/loading.gif" lazyload alt="image-20231210144242367"></p>
<p>该算法步骤为：</p>
<ul>
<li>创建一个只有头结点的空链表。</li>
<li>根据待创建链表中的元素个数n，循环n次执行以下操作：
<ul>
<li>生成一个新结点*p；</li>
<li>输入元素值赋给新结点*p的数据域；</li>
<li>将新结点*p插入到头结点之后。</li>
</ul>
</li>
</ul>
<p>相应的算法描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//逆位序输入n个元素的值，建立带表头结点的单链表L</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateList_H</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 先建立一个带头结点的空链表</span><br>    L=(LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    L-&gt;next=<span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<br>        <span class="hljs-comment">// 生成新结点*p</span><br>        p=(LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>        <span class="hljs-comment">// 输入元素值赋给新结点*p的数据域</span><br>        <span class="hljs-built_in">cin</span>&gt;&gt;p-&gt;data;<br>        <span class="hljs-comment">// 将新结点*p插入到头结点之后</span><br>        p-&gt;next=L-&gt;next;<br>        L-&gt;next=p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>显然，该算法的时间复杂度与数据规模n有关，其时间复杂度为O(n)。</p>
<h5 id="3-1-6-2、后插法">3.1.6.2、后插法</h5>
<p>后插法，是指通过将新结点逐个插入到链表的尾部来创建链表。同前插法一样，每次申请一个新结点，读入相应的数据元素值。不同的是，为了使新结点能够插入到表尾，需要增加一个尾指针r指向链表的尾结点。如下图，是采用后插法创建线性表(a,b,c,d,e)的过程。</p>
<p><img src="/img/image-20231210145028960.png" srcset="/img/loading.gif" lazyload alt="image-20231210145028960"></p>
<p>该算法步骤为：</p>
<ul>
<li>
<p>创建一个只有头结点的空链表。</p>
</li>
<li>
<p>尾指针r初始化指向头结点。</p>
</li>
<li>
<p>根据待创建链表中的元素个数n，循环n次执行以下操作：</p>
<ul>
<li>生成一个新结点*p；</li>
<li>输入元素值赋给新结点*p的数据域；</li>
<li>将新结点*p插入到尾结点*r之后；</li>
<li>尾指针r指向新的尾结点*p。</li>
</ul>
</li>
</ul>
<p>相应的算法描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 正位序输入n个元素的值，建立带表头结点的单链表L</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateList_R</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 先建立一个带头结点的空链表</span><br>    L=(LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    L-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">// 尾指针r指向头结点</span><br>    r=L;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<br>        <span class="hljs-comment">// 生成新结点</span><br>        p=(LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>        <span class="hljs-comment">// 输入元素值赋给新结点*p的数据域</span><br>        <span class="hljs-built_in">cin</span>&gt;&gt;p-&gt;data;<br>        <span class="hljs-comment">// 将新结点*p插入尾结点*r之后</span><br>        p-&gt;next=<span class="hljs-literal">NULL</span>;<br>        r-&gt;next=p;<br>        <span class="hljs-comment">// r指向新的尾结点*p</span><br>        r=p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>显然，该算法的时间复杂度与数据规模n有关，其时间复杂度为O(n)。</p>
<h4 id="3-1-7、头节点的作用">3.1.7、头节点的作用</h4>
<p>看到这里，我们可能会有一个疑问，在链表中，为什么要设置头节点？在回答这个问题之前，我们先来看看，在不设头节点的情况下，如何通过尾插法建立单链表。话不多说，我们直接上代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 正位序输入n个元素的值，建立带表头结点的单链表L</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateList_R</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 先将链表置空，即头尾指针都为NULL</span><br>    L=<span class="hljs-literal">NULL</span>;<br>    r=<span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<br>        <span class="hljs-comment">// 生成新结点</span><br>        p=(LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>        <span class="hljs-comment">// 输入元素值赋给新结点*p的数据域</span><br>        <span class="hljs-built_in">cin</span>&gt;&gt;p-&gt;data;<br>		p-&gt;next=<span class="hljs-literal">NULL</span>;<br>		<br>		<span class="hljs-comment">// 链表为空时，将头指针指向新结点</span><br>		<span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>) L=p;<br>		<span class="hljs-comment">// 链表非空时，将新节点插入到尾节点之后</span><br>		<span class="hljs-keyword">else</span> r-&gt;next=p;<br>  <br>        <span class="hljs-comment">// r指向新的尾结点*p</span><br>        r=p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对比前面带头节点的尾插法，我们不难看出，对于首元节点，该算法要进行特殊处理，代码逻辑会变得复杂，且不易理解。概括来讲，在链表中增加头节点，有两个重要的作用：</p>
<ul>
<li>
<p>便于首元结点的处理。在带头结点的链表中，首元结点的地址保存在头结点的指针域中，这样对链表的第一个数据元素的操作与其他数据元素相同，无需进行特殊处理。</p>
</li>
<li>
<p>便于空表和非空表的统一处理。假设L为单链表的头指针，当链表不设头结点时，头指针应该指向首元结点，如果链表为空，则头指针为空，判定空表的条件为：L==NULL。增加头结点后，若链表为空，则头结点的指针域为空，判定空表的条件为：L-&gt;next ==NULL，而这和非空表的处理是一致的。</p>
</li>
</ul>
<h3 id="3-2、循环链表">3.2、循环链表</h3>
<p>循环链表（Circular Linked List），是指链表中最后一个结点的指针域不为空，而是指向链表的头结点，使整个链表形成一个环。因此，从表中任一结点出发，都能访问到表中的其他结点。</p>
<p><img src="/img/image-20231209163315032.png" srcset="/img/loading.gif" lazyload alt="image-20231209163315032"></p>
<p>在单循环链表中，为了使空表和非空表的处理一致，通常也会设置头结点。单循环链表的结点类型与单链表完全相同，在操作上也与单链表基本一致。差别仅在于，算法中循环的结束判断条件不再是p==NULL或p-&gt;next==NULL，而是它们是否等于头指针。</p>
<p>在某些情况下，若在循环链表中设立尾指针而不设头指针，可使一些操作简化。</p>
<p><img src="/img/e3e64278595946c9c5e5d4278b62944e.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>例如，在将两个线性表合并成一个表时，仅需将第一个表（假设为A）的尾指针指向第二个表（假设为B）的第一个结点，第二个表的尾指针指向第一个表的头结点，然后释放第二个表的头结点。这个操作仅需改变两个指针值即可，主要语句如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 保存第二个表的第一个结点</span><br>p=B-&gt;next-&gt;next;<br><span class="hljs-comment">// 将第二个表的尾指针指向第一个表的头结点</span><br>B-&gt;next=A-&gt;next;<br><span class="hljs-comment">// 将第一个表的尾指针指向第二个表的第一个结点</span><br>A-&gt;next=p;<br></code></pre></td></tr></table></figure>
<h3 id="3-3、双向链表">3.3、双向链表</h3>
<p>双向链表，是在单链表的基础上增加一个指向其直接前趋的指针域prior，其结构如下：</p>
<p><img src="/img/image-20231209203952780.png" srcset="/img/loading.gif" lazyload alt="image-20231209203952780"></p>
<p>在单链表中，只有一个指示直接后继的指针域，由此，从某个结点出发只能顺指针向后寻查其他结点。若要寻查结点的直接前驱，则必须从表头指针出发。换句话说，在单链表中，查找直接后继结点的执行时间为O(1)，而查找直接前驱的执行时间为O(n)。为克服单链表这种单向性的缺点，可使用双向链表（Double Linked List）。</p>
<p>和单链表的循环表类似，双向链表也由头指针唯一确定。为了使某些操作方便，双向链表也会增设一个头结点。双向链表也可以有循环表。其结构如下：</p>
<p><img src="/img/image-20231209210832745.png" srcset="/img/loading.gif" lazyload alt="image-20231209210832745"></p>
<p>在C语言中，双向链表的描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 双向链表的存储结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DuLNode</span> &#123;</span><br>    <span class="hljs-comment">// 数据域</span><br>    ElemType data;<br>    <span class="hljs-comment">// 前驱指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DuLNode</span> *<span class="hljs-title">prior</span>;</span><br>    <span class="hljs-comment">// 后继指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DuLNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;DuLNode, *DuLinkList;<br></code></pre></td></tr></table></figure>
<p>在双向链表中，有些操作（如ListLength、GetElem和LocateElem等）仅需涉及一个方向的指针，它们的算法描述和单链表的操作相同，但在插入、删除时有很大的不同。接下来，我们重点讨论这两种操作。</p>
<h4 id="3-3-1、插入">3.3.1、插入</h4>
<p>在插入结点时需要修改四个指针，操作过程如下：</p>
<p><img src="/img/image-20231214090952590.png" srcset="/img/loading.gif" lazyload alt="image-20231214090952590"></p>
<p>相应的算法描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在带头结点的双向链表L中第i个位置之前插入元素e</span><br>Status <span class="hljs-title function_">ListInsert_DuL</span><span class="hljs-params">(DuLinkList &amp;L, <span class="hljs-type">int</span> i, ElemType e)</span> &#123;<br>    <span class="hljs-comment">// 指针p指向链表中第i个位置的元素</span><br>    <span class="hljs-keyword">if</span>(!(p=GetEem_DuL(L,i))) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">// 生成新结点*s</span><br>    s=(DuLNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DuLNode));<br>    <span class="hljs-comment">// 将e赋给新结点的数据域</span><br>    s-&gt;data=e;<br>    <span class="hljs-comment">// 插入新结点</span><br>    s-&gt;prior=p-&gt;prior;<br>    p-&gt;prior-&gt;next=s;<br>    s-&gt;next=p;<br>    p-&gt;prior=s;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该算法主要有两个操作：设置指针和获取第i个数据元素。前者的时间复杂度为O(1)，而后者需要分析其平均时间复杂度，在等概率情况下，该操作的平均复杂度为O(n)。</p>
<h4 id="3-3-2、删除">3.3.2、删除</h4>
<p>在删除结点时需要修改两个指针，操作过程如下：</p>
<p><img src="/img/image-20231214091059956.png" srcset="/img/loading.gif" lazyload alt="image-20231214091059956"></p>
<p>相应的算法描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 删除带头结点的双向链表L中的第i个元素</span><br>Status <span class="hljs-title function_">ListDelete_DuL</span><span class="hljs-params">(DuLinkList &amp;L, <span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-comment">// 指针p指向链表中第i个位置的元素</span><br>    <span class="hljs-keyword">if</span>(!(p=GetElem_DuL(L,i))) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    p-&gt;prior-&gt;next=p-&gt;next;<br>    p-&gt;next-&gt;prior=p-&gt;prior;<br>    <br>    delete p;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>与插入类似，在等概率情况下，该操作的平均复杂度为O(n)。</p>
<h3 id="3-4、小结">3.4、小结</h3>
<p>单链表、循环链表和双向链表是线性链表的三种不同形式，它们有不同的应用场合。下表，对三者的几项有差别的基本操作进行了比较。</p>
<p><img src="/img/image-20231210113147496.png" srcset="/img/loading.gif" lazyload alt="image-20231210113147496"></p>
<h2 id="四、顺序表-vs-链表">四、顺序表 vs 链表</h2>
<p>在实际应用中，不能笼统地说，顺序表和链表哪种存储结构更好。它们各有优缺点，选用哪种存储结构，应根据具体问题作具体分析，通常会从空间性能和时间性能两个方面作比较分析。</p>
<h3 id="4-1、空间性能比较">4.1、空间性能比较</h3>
<h4 id="4-1-1、存储空间的分配">4.1.1、存储空间的分配</h4>
<p>顺序表的存储空间必须预先分配，元素个数扩充受一定限制，易造成存储空间浪费或空间溢出现象；而链表不需要为其预先分配空间，只要内存空间允许，链表中的元素个数就没有限制。</p>
<p>基于此，当线性表的长度变化较大，难以预估存储规模时，宜采用链表作为存储结构。</p>
<h4 id="4-1-2、存储密度的大小">4.1.2、存储密度的大小</h4>
<p>所谓存储密度是指数据元素本身所占用的存储量和整个结点结构所占用的存储量之比，即</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>存储密度</mtext><mo>=</mo><mfrac><mtext>数据元素本身占用的存储量</mtext><mtext>结点结构占用的存储量</mtext></mfrac></mrow><annotation encoding="application/x-tex">存储密度 = \frac{数据元素本身占用的存储量}{结点结构占用的存储量}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">存储密度</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">结点结构占用的存储量</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">数据元素本身占用的存储量</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>一般来说，存储密度越大，存储空间的利用率就越高。显然，顺序表的存储密度为1，而链表的存储密度小于1。</p>
<p>链表的每个结点除了设置数据域用来存储数据元素外，还要额外设置指针域，用来存储指示元素之间逻辑关系的指针。如果每个元素数据域占据的空间较小，则指针域会占整个结点的大部分空间，这样存储密度会变小。</p>
<p>例如，若单链表的结点数据均为整数，指针所占用的空间和整型量相同，则单链表的存储密度为0.5。因此，如果不考虑顺序表中的空闲区，则顺序表的存储空间利用率为100%，而单链表的存储空间利用率仅为50%。</p>
<p>基于此，当线性表的长度变化不大，易于事先确定其大小时，为了节约存储空间，宜采用顺序表作为存储结构。</p>
<h3 id="4-2、时间性能比较">4.2、时间性能比较</h3>
<h4 id="4-2-1、存储元素的效率">4.2.1、存储元素的效率</h4>
<p>顺序表是由数组实现的，它是一种随机存取结构，指定任意一个位置序号i，都可以在O(1)时间内直接存取该位置上的元素，即取值操作的效率高；而链表是一种顺序存取结构，按位置访问链表中第i个元素时，只能从表头开始依次向后遍历链表，直到找到第i个位置上的元素，时间复杂度为O(n)，即取值操作的效率低。</p>
<p>基于此，若线性表的主要操作是和元素位置紧密相关的这类取值操作，很少做插入或删除时，宜采用顺序表作为存储结构。</p>
<h4 id="4-2-2、插入和删除操作的效率">4.2.2、插入和删除操作的效率</h4>
<p>对于链表，在确定插入或删除的位置后，插入或删除操作无需移动数据，只需要修改指针，时间复杂度为O(1)。而对于顺序表，进行插入或删除时，平均要移动表中近一半的结点，时间复杂度为O(n)。尤其是当每个结点的信息量较大时，移动结点的时间开销就相当可观。</p>
<p>基于此，对于频繁进行插入或删除操作的线性表，宜采用链表作为存储结构。</p>
<h2 id="五、总结">五、总结</h2>
<p>线性表是最基础的数据结构，也是其它许多复杂数据结构的实现基础，因此需要重点掌握。本篇文章的主要内容如下：</p>
<p><img src="/img/image-20231210125028700.png" srcset="/img/loading.gif" lazyload alt="image-20231210125028700"></p>
<h2 id="六、参考">六、参考</h2>
<p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26713328/">《数据结构（C语言版 第2版）》</a></p>
<p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/10732022/">《数据结构 自考02331》</a></p>
<p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/35474931/">《数据结构与算法之美》</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="category-chain-item">数据结构</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="print-no-link">#数据结构</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>数据结构：线性表</div>
      <div>https://kuberxy.github.io/2023/12/02/数据结构：线性表/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年12月2日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/12/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%88/" title="数据结构：栈">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">数据结构：栈</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/" title="数据结构：算法的分析方法">
                        <span class="hidden-mobile">数据结构：算法的分析方法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
